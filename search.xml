<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>算法模板</title>
    <url>/2023/03/08/14-45-11/</url>
    <content><![CDATA[<h1 id="特殊函数"><a href="#特殊函数" class="headerlink" title="特殊函数"></a>特殊函数</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//万能头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span> </span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="built_in">sort</span>(a,a+n,<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;());<span class="comment">//内置类型的由小到大排序</span></span><br><span class="line"><span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line"><span class="comment">//作用相当于 bool cmd();</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line">  string s;</span><br><span class="line">  s = <span class="built_in">bitset</span>&lt;<span class="number">8</span>&gt;(a[i]).<span class="built_in">to_string</span>();     <span class="comment">//  转换字符串</span></span><br><span class="line">  <span class="built_in">to_ulong</span>()    <span class="comment">// 转换为unsigned long类型</span></span><br><span class="line">  <span class="built_in">to_ullong</span>();　<span class="comment">// 转换成unsigned long long类型</span></span><br><span class="line">  <span class="built_in">set</span>(x, v);    <span class="comment">// 没有参数时 将全部位设为1</span></span><br><span class="line">                <span class="comment">// 有一个x， 将x下标处设为1</span></span><br><span class="line">                <span class="comment">// 两个参数，将x处设为v值</span></span><br><span class="line">  <span class="built_in">reset</span>(x);    <span class="comment">// 置0   无参全部置，有参置下标</span></span><br><span class="line">  <span class="built_in">flip</span>(x);     <span class="comment">// 取反，无参全部取，有参取下标处</span></span><br><span class="line">  <span class="built_in">text</span>(x);     <span class="comment">// 检测下标处是不是1 返回true 0返回false</span></span><br><span class="line">  <span class="built_in">any</span>();       <span class="comment">// 检查是否有1</span></span><br><span class="line">  <span class="built_in">none</span>();      <span class="comment">// 检查是否没有1</span></span><br><span class="line">  <span class="built_in">all</span>();       <span class="comment">// 检查是否全为1</span></span><br><span class="line">  <span class="built_in">count</span>();     <span class="comment">// 求1的个数</span></span><br><span class="line">  <span class="built_in">size</span>();      <span class="comment">// 求位数</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="built_in">typeid</span>(x).<span class="built_in">name</span>();   <span class="comment">// 获取x的类型</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输出重定向</span></span><br><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"><span class="comment">//控制台输入数据，如何输入文件结束标志</span></span><br><span class="line"><span class="comment">//**在Windows下，输入完毕后先按Enter键，再按Ctrl＋Z键，最后再按Enter键</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加快输入速度的两种方法</span></span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);   cin &gt;&gt; x;</span><br><span class="line"><span class="built_in">scanf</span>()；</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类型转换</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line">ss.<span class="built_in">clear</span>();  <span class="comment">// 清空</span></span><br><span class="line">ss &lt;&lt; s;</span><br><span class="line">ss &gt;&gt; a;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="built_in">isdigit</span>(s[i]);  <span class="comment">// 若参数c为阿拉伯数字0~9 字符，则返回非0值，否则返回0。</span></span><br><span class="line"><span class="type">int</span> n = <span class="built_in">stoi</span>(s);   <span class="comment">//  把s转化为int型 </span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line">cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>);   <span class="comment">// 设置位数</span></span><br><span class="line"><span class="built_in">setprecision</span>(n)     <span class="comment">//设置显示小数精度为n位</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">stefill</span>(c);  <span class="comment">// 设置填充字符</span></span><br><span class="line"><span class="built_in">setiosflags</span>(ios::scientific)   <span class="comment">//指数表示</span></span><br><span class="line"><span class="built_in">setiosflags</span>(ios::left)     <span class="comment">//左对齐</span></span><br><span class="line"><span class="built_in">setiosflags</span>(ios::right)    <span class="comment">//右对齐</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">include &lt;string&gt;</span><br><span class="line"><span class="built_in">substr</span>(<span class="type">int</span> index, <span class="type">int</span> mum); <span class="comment">// 返回一个子字符串 </span></span><br><span class="line"><span class="comment">//std::string::npos是一个常数，它等于size_type类型可以表示的最大值</span></span><br><span class="line"><span class="comment">//用在 s.find()  返回值</span></span><br></pre></td></tr></table></figure>
<h1 id="算法模板"><a href="#算法模板" class="headerlink" title="算法模板"></a>算法模板</h1><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法比赛</tag>
        <tag>c++</tag>
        <tag>算法模板</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 笔记五 优化程序性能</title>
    <url>/2023/07/06/14-25-42/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>23.07.06：初稿</li>
</ul>
<h1 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h1><ul>
<li><a href="/2023/03/15/10-59-10/" title="csapp 笔记汇总">CSAPP - 笔记汇总</a></li>
<li><a href="/2023/05/24/13-04-09/" title="CSAPP 笔记三 程序的机器级表示">第三章 - 程序的机器级表示</a></li>
<li><a href="/2023/07/06/14-25-42/" title="CSAPP 笔记五 优化程序性能">第五章 - 优化程序性能</a></li>
<li><a href="/2023/07/23/09-27-18/" title="CSAPP 笔记六 存储器层次结构">第六章 - 存储器层次结构</a>
</li>
</ul>
<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>通过查看汇编代码，对没有优化的代码进行调整。</p>
<h1 id="Generally-Useful-Optimizations"><a href="#Generally-Useful-Optimizations" class="headerlink" title="Generally Useful Optimizations"></a>Generally Useful Optimizations</h1><ul>
<li><p>Code Motion：代码移动，把常用的结果存到循环外。优化等级1以上，编译器会自动完成这个工作。</p>
</li>
<li><p>Reduction in Strength：减少计算量，乘法换左移或加法。</p>
</li>
<li><p>Share Common Subexpressions：寻找公共表达式，减少计算量。</p>
</li>
</ul>
<h1 id="Optimization-Blockers"><a href="#Optimization-Blockers" class="headerlink" title="Optimization Blockers"></a>Optimization Blockers</h1><ul>
<li><p>Procedure Calls：循环中进行相同结果的重复调用。</p>
<blockquote>
<p>编译器无法优化的原因：</p>
<p>1.不知道是否在循环中修改了字符串；2. 文件单独编译，编译器不知道函数使用的是哪个文件中的函数，编译器事先假设函数是一个黑盒。</p>
</blockquote>
</li>
<li><p>Memory Matters: 循环中重复读取内存。</p>
<blockquote>
<p>无法优化的原因：</p>
<p>编译器不确定C语言是否存在内存别名，之前的结果会不会影响下一次读取的内存值。所以每次都进行读取写入操作。</p>
</blockquote>
</li>
<li><p>Memory Aliasing：引入局部变量防止内存重叠。</p>
</li>
</ul>
<h1 id="Exploiting-Instruction-Level-Parallelism"><a href="#Exploiting-Instruction-Level-Parallelism" class="headerlink" title="Exploiting Instruction-Level Parallelism"></a>Exploiting Instruction-Level Parallelism</h1><p>采用指令级并行，适用于各种机器的通用优化方法</p>
<h2 id="Benchmark-Example"><a href="#Benchmark-Example" class="headerlink" title="Benchmark Example"></a>Benchmark Example</h2><p>基准例子，使用一个抽象的数据结构。</p>
<img src="/2023/07/06/14-25-42/WX20230706-153904@2x.png" class="">
<p><strong>Basic Optimizations</strong></p>
<ul>
<li><p>计算数组长度移出循环</p>
</li>
<li><p>移除边界检查，用新函数获取数组</p>
</li>
<li><p>引入局部变量</p>
</li>
</ul>
<img src="/2023/07/06/14-25-42/WX20230706-154041@2x.png" class="">
<p>优化后性能：</p>
<img src="/2023/07/06/14-25-42/WX20230706-154316@2x.png" class="">
<p><code>优化的基本限制</code>: 程序限制了整数和浮点数的乘法必须顺序执行，所需要的周期为3和5。</p>
<p><strong>Modern CPU Design</strong></p>
<img src="/2023/07/06/14-25-42/WX20230706-163939@2x.png" class="">
<p> 1995年的CPU，了解流程。</p>
<p> 超标量乱序执行：顺序指令分解重组，实现指令级并行。</p>
<p>Superscalar Processor：超标量处理器</p>
<p><strong>Pipelined Functional Units</strong></p>
<img src="/2023/07/06/14-25-42/WX20230706-170033@2x.png" class="">
<p>指令流水线：<code>这里假设指令需要三个阶段完成</code></p>
<h2 id="Loop-Unrolling"><a href="#Loop-Unrolling" class="headerlink" title="Loop Unrolling"></a>Loop Unrolling</h2><p><code>循环展开</code>: 循环中计算多个值，而不是计算一次。</p>
<img src="/2023/07/06/14-25-42/WX20230707-094102@2x.png" class="">
<blockquote>
<p>每次循环计算两个操作数</p>
<p><code>limit</code>: n-1, 循环i跳出时满足 i + 1 &lt; (n - 1) + 1 = n; </p>
</blockquote>
<img src="/2023/07/06/14-25-42/WX20230707-094654@2x.png" class="">
<blockquote>
<p>只有加法的CPE有了提升，降低了循环计数的消耗。其他没用提升是因为接近了延迟界限。</p>
</blockquote>
<p>调整循环展开的计算顺序：</p>
<p><code>x = x OP (d[i] OP d[i+1])</code></p>
<img src="/2023/07/06/14-25-42/WX20230707-105030@2x.png" class="">
<p>吞吐量突破了延迟界限，浮点数两个乘法器，一个加法器。</p>
<img src="/2023/07/06/14-25-42/WX20230707-105355@2x.png" class="">
<p>减少了计算的依赖，两个元素的计算不需要等上一个x的结果。浮点数不满足结合律，改变括号可能会发生舍入溢出，结果发生变化。</p>
<p><code>Latency Bound</code>：严格顺序执行时，一条指令需要花费的全部时间。</p>
<p><code>Throughput Bound</code>：基于硬件数量和性能限制，<code>只有两个load单元，吞吐量为0.5</code></p>
<p><strong>Separate Accumulators</strong></p>
<p>多累加器，改变元素组合的顺序，如奇偶分开。</p>
<img src="/2023/07/06/14-25-42/WX20230707-112901@2x.png" class="">
<p><strong>Unrolling &amp; Accumulating</strong></p>
<p>以K为因子展开一个L长度的数组，CPE可以接近吞吐界限</p>
<h2 id="Programming-with-AVX2"><a href="#Programming-with-AVX2" class="headerlink" title="Programming with AVX2"></a>Programming with AVX2</h2><p><strong>YMM Registers</strong></p>
<p>总共有16个32字节的寄存器 ，是%XMM的二倍。</p>
<h2 id="SIMD-Operations"><a href="#SIMD-Operations" class="headerlink" title="SIMD Operations"></a>SIMD Operations</h2><img src="/2023/07/06/14-25-42/WX20230707-114005@2x.png" class="">
<p><code>Vector Instructions</code>矢量指令：并行执行八次单精度或四次双精度浮点操作</p>
<p>矢量指令是为处理视频，声音，图形引入的</p>
<p>gcc对矢量指令的优化是有限的</p>
<h1 id="Dealing-with-Conditionals"><a href="#Dealing-with-Conditionals" class="headerlink" title="Dealing with Conditionals"></a>Dealing with Conditionals</h1><h2 id="What-About-Branches？"><a href="#What-About-Branches？" class="headerlink" title="What About Branches？"></a>What About Branches？</h2><p><strong>Branch Prediction</strong></p>
<p>分支预测技术：先执行猜测的分支，然后再判断分支是否正确</p>
<blockquote>
<p>所有的分支预测结果都写在寄存器副本中，错误时会回退正确的寄存器结果</p>
</blockquote>
<p><strong>Performance Cost</strong></p>
<p>执行代价就是用了很多时钟周期处理所有的分支指令，可能会执行大量无效操作</p>
]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 笔记三 程序的机器级表示</title>
    <url>/2023/05/24/13-04-09/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>23.05.24：初稿</li>
</ul>
<h1 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h1><ul>
<li><a href="/2023/03/15/10-59-10/" title="csapp 笔记汇总">CSAPP - 笔记汇总</a></li>
<li><a href="/2023/05/24/13-04-09/" title="CSAPP 笔记三 程序的机器级表示">第三章 - 程序的机器级表示</a></li>
<li><a href="/2023/07/06/14-25-42/" title="CSAPP 笔记五 优化程序性能">第五章 - 优化程序性能</a></li>
<li><a href="/2023/07/23/09-27-18/" title="CSAPP 笔记六 存储器层次结构">第六章 - 存储器层次结构</a>
</li>
</ul>
<h1 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h1><h2 id="Intel-x86-Processors"><a href="#Intel-x86-Processors" class="headerlink" title="Intel x86 Processors"></a>Intel x86 Processors</h2><ul>
<li><p>CISC - Complex 复杂指令集，RISC - Reduced 精简指令集。</p>
</li>
<li><p>x86-64，Linux的命名</p>
</li>
<li><p>ARM架构- Acorn RISC Machine</p>
</li>
<li><p>两种汇编语法：AT&amp;T和Intel。Linux和课程使用的是AT&amp;T。</p>
</li>
</ul>
<h2 id="C-assembly-machine-code"><a href="#C-assembly-machine-code" class="headerlink" title="C,assembly, machine code"></a>C,assembly, machine code</h2><ul>
<li>Micro architecture：微指令架构，CSAPP中很少涉及</li>
</ul>
<p><strong>Turning C into Object Code</strong></p>
<ul>
<li>编译命令<br><code>gcc -Og p1.c p2.c -o p</code><br><code>gcc -Og -S sum.c</code>：<br><code>-S</code>:编译阶段终止，生成汇编语言<br><code>-Og</code>:Optimize编译优化，<code>O1</code>是过去的优化级别，<code>g</code>级可以使代码更可读</li>
</ul>
<p><strong>Assembly Characteristics</strong></p>
<p>Data Types</p>
<ul>
<li><p>integer: 以1，2，4，8字节存储<br>数据和地址都用整型保存，不区分无符号和有符号。</p>
</li>
<li><p>floating point: 4，8，10字节</p>
</li>
<li><p>没有数组以及结构体，这些是由编译器构造的。</p>
</li>
</ul>
<p><strong>Operations</strong></p>
<ul>
<li><p>执行算术操作</p>
</li>
<li><p>在内存和寄存器之间传送数据</p>
</li>
<li><p>转移控制</p>
</li>
</ul>
<p>Disassembling Object Code</p>
<blockquote>
<p>指令长度在1-15个字节</p>
</blockquote>
<p>反汇编：将目标代码文件反汇编为类汇编语言。</p>
<ul>
<li><code>objdump -d sum</code>: 反汇编</li>
</ul>
<h2 id="Assembly-Basics-Registers-operands-move"><a href="#Assembly-Basics-Registers-operands-move" class="headerlink" title="Assembly Basics: Registers, operands, move"></a>Assembly Basics: Registers, operands, move</h2><p><strong>Integer Registers</strong></p>
<img src="/2023/05/24/13-04-09/WX20230603-145124@2x.png" class="">
<ul>
<li><p>参数：1<code>rdi</code>, 2<code>rsi</code>, 3<code>rdx</code>, 4<code>rcx</code>, 5<code>r8</code>, 6<code>r9</code>，只能传递整型或者指针，浮点数由另外一组单独的寄存器传递。超出的参数存在栈里。</p>
</li>
<li><p>返回值：<code>rax</code></p>
</li>
</ul>
<p><strong>Moving Data</strong></p>
<blockquote>
<p><code>mov Source, Dest</code></p>
</blockquote>
<ul>
<li><p>不允许从内存取出，存入内存。从内存取出，只能存入寄存器。</p>
</li>
<li><p><code>mov $0x4, %rax</code>：目的地址是寄存器<br><code>mov $0x4, (%rax)</code>: 目的地址是内存</p>
</li>
<li><p><code>D(R)</code>: Mem[Reg[R] + D]</p>
</li>
<li><p><code>D(Rb, Ri, S)</code>: Mem[Reg[Rb] + S * Reg[Ri] + D]</p>
</li>
</ul>
<h2 id="Arithmetic-amp-logical-operations"><a href="#Arithmetic-amp-logical-operations" class="headerlink" title="Arithmetic &amp; logical operations"></a>Arithmetic &amp; logical operations</h2><p><strong>lea Src, Dst</strong></p>
<blockquote>
<p>C语言中的&amp;，取地址</p>
</blockquote>
<p>实际使用中C语言编译器喜欢用这条指令做算术运算，<code>lea (%rdi, %rdi, 2), %rax</code>, mov是将地址指向的内存值取出，lea指令将内存值所在地址取出，相当于存入的是<code>%rdi + %rdi * 2</code>。</p>
<p>Some ArTwo Operand Instructions</p>
<img src="/2023/05/24/13-04-09/WX20230603-152227@2x.png" class="">
<ul>
<li><p>目的操作数作为第一个操作数，类似<code>x+=y</code></p>
</li>
<li><p>算术左移和逻辑左移相同</p>
</li>
</ul>
<p>One Operand Instructions</p>
<img src="/2023/05/24/13-04-09/WX20230603-152823@2x.png" class="">
<h1 id="Control"><a href="#Control" class="headerlink" title="Control"></a>Control</h1><h2 id="Condition-Codes"><a href="#Condition-Codes" class="headerlink" title="Condition Codes"></a>Condition Codes</h2><p><strong>Single bit registers</strong></p>
<ul>
<li><p><code>CF</code>: Carry Flag (for unsigned)，同样表示无符号数溢出</p>
</li>
<li><p><code>SF</code>: Sign Flag (for signed)，负数为1</p>
</li>
<li><p><code>ZF</code>: Zero Flag</p>
</li>
<li><p><code>OF</code>: Overflow Flag (for signed)</p>
</li>
</ul>
<p><strong>Explicit Setting</strong></p>
<p>Compare</p>
<blockquote>
<p>cmpq Src2, Src1</p>
</blockquote>
<p>类似减法，Src1 - Src2，但是不保存值，只改变四个条件码</p>
<ul>
<li><p>溢出：<code>cmp b， a</code>，有符号补码<br>同号不会溢出，异号才会溢出</p>
<ul>
<li><p>负溢出：a-，b+， a-b&gt;0</p>
</li>
<li><p>正溢出：a+，b-，a-b&lt;0</p>
</li>
</ul>
</li>
</ul>
<p>Test</p>
<blockquote>
<p>testq Src2, Src1</p>
</blockquote>
<p>与运算，改变SF和ZF。</p>
<p>SetX Instructions</p>
<img src="/2023/05/24/13-04-09/WX20230605-113101@2x.png" class="">
<blockquote>
<p>x86-64中4字节计算结果会将高4字节零填充，而2字节操作只会改变2字节。</p>
</blockquote>
<h2 id="Conditional-branches"><a href="#Conditional-branches" class="headerlink" title="Conditional branches"></a>Conditional branches</h2><p><strong>Jumping</strong></p>
<p>JX Instructions</p>
<img src="/2023/05/24/13-04-09/WX20230605-113806@2x.png" class="">
<p><strong>Using Conditional Moves</strong></p>
<p>分支预测技术，更多时候分支预测正确率很低，选择执行分支的两部分指令，计算出两个结果，在最后一分钟选择需要的结果。只适用在两个分支都是简单计算。</p>
<blockquote>
<p><code>cmovle</code>: 小于等于的时候移动</p>
</blockquote>
<h2 id="Loops"><a href="#Loops" class="headerlink" title="Loops"></a>Loops</h2><p>C代码中最底层的控制就是跳转和测试。</p>
<h2 id="Switch-Statements"><a href="#Switch-Statements" class="headerlink" title="Switch Statements"></a>Switch Statements</h2><ul>
<li><p>用跳转表保存代码块的地址，可以快速跳转到该地址。</p>
</li>
<li><p>无论最小值是多少，通过增加偏置变为0</p>
</li>
<li><p>跳转表由编译器生成，汇编程序填写。</p>
</li>
<li><p>值范围很大，相对稀疏，会转变为条件树。</p>
</li>
</ul>
<h1 id="Procedures"><a href="#Procedures" class="headerlink" title="Procedures"></a>Procedures</h1><h2 id="Stack-Structure"><a href="#Stack-Structure" class="headerlink" title="Stack Structure"></a>Stack Structure</h2><ul>
<li><p>内存地址从下往上递增</p>
</li>
<li><p>栈底在上，push时rsp减小</p>
</li>
</ul>
<p><strong>Push &amp; Pop</strong></p>
<ul>
<li><p>Push：先减小，在写入</p>
</li>
<li><p>Pop：rsp增加</p>
</li>
</ul>
<h2 id="Calling-Conventions"><a href="#Calling-Conventions" class="headerlink" title="Calling Conventions"></a>Calling Conventions</h2><p><strong>Passing Control</strong></p>
<ul>
<li><p><code>call label</code>: 返回地址入栈，跳转到label</p>
</li>
<li><p><code>ret</code>: 出栈，返回</p>
</li>
<li><p><code>pc</code>寄存器就存在<code>rip</code>。</p>
</li>
</ul>
<p><strong>Passing data</strong></p>
<p>数据在寄存器和内存中传递，采用默认的规则，在不同的编译器下都可以传递参数。</p>
<p><strong>Managing local data</strong></p>
<p>Stack Frame</p>
<p>每个函数使用的内存块称为栈帧。</p>
<ul>
<li><p><code>rbp</code>: 表示基指针，栈底。调用者的<code>rbp</code>保存在被调用者的栈底。</p>
</li>
<li><p><code>rsp</code>: 栈顶，当它被分配了多少字节，就知道需要释放多少字节</p>
</li>
</ul>
<h2 id="Illustration-of-Recursion"><a href="#Illustration-of-Recursion" class="headerlink" title="Illustration of Recursion"></a>Illustration of Recursion</h2><p>栈帧是递归调用的前提。</p>
<h1 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h1><h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><p><strong>One-dimensional</strong></p>
<ul>
<li>指针加常量， 常量会被适当放缩。</li>
</ul>
<p><strong>Multi-dimensional(nested)</strong></p>
<ul>
<li>多维嵌套数组，按行或列连续存储。</li>
</ul>
<p><strong>Multi-level</strong></p>
<ul>
<li>三个数组，一个以为指针数组保存三个数组的起始地址。</li>
</ul>
<h2 id="Structures"><a href="#Structures" class="headerlink" title="Structures"></a>Structures</h2><p><strong>Access</strong></p>
<ul>
<li>通过字节偏移访问对应的结构体成员。</li>
</ul>
<p><strong>Alignment</strong></p>
<ul>
<li><p>字节对齐，访问更方便，数据不会跨越多个块</p>
</li>
<li><p>占m字节的变量，就存放在m的倍数地址处</p>
</li>
<li><p>调整声明顺序，可以优化对齐</p>
</li>
</ul>
<h2 id="Floating-Point"><a href="#Floating-Point" class="headerlink" title="Floating Point"></a>Floating Point</h2><img src="/2023/05/24/13-04-09/WX20230605-164923@2x.png" class="">
<h1 id="Advanced-Topics"><a href="#Advanced-Topics" class="headerlink" title="Advanced Topics"></a>Advanced Topics</h1><h2 id="Memory-Layout"><a href="#Memory-Layout" class="headerlink" title="Memory Layout"></a>Memory Layout</h2><p>目前64位的内存只允许使用47位。Linux栈的大小为8MB。</p>
<ul>
<li><p>Stack: 局部变量</p>
</li>
<li><p>Text：执行的机器指令，只可读</p>
</li>
<li><p>Data：存放全局变量，静态变量，字符串常量</p>
</li>
<li><p>Heap：动态申请，malloc，calloc，new</p>
</li>
<li><p>Shared Libraries：存放库函数，动态加载</p>
</li>
</ul>
<p>堆分配的内存是从高位低位向中间分配，中间的一部分没有分配的内存访问段错误。<code>这是由操作系统的管理策略决定</code></p>
<h2 id="Buffer-Overflow"><a href="#Buffer-Overflow" class="headerlink" title="Buffer Overflow"></a>Buffer Overflow</h2><p><strong>Vulnerability</strong></p>
<ul>
<li><p><code>gets()</code>: 函数不检查缓冲区大小，容易越界。 </p>
</li>
<li><p><code>strcpy</code>, <code>strcat</code>,<code>scanf</code>, <code>fscanf</code>, <code>sscanf</code>, 都有溢出风险。</p>
</li>
<li><p>机器指令是小端存放的，低位在前。 </p>
</li>
</ul>
<p><strong>Code Injection Attacks</strong></p>
<p>代码注入攻击，把字符填充到缓冲区中，形成可执行的指令，修改返回指针。</p>
<blockquote>
<p>Worm与Virus：蠕虫可以自己生存，病毒不能独自运行。</p>
</blockquote>
<p><strong>Protection</strong></p>
<p><strong>Randomized stack offsets</strong>栈随机化</p>
<p>栈随机化会让缓冲区随机变化，无法预测下一个地址。</p>
<p><strong>Nonexecutable code segments</strong></p>
<p>标记栈是不可执行的代码。</p>
<p><strong>Stack Canaries</strong></p>
<p><code>gcc -fstack-protector</code> 默认启动栈保护</p>
<p><code>%fs</code>: 特殊寄存器，某块内存的值，如果Canay值改变了说明有溢出。Canay值是<code>小端存放</code>。</p>
<blockquote>
<p>Canay的值最低位字节为0，这是字符串的off-by-one bug，虽然字符串的空字符占用了Canay值，产生了溢出，但是检测不到溢出。</p>
</blockquote>
<p><strong>Return-Oriented Programming Attacks</strong></p>
<p>Canay无法破解，但是我们知道代码在什么地方，全局变量和代码的位置没有改变，通过找到某段代码组合在一起，面向返回编程。</p>
<blockquote>
<p>gadget: 通过截断一些指令，形成新的指令，替换了程序计数器</p>
</blockquote>
<img src="/2023/05/24/13-04-09/WX20230608-112255@2x.png" class="">
<p>attack Lab中关闭了canary，可以通过缓冲区溢出设置需要的返回地址。</p>
<h2 id="Unions"><a href="#Unions" class="headerlink" title="Unions"></a>Unions</h2><ul>
<li><p>联合体只会为最大的域分配地址。</p>
</li>
<li><p>联合体可以用来做类型转换，不改变位。</p>
</li>
</ul>
<h2 id="大端小端"><a href="#大端小端" class="headerlink" title="大端小端"></a>大端小端</h2><ul>
<li><p>IA32：字节小端存放</p>
</li>
<li><p>x86-64：字节小端存放</p>
</li>
</ul>
]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 笔记六 存储器层次结构</title>
    <url>/2023/07/23/09-27-18/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>23.07.23：初稿</li>
</ul>
<h1 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h1><ul>
<li><a href="/2023/03/15/10-59-10/" title="csapp 笔记汇总">CSAPP - 笔记汇总</a></li>
<li><a href="/2023/05/24/13-04-09/" title="CSAPP 笔记三 程序的机器级表示">第三章 - 程序的机器级表示</a></li>
<li><a href="/2023/07/06/14-25-42/" title="CSAPP 笔记五 优化程序性能">第五章 - 优化程序性能</a></li>
<li><a href="/2023/07/23/09-27-18/" title="CSAPP 笔记六 存储器层次结构">第六章 - 存储器层次结构</a>
</li>
</ul>
<h1 id="The-Memory-Hierarchy"><a href="#The-Memory-Hierarchy" class="headerlink" title="The Memory Hierarchy"></a>The Memory Hierarchy</h1><h2 id="Storage-technologies-and-trends"><a href="#Storage-technologies-and-trends" class="headerlink" title="Storage technologies and trends"></a>Storage technologies and trends</h2><p><strong>Random-Access Memory(RAM)</strong></p>
<p>根据存储单元实现方式区分为：</p>
<p><strong>SRAM(Static)</strong></p>
<ul>
<li><p>4或6个晶体存储 1 bit， 成本很高</p>
</li>
<li><p>访问速度比DRAM快</p>
</li>
<li><p>不太需要EDC(error detection and correction)错误检测和纠正</p>
</li>
<li><p>组成cache</p>
</li>
</ul>
<p><strong>DRAM(Dynamic)</strong></p>
<ul>
<li><p>一个晶体存储 1 bit</p>
</li>
<li><p>需要刷新 </p>
</li>
<li><p>需要EDC</p>
</li>
<li><p>组成主存储器，图形显卡的帧缓存(frame buffers)</p>
</li>
</ul>
<p><strong>Nonvolatile Memories</strong></p>
<p>Read-only memory(ROM):生产期间硬编程一次</p>
<p>Programmable ROM(PROM): 可编程ROM</p>
<p>Eraseable PROM(EPROM): 可擦拭可编程ROM</p>
<p>Electrically eraseable PROM(EEPROM): 电子可擦拭可编程ROM</p>
<p>Flash memory: 闪存，提供了擦拭模块，但是会有损耗。</p>
<p><strong>Disk Drive</strong></p>
<p>因为机械特性，硬盘会比SRAM，DRAM慢很多。</p>
<img src="/2023/07/23/09-27-18/QQ20230723-095730@2x.jpg" class="">
<p>Sectors：扇区</p>
<img src="/2023/07/23/09-27-18/QQ20230723-143055@2x.jpg" class="">
<p>Cylinder: 柱面</p>
<p>Logical Disk Blocks：逻辑块</p>
<p>实现物理块与逻辑块之间的映射关系。</p>
<p><strong>Solid State Disks(SSDs)</strong></p>
<img src="/2023/07/23/09-27-18/QQ20230723-143913@2x.jpg" class="">
<ul>
<li><p>没有机械部件，由闪存翻译层固件控制</p>
</li>
<li><p>以页为单位读写，写入时必须擦拭整个块</p>
</li>
</ul>
<h2 id="Locality-of-reference"><a href="#Locality-of-reference" class="headerlink" title="Locality of reference"></a>Locality of reference</h2><p>程序的局部性</p>
<p>程序需要良好的局部性，有利用于读写内存。</p>
<h2 id="Caching-in-the-Memory-Hierarchy"><a href="#Caching-in-the-Memory-Hierarchy" class="headerlink" title="Caching in the Memory Hierarchy"></a>Caching in the Memory Hierarchy</h2><p>利用缓存和局部性原理构建了存储器层次结构。</p>
<img src="/2023/07/23/09-27-18/QQ20230723-144603@2x.jpg" class="">
<blockquote>
<p>高层保存着从低层检索到的数据</p>
</blockquote>
<p><strong>Caches</strong></p>
<img src="/2023/07/23/09-27-18/QQ20230723-144821@2x.jpg" class="">
<p>Cold (compulsory) miss: 冷命中，初始时cache为空</p>
<p>Conflict miss: 冲突不命中，位置被占用了</p>
<p>Capacity miss: 容量不命中，不可以容纳超过缓存大小的工作集</p>
]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 实验I Data Lab</title>
    <url>/2023/03/09/11-54-50/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>23.03.10：初稿</li>
<li></li>
</ul>
<h1 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h1><ul>
<li><a href="/2023/03/15/10-59-10/" title="csapp 笔记汇总">CSAPP - 笔记汇总</a></li>
<li><a href="/2023/03/09/11-54-50/" title="CSAPP 实验I Data Lab">I Data Lab - 位操作，数据表示</a></li>
<li><a href="/2023/03/14/09-43-26/" title="CSAPP 实验II Bomb Lab">II Bomb Lab - 汇编，栈帧与 gdb</a></li>
<li><a href="/2023/03/18/15-54-47/" title="CSAPP 实验III Attack Lab">III Attack Lab - 漏洞是如何被攻击的</a></li>
<li><a href="/2024/03/09/16-34-34/" title="CSAPP 实验IV CacheLab">IV Cache Lab - 实现一个缓存系统</a></li>
<li><a href="/2024/03/14/12-34-42/" title="CSAPP 实验V ShellLab">V Shell Lab - 实现一个Shell</a>
</li>
</ul>
<h1 id="任务目标"><a href="#任务目标" class="headerlink" title="任务目标"></a>任务目标</h1><p>DataLab实验，需要我们完善函数，条件是使用限定的操作符，并且操作符的数量也有限制，“=”不做数量限制。</p>
<h1 id="相关内容"><a href="#相关内容" class="headerlink" title="相关内容"></a>相关内容</h1><ol>
<li><p>自己定义的int整型的赋值范围是0到0xFF，8bits</p>
</li>
<li><p>机器是32位</p>
</li>
<li><p>只能使用一元操作符<code>!</code> <code>~</code>，二元操作符<code>&amp;</code> <code>|</code> <code>+</code> <code>&lt;&lt;</code> <code>&gt;&gt;</code> </p>
</li>
<li><p>不可以调用其他函数</p>
</li>
<li><p>测试命令</p>
<blockquote>
<p><code>make clean</code>：清除生成，每次修改<code>bits.c</code>文件都要清除重新生成<code>make</code>：生成文件<br><code>./btest -f funname -1 v</code>：测试单独的函数，带参数 <code>-T 100</code>：修改限制时间<br><code>./dlc bits.c</code> ：测试编码是否符合规则,符合规则无输出，参数<code>-e</code>，输出所有信息<br><code>./ishow 22</code>：输出int值的二进制，数值<br><code>./fshow 22</code>：输出float的二进制，数值，已经非规范值</p>
</blockquote>
</li>
</ol>
<h1 id="题目及解法"><a href="#题目及解法" class="headerlink" title="题目及解法"></a>题目及解法</h1><h2 id="bitXor"><a href="#bitXor" class="headerlink" title="bitXor"></a>bitXor</h2><ul>
<li><p>题目要求：返回两个int的异或值</p>
</li>
<li><p>允许操作：<code>~ &amp;</code></p>
</li>
<li><p>操作数量：14</p>
</li>
<li><p>分值：1</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bitXor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ~(~(~x &amp; y) &amp; ~(x &amp; ~y));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="tmin"><a href="#tmin" class="headerlink" title="tmin"></a>tmin</h2><ul>
<li><p>题目要求：求补码的最小值</p>
</li>
<li><p>允许操作：<code>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</code></p>
</li>
<li><p>操作数量：4</p>
</li>
<li><p>分值：1</p>
</li>
</ul>
<p>32位机器码的补码最小值是最高位为1，其他位0，所以用1左移31位形成。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tmin</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">  x = x &lt;&lt; <span class="number">31</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="isTmax"><a href="#isTmax" class="headerlink" title="isTmax"></a>isTmax</h2><ul>
<li><p>题目要求：如果x是补码最大值返回1，否则返回0</p>
</li>
<li><p>允许操作：<code>! ~ &amp; ^ | +</code></p>
</li>
<li><p>操作数量：10</p>
</li>
<li><p>分值：1</p>
</li>
</ul>
<p>补码的最大值是最高位0，其他位1。加1后是最小值，Tmin和Tmax每位都相反，Tmin^Tmax是全1，可以使用这个值进行返回。需要注意补码的特殊值Tmin，Tmax，还需要注意-1，32位全1 <code>1111</code>，因为-1 ^ 0 = 1，需要排除这种情况</p>
<ul>
<li><p>flag_2 表示x是否等于 -1 </p>
<ol>
<li><p>如果x==-1， y=0，y^0 == 0   flag_2为0</p>
</li>
<li><p>如果x!=-1，y!=0， y^0 != 0，flag_2不为0，flag的值是0或1，所以需要取非两次，把非零值转换为1</p>
</li>
</ol>
</li>
<li><p>flag_1 表示(x+1)^x，有两种情况结果为全1，x是<code>Tmax</code>和<code>-1</code>，我们只需要全为1的情况，所以先取反~，换成全0，再取非!， 转为1。</p>
</li>
<li><p>返回值为两个标志相与，用flag_2排除掉flag_1中-1的这种情况，剩下的就是Tmax</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isTmax</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> y = x + <span class="number">1</span>;  <span class="comment">//Tmin</span></span><br><span class="line">  <span class="type">int</span> flag_1 = !(~(x ^ y)); </span><br><span class="line">  <span class="type">int</span> flag_2= !!(y ^ <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> flag_1 &amp; flag_2; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="allOddBits"><a href="#allOddBits" class="headerlink" title="allOddBits"></a>allOddBits</h2><ul>
<li><p>题目要求：如果每一个偶数位都是1返回1，否则返回0</p>
</li>
<li><p>允许操作：<code>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</code></p>
</li>
<li><p>操作数量：12</p>
</li>
<li><p>分值：2</p>
</li>
</ul>
<p>先从32比特中只保留所有偶数位的值，其他位赋值0，再和<code>0xAAAAAAAA</code>作对比相等返回1，因为不能用等号，所以用异或^代替判断，如果相等全为0，取非!值为1，否则为0。</p>
<ul>
<li><p>移位和加法让变量y等于0xAAAAAAAA。</p>
</li>
<li><p>x与y相与，只留下x的偶数位的值</p>
</li>
<li><p>用异或判断x与y是不是相等</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">allOddBits</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> y = <span class="number">0xAA</span>; </span><br><span class="line">  <span class="comment">//+优先级大于 &lt;&lt; </span></span><br><span class="line">  y  = y + (y &lt;&lt; <span class="number">8</span>);</span><br><span class="line">  y = y + (y &lt;&lt; <span class="number">16</span>);</span><br><span class="line">  <span class="comment">//只留下x的偶数位值</span></span><br><span class="line">  x = x &amp; y;</span><br><span class="line">  <span class="keyword">return</span> !(y ^ x) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="negate"><a href="#negate" class="headerlink" title="negate"></a>negate</h2><ul>
<li><p>题目要求：返回-x</p>
</li>
<li><p>允许操作：<code>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</code></p>
</li>
<li><p>操作数量：5</p>
</li>
<li><p>分值：2</p>
</li>
</ul>
<p>这个比较简单，根据二进制补码x与-x就是按位取反再加1。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">negate</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ~x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="isAsciiDigit"><a href="#isAsciiDigit" class="headerlink" title="isAsciiDigit"></a>isAsciiDigit</h2><ul>
<li><p>题目要求：判断x是不是ASCII码的0-9， 相当于判断x的值是不是0x30到0x39。</p>
</li>
<li><p>允许操作：<code>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</code></p>
</li>
<li><p>操作数量：15</p>
</li>
<li><p>分值：3</p>
</li>
</ul>
<p>先观察0-9的补码形式</p>
<p>0x30 <code>110000</code>  </p>
<p>0x37 <code>110111</code>  </p>
<p>0x38 <code>111000</code>  </p>
<p>0x39 <code>111001</code></p>
<p>首先需要满足除后6位外，高位全为0，满足第一个条件后0-7满足前三位为<code>110</code>，剩下的直接对比是不是等于8或9。<code>不能使用等号所以用异或判断相等</code></p>
<ul>
<li><p>flag_1 右移6位后，如果高位全为0，就是0，取非!为1，不然就是0</p>
</li>
<li><p>flag_2 右移3位后，满足第一个条件的除了低3位其他全为0，与<code>110</code>比较相等就是0到7中的值</p>
</li>
<li><p>flag_3， flag_4，直接判断是不是等于8，9。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isAsciiDigit</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> y = x &amp; <span class="number">0x3f</span>; <span class="comment">//截取x的后6位</span></span><br><span class="line">  <span class="type">int</span> flag_1 = !(x &gt;&gt; <span class="number">6</span>); <span class="comment">//右移六位后,取非为1   x的高位全是0  符合条件</span></span><br><span class="line">  <span class="type">int</span> flag_2 = !((x &gt;&gt; <span class="number">3</span>) ^ <span class="number">0x6</span>);  <span class="comment">//满足第一个条件后,右移3位   异或110   如果为0  就是属于&#x27;0&#x27; 到&#x27;7&#x27;</span></span><br><span class="line">  <span class="type">int</span> flag_3 = !(y ^ <span class="number">0x38</span>);  <span class="comment">//满足第一个条件后   是&#x27;8&#x27;</span></span><br><span class="line">  <span class="type">int</span> flag_4 = !(y ^ <span class="number">0x39</span>);   <span class="comment">//满足第一个条件后   是&#x27;9&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> flag_1 &amp; (flag_2 | flag_3 | flag_4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="conditional"><a href="#conditional" class="headerlink" title="conditional"></a>conditional</h2><ul>
<li><p>题目要求：x不为0，返回y， x等于0，返回z。</p>
</li>
<li><p>允许操作：<code>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</code></p>
</li>
<li><p>操作数量：16</p>
</li>
<li><p>分值：3</p>
</li>
</ul>
<p>先找返回值，x等于0，return (x &amp; y) ^ (~x &amp; z)，x不等于0的时候，结果很多，这时候把x处理一下变为全1，返回值就相等了。</p>
<ul>
<li><p>对于x不等于0的情况，换全1比较麻烦，对x取非!，把x简化成0或1。</p>
</li>
<li><p>把x扩展到全1和全0，用移位加也能做出来而且满足操作数量的限制，继续做后面的题目<code>logicalNeg</code>想到了一个快速扩展的方法，0或1，取反加1，就是全0或者全1。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">conditional</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> &#123;</span><br><span class="line">  x = !x;   <span class="comment">//取非 把x变为 0 1两种    把他们扩展到32位</span></span><br><span class="line">  x = ~x + <span class="number">1</span>;  <span class="comment">//01快速扩展到全0全1 </span></span><br><span class="line"> <span class="comment">// x = (x &lt;&lt; 1) + x;</span></span><br><span class="line"> <span class="comment">// x = (x &lt;&lt; 2) + x;</span></span><br><span class="line"> <span class="comment">// x = (x &lt;&lt; 4) + x;</span></span><br><span class="line"> <span class="comment">// x = (x &lt;&lt; 8) + x;</span></span><br><span class="line"> <span class="comment">// x = (x &lt;&lt; 16) + x;</span></span><br><span class="line">  <span class="keyword">return</span> ((~x) &amp; y) ^ (x &amp; z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="isLessOrEqual"><a href="#isLessOrEqual" class="headerlink" title="isLessOrEqual"></a>isLessOrEqual</h2><ul>
<li><p>题目要求：x&lt;=y，返回1，否则返回0。</p>
</li>
<li><p>允许操作：<code>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</code></p>
</li>
<li><p>操作数量：24</p>
</li>
<li><p>分值：3</p>
</li>
</ul>
<p>找出所以返回1的情况，一共两种情况，相等，小于。相等的时候比较好做，用异或判断相等，小于的情况比较复杂。</p>
<ul>
<li><p>等于：flag_3表示相等的情况  异或判断</p>
</li>
<li><p>小于：有两种情况 <code>需要注意减法同号一点不会溢出</code></p>
<ol>
<li><p>flag_5：x负数，y正数。</p>
</li>
<li><p>flag_4：x，y同号，x &lt; y，转换为 y-x&gt;0。</p>
</li>
</ol>
</li>
<li><p>用flag_5 表示x负数，y正数。   <code>用右移31位看符号看判断正负</code></p>
</li>
<li><p>用flag_6 表示x正数，y负数。</p>
</li>
<li><p>用sum=y - x，flag_4 表示符号。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isLessOrEqual</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">  <span class="type">int</span> nagete_x = ~x + <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> sum = y + nagete_x; </span><br><span class="line">  <span class="type">int</span> flag_3 = !(x ^ y);</span><br><span class="line">  <span class="type">int</span> flag_5 = (x &gt;&gt; <span class="number">31</span>) &amp; !(y &gt;&gt; <span class="number">31</span>);   </span><br><span class="line">  <span class="type">int</span> flag_6 = !(x &gt;&gt; <span class="number">31</span>) &amp; (y &gt;&gt; <span class="number">31</span>);   </span><br><span class="line">  <span class="type">int</span> flag_4 = !(sum &gt;&gt; <span class="number">31</span>) &amp; !flag_5 &amp; !flag_6;   <span class="comment">//xy同号  减法不会溢出  减法有效</span></span><br><span class="line">  <span class="keyword">return</span> flag_3 | flag_4 | flag_5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="logicalNeg"><a href="#logicalNeg" class="headerlink" title="logicalNeg"></a>logicalNeg</h2><ul>
<li><p>题目要求：实现取非!的功能</p>
</li>
<li><p>允许操作：<code>~ &amp; ^ | + &lt;&lt; &gt;&gt;</code></p>
</li>
<li><p>操作数量：12</p>
</li>
<li><p>分值：4</p>
</li>
</ul>
<p>思路：取非结果只有0和1，把全0或全1加1，就是1或0，所以就需要把0转换为全1，非0转换为全0，然后加1，就是返回值。默认返回0，找出返回1的情况，也就是全1。<code>只有0和Tmin的负值和自己符号相同，其他的符号都相反</code></p>
<ul>
<li><p>取负值，对符号位扩展，然后自己的符号位和负值符号位相加，</p>
<ol>
<li><p>0和Tmin，结果为0。</p>
</li>
<li><p>其他结果为全1。</p>
</li>
</ol>
</li>
<li><p>flag_1：~sum，0和Tmin结果为全1， 其他为全0。</p>
</li>
<li><p>flag_2：~Tmin 01111 ~0全1</p>
</li>
<li><p>flag_3：flag_1 中排除到flag_2的Tmin情况</p>
<ol>
<li><p>Tmin <code>0111</code>  0为<code>1111</code>  其余为<code>0000</code></p>
</li>
<li><p>取反，只保留符号位， Tmin <code>1111</code> 0为<code>0000</code> 其余为<code>1111</code></p>
</li>
<li><p>加1后，0为<code>0001</code>， 其余都统一为<code>0000</code></p>
</li>
</ol>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">logicalNeg</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> neg_x = ~x;</span><br><span class="line">  <span class="type">int</span> y = neg_x + <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> hight_x = x &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  <span class="type">int</span> hight_y = y &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  <span class="type">int</span> flag_1 = ~(hight_x + hight_y);</span><br><span class="line">  <span class="type">int</span> flag_2 = neg_x;</span><br><span class="line">  <span class="type">int</span> flag_3 = (~(flag_1 &amp; flag_2) &gt;&gt; <span class="number">31</span>) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> flag_3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="howManyBits"><a href="#howManyBits" class="headerlink" title="howManyBits"></a>howManyBits</h2><ul>
<li><p>题目要求：返回表示x的补码最短长度 <code>注意-1，用一位</code></p>
</li>
<li><p>允许操作：<code>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</code></p>
</li>
<li><p>操作数量：90</p>
</li>
<li><p>分值：4</p>
</li>
</ul>
<p>思路：用上面做的函数 conditional 做两个if功能， 一次返回分半查找的剩余一半函数 ，一次计算分半如果选择前一半，bit数要加上一半的长度，选择后面长度加0不做处理。</p>
<blockquote>
<p>用0xffff0000 留下x的前16位,如果不等于0 说明位数大于16 等于0 说明位数小于16 在后16位内再进行分半查找</p>
</blockquote>
<p>正负数的处理<code>重点</code><br>都处理成正数，方便右移添0。加上符号位就是有效位数。</p>
<ul>
<li><p>正数：找出最高位的1。</p>
</li>
<li><p>负数：找出最高位的0，<code>Tmin也符合</code></p>
<blockquote>
<p>负数高位连续的1都是无用数据，只需要找到高位连续的1后的第一个0在哪里，做法是取反，如<code>1110010</code>，有用的数据是<code>10010</code>，全部取反后<code>0001101</code>， 有效位数是4位，加上符号位。</p>
</blockquote>
</li>
<li><p>flag_nage： x是负数 值为1</p>
</li>
<li><p>重点代码，</p>
<ol>
<li><p>if函数功能</p>
<blockquote>
<p><code>x = (extend_f_n &amp; (~x)) ^ ((~extend_f_n) &amp; x);</code> ：如果标记为全1，选择的~x， 如果为全0，选择的x。异或的两边有一个一直为全0，结果一定是另一个。</p>
</blockquote>
</li>
<li><p>一个二分法</p>
<blockquote>
<p><code>x_32 = x &amp; bit_32;</code> ：取x的前16位<br><code>x_32 = !x_32;</code>：取非，如果前16位全0，值就是1，否则是0<br><code>x_32 = ~x_32 + 1;</code> 前16位全0，扩充到全1，否则扩充到全0<br><code>flag_32 = ~x_32;</code> 这里是为了减少一个op值，重复使用代码<br><code>x_16 = (flag_32 &amp; (x &gt;&gt; 16)) ^ ((x_32 &amp; (x &amp; (~bit_32))));</code><br>x_32如果全0，说明前16位，有1，那就把x右移16位，覆盖掉后面，继续对这16位进行二分法。<code>这里不用考虑右移补1，因为都是正数最高位都是0</code>。并且总数加16。<br>如果全1，说明前16位都是0，要从后16位开始二分法，不用移位，x_16要等于x的后16位。总数加0。<br><code>sum = sum + (flag_32 &amp; 16);</code>：</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">howManyBits</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> x_32, x_16, x_8, x_4, x_2;  <span class="comment">//分别表示x的不同比特</span></span><br><span class="line">  <span class="type">int</span> bit_8 = <span class="number">0xff</span> &lt;&lt; <span class="number">8</span>;</span><br><span class="line">  <span class="type">int</span> bit_32 = (bit_8 + <span class="number">0xff</span>) &lt;&lt; <span class="number">16</span>;   </span><br><span class="line">  <span class="type">int</span> bit_16 = bit_8;</span><br><span class="line">  <span class="type">int</span> flag_32,flag_16,flag_8,flag_4,flag_2;  <span class="comment">//表示 ~x_32  重使用一次 减少 ops数量</span></span><br><span class="line">  <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> flag_nage = !!(x &gt;&gt; <span class="number">31</span>);     <span class="comment">//  x是负数   值为1</span></span><br><span class="line">  <span class="comment">//通过负0和Tmin 都是自己   ^之后为0  排除x是0的情况    当x是Tmin 是值为1</span></span><br><span class="line">  <span class="comment">//int flag_Tmin = !(x ^ (~x + 1)) &amp; x; </span></span><br><span class="line">  <span class="type">int</span> flag_Tmin = !(x &lt;&lt; <span class="number">1</span>) &amp; x;   <span class="comment">//Tmin 左移一位 去掉符号位后是全0   比上面的方法减少op</span></span><br><span class="line">  <span class="type">int</span> extend_f_T = ~flag_Tmin + <span class="number">1</span>;      <span class="comment">//扩展flag_Tmin</span></span><br><span class="line">  <span class="type">int</span> extend_f_n = ~flag_nage + <span class="number">1</span>;      <span class="comment">//扩展flag_nage</span></span><br><span class="line">  sum = sum + (flag_Tmin &amp; <span class="number">32</span>);</span><br><span class="line">  x = (extend_f_T &amp; <span class="number">0</span>) ^ ((~extend_f_T) &amp; x);  <span class="comment">// flag_Tmin 是1时  x赋值0   是0是  x不变</span></span><br><span class="line"></span><br><span class="line">  x = (extend_f_n &amp; (~x)) ^ ((~extend_f_n) &amp; x);  <span class="comment">// flag_nage 是1时  x赋值~x   是0是  x不变</span></span><br><span class="line"></span><br><span class="line">  bit_8 = <span class="number">0xf0</span>; </span><br><span class="line">  x_32 = x &amp; bit_32;</span><br><span class="line">  x_32 = !x_32;</span><br><span class="line">  x_32 = ~x_32 + <span class="number">1</span>;</span><br><span class="line">  flag_32 = ~x_32;</span><br><span class="line">  x_16 = (flag_32 &amp; (x &gt;&gt; <span class="number">16</span>)) ^ ((x_32 &amp; (x &amp; (~bit_32))));</span><br><span class="line">  sum = sum + (flag_32 &amp; <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">  x = x_16;   <span class="comment">//改变x</span></span><br><span class="line">  x_16 = x &amp; bit_16;</span><br><span class="line">  x_16 = !x_16;</span><br><span class="line">  x_16 = ~x_16 + <span class="number">1</span>;</span><br><span class="line">  flag_16 = ~x_16;</span><br><span class="line">  x_8 = (flag_16 &amp; (x &gt;&gt; <span class="number">8</span>)) ^ ((x_16 &amp; (x &amp; <span class="number">0xff</span>)));</span><br><span class="line">  sum = sum + (flag_16 &amp; <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">  x = x_8;   <span class="comment">//改变x</span></span><br><span class="line">  x_8 = x &amp; bit_8;</span><br><span class="line">  x_8 = !x_8;</span><br><span class="line">  x_8 = ~x_8 + <span class="number">1</span>;</span><br><span class="line">  flag_8 = ~x_8;</span><br><span class="line">  x_4 = (flag_8 &amp; (x &gt;&gt; <span class="number">4</span>)) ^ ((x_8 &amp; (x &amp; (<span class="number">0xf</span>))));   <span class="comment">//~bit_8  改为0xf  省一个op</span></span><br><span class="line">  sum = sum + (flag_8 &amp; <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">  x = x_4;   <span class="comment">//改变x</span></span><br><span class="line">  x_4 = x &amp; <span class="number">12</span>;</span><br><span class="line">  x_4 = !x_4;</span><br><span class="line">  x_4 = ~x_4 + <span class="number">1</span>;</span><br><span class="line">  flag_4 = ~x_4;</span><br><span class="line">  x_2 = (flag_4 &amp; (x &gt;&gt; <span class="number">2</span>)) ^ ((x_4 &amp; (x &amp; <span class="number">3</span>)));</span><br><span class="line">  sum = sum + (flag_4 &amp; <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  x = x_2;</span><br><span class="line">  x_2 = x_2 &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  x_2 = !x_2;</span><br><span class="line">  x_2 = ~x_2 + <span class="number">1</span>;</span><br><span class="line">  flag_2 = ~x_2;</span><br><span class="line">  x = (flag_2 &amp; (x &gt;&gt; <span class="number">1</span>)) ^ ((x_2 &amp; (x &amp; <span class="number">1</span>)));</span><br><span class="line">  sum = sum + (flag_2 &amp; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  sum = sum + (x &amp; <span class="number">1</span>);  <span class="comment">//如果x是0  或者处理之后的Tmin  剩余位全是0    不加最后一个比特位   其他情况加上1</span></span><br><span class="line"></span><br><span class="line">  sum = sum + (!flag_Tmin &amp; <span class="number">1</span>);   <span class="comment">//非Tmin  加上符号位    0符号位就是0  一个bit表示</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="floatScale2"><a href="#floatScale2" class="headerlink" title="floatScale2"></a>floatScale2</h2><ul>
<li><p>题目要求：无符号数保存的float值，返回乘2</p>
</li>
<li><p>允许操作：<code>所有的int，无符号操作符，if，while</code></p>
</li>
<li><p>操作数量：30</p>
</li>
<li><p>分值：4</p>
</li>
</ul>
<p>思路：</p>
<ol>
<li><p>0返回0</p>
</li>
<li><p>exp全1： 为无穷 直接返回</p>
</li>
<li><p>exp全0： <code>非规格化值：小数部分没有隐藏位</code></p>
<blockquote>
<p>f不是全0 直接加左移一位 最后补上符号。<code>非规格化到规格化的过渡</code><br>f是全0 不做处理 返回原值 ，就是第一种情况</p>
</blockquote>
</li>
<li><p>exp 不全1全0 直接加1 相当于乘2</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="title function_">floatScale2</span><span class="params">(<span class="type">unsigned</span> uf)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> bit_exp;</span><br><span class="line">  <span class="type">unsigned</span> bit_f;  <span class="comment">//小数部分</span></span><br><span class="line">  <span class="type">unsigned</span> flag_s;  <span class="comment">//符号位</span></span><br><span class="line">  <span class="keyword">if</span>(uf == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bit_f = uf &amp; (<span class="number">0x007fffff</span>);</span><br><span class="line">  bit_exp = uf &amp; (<span class="number">0x7f800000</span>);   <span class="comment">//取出指数部分</span></span><br><span class="line">  flag_s = uf &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  <span class="keyword">if</span>(bit_exp == <span class="number">0x7f800000</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> uf;</span><br><span class="line">  &#125;</span><br><span class="line">  bit_exp = bit_exp &gt;&gt; <span class="number">23</span>;       <span class="comment">//exp的值</span></span><br><span class="line">  <span class="keyword">if</span>(bit_exp != <span class="number">0</span>)&#123;</span><br><span class="line">    bit_exp = bit_exp + <span class="number">1</span>;</span><br><span class="line">    bit_exp = bit_exp &lt;&lt; <span class="number">23</span>;</span><br><span class="line">    uf = uf &amp; ~(<span class="number">0x7f800000</span>);</span><br><span class="line">    uf = uf ^ bit_exp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(bit_exp == <span class="number">0</span> &amp;&amp; bit_f != <span class="number">0</span>)&#123;</span><br><span class="line">      uf = uf &lt;&lt; <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(flag_s == <span class="number">1</span>)&#123;</span><br><span class="line">        uf = uf | (flag_s &lt;&lt; <span class="number">31</span>);  <span class="comment">//补上符号位</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> uf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="floatFloat2Int"><a href="#floatFloat2Int" class="headerlink" title="floatFloat2Int"></a>floatFloat2Int</h2><ul>
<li><p>题目要求：float转int值</p>
</li>
<li><p>允许操作：<code>所有的int，无符号操作符，if，while</code></p>
</li>
<li><p>操作数量：30</p>
</li>
<li><p>分值：4</p>
</li>
</ul>
<p>思路：<code>确定指数的范围</code></p>
<ol>
<li><p>exp &lt; 127 指数小于0时，是小数，返回0。</p>
</li>
<li><p>exp &gt; 158 指数大于31 越界</p>
</li>
<li><p>exp 全0 返回0</p>
</li>
<li><p>exp 全1 返回0x80000000u</p>
</li>
<li><p>exp 其他情况下 对f部分补上隐藏位1 再右移exp-127位，最后补上符号位</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">floatFloat2Int</span><span class="params">(<span class="type">unsigned</span> uf)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> bit_exp;</span><br><span class="line">  <span class="type">unsigned</span> bit_f;  <span class="comment">//小数部分</span></span><br><span class="line">  <span class="type">unsigned</span> flag_s;  <span class="comment">//符号位</span></span><br><span class="line">  <span class="type">unsigned</span> E;      <span class="comment">//指数</span></span><br><span class="line">  <span class="type">int</span> F2Int;</span><br><span class="line">  bit_f = uf &amp; (<span class="number">0x007fffff</span>);   <span class="comment">//取出小数部分</span></span><br><span class="line">  bit_f = bit_f | (<span class="number">0x00800000</span>);  <span class="comment">//补上前面隐藏1</span></span><br><span class="line">  bit_exp = uf &amp; (<span class="number">0x7f800000</span>);   <span class="comment">//取出指数部分</span></span><br><span class="line">  bit_exp = bit_exp &gt;&gt; <span class="number">23</span>;</span><br><span class="line">  flag_s = uf &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  <span class="comment">//printf(&quot;s %u %x  exp  %u %x   f  %u  %x\n&quot;, flag_s, flag_s, bit_exp, bit_exp, bit_f, bit_f);</span></span><br><span class="line">  <span class="keyword">if</span>(bit_exp == <span class="number">0xff</span> || bit_exp &gt; <span class="number">158</span>)&#123;  <span class="comment">//无穷   或者NaN   指数越界  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x80000000</span>u;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(bit_exp &lt; <span class="number">127</span> || bit_exp  == <span class="number">0</span>)&#123;  <span class="comment">//指数是负数   非规格数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;   </span><br><span class="line">  E = bit_exp - <span class="number">127</span>;</span><br><span class="line">  bit_f = bit_f &gt;&gt; (<span class="number">23</span> - E);  <span class="comment">//右移</span></span><br><span class="line">  <span class="comment">//printf(&quot;E %u %x  bit_f   %u %x \n&quot;, E, E, bit_f, bit_f);</span></span><br><span class="line">  F2Int = bit_f;   </span><br><span class="line">  <span class="keyword">if</span>(flag_s == <span class="number">1</span>)&#123;</span><br><span class="line">    F2Int = -F2Int;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> F2Int;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="floatPower2"><a href="#floatPower2" class="headerlink" title="floatPower2"></a>floatPower2</h2><ul>
<li><p>题目要求：返回float值 2的x次方，x为32位int</p>
</li>
<li><p>允许操作：<code>所有的int，无符号操作符，if，while</code></p>
</li>
<li><p>操作数量：30</p>
</li>
<li><p>分值：4</p>
</li>
</ul>
<p>思路：<code>确定指数的范围</code> x为-127到128之间。</p>
<p>时间超时 10s内跑不完所有测试数据 可能是电脑问题</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="title function_">floatPower2</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> bit_exp;</span><br><span class="line">  <span class="type">unsigned</span> bit_float;  <span class="comment">//float值的bit位</span></span><br><span class="line">  <span class="type">unsigned</span> INF = <span class="number">0x7f800000</span>;</span><br><span class="line">  <span class="keyword">if</span>(x &lt; <span class="number">-127</span>)&#123;  <span class="comment">//值太小</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;   </span><br><span class="line">  <span class="keyword">if</span>(x &gt; <span class="number">128</span>)&#123;  <span class="comment">//太大  返回+INF</span></span><br><span class="line">    <span class="keyword">return</span> INF;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//printf(&quot;x    %d\n&quot;, x);</span></span><br><span class="line">  bit_exp = x + <span class="number">127</span>;</span><br><span class="line">  bit_exp = bit_exp &lt;&lt; <span class="number">23</span>;</span><br><span class="line">  <span class="comment">//printf(&quot;bit_float  %u  %x\n&quot;, bit_float, bit_float);</span></span><br><span class="line">  <span class="keyword">return</span> bit_exp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 实验II Bomb Lab</title>
    <url>/2023/03/14/09-43-26/</url>
    <content><![CDATA[<p>更新历史：</p>
<ul>
<li>23.03.14：初稿</li>
<li>23.03.18：新增secret_phase</li>
</ul>
<h1 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h1><ul>
<li><a href="/2023/03/15/10-59-10/" title="csapp 笔记汇总">CSAPP - 笔记汇总</a>
</li>
<li><a href="/2023/03/09/11-54-50/" title="CSAPP 实验I Data Lab">I Data Lab - 位操作，数据表示</a>
</li>
<li><a href="/2023/03/14/09-43-26/" title="CSAPP 实验II Bomb Lab">II Bomb Lab - 汇编，栈帧与 gdb</a>
</li>
<li><a href="/2023/03/18/15-54-47/" title="CSAPP 实验III Attack Lab">III Attack Lab - 漏洞是如何被攻击的</a>
</li>
<li><a href="/2024/03/09/16-34-34/" title="CSAPP 实验IV CacheLab">IV Cache Lab - 实现一个缓存系统</a>
</li>
<li><a href="/2024/03/14/12-34-42/" title="CSAPP 实验V ShellLab">V Shell Lab - 实现一个Shell</a>
</li>
</ul>
<h1 id="任务目标"><a href="#任务目标" class="headerlink" title="任务目标"></a>任务目标</h1><p>Bomb Lab实验，使用GDB工具拆除六个阶段的炸弹，需要仔细输入，爆炸次数过多实验会失败。</p>
<h1 id="相关内容"><a href="#相关内容" class="headerlink" title="相关内容"></a>相关内容</h1><ol>
<li><p>下载自己的炸弹，不能修改bomb.c代码。</p>
</li>
<li><p>每爆炸一次失去一半的分数。</p>
</li>
<li><p>测试命令</p>
<blockquote>
<p><code>./bomb</code>：运行炸弹程序， <code>psol.txt</code>：文件输入答案</p>
</blockquote>
</li>
<li><p>GDB命令</p>
<blockquote>
<p><code>gdb boom</code>：调试命令。参数：<code>-e</code>：置顶可执行文件名<br><code>quit</code>：退出调试<br><code>run [参数]</code>：运行程序；<code>&lt; psol.txt</code>：文件输入<br><code>continue</code>：断点继续<br><code>print expr</code>：打印表达式值，区别：x打印的内存的值<br><code>nexti</code>：单步执行，不进入函数调用<br><code>stepi</code>：单步执行进入函数调用<br><code>break function</code>：函数处断点<br><code>break *address</code>：内存地址处断点<br><code>delete n</code>：删除n号断点<br><code>delete</code>：删除所有断点<br><code>finish</code>：运行的当前函数返回停止<br><code>x/5cb str</code> ：显示5个单字节；<code>h</code>：两个；<code>w</code>：四个；<code>g</code>：八个<br><code>x/1sb str</code> ：显示字符串str<br><code>x/4dw arr</code> ：取4个整型数字以十进制格式显示<br><code>display arr</code>：每次断点都打印数据，参数<code>/x /s /u /c</code>。<br><code>disas</code>：反汇编当前函数<br><code>info registers</code>：显示寄存器内容</p>
</blockquote>
</li>
<li><p>objdump命令 <code>反汇编</code></p>
<blockquote>
<p><code>objdump -t</code>：打印变量内容的存储位置<br><code>objdump -d bomb &gt; bomb.s</code>：反汇编生成bomb.s文件。<code>需要使用gdb查看函数</code></p>
</blockquote>
</li>
<li><p>screen 命令 <code>分屏看汇编文件，也可以不分屏在GDB中使用disas命令</code></p>
<blockquote>
<p><code>screen -ls</code>：查看所有screen终端<br><code>screen -S name</code> ：创建终端<br><code>screen -r name or id</code> ：连接终端。连接失败用<code>screen -d **</code>：连接<br><code>exit</code>：退出终端<br><code>Ctrl + a，d</code>：暂离；<code>c</code>：创建子会话；<code>w</code>：子会话列表；<code>p</code>：上一个；<code>n</code>：下一个；<code>0-9</code>：切换；<code>：</code>：命令行模式(<code>resize 80</code>)调整窗口大小。<br><code>screen -S id -X quit</code>：关闭视窗</p>
</blockquote>
</li>
<li><p>函数参数传递相关寄存器</p>
<blockquote>
<p><code>%rax</code>：返回值<br><code>%rdi</code>：第一个参数<br><code>%rsi</code>：第二个参数<br><code>%rdx</code>：第三个参数<br><code>%rcx</code>：第四个参数<br><code>%d8</code>，<code>%d9</code>，<code>%d10</code>依次是后面的参数</p>
</blockquote>
</li>
</ol>
<h1 id="题目及解法"><a href="#题目及解法" class="headerlink" title="题目及解法"></a>题目及解法</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先从源码<code>bomb.c</code>可以看出调用顺序，通过函数<code>explode_bomb</code>让炸弹爆炸，所有我们在调试过程中，在这个函数处打断点，每次只要输入错误密码，炸弹爆炸的时候程序都会进入断点，这样就不会扣分了。从源码里还能看出每一个关卡的函数都是<code>phase_x</code>，所以每次调试之前，在爆炸处打断点，在<code>phase_x</code>处打断点，进入这关之后，用反汇编命令<code>disas</code>，显示函数的汇编代码，然后进行解题。</p>
<h2 id="phase-1"><a href="#phase-1" class="headerlink" title="phase_1"></a>phase_1</h2><p>思路：</p>
<p>第一个比较简单，找到字符串对比函数，参数1放在寄存器rdi里，参数2放在寄存器rsi里。<br>在字符串对比函数内打断点，命令<code>x/1sb $rsi</code>,打印出寄存器里的字符串内容。<br>做法：</p>
<ol>
<li><p><code>break phase_1</code> ：打断点</p>
</li>
<li><p><code>disas</code>：显示汇编指令</p>
<img src="/2023/03/14/09-43-26/WX20230315-120145@2x.png" class="">
</li>
<li><p><code>break explode_bomb</code> ：在爆炸函数打断点，防止进入这里引爆炸弹  </p>
</li>
<li><p>根据汇编语言可以看出，输入的字符串在调用字符串对比函数中进行对比，根据返回值进行选择是否爆炸。<br><code>break strings_not_equal</code> ：打断点</p>
</li>
<li><p><code>x/1sb $rsi</code>：打印<code>$rsi</code>内容，根据phase_1函数的汇编指令中，改变了rsi内容，说明我们输入的密码在<code>$rdi</code>中，解密的密码在<code>$rsi</code>中。</p>
<img src="/2023/03/14/09-43-26/WX20230315-122703@2x.png" class="">
</li>
</ol>
<p>答案:</p>
<p><code>Border relations with Canada have never been better.</code></p>
<h2 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h2><p>思路：</p>
<p>第二个主要是是在函数分配的栈里面进行操作,通过sscanf函数的第二个参数,format,”%d %d %d %d %d %d”，可以看出密码应该是六个数,通过记录的<code>%rsi</code>是phase2函数的<code>%rsp</code>，可以知道最终密码应该是保存在主函数的栈区，第一次和1比较,相同才能继续，第一个数字是1， 后面每一个数字都是和前一个数字*2相比较，那么就是一个等比数列，公比2。<br>做法：</p>
<ol>
<li><p><code>break phase_2</code> ：打断点</p>
</li>
<li><p><code>disas</code>：显示汇编指令</p>
<img src="/2023/03/14/09-43-26/WX20230315-164003@2x.png" class="">
<p>发现函数调用了read_six_numbers函数，所以继续在这里打断点，看具体输入了什么。</p>
</li>
<li><p><code>break read_six_numbers</code>，查看这个函数的汇编指令</p>
<img src="/2023/03/14/09-43-26/WX20230315-164335@2x.png" class="">
<p>从调用sscanf函数之前可以看出输入格式在第二个参数里 ，以在调用之前打断点，打印<code>rsi</code>的内容。从调用爆炸函数的条件也可以看出来，sscanf返回值大于等于6的时候才会正常跳转，输入的数太少会直接爆炸。</p>
<img src="/2023/03/14/09-43-26/WX20230315-164848@2x.png" class="">
<p>这道题的密码应该是6位数字，输入的内容保存在后面的传参里，地址在<code>rsi</code>寄存器里，根据phase_2的调用之前，<code>rsi</code>寄存器里存的是<code>rsp</code>的地址，所以可以判断出，读取函数把输入的数字存到了<code>rsp</code>内的地址里。</p>
</li>
<li><p>根据返回到phase_2函数的下一条指令<code>cmpl   $0x1,(%rsp)</code><br><code>cmpl</code>：代表双字，四个字节，用<code>x/6dw $rsp</code>：打印输入的内容看一下是不是自己输入的；根据跳转条件可以看出，第一个密码是1，</p>
</li>
<li><p>第一个密码正确后，依次看后面的指令:<br><code>lea    0x4(%rsp),%rbx</code>：下四个字节，第二个密码地址放到<code>rbx</code>里。<br><code>lea    0x18(%rsp),%rbp</code>：第24字节地址放到<code>rbx</code>里。<code>相当于for循环结束条件</code><br><code>mov    -0x4(%rbx),%eax</code>：第一个密码1存到<code>eax</code>。<br><code>add    %eax,%eax</code>：<code>eax</code>+<code>eax</code>。<code>乘2</code><br><code>cmp    %eax,(%rbx)</code>：对比第二个密码是不是2。<br><code>add    $0x4,%rbx</code>：<code>rbx</code>指向下四个字节，第三个密码。<br><code>cmp    %rbp,%rbx</code>：对比是不是到了结束末尾，否则继续进行循环。<br>所以这六个数字密码是一个1开头的等比数列，公比为2。</p>
</li>
</ol>
<p>答案:</p>
<p><code>1 2 4 8 16 32</code></p>
<h2 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h2><p>思路：</p>
<p>第三个和第二个相同,查看输入的是两个%d,存在phase3的栈里面,不一样的地方是,这道题目的答案有7种,因为第一个密码小于7,所有一共有8组答案,分别是0,207,   1-0x137,2-0x2c3,3-0x100,4-0x185,5-0xce, 6-0x2aa, 7-0x147.<br>做法：</p>
<ol>
<li><p><code>break phase_3</code> ：打断点</p>
</li>
<li><p><code>disas</code>：显示汇编指令</p>
<img src="/2023/03/14/09-43-26/WX20230316-103622@2x.png" class="">
<p>找到<code>sscanf</code>函数，和之前一样打断点查看输入格式。</p>
</li>
<li><p><code>x/1sb $rsi</code>：这道题的密码应该是两个数</p>
<img src="/2023/03/14/09-43-26/WX20230316-103921@2x.png" class="">
</li>
<li><p>基本步骤和上面一样，看一下密码对比的循环指令：<br><code>cmpl   $0x7,0x8(%rsp)</code>：对比第一个数字和7的大小<br><code>ja     0x400fad &lt;phase_3+106&gt;</code>：无符号大于就跳转，跳转之后调用了爆炸函数，说明第一个数字小于等于7并且大于等于0<code>负数当无符号数时第一位总是1，一定比8大</code>。<br><code>mov    0x8(%rsp),%eax</code>：把第一个数字放到<code>eax</code>里。<br><code>jmpq   *0x402470(,%rax,8)</code>：跳转到<code>*(0x402470 + (%rax * 8))</code><br>打印一下从<code>0x402470</code>这里开始存的是什么：<code>x/8xg 0x402470</code>或者<code>x/64xb 0x402470</code>：这里要注意数据是按照大端法存储的。</p>
<img src="/2023/03/14/09-43-26/WX20230316-110646@2x.png" class="">
<p>可以看出对应跳转关系，跳转后执行的指令为：<code>mov    $0xcf,%eax</code>，根据不同的第一位数字得到的为：<code>0--0xcf</code> <code>1--0x137</code> <code>2--0x2c3</code> <code>3--0x100</code> <code>4--0x185</code> <code>5--0xce</code> <code>6--0x2aa</code> <code>7--0x147</code></p>
</li>
</ol>
<p>答案:</p>
<p><code>0 207</code></p>
<h2 id="phase-4"><a href="#phase-4" class="headerlink" title="phase_4"></a>phase_4</h2><p>思路：</p>
<p>第四个主要难点在func4函数里有一个单操作数的sar指令，之前一直以为移位的数存在寄存器cl里，后来才发现这是默认移位1，所有这个题的密码第一位是在用二分法在(0-14)中找值，但是由于函数返回值是0才不会爆炸，往右半部分查找时，返回值不为0,所以密码只能在左半部分，分别是7，3，1，0，四种答案，第二个密码是在phase_4函数里，对比的数字是0，所以第二个密码是0。<br>做法：</p>
<ol>
<li><p><code>break phase_4</code> ：打断点</p>
</li>
<li><p><code>disas</code>：显示汇编指令</p>
<img src="/2023/03/14/09-43-26/WX20230316-112833@2x.png" class="">
<p>找到<code>sscanf</code>函数，和之前一样打断点查看输入格式。这道题和上一道的<code>rsi</code>内容一样，说明都是两个数。</p>
</li>
<li><p><code>cmpl   $0xe,0x8(%rsp)</code>：<br><code>jbe    0x40103a &lt;phase_4+46&gt;</code>：小于等于跳转，说明第一个密码小于等于14。<br><code>mov    $0xe,%edx</code>：14存到<code>rdx</code>第三个参数。<br><code>mov    $0x0,%esi</code>：0存到<code>rsi</code>第二个参数。<br><code>mov    0x8(%rsp),%edi</code>：第一个密码存到<code>rdi</code>第一个参数。<br><code>callq  0x400fce &lt;func4&gt;</code>：调用func4函数。</p>
</li>
<li><p><code>disas</code>：打断点反汇编，区间(a,b)</p>
<img src="/2023/03/14/09-43-26/WX20230316-113725@2x.png" class="">
<p><code>mov    %edx,%eax</code>：第三个参数14存到<code>rax</code><br><code>sub    %esi,%eax</code>：<code>rax</code>-<code>rsi</code><br><code>mov    %eax,%ecx</code>：把两个参数的差存到<code>rcx</code> 记为m<br><code>shr    $0x1f,%ecx</code>：<code>ecx</code>逻辑右移31位，<code>ecx</code>是32位的，移动31位，只剩下了符号位。<br><code>add    %ecx,%eax</code>：<code>eax</code>等于0+差。<code>如果b-a=-1，ecx=1，eax+1=0</code><br><code>sar    %eax</code>：<code>eax</code>右移一位，算术右移，等于7，m<br><code>lea    (%rax,%rsi,1),%ecx</code>：加载有效地址，效果是<code>rcx</code>里存入了a+m<br><code>cmp    %edi,%ecx</code>比较中间值是否等于第一个数字。<br>如果大于：<code>lea    -0x1(%rcx),%edx</code>b等于m-1。递归函数，左边区间查找是结束递归后<code>rax</code>乘2。<br>小于等于：<br><code>mov    $0x0,%eax</code>：<code>eax</code>等于0<br><code>cmp    %edi,%ecx</code>：对比中间值和第一个数字<br><code>jge    0x401007 &lt;func4+57&gt;</code>：大于等于跳转，本来是小于等于，相等于等于跳转，所以结束标志是第一个参数等于中间值m。返回值<code>rax</code>为0。<br><code>0x1(%rcx),%esi</code>：小于时，a = m+ 1，继续递归，小于时结束递归后执行的是<code>0x1(%rax,%rax,1),%eax</code>，不为0。</p>
</li>
<li><p>根据<code>func4</code>返回后<code>test   %eax,%eax</code>，如果不相等就爆炸，所以eax只能等于0，所以第一个数字一定是在二分查找的左边区间，所以可能值为7，3，1，0。</p>
</li>
<li><p><code>cmpl   $0x0,0xc(%rsp)</code>：相等时函数结束，说明第二个密码是固定值0。</p>
</li>
</ol>
<p>答案:</p>
<p><code>0 0</code></p>
<h2 id="phase-5"><a href="#phase-5" class="headerlink" title="phase_5"></a>phase_5</h2><p>思路：</p>
<p>第五个比较有趣,还是和12一样计算字符串长度,知道密码应该是一个6位长度字符串，计算字符串是不是相等函数的参数显示待匹配的字符串是”flyers”，编译的时候用了canary，栈指针每次都不同，这个对解密应该是没影响，主要是输入的字符串，每一个字节只保留了低四位,然后加上一个地址，将内存中的值送到了rsp里，那么这个地址应该是一个数组，打印一下这个地址开始的15个字节，是一串字符maduiersnfotvbyl，需要我们从里面找出密码，位置分别是9，15，14，5，6，7。所以输入的字符串的ASCII编码后四位应该就是这个值，答案比较多，找<br>了一个’a’-‘z’中的答案。<br>做法：</p>
<ol>
<li><p><code>break phase_5</code> ：打断点</p>
</li>
<li><p><code>disas</code>：显示汇编指令</p>
<img src="/2023/03/14/09-43-26/WX20230316-132301@2x.png" class="">
<p>根据字符串对比函数的下一条<code>cmp    $0x6,%eax</code>，可以看出这道题密码长度为6。</p>
</li>
<li><p>分析跳转后的代码</p>
<img src="/2023/03/14/09-43-26/WX20230316-160027@2x.png" class="">
<p><code>movzbl (%rbx,%rax,1),%ecx</code>：<code>ecx</code>内存的是<code>rbx</code>的第<code>rax</code>个字节做零扩展到双字，如图是<code>0x69</code>；<code>rax</code>相当于是for循环里的i。<br><code>mov    %cl,(%rsp)</code>：把<code>rcx</code>的低八位送入栈顶指针指向的地址。<br><code>mov    (%rsp),%rdx</code>：把值继续送到<code>rdx</code>。<br><code>and    $0xf,%edx</code>：只保留<code>rdx</code>的低四位。<br><code>movzbl 0x4024b0(%rdx),%edx</code>：把<code>rdx</code>的值加上<code>0x4024b0</code>，新地址的内容存到<code>edx</code>里。<br><code>mov    %dl,0x10(%rsp,%rax,1)</code>：把<code>rdx</code>的低八位存入<code>rax+rsp+0x10</code>的位置。<br><code>add    $0x1,%rax</code>：i自加<br><code>cmp    $0x6,%rax</code>：循环结束判断</p>
</li>
<li><p>后续指令把所有的输入字符改变之后保存在了<code>rsp + 0x10</code>指向的地址里，然后调用<code>strings_not_equal</code>：我们可以根据查看传参，看一下标准答案是什么。</p>
<img src="/2023/03/14/09-43-26/WX20230316-161808@2x.png" class="">
<p>可以看到密码是字符串<code>flyers</code>，对应的字节是<code>0x66 0x6c 0x79 0x65 0x72 0x73</code>。</p>
</li>
<li><p>我们在打印一下for循环里跳转的地址<code>0x4024b0</code>保存的是什么?</p>
<img src="/2023/03/14/09-43-26/WX20230316-162400@2x.png" class="">
<p>由于偏移量总是低四位，范围是0-15，所以字符串只需要关注<br><code>maduiersnfotvbyl</code>前面这些，需要我们从里面找出密码，位置分别是9，15，14，5，6，7。所以输入的字符串的ASCII编码后四位应该就是这个值，答案比较多，找了一个’a’-‘z’中的答案。</p>
</li>
</ol>
<p>答案:</p>
<p><code>ionefg</code></p>
<h2 id="phase-6"><a href="#phase-6" class="headerlink" title="phase_6"></a>phase_6</h2><p>思路：</p>
<p>第六个是一个链表，节点的前八个字节中低位是数据，高位是输入的密码，高位的8个字节是下一跳地址，根据输入的6个数必须是1-6，切两两不相同，还进行了一次处理，每一位密码x，变成了y = 7-x。</p>
<p>然后是链表的操作，每一个密码的节点对应的是(y - 1) * 8 + 结点首地址， 分配好结点后进行结点连接。<br>每一位密码的下一跳就是下一位密码对应的结点地址，最后一位结点的下一跳是0；要求是必要让结点中的数据，满足前一个结点大于等于后一个结点，<br>而所有结点的数据分别是：<br>(1):332<br>(2):168<br>(3):924<br>(4):691<br>(5):477<br>(6):443<br>所以数据最大的结点应该在最前面，序号应该是3 4 5 6 1 2。<br>而输入的密码应该是7 - y：   4 3 2 1 6 5<br>做法：</p>
<ol>
<li><p><code>break phase_6</code> ：打断点</p>
</li>
<li><p><code>disas</code>：显示汇编指令</p>
<img src="/2023/03/14/09-43-26/WX20230316-163103@2x.png" class="">
<img src="/2023/03/14/09-43-26/WX20230316-163118@2x.png" class="">
<img src="/2023/03/14/09-43-26/WX20230316-163134@2x.png" class="">
</li>
<li><p>根据指令，这道题是读取了六个数字，我们直接看后面的处理。输入的数字保存在<code>rsp</code>指向的地址里。每个数字存储在四个字节里<br><code>mov    %rsp,%r14</code>：把输入的数组起始地址送到<code>r14</code><br><code>mov    $0x0,%r12d</code>：<code>r12d</code>赋值0，记为<code>i</code><br><code>mov    %r13,%rbp</code>：<code>rbp</code>保存栈顶指针，数组起始地址<br><code>mov    0x0(%r13),%eax</code>：<code>rax</code>等于输入的第一个值<br><code>sub    $0x1,%eax</code>：自减1<br><code>cmp    $0x5,%eax</code>：判断<code>rax</code>是不是等于5<br><code>jbe    0x401128 &lt;phase_6+52&gt;</code>：无符号小于等于才不会爆炸，所以输入的数字自减前必须是<code>1-6</code>。<br><code>add    $0x1,%r12d</code>：<code>i</code>+1<br><code>cmp    $0x6,%r12d</code>：循环结束标志，相等跳转<br>不相等：<br><code>mov    %r12d,%ebx</code>：把<code>i</code>送到<code>rbx</code>， 记为<code>j = i + 1</code>。<br><code>movslq %ebx,%rax</code>：符号扩展送到<code>rax</code>，等于<code>j</code><br><code>mov    (%rsp,%rax,4),%eax</code>：输入的第<code>j</code>个数 送到 <code>rax</code><br><code>cmp    %eax,0x0(%rbp)</code>：对比<code>rax</code>和栈顶指针指向的数是否相同，相等就爆炸，数字不能重复。<br><code>add    $0x1,%ebx</code>：<code>j++</code><br><code>cmp    $0x5,%ebx</code>：循环跳出条件，后面的每一个数不能和第一个数相等。<br><code>add    $0x4,%r13</code>：循环重复，<code>i</code>指向下一个数<br>所有的数范围是<code>1-6</code>，且不重复时。</p>
</li>
<li><p><code>lea    0x18(%rsp),%rsi</code>：把最后一个数的地址送到<code>rsi</code><br><code>mov    %r14,%rax</code>：数组的第一个地址送到<code>rax</code><br><code>mov    $0x7,%ecx</code>：<code>rcx</code>等于7<br><code>mov    %ecx,%edx</code>：<code>rdx</code> = 7<br><code>sub    (%rax),%edx</code>：<code>rdx</code> = 7 - <code>*rax</code>，数组的第一个数<br><code>mov    %edx,(%rax)</code>：覆盖这个数<br><code>add    $0x4,%rax</code>：数组下一个<br><code>cmp    %rsi,%rax</code>：跳出条件<br>这段代码把所有数组的数，全部用7减，保存差</p>
</li>
<li><p><code>mov    $0x0,%esi</code>：<code>rsi</code> = 0，记为<code>i</code><br><code>mov    (%rsp,%rsi,1),%ecx</code>：<code>rcx</code>保存<code>rsp</code>的第<code>i</code>个字节地址的数字，记为<code>x</code>，注意数字在4的倍数字节处<br><code>cmp    $0x1,%ecx</code>：<code>x</code> == 1，1进行这个if判断<br>如果x==1：<br><code>mov    $0x6032d0,%edx</code>：<code>rdx</code>赋值，这里要注意应该就是密码所在地<br>如果x&gt;1：<br><code>mov    $0x1,%eax</code>：<code>rax</code> = 1<br><code>mov    $0x6032d0,%edx</code>:<br><code>mov    0x8(%rdx),%rdx</code>：<code>rdx</code> =  （<code>rdx</code> + 8地址保存的数据），就是<code>rdx</code>地址指向的节点的next。<br><code>add    $0x1,%eax</code>：<code>rax</code> + 1<br><code>cmp    %ecx,%eax</code>：对比<code>x</code>和<code>rax</code><br>不相等时<code>rax</code>一直加1，最终<code>rdx</code>指向第x个节点地址<br>if判断结束：<br><code>mov    %rdx,0x20(%rsp,%rsi,2)</code>：把<code>rdx</code>数送入<code>rsp</code> + 2 <em> i + 0x20，这个地址，相当于把数组整体换位置，后面是偏移量。<br><code>add    $0x4,%rsi</code>：<code>i</code> = <code>i</code> + 4<br><code>cmp    $0x18,%rsi</code>：结束条件<br>这段循环把数组里的数，全部向后偏移保存了一个数组，这个数组中0，1对应的是固定值<code>$0x6032d0</code>，大于1的值都是`$0x6032d0 + 8 </em> (x - 1)`。新数组的每一个数长度是8字节，数据是一串地址。</p>
<img src="/2023/03/14/09-43-26/WX20230317-124521@2x.png" class="">
<p>可以看出在<code>rsp</code>后0x20地址处，是六个地址。</p>
</li>
<li><p><code>mov    0x20(%rsp),%rbx</code>：<code>rbx</code>等于新建数组的第一个数，记为<code>i</code><br><code>lea    0x28(%rsp),%rax</code>：<code>rax</code>是新数组第二个数的地址，记为<code>&amp;j</code><br><code>lea    0x50(%rsp),%rsi</code>：<code>rsi</code>数组最大地址<br><code>mov    %rbx,%rcx</code>：<code>rcx</code>存第一个数，记为<code>i</code><br>循环：<br><code>mov    (%rax),%rdx</code>：<code>rdx</code>：存下个数，记为<code>j</code><br><code>mov    %rdx,0x8(%rcx)</code>：把<code>j</code>放到<code>i</code>后8个字节处<br><code>add    $0x8,%rax</code>：<code>&amp;j = &amp;j + 8</code>，后移八个字节<br><code>cmp    %rsi,%rax</code>：对比有没有到了数组末尾<br>没有到最后一个地址：<br><code>mov    %rdx,%rcx</code>：<code>rcx</code> = <code>rdx</code>，<code>i</code>后移8个字节<br>继续上面的循环<br>如果到了最后一个地址：<br><code>movq   $0x0,0x8(%rdx)</code>：把0存到最后一个节点的后8字节处，尾结点的next=0。<br>上面把所有链表连接起来了。链接方式是按照输入的六个数字进行连接，按照1-6的顺序，数字越大，地址越大。每个数字代表一个地址，从1-6链接起来。</p>
</li>
<li><p>下面进行的是爆炸判断：<br><code>mov    $0x5,%ebp</code>：<code>rbp</code> = 5<br>循环：<br><code>mov    0x8(%rbx),%rax</code>：<code>rax</code>=第一个节点的next<br><code>mov    (%rax),%eax</code>：<code>rax</code>=地址保存的数<br><code>cmp    %eax,(%rbx)</code>：<em>next对比*</em>this<br>小于就爆炸：<br>大于等于：<br><code>mov    0x8(%rbx),%rbx</code>：this向后移动8位<br><code>sub    $0x1,%ebp</code>：<code>rbp</code>减1<br>不等于0时，循环继续<br>上面这段循环如果链表的数据表示的地址内存的数是递增的就爆炸了。所以就是要把链表调整为递减的链表，通过输入的1-6。</p>
</li>
<li><p>打印看一下这个<code>$0x6032d0</code>地址处保存的数据是什么？<br>链接之前的链表：</p>

<p>重新链接之后的链表：</p>

<p>根据爆炸判断，这道题就是让链表排序成递减。</p>
</li>
</ol>
<p>答案:</p>
<p><code>4 3 2 1 6 5</code></p>
<h2 id="secret-phase"><a href="#secret-phase" class="headerlink" title="secret_phase"></a>secret_phase</h2><p>重新开始写解题笔记的时候，按照小土刀的博客搭建了hexo博客，根据他的文章格式写出了这篇解题笔记，在他的文章里发现还有一道彩蛋题目，藏在了<code>phase_defused</code>函数里。这个不仔细读汇编代码很难发现，因为一般不会看拆弹成功的函数。现在自己把这个彩蛋也做一下。</p>
<p>思路：</p>
<p>做法：</p>
<ol>
<li><p>在函数<code>phase_defused</code>处打断点。</p>
<img src="/2023/03/14/09-43-26/WX20230317-143025@2x.png" class="">
<p>发现这里有一个<code>secret_phase</code>函数，对这个函数打断点发现不会进入。<br>在汇编代码里找一下函数入口。</p>
</li>
<li><p><code>cmpl   $0x6,0x202181(%rip)        # 0x603760 &lt;num_input_strings&gt;</code>：对比当前的关卡数，不等于6时跳转，等于6时，可能会进入彩蛋。</p>
</li>
<li><p><code>mov    $0x402619,%esi</code>和<code>mov    $0x603870,%edi</code>，根据这两个参数，应该是调用的sscanf函数，看一下输入参数是什么？</p>
<img src="/2023/03/14/09-43-26/WX20230317-145028@2x.png" class="">
<p>可以看出密码是两个数字一个字符串。</p>
</li>
<li><p><code>mov    $0x402622,%esi</code>：打印看一下这里存的是什么？</p>
<img src="/2023/03/14/09-43-26/WX20230317-150241@2x.png" class="">
<p>可以确定第三个密码是<code>DrEvil</code></p>
</li>
<li><p><code>mov    $0x4024f8,%edi</code>：<br><code>mov    $0x402520,%edi</code>：打印看一下这里是什么？</p>
<img src="/2023/03/14/09-43-26/WX20230317-150454@2x.png" class="">
</li>
<li><p>修改一下我们的<code>psol.txt</code>，最后一行加上<code>0 0 DrEvil</code>，重新调试进入<code>secret_phase</code>看一下汇编代码，代码没有进入，说明输入不在最后，继续看一下汇编代码。</p>
</li>
<li><p>根据sscanf的第一个参数地址在<code>0x603870</code>，我们就找一下之前输入的数据哪一个存放在这周围，在<code>bomb.s</code>文件里搜一下最近的是<code>read_line</code>函数里的<code>0x603780</code>。<br>看一下附件的代码：<br><code>lea    (%rax,%rax,4),%rsi</code>：<br><code>shl    $0x4,%rsi</code>：<br><code>add    $0x603780,%rsi</code>：<br><code>rax</code>放的是题目序号，乘5，左移4位，加上<code>0x603780</code>后等于我要的值，<code>rax</code>应该等于3。也就是说第三道题目解出来之后，第四道题目的输入缓冲区在<code>0x603870</code>。把输入文件改一下。</p>
</li>
<li><p>成功进入彩蛋函数，现在开始解这个彩蛋。<br>这里要把彩蛋的输入放在第六道题的下一行，彩蛋的入口在第四道题的输入后面。<br><code>disas</code>：先看一下汇编代码</p>
<img src="/2023/03/14/09-43-26/WX20230317-163059@2x.png" class="">
<p><code>mov    $0xa,%edx</code>：<code>rdx</code>=10<br><code>mov    $0x0,%esi</code>：<code>rsi</code>=0<br><code>mov    %rax,%rdi</code>：<code>rdi</code> = read_line的返回值。就是我们输入的字符串地址。<br><code>callq  0x400bd0 &lt;strtol@plt&gt;</code>：调用函数，找开头的十进制数转换为long int，存在<code>rax</code>里，结尾的下一个地址放在<code>rsi</code>里。<br><code>mov    %rax,%rbx</code>：<code>rbx</code>=数字<br><code>lea    -0x1(%rax),%eax</code>：<code>rax</code>-1存到<code>rax</code>里<br><code>cmp    $0x3e8,%eax</code>：对比如果，0x3e8是1000<br>如果大于，爆炸：<br>如果小于等于：<br><code>mov    %ebx,%esi</code>：<code>rsi</code>=<code>rbx</code><br><code>mov    $0x6030f0,%edi</code>：<code>rdi</code>赋值，这里应该是密码所在地<br><code>callq  0x401204 &lt;fun7&gt;</code>：跳转到fun7函数</p>
</li>
<li><p>在fun7函数里打断点，看下汇编代码</p>
<img src="/2023/03/14/09-43-26/WX20230317-174533@2x.png" class="">
<p><code>test   %rdi,%rdi</code>：test<code>rdi</code><br>如果等于0就跳转：<br><code>mov    $0xffffffff,%eax</code>：赋值32位全1，返回<br>不等于0：<br><code>mov    (%rdi),%edx</code>：把<code>rdi</code>地址保存的数据<code>$</code>给<code>rdx</code><br><code>cmp    %esi,%edx</code>：对比<code>rdx</code>和我们输入的密码<br><code>jle    0x401220 &lt;fun7+28&gt;</code>：<br>如果<code>rdx</code>&lt;=<code>rsi</code>：<br><code>mov    $0x0,%eax</code>：赋值0<br><code>cmp    %esi,%edx</code>：继续对比<br>如果<code>rdx</code>==<code>rsi</code>：返回0。根据彩蛋的汇编代码，可以看出返回值等于2才可以拆弹成功。<br>如果<code>rdx</code>&lt;<code>rsi</code>：<br><code>mov    0x10(%rdi),%rdi</code>：把<code>rdi</code>指向的地址+0x10，取数据送到<code>rdi</code><br>递归fun7。<br><code>lea    0x1(%rax,%rax,1),%eax</code>：<code>rax</code>左移一位再加1。<br>如果<code>rdx</code> &gt; <code>rsi</code>：<br><code>mov    0x8(%rdi),%rdi</code>：把<code>rdi</code>指向的地址+0x8，取数据送到<code>rdi</code><br>递归fun7。<br><code>add    %eax,%eax</code>：<code>rax</code>左移一位</p>
</li>
<li><p>根据上面的分析。递归的返回值一共四种<br>（1）：返回32位1<br>（2）：左移一位<br>（3）：0<br>（4）：左移一位加1<br>要想拆掉炸弹，需要返回的是2。<br>返回值顺序是：左移一位&lt;左移一位加1&lt;返回0<br>先从内层递归找条件：fun(x，y)<br>返回0：<code>rdi</code>指向的数 == y<br>左移一位加1：<code>rdi</code>指向的数 &lt; y，这里x+16字节<br>左移一位：<code>rdi</code>指向的数 &gt; y，这里x+8字节<br>递归顺序为：<br>fun(x，y) -&gt; fun(x + 8，y) -&gt; fun(x+16，y)</p>
</li>
<li><p>打印一下链表存的数据是哪些？</p>
<img src="/2023/03/14/09-43-26/WX20230317-174533@2x.png" class="">
<img src="/2023/03/14/09-43-26/WX20230317-174534@2x.png" class="">
<p>根据搜索路径可以看出，需要输入的密码应该是22。</p>
</li>
<li><p>测试一下</p>
<img src="/2023/03/14/09-43-26/WX20230317-174535@2x.png" class="">
<p>彩蛋拆除成功！！</p>
</li>
</ol>
<p>答案：<code>22</code>+任意字符串</p>
]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
        <tag>shell</tag>
        <tag>gdb</tag>
        <tag>objdump</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 实验V Performance Lab</title>
    <url>/2023/07/07/16-27-21/</url>
    <content><![CDATA[<p>更新历史：</p>
<ul>
<li>23.07.07：初稿</li>
<li>23.07.22：没学过汇编，复杂代码看不懂，明年有时间再回头做这个实验</li>
<li>24.03.09：实验作废，用cache lab 替代。</li>
</ul>
<h1 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h1><ul>
<li><a href="/2023/03/15/10-59-10/" title="csapp 笔记汇总">CSAPP - 笔记汇总</a>
</li>
</ul>
<h1 id="任务目标"><a href="#任务目标" class="headerlink" title="任务目标"></a>任务目标</h1><p>采用代码移动，循环展开以及指令并行对图像的旋转和平滑函数进行优化。</p>
<h1 id="相关内容"><a href="#相关内容" class="headerlink" title="相关内容"></a>相关内容</h1><ol>
<li><p><code>make driver</code>：生成运行文件， 运行<code>./driver</code>参数</p>
<blockquote>
<p><code>-g</code>：尽运行<code>rotate</code>和<code>smooth</code>函数</p>
<p><code>-f</code>：指定文件输入运行</p>
<p><code>-d</code>： 运行写入指定文件</p>
<p><code>-q</code>：写入文件后结束运行</p>
</blockquote>
</li>
<li><p><code>指导文件建议</code>：观看汇编代码，平滑函数计算密集，翻转函数存储密集。</p>
</li>
<li><p>允许添加宏，全局变量和其他函数(过程)。</p>
</li>
<li><p>假定图像矩阵的大小为32的倍数</p>
</li>
</ol>
<h1 id="题目及解法"><a href="#题目及解法" class="headerlink" title="题目及解法"></a>题目及解法</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>课程中讲过的常见优化方式：代码移动，减少重复过程调用，消除不必要的内存引用，循环展开以及提高并行性。先查看汇编代码，根据汇编代码选择合适的方法对函数进行优化。</p>
<h2 id="Phase-Rotate"><a href="#Phase-Rotate" class="headerlink" title="Phase Rotate"></a>Phase Rotate</h2><p>原函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">naive_rotate</span><span class="params">(<span class="type">int</span> dim, pixel *src, pixel *dst)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; dim; i++)</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; dim; j++)</span><br><span class="line">        dst[RIDX(dim<span class="number">-1</span>-j, i, dim)] = src[RIDX(i, j, dim)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>汇编：</p>
<img src="/2023/07/07/16-27-21/QQ20230719-190626@2x.jpg" class="">
<img src="/2023/07/07/16-27-21/QQ20230719-190641@2x.jpg" class="">
<blockquote>
<p><del>之前的lab里讲过实验环境在32位shark机器下，这里汇编代码在push占用了8个字节，不太明白是不是我的环境不对</del></p>
<p><code>已解决</code>：确实环境不对，没有32位依赖，更新之后push占用4个字节</p>
<p><code>imul multi， src， des</code>三目运算</p>
</blockquote>
<p><strong>1.数据存放方式</strong></p>
<p>数据在栈空间中小端存放，<code>rdi</code>存放在<code>rsp + 0x18</code>，<code>edi</code>存放在加4个字节的位置。所以 0x1c(%esp) 的值就是dim。</p>
]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
        <tag>shell</tag>
        <tag>gdb</tag>
        <tag>objdump</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 实验III Attack Lab</title>
    <url>/2023/03/18/15-54-47/</url>
    <content><![CDATA[<p>更新历史：</p>
<ul>
<li>23.03.18：初稿</li>
</ul>
<h1 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h1><ul>
<li><a href="/2023/03/15/10-59-10/" title="csapp 笔记汇总">CSAPP - 笔记汇总</a>
</li>
<li><a href="/2023/03/09/11-54-50/" title="CSAPP 实验I Data Lab">I Data Lab - 位操作，数据表示</a>
</li>
<li><a href="/2023/03/14/09-43-26/" title="CSAPP 实验II Bomb Lab">II Bomb Lab - 汇编，栈帧与 gdb</a>
</li>
<li><a href="/2023/03/18/15-54-47/" title="CSAPP 实验III Attack Lab">III Attack Lab - 漏洞是如何被攻击的</a>
</li>
<li><a href="/2024/03/09/16-34-34/" title="CSAPP 实验IV CacheLab">IV Cache Lab - 实现一个缓存系统</a>
</li>
<li><a href="/2024/03/14/12-34-42/" title="CSAPP 实验V ShellLab">V Shell Lab - 实现一个Shell</a>
</li>
</ul>
<h1 id="任务目标"><a href="#任务目标" class="headerlink" title="任务目标"></a>任务目标</h1><p>Attack Lab实验，采用 code-injection 和 return-oriented 两种方法攻击程序。</p>
<h1 id="相关内容"><a href="#相关内容" class="headerlink" title="相关内容"></a>相关内容</h1><ol>
<li><code>./ctarget -q</code>：运行目标文件用参数<code>-q</code>，不使用服务器</li>
<li><code>-i FILE</code>: 文件输入</li>
<li><code>./hex2raw &lt; 1.txt | ./ctarget -q</code>: 答案不换行，用<code>hex2raw</code>转换成字符串，注意需要用小端存储。</li>
<li><code>call</code>指令会将8个字节的<code>rip</code>值入栈，作为<code>ret</code>返回地址。</li>
<li>code-injection：关闭了栈随机化，栈不可执行和canary。</li>
<li>return-oriented：打开栈随机化和不可执行，关闭canary。</li>
</ol>
<h1 id="题目及解法"><a href="#题目及解法" class="headerlink" title="题目及解法"></a>题目及解法</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>和课程中讲解的两种漏洞的破解方式相同：代码注入利用缓冲区溢出，把需要执行的指令输入到栈中。面向返回编程将需要的指令片段返回地址输入到缓冲区中，模拟一个程序计数器，顺序执行需要执行的指令。由于bomb实验对每一条汇编命令都进行了解释，这个实验就不逐条解释了，把之前做过的答案重新整理一遍。</p>
<h2 id="Phase-1"><a href="#Phase-1" class="headerlink" title="Phase 1"></a>Phase 1</h2><p>思路：第一个很简单输入函数开辟了0x28的空间用于保存输入,返回地址在rsp+0x28的位置,所以输入一段0x28字节的字符串后面跟上返回touch1的地址,注意地址是小端存放:<code>C0 17 40 00 00 00 00 00</code>, 以下答案为了方便观看添加了换行，运行程序时需要去掉换行。</p>
<ol>
<li><p>gdb进入程序，对test函数反汇编：</p>
<img src="/2023/03/18/15-54-47/WX20230609-103056@2x.png" class="">
</li>
<li><p>调用了getbuf函数，可以查看一下汇编代码，找出缓冲区的大小</p>
<img src="/2023/03/18/15-54-47/WX20230609-103332@2x.png" class="">
</li>
<li><p>缓冲区大小为<code>0x28</code>，40个字节，输入的字符串保存在当前<code>rsp</code>处。然后输入40个字节无用数据，充满缓冲区，继续输入8个字节的touch1地址，覆盖掉原地址。</p>
</li>
<li><p>对要跳转的touch1函数反汇编，找一下函数入口地址：</p>
<img src="/2023/03/18/15-54-47/WX20230609-102814@2x.png" class="">
</li>
<li><p>所以需要返回的地址为<code>0x00000000004017c0</code>，输入小端存放。</p>
</li>
</ol>
<p>答案：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">c0 <span class="number">17</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br></pre></td></tr></table></figure>
<h2 id="Phase-2"><a href="#Phase-2" class="headerlink" title="Phase 2"></a>Phase 2</h2><p>思路：</p>
<p>第二个需要注入可执行代码, 需要把touch2的参数寄存器<code>rdi</code>内容设置为cookie, 这样重置ret到touch2才能正确执行, 所有第一次在getbuf中把返回值重置为一个栈地址, 然后在这个地址内写入一系列操作, 每次ret后返回地址会自动退栈, 所以先把<code>rsp</code>-8, 然后在<code>rdi</code>写入touch2的地址,然后将<code>rdi</code>写入<code>rsp</code>指向的栈地址中,然后把cookie值写入<code>rdi</code>中,最后ret。</p>
<ol>
<li><p>先查看一下touch2函数的入口在哪里：</p>
<img src="/2023/03/18/15-54-47/WX20230609-104729@2x.png" class="">
</li>
<li><p>可以看到需要返回地址为<code>0x00000000004017ec</code>， 参数可以进入touch2函数打印一下那个局部变量的值，也可以在上一个题目输出信息那里看到，我的cookie值为<code>0x59b997fa</code>。</p>
</li>
<li><p>这次需要让指令在栈中执行，所以需要知道getbuf时<code>%rsp</code>的值，可以在test处打断点，<code>display $rsp</code>，值为<code>$rsp = (void *) 0x5561dcb0</code>。test函数中分配8个字节，call getbuf 时使用了8个字节，getbuf分配40个字节，一共分配了56个字节，所以在我们输入字符串时，<code>rsp</code>指向的地址值应该是<code>0x5561dc78</code></p>
</li>
<li><p>接下来就是注入一段需要运行的代码，可以先写汇编代码，通过指令<code>gcc -c foo.s</code>，生成二进制代码<code>foo.o</code>， 在通过<code>objdump -d foo.o</code>反汇编，生成可读的机器指令。</p>
</li>
</ol>
<p>答案：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">48</span> <span class="number">83</span> ec <span class="number">08</span>           <span class="comment">/*  sub    $0x8,%rsp */</span></span><br><span class="line"><span class="number">48</span> c7 c7 ec <span class="number">17</span> <span class="number">40</span> <span class="number">00</span>  <span class="comment">/*  mov    $0x4017ec,%rdi */</span></span><br><span class="line"><span class="number">48</span> <span class="number">89</span> <span class="number">3</span>c <span class="number">24</span>           <span class="comment">/*  mov    %rdi,(%rsp) */</span></span><br><span class="line"><span class="number">48</span> c7 c7 fa <span class="number">97</span> b9 <span class="number">59</span>  <span class="comment">/*  mov    $0x59b997fa,%rdi   -   set cookie */</span></span><br><span class="line">c3                    <span class="comment">/*  retq  */</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span></span><br><span class="line"><span class="number">78</span> dc <span class="number">61</span> <span class="number">55</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span><span class="comment">/* return adress, execute exploit code */</span></span><br></pre></td></tr></table></figure>
<h2 id="Phase-3"><a href="#Phase-3" class="headerlink" title="Phase 3"></a>Phase 3</h2><p>思路：</p>
<p>第三题和第二题基本相同return到touch3后要进行一次cookie对比,第二题是十六进制的数字对比,可以提前把cookie写入<code>rdi</code>寄存器里,但是第三题的参数是一个字符串指针,所以要把字符串地址写入<code>rsi</code>第二个参数寄存器里,不能用在栈中写,因为后面还有两次函数调用,栈空间很容易被覆盖,找了一下变量cookie的地址,这个地址<code>0x6044e4</code>的后面有很长一段地址没有使用过,所以可以把字符串写入<code>0x6044ec</code>,<code>rsi</code>的参数传递在<code>0x6044ec</code>,还有一个地方是字符串<code>0x59b997fa</code>,每个字符存在一个字节里,一共需要8个字节的空间,可以用<code>mov</code>,写入十六进制数,但是要注意字符串大端存放,数字是小端存放,翻转一下就可以了.</p>
<ol>
<li><p>根据实验指南中提示的函数<code>hexmatch</code>, 做了一个字符串对比，第二个参数是字符串地址，而且在函数中将传入的cookie值转换成了一个随机地址的字符串，然后进行字符串对比，所以我们需要提前把字符串写入到固定的地址，然参数传进去。</p>
</li>
<li><p><code>disas touch3</code></p>
<img src="/2023/03/18/15-54-47/WX20230609-123834@2x.png" class="">
</li>
<li><p>可以看出cookie值存在内存的<code>0x6044e4</code>处，打印一下周围的内存值，<code>x/6xg</code></p>
<img src="/2023/03/18/15-54-47/WX20230609-130233@2x.png" class="">
</li>
<li><p>上面可以看到后面有一部分是没有使用的内存，选一个<code>0x6044ec</code>，把我们的字符串写入这里，注意大端存放。</p>
</li>
<li><p>接下来注入要运行的指令，和上一题相同，但是要把字符串写入到选定的地址里，字符串<code>59b997fa</code>转换为16进制为<code>0x35 0x39 0x62 0x39 0x39 0x37 0x66 0x61</code>，但是要注意小端存放的值为<code>0x6166373939623935</code>，所以写入这个值，当做字符串读出时刚好是cookie值。<code>movabs</code>：用于64位立即数赋值。</p>
</li>
</ol>
<p>答案：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">48</span> <span class="number">83</span> ec <span class="number">08</span>           <span class="comment">/*  sub    $0x8,%rsp */</span></span><br><span class="line">bf fa <span class="number">18</span> <span class="number">40</span> <span class="number">00</span>        <span class="comment">/*  mov    $0x4018fa,%edi */</span></span><br><span class="line"><span class="number">48</span> <span class="number">89</span> <span class="number">3</span>c <span class="number">24</span>           <span class="comment">/*  mov    %rdi,(%rsp) */</span></span><br><span class="line">bf ec <span class="number">44</span> <span class="number">60</span> <span class="number">00</span>        <span class="comment">/*  mov    $0x6044ec,%edi  */</span></span><br><span class="line"><span class="number">48</span> be <span class="number">35</span> <span class="number">39</span> <span class="number">62</span> <span class="number">39</span> <span class="number">39</span>  </span><br><span class="line"><span class="number">37</span> <span class="number">66</span> <span class="number">61</span>              <span class="comment">/*  movabs $0x6166373939623935,%rsi */</span></span><br><span class="line"><span class="number">48</span> <span class="number">89</span> <span class="number">37</span>              <span class="comment">/*  mov    %rsi,(%rdi)    */</span></span><br><span class="line">c3                    <span class="comment">/*  retq  */</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span></span><br><span class="line"><span class="number">78</span> dc <span class="number">61</span> <span class="number">55</span> <span class="comment">/* return adress, execute exploit code */</span></span><br></pre></td></tr></table></figure>
<h2 id="Phase-4"><a href="#Phase-4" class="headerlink" title="Phase 4"></a>Phase 4</h2><p>思路：</p>
<p>第四题,和第二题相同,需要把代码返回到touch2里面,但是不能像phase2中代码注入运行代码,因为栈内标记为不可执行了,所以要使用ROP的方法来操作,在给出的gadget中选择两个连续的48 89 c7 c3, mov %rax,%rdi,   还有一个58 c3, popq %rax,将这两条指令的地址用栈溢出的方法写到返回里,在返回地址中间加上cookie码。</p>
<ol>
<li><p><strong><em><code>gcc -c farm.c</code>：生成目标文件<br><code>objdump -d farm.o &gt; farm.s</code>：反汇编生成可读指令<br><code>这里需要注意优化级别为 -Og，与实验的优化级别相同</code></em></strong><br><code>objdump -d rtarget.o &gt; rtarget.s</code>：直接对可执行文件反汇编生成的指令带地址，更方便看一些。</p>
</li>
<li><p>在<code>rtarget.s</code>中找我们需要的指令，</p>
</li>
<li><p><code>setval_426</code>函数中有：地址为<code>4019c5</code></p>
<img src="/2023/03/18/15-54-47/WX20230609-140230@2x.png" class="">
</li>
<li><p>找到我们需要的<code>48 89 c7</code>，后续的<code>90</code>是一个nop，什么也不做，计数器加1，最后跟着<code>c3</code>ret。</p>
</li>
<li><p>上面把<code>rax</code>的值存到<code>rdi</code>中了，接下来我们就是找一个pop指令<code>58 90 c3</code>，退栈到<code>rax</code>中，找到<code>getval_280</code>：地址为<code>4019cc</code></p>
<img src="/2023/03/18/15-54-47/WX20230609-140336@2x.png" class="">
</li>
<li><p>所以溢出的输入为退栈到<code>rax</code>，栈顶是cookie值，然后执行<code>0x4019c5</code>的mov指令，最后返回touch2。注意所有的操作都是8字节。</p>
</li>
</ol>
<p>答案：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">01</span> <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>   <span class="comment">/*40个字节溢出  */</span></span><br><span class="line">cc <span class="number">19</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">fa <span class="number">97</span> b9 <span class="number">59</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">c5 <span class="number">19</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">ec <span class="number">17</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br></pre></td></tr></table></figure>
<h2 id="Phase-5"><a href="#Phase-5" class="headerlink" title="Phase 5"></a>Phase 5</h2><p>思路：</p>
<p>和Phase 3相同，但是要把代码注入改为target序列执行指令，可能需要对寄存器的低字节进行操作，还没想出怎么做这个题目，后面有时间了再来做。</p>
<p>答案：</p>
]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
        <tag>shell</tag>
        <tag>gdb</tag>
        <tag>objdump</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux和SSH相关命令</title>
    <url>/2023/03/11/15-22-24/</url>
    <content><![CDATA[<h1 id="linux命令"><a href="#linux命令" class="headerlink" title="linux命令"></a>linux命令</h1><h2 id="ln链接文件"><a href="#ln链接文件" class="headerlink" title="ln链接文件"></a>ln链接文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ln -s 源文件  目的文件    #建立软链接</span><br><span class="line">ln    源文件  目的文件    #硬链接</span><br></pre></td></tr></table></figure>
<h2 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a>pwd命令</h2><p>显示当前地址</p>
<h1 id="SSH命令"><a href="#SSH命令" class="headerlink" title="SSH命令"></a>SSH命令</h1><h2 id="scp传输文件"><a href="#scp传输文件" class="headerlink" title="scp传输文件"></a>scp传输文件</h2><p><code>注意要在本地使用这个命令，ssh登录后使用，文件从服务器下载到服务器了</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scp username@ip_address:/home/username/filename ~/   #从服务器下载到本地</span><br><span class="line"># 参数 -P 端口号   要大写</span><br><span class="line"># 参数 -r 文件夹</span><br><span class="line">scp -P2222 -r</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ssh</tag>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 实验V ShellLab</title>
    <url>/2024/03/14/12-34-42/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.03.14：初稿</li>
</ul>
<h1 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h1><ul>
<li><a href="/2023/03/15/10-59-10/" title="csapp 笔记汇总">CSAPP - 笔记汇总</a></li>
<li><a href="/2023/03/09/11-54-50/" title="CSAPP 实验I Data Lab">I Data Lab - 位操作，数据表示</a></li>
<li><a href="/2023/03/14/09-43-26/" title="CSAPP 实验II Bomb Lab">II Bomb Lab - 汇编，栈帧与 gdb</a></li>
<li><a href="/2023/03/18/15-54-47/" title="CSAPP 实验III Attack Lab">III Attack Lab - 漏洞是如何被攻击的</a></li>
<li><a href="/2024/03/09/16-34-34/" title="CSAPP 实验IV CacheLab">IV Cache Lab - 实现一个缓存系统</a></li>
<li><a href="/2024/03/14/12-34-42/" title="CSAPP 实验V ShellLab">V Shell Lab - 实现一个Shell</a>
</li>
</ul>
<h1 id="任务目标"><a href="#任务目标" class="headerlink" title="任务目标"></a>任务目标</h1><p>ShellLab实验，理解程序控制和信号，完成一个简单Shell。</p>
<h1 id="相关内容"><a href="#相关内容" class="headerlink" title="相关内容"></a>相关内容</h1><ul>
<li><p><code>tsh&gt; /bin/ls -l -d</code>，<code>&amp;</code>后台运行</p>
</li>
<li><p><code>int main(int argc, char *argv[])</code></p>
<ul>
<li><p><code>argc</code>：参数个数  <code>argv[]</code>：从左往右的参数</p>
</li>
<li><p><code>ctrl-c</code> SIGINT终止信号，<code>ctrl-z</code>SIGTSTP停止信号，SIGCONT继续信号</p>
</li>
<li><p><code>jobs</code>：列出所有作业</p>
</li>
<li><p><code>bg &lt;job&gt;</code>：后台暂停的作业开始运行</p>
</li>
<li><p><code>fg &lt;job&gt;</code>：前台暂停的作业开始运行</p>
</li>
<li><p><code>kill &lt;job&gt;</code>：杀死作业</p>
</li>
</ul>
</li>
<li><p><strong>tsh</strong>的规格</p>
<ul>
<li><p>提示符为<code>tsh&gt;</code></p>
</li>
<li><p>输入命令为<code>name arguments</code>：如果name是内置命令，直接执行，否则视为可执行文件路径，并调用初始子进程运行</p>
</li>
<li><p>不需要支持<code>|</code>和<code>&lt;</code>，<code>&gt;</code></p>
</li>
<li><p>信号需要传递到所有子进程</p>
</li>
<li><p>命令末尾带<code>&amp;</code>，后台运行</p>
</li>
<li><p>进程PID<code>%5</code>，作业JID<code>5</code></p>
</li>
<li><p>需要支持内置命令<code>quit</code>，<code>jobs</code>，<code>bg &lt;job&gt;</code>，<code>fg &lt;job&gt;</code></p>
</li>
<li><p>如果僵尸进程没有收到信号就终止了，需要打印出异常信息</p>
</li>
</ul>
</li>
<li><p>检查作业</p>
<ul>
<li><p><code>tshref</code>：样例tsh，可以对比自己的shell</p>
</li>
<li><p><code>sdriver.pl</code>：打印输入的shell命令和输出信息<br> <code>./sdriver.pl -t trace01.txt -s ./tsh -a &quot;-p&quot;</code>：<code>-t</code>追踪文件，<code>-s</code>指定shell，<code>-a &quot;-p&quot;</code>不输出提示符</p>
</li>
<li><p>也可以使用<code>make test01</code>测试自己的shell，<code>make rtest01</code>测试样例shell</p>
</li>
<li><p><code>trace01.txt</code>序号从01-16，越小测试越简单</p>
</li>
<li><p><code>tshref.out</code>所有的输出信息以供参考</p>
</li>
</ul>
</li>
<li><p>提示</p>
<ul>
<li><p>根据追踪文件来设计shell，依次从简单开始，按照输出完成设计</p>
</li>
<li><p>要检测出<code>kill -pid</code>的错误</p>
</li>
<li><p>多使用下列函数</p>
<ul>
<li><p><code>pid_t waitpid (pid_t pid, int* statusp, int options)</code>：</p>
<blockquote>
<p>成功时返回子进程的PID，  </p>
<p>options = WNOHANG时立即返回0     表示没有任何子进程终止</p>
<p>options = WUNTRACED时，接收到SIGSTOP信号，终止或暂停。</p>
<p>如果发生其他错误返回-1。</p>
</blockquote>
</li>
<li><p><code>kill</code>:<code>kill -s &lt;信号&gt;</code></p>
<blockquote>
<p>用指定信号形式终止进程，可以杀死可以暂停</p>
<p>-s，会将s的进程组全部执行</p>
</blockquote>
</li>
<li><p><code>int fork(void)</code>:</p>
<blockquote>
<p>创建一个子进程，子进程返回0，父进程返回子进程的ID，调用一次返回两次，先返回子进程，再返回父进程</p>
</blockquote>
</li>
<li><p><code>int execve(const char *filename, char *const argv[], char *const envp[]);</code>: </p>
<blockquote>
<p>参数为新程序的路径名称，命令行参数数组，环境变量参数数组</p>
<p>替换进程的状态和上下文，切换另一个进程</p>
<p>执行成功不会返回到调用，错误返回-1</p>
</blockquote>
</li>
<li><p><code>int setpgid(pid_t pid, pid_t pgid)</code>:</p>
<blockquote>
<p>给pid进程设置为pgid进程组识别码，如果pid为0设置当前进程，pgid为0，用当前组识别码取代，返回为组识别码，-1错误</p>
</blockquote>
</li>
<li><p><code>sigprocmash</code>:</p>
<blockquote>
<p>int sigprocmask(int how, const sigset_t <em>set, sigset_t </em>oldset);<br>参数：<br>how：用于指定信号修改的方式，可能选择有三种：<br>SIG_BLOCK //加入信号到进程屏蔽。<br>SIG_UNBLOCK //从进程屏蔽里将信号删除。<br>SIG_SETMASK //将set的值设定为新的进程屏蔽。</p>
<p>set：为指向信号集的指针，在此专指新设的信号集，如果仅想读取现在的屏蔽值，可将其置为NULL。<br>oldset：也是指向信号集的指针，在此存放原来的信号集。<br>返回说明：<br>成功执行时，返回0。失败返回-1，errno被设为EINVAL。</p>
</blockquote>
</li>
<li><p><code>exit(int status)</code>：</p>
<blockquote>
<p>终止进程，正常返回状态0</p>
</blockquote>
</li>
<li><p>尽量不要在自己的shell中使用more, less, vi, emacs，多使用/bin/ls,/bin/ps, /bin/echo</p>
</li>
<li><p>如果在Unix shell中像自己的shell输入 ctrl-c：fork之后执行之前，子进程先调用<code>setpgid(0, 0)</code>，放入一个新的进程组，保证Unix shell的进程组中只有shell。不会把命令传递给所有Unix shell的进程组，只传递给shell。</p>
</li>
<li><p>建议在<code>waitfg</code>的循环中用<code>sleep</code>函数，在<code>sigchld_handler</code>中调用<code>waitpid</code></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>常用信号量</p>
<img src="/2024/03/14/12-34-42/QQ20240314-160705@2x.png" class="">
<img src="/2024/03/14/12-34-42/QQ20240314-154949@2x.png" class="">
</li>
</ul>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h2><p>trace01-03比较简单，用课本中代码写入就可以，修改一下fork和execve封装。</p>
<h2 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h2><h3 id="trace04"><a href="#trace04" class="headerlink" title="trace04"></a>trace04</h3><p>根据标准输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./sdriver.pl -t trace04.txt -s ./tsh -a &quot;-p&quot;</span><br><span class="line">#</span><br><span class="line"># trace04.txt - Run a background job.</span><br><span class="line">#</span><br><span class="line">tsh&gt; ./myspin 1 &amp;</span><br><span class="line">[1] (26252) ./myspin 1 &amp;</span><br></pre></td></tr></table></figure>
<p>在主函数执行中增加添加作业函数<code>addjob</code>，修改一下原来的输出格式，<code>printf(&quot;[%d] (%d)  %s&quot;, pid2jid(pid), pid, cmdline);</code>。</p>
<p>问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tsh&gt; ./myspin 1 &amp;</span><br><span class="line">[2] (920)  ./myspin 1 &amp;</span><br></pre></td></tr></table></figure>
<p>作业从[2]标号开始，可能是重复添加作业了。查看输出后，发现echo函数添加作业后，运行结束时没有删除作业，导致作业号多一个。</p>
<p>解决办法：</p>
<p>在waitpid之后，增加一个删除作业函数<code>deletejob</code></p>
<h2 id="trace05"><a href="#trace05" class="headerlink" title="trace05"></a>trace05</h2><p>增加打印jobs列表</p>
<h3 id="trace06"><a href="#trace06" class="headerlink" title="trace06"></a>trace06</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line"># trace06.txt - Forward SIGINT to foreground job.</span><br><span class="line">#</span><br><span class="line">/bin/echo -e tsh&gt; ./myspin 4</span><br><span class="line">./myspin 4 </span><br><span class="line"></span><br><span class="line">SLEEP 2</span><br><span class="line">INT</span><br></pre></td></tr></table></figure>
<blockquote>
<p>SLEEP命令不是输入进去的字符串，主要是获取作业的终止状态</p>
</blockquote>
<p>相关内容</p>
<ul>
<li><p>waitpid返回状态status</p>
<ul>
<li><p>WIFEXITED(status)：非0正常结束，退出状态WEXITSTATUS(status)</p>
</li>
<li><p>WIFSIGNALED(status)：非0异常终止，退出的信号编号WTERMSIG(status)</p>
</li>
<li><p>WIFSTOPPED(status)：非0暂停状态，暂停的信号编号WSTOPSIG(status)</p>
</li>
<li><p>WIFCONTINUED(status)：非0 暂停后以继续运行</p>
</li>
</ul>
</li>
<li><p>options变量</p>
<ul>
<li><p><code>WNOHANG</code>：没有子进程终止时立即返回，而不会阻塞。</p>
</li>
<li><p><code>WUNTRACED</code>：挂起，返回终止或暂停的进程pid</p>
</li>
<li><p><code>WCONTINUED</code>：挂起，返回一个正在运行的进程终止，或一个暂停的收到SIGCONT信号继续执行。</p>
</li>
</ul>
</li>
<li><p>信号量相关</p>
<ul>
<li><p><code>sigfillset(&amp;mask_all);</code>返回当前进程的信号阻塞集合</p>
</li>
<li><p><code>sigemptyset(&amp;mask_one);</code>初试空值</p>
</li>
<li><p><code>sigaddset(&amp;mask_one, SIGCHLD);</code>，添加一位阻塞位</p>
</li>
<li><p><code>sigprocmask(int how, sigset_t *set, sigset_t *oldset)</code></p>
<blockquote>
<p>how: <code>SIG_SETMASK</code>赋值  </p>
<pre><code>      `SIG_BLOCK`阻塞 做或运算   与原来的集合

      `SIG_UNBLOCK` 解除  做与运算
</code></pre><p>set，操作集合</p>
<p>oldset，保存原集合，可以为NULL</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>对add函数和del函数阻塞信号。</p>
<p>检测INT键，绑定响应函数，用kill杀死进程，系统发出<code>SIGCHLD</code>信号，在<code>SIGCHLD</code>响应函数中删除作业。</p>
<h3 id="trace07"><a href="#trace07" class="headerlink" title="trace07"></a>trace07</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line"># trace07.txt - Forward SIGINT only to foreground job.</span><br><span class="line">#</span><br><span class="line">/bin/echo -e tsh&gt; ./myspin 4 \046</span><br><span class="line">./myspin 4 &amp;</span><br><span class="line"></span><br><span class="line">/bin/echo -e tsh&gt; ./myspin 5</span><br><span class="line">./myspin 5 </span><br><span class="line"></span><br><span class="line">SLEEP 2</span><br><span class="line">INT</span><br><span class="line"></span><br><span class="line">/bin/echo tsh&gt; jobs</span><br><span class="line">jobs</span><br></pre></td></tr></table></figure>
<p>06已经做完了，输出完整。</p>
<h3 id="trace08"><a href="#trace08" class="headerlink" title="trace08"></a>trace08</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/bin/echo -e tsh&gt; ./myspin 4 \046</span><br><span class="line">./myspin 4 &amp;</span><br><span class="line"></span><br><span class="line">/bin/echo -e tsh&gt; ./myspin 5</span><br><span class="line">./myspin 5 </span><br><span class="line"></span><br><span class="line">SLEEP 2</span><br><span class="line">TSTP</span><br><span class="line"></span><br><span class="line">/bin/echo tsh&gt; jobs</span><br><span class="line">jobs</span><br></pre></td></tr></table></figure>
<p>完成前台进程暂停信号响应。kill函数可以暂停进程。</p>
<p>代码可以正常暂停，但是暂停之后不会终止，无法退出。</p>
<p>解决：</p>
<p>用kill(-pid,sig);函数对进程组整体操作。</p>
<h3 id="trace09"><a href="#trace09" class="headerlink" title="trace09"></a>trace09</h3><p>问题：</p>
<p>需要完成bg内置命令，暂停程序后台运行。</p>
<blockquote>
<p>不太清楚中间一次输出信息，为什么不需要换行。</p>
</blockquote>
<h3 id="trace10"><a href="#trace10" class="headerlink" title="trace10"></a>trace10</h3><p>完成fg内置命令</p>
<h3 id="trace11-13"><a href="#trace11-13" class="headerlink" title="trace11-13"></a>trace11-13</h3><img src="/2024/03/14/12-34-42/QQ20240316-185955@2x.png" class="">
<p>输出信息与样例shell相同，但和答案不同。</p>
<h3 id="trace14"><a href="#trace14" class="headerlink" title="trace14"></a>trace14</h3><p>问题：</p>
<p>简单的错误处理，处理输入输出格式错误。</p>
<h3 id="trace15-16"><a href="#trace15-16" class="headerlink" title="trace15-16"></a>trace15-16</h3><p>运行结果都对</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>不处理行数问题了，没有评分程序。只有所有例子都输出相同，不太确定是不是都是正确的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * tsh - A tiny shell program with job control</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;Put your name and login ID here&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Misc manifest constants */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 1024   <span class="comment">/* max line size */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXARGS 128    <span class="comment">/* max args on a command line */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXJOBS 16     <span class="comment">/* max jobs at any point in time */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXJID 1 &lt;&lt; 16 <span class="comment">/* max job ID */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Job states */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNDEF 0 <span class="comment">/* undefined */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FG 1    <span class="comment">/* running in foreground */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BG 2    <span class="comment">/* running in background */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ST 3    <span class="comment">/* stopped */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Jobs states: FG (foreground), BG (background), ST (stopped)</span></span><br><span class="line"><span class="comment"> * Job state transitions and enabling actions:</span></span><br><span class="line"><span class="comment"> *     FG -&gt; ST  : ctrl-z</span></span><br><span class="line"><span class="comment"> *     ST -&gt; FG  : fg command</span></span><br><span class="line"><span class="comment"> *     ST -&gt; BG  : bg command</span></span><br><span class="line"><span class="comment"> *     BG -&gt; FG  : fg command</span></span><br><span class="line"><span class="comment"> * At most 1 job can be in the FG state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Global variables */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ;   <span class="comment">/* defined in libc */</span></span><br><span class="line"><span class="type">char</span> prompt[] = <span class="string">&quot;tsh&gt; &quot;</span>; <span class="comment">/* command line prompt (DO NOT CHANGE) */</span></span><br><span class="line"><span class="type">int</span> verbose = <span class="number">0</span>;         <span class="comment">/* if true, print additional output */</span></span><br><span class="line"><span class="type">int</span> nextjid = <span class="number">1</span>;         <span class="comment">/* next job ID to allocate */</span></span><br><span class="line"><span class="type">char</span> sbuf[MAXLINE];      <span class="comment">/* for composing sprintf messages */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> &#123;</span>           <span class="comment">/* The job struct */</span></span><br><span class="line">  <span class="type">pid_t</span> pid;             <span class="comment">/* job PID */</span></span><br><span class="line">  <span class="type">int</span> jid;               <span class="comment">/* job ID [1, 2, ...] */</span></span><br><span class="line">  <span class="type">int</span> state;             <span class="comment">/* UNDEF, BG, FG, or ST */</span></span><br><span class="line">  <span class="type">char</span> cmdline[MAXLINE]; <span class="comment">/* command line */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> <span class="title">jobs</span>[<span class="title">MAXJOBS</span>];</span> <span class="comment">/* The job list */</span></span><br><span class="line"><span class="comment">/* End global variables */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Function prototypes */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//补充函数</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">Fork</span><span class="params">(<span class="type">void</span>)</span>;                                                              <span class="comment">//封装fork</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> environ[])</span>;  <span class="comment">//封装execv函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Here are the functions that you will implement */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">eval</span><span class="params">(<span class="type">char</span> *cmdline)</span>;  <span class="comment">//分析命令</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">builtin_cmd</span><span class="params">(<span class="type">char</span> **argv)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">do_bgfg</span><span class="params">(<span class="type">char</span> **argv)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">waitfg</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigchld_handler</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sigtstp_handler</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sigint_handler</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Here are helper routines that we&#x27;ve provided for you */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">parseline</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cmdline, <span class="type">char</span> **argv)</span>;  <span class="comment">//返回bg标志  1 后台</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigquit_handler</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">clearjob</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *job)</span>;                                     <span class="comment">//清除队列中的一个作业</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initjobs</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs)</span>;                                    <span class="comment">//初始化</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxjid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs)</span>;                                       <span class="comment">//返回以分配的最大作业号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">addjob</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs, <span class="type">pid_t</span> pid, <span class="type">int</span> state, <span class="type">char</span> *cmdline)</span>;  <span class="comment">//添加一个作业  返回1  满了返回0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deletejob</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs, <span class="type">pid_t</span> pid)</span>;                         <span class="comment">//删除队列中一个作业   成功返回1</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fgpid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs)</span>;                                      <span class="comment">//返回一个前台运行的作业号    没有返回0</span></span><br><span class="line"><span class="keyword">struct</span> <span class="type">job_t</span> *<span class="title function_">getjobpid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs, <span class="type">pid_t</span> pid)</span>;               <span class="comment">//使用pid查找一个作业  没找到 返回空</span></span><br><span class="line"><span class="keyword">struct</span> <span class="type">job_t</span> *<span class="title function_">getjobjid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs, <span class="type">int</span> jid)</span>;                 <span class="comment">//用jid查找一个作业</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pid2jid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;                                               <span class="comment">// 用pid 返回 jid,  没找到返回0</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">listjobs</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs)</span>;                                    <span class="comment">//打印作业队列</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">usage</span><span class="params">(<span class="type">void</span>)</span>;                                   <span class="comment">//打印帮助菜单</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">unix_error</span><span class="params">(<span class="type">char</span> *msg)</span>;                         <span class="comment">// unix风格打印错误信息</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">app_error</span><span class="params">(<span class="type">char</span> *msg)</span>;                          <span class="comment">// app风格的错误信息</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> <span class="title function_">handler_t</span><span class="params">(<span class="type">int</span>)</span>;                        <span class="comment">//一个int参数,无返回</span></span><br><span class="line"><span class="type">handler_t</span> *<span class="title function_">Signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">handler_t</span> *handler)</span>;  <span class="comment">//信号包装器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * main - The shell&#x27;s main routine</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">  <span class="type">char</span> cmdline[MAXLINE];</span><br><span class="line">  <span class="type">int</span> emit_prompt = <span class="number">1</span>; <span class="comment">/* emit prompt (default) */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//不用管    重定向输出</span></span><br><span class="line">  <span class="comment">/* Redirect stderr to stdout (so that driver will get all output</span></span><br><span class="line"><span class="comment">   * on the pipe connected to stdout) */</span></span><br><span class="line">  dup2(<span class="number">1</span>, <span class="number">2</span>);  <span class="comment">//把1的文件描述符 复制给2</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Parse the command line */</span></span><br><span class="line">  <span class="keyword">while</span> ((c = getopt(argc, argv, <span class="string">&quot;hvp&quot;</span>)) != EOF) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>: <span class="comment">/* print help message */</span></span><br><span class="line">        usage();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>: <span class="comment">/* emit additional diagnostic info */</span></span><br><span class="line">        verbose = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:          <span class="comment">/* don&#x27;t print a prompt */</span></span><br><span class="line">        emit_prompt = <span class="number">0</span>; <span class="comment">/* handy for automatic testing */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        usage();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Install the signal handlers */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* These are the ones you will need to implement */</span></span><br><span class="line">  Signal(SIGINT, sigint_handler);   <span class="comment">/* ctrl-c */</span></span><br><span class="line">  Signal(SIGTSTP, sigtstp_handler); <span class="comment">/* ctrl-z */</span></span><br><span class="line">  Signal(SIGCHLD, sigchld_handler); <span class="comment">/* Terminated or stopped child */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* This one provides a clean way to kill the shell */</span></span><br><span class="line">  Signal(SIGQUIT, sigquit_handler);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Initialize the job list */</span></span><br><span class="line">  initjobs(jobs);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Execute the shell&#x27;s read/eval loop */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* Read command line */</span></span><br><span class="line">    <span class="keyword">if</span> (emit_prompt) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, prompt);</span><br><span class="line">      fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((fgets(cmdline, MAXLINE, <span class="built_in">stdin</span>) == <span class="literal">NULL</span>) &amp;&amp; ferror(<span class="built_in">stdin</span>))</span><br><span class="line">      app_error(<span class="string">&quot;fgets error&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (feof(<span class="built_in">stdin</span>)) &#123; <span class="comment">/* End of file (ctrl-d) */</span></span><br><span class="line">      fflush(<span class="built_in">stdout</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Evaluate the command line */</span></span><br><span class="line">    eval(cmdline);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">/* control never reaches here */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * eval - Evaluate the command line that the user has just typed in</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the user has requested a built-in command (quit, jobs, bg or fg)</span></span><br><span class="line"><span class="comment"> * then execute it immediately. Otherwise, fork a child process and</span></span><br><span class="line"><span class="comment"> * run the job in the context of the child. If the job is running in</span></span><br><span class="line"><span class="comment"> * the foreground, wait for it to terminate and then return.  Note:</span></span><br><span class="line"><span class="comment"> * each child process must have a unique process group ID so that our</span></span><br><span class="line"><span class="comment"> * background children don&#x27;t receive SIGINT (SIGTSTP) from the kernel</span></span><br><span class="line"><span class="comment"> * when we type ctrl-c (ctrl-z) at the keyboard.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">eval</span><span class="params">(<span class="type">char</span> *cmdline)</span> &#123;</span><br><span class="line">  <span class="type">char</span> *argv[MAXARGS]; <span class="comment">/*Argument list execve() */</span></span><br><span class="line">  <span class="type">char</span> buf[MAXLINE];   <span class="comment">/*Holds modified command line */</span></span><br><span class="line">  <span class="type">int</span> bg;              <span class="comment">/*Should the job run in bg or fg? */</span></span><br><span class="line">  <span class="type">pid_t</span> pid;           <span class="comment">/*Process id */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">sigset_t</span> mask_all, mask_one, prev_one;</span><br><span class="line">  sigfillset(&amp;mask_all);</span><br><span class="line">  sigemptyset(&amp;mask_one);</span><br><span class="line">  sigaddset(&amp;mask_one, SIGCHLD);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(buf, cmdline);</span><br><span class="line">  bg = parseline(buf, argv);</span><br><span class="line">  <span class="keyword">if</span> (argv[<span class="number">0</span>] == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">/* Ignore empty lines */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!builtin_cmd(argv)) &#123;</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;mask_one, &amp;prev_one);   <span class="comment">//阻塞SIGCHLD</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pid = Fork()) == <span class="number">0</span>) &#123;         <span class="comment">/* Child runs user job */</span></span><br><span class="line">      setpgid(<span class="number">0</span>, <span class="number">0</span>);          <span class="comment">//单独加入一个组</span></span><br><span class="line">      sigprocmask(SIG_SETMASK, &amp;prev_one, <span class="literal">NULL</span>);  <span class="comment">//解除SIGCHLD阻塞 赋值新的mask</span></span><br><span class="line">      Execve(argv[<span class="number">0</span>], argv, environ);  <span class="comment">//执行函数不会返回   会结束运行</span></span><br><span class="line">    &#125;                                  <span class="comment">/* Parent waits for foreground job to terminate */</span></span><br><span class="line">    <span class="comment">//添加作业     FG = 0 + 1 = 1    BG = 1 + 1 = 2</span></span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;mask_all, <span class="literal">NULL</span>);   <span class="comment">//应该是重置作用</span></span><br><span class="line">    addjob(jobs, pid, bg + <span class="number">1</span>, cmdline);</span><br><span class="line">    sigprocmask(SIG_SETMASK, &amp;prev_one, <span class="literal">NULL</span>); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!bg) &#123;</span><br><span class="line">      waitfg(pid);   <span class="comment">//等待前台运行结束</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d)  %s&quot;</span>, pid2jid(pid), pid, cmdline);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * parseline - Parse the command line and build the argv array.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Characters enclosed in single quotes are treated as a single</span></span><br><span class="line"><span class="comment"> * argument.  Return true if the user has requested a BG job, false if</span></span><br><span class="line"><span class="comment"> * the user has requested a FG job.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">parseline</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cmdline, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">char</span> <span class="built_in">array</span>[MAXLINE]; <span class="comment">/* holds local copy of command line */</span></span><br><span class="line">  <span class="type">char</span> *buf = <span class="built_in">array</span>;          <span class="comment">/* ptr that traverses command line */</span></span><br><span class="line">  <span class="type">char</span> *delim;                <span class="comment">/* points to first space delimiter */</span></span><br><span class="line">  <span class="type">int</span> argc;                   <span class="comment">/* number of args */</span></span><br><span class="line">  <span class="type">int</span> bg;                     <span class="comment">/* background job? */</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(buf, cmdline);</span><br><span class="line">  buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="string">&#x27; &#x27;</span>;   <span class="comment">/* replace trailing &#x27;\n&#x27; with space */</span></span><br><span class="line">  <span class="keyword">while</span> (*buf &amp;&amp; (*buf == <span class="string">&#x27; &#x27;</span>)) <span class="comment">/* ignore leading spaces */</span></span><br><span class="line">    buf++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Build the argv list */</span></span><br><span class="line">  argc = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (*buf == <span class="string">&#x27;\&#x27;&#x27;</span>) &#123;</span><br><span class="line">    buf++;</span><br><span class="line">    delim = <span class="built_in">strchr</span>(buf, <span class="string">&#x27;\&#x27;&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    delim = <span class="built_in">strchr</span>(buf, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (delim) &#123;</span><br><span class="line">    argv[argc++] = buf;</span><br><span class="line">    *delim = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    buf = delim + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (*buf &amp;&amp; (*buf == <span class="string">&#x27; &#x27;</span>)) <span class="comment">/* ignore spaces */</span></span><br><span class="line">      buf++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*buf == <span class="string">&#x27;\&#x27;&#x27;</span>) &#123;</span><br><span class="line">      buf++;</span><br><span class="line">      delim = <span class="built_in">strchr</span>(buf, <span class="string">&#x27;\&#x27;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      delim = <span class="built_in">strchr</span>(buf, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  argv[argc] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc == <span class="number">0</span>) <span class="comment">/* ignore blank line */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* should the job run in the background? */</span></span><br><span class="line">  <span class="keyword">if</span> ((bg = (*argv[argc - <span class="number">1</span>] == <span class="string">&#x27;&amp;&#x27;</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">    argv[--argc] = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * builtin_cmd - If the user has typed a built-in command then execute</span></span><br><span class="line"><span class="comment"> *    it immediately.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">builtin_cmd</span><span class="params">(<span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;quit&quot;</span>))</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;jobs&quot;</span>)) &#123;</span><br><span class="line">    listjobs(jobs);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;bg&quot;</span>) || !<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;fg&quot;</span>)) &#123;</span><br><span class="line">    do_bgfg(argv);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;&amp;&quot;</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* not a builtin command */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * do_bgfg - Execute the builtin bg and fg commands</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_bgfg</span><span class="params">(<span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  <span class="type">int</span> doid;</span><br><span class="line">  <span class="type">pid_t</span> pid;</span><br><span class="line">  <span class="type">pid_t</span> t_pid;</span><br><span class="line">  <span class="keyword">if</span>(argv[<span class="number">1</span>] == <span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s command requires PID or %%jobid argument\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> jflag = <span class="number">0</span>;  <span class="comment">//组标记</span></span><br><span class="line">  <span class="keyword">if</span>(argv[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27;%&#x27;</span>)&#123;</span><br><span class="line">    jflag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isdigit</span>(argv[<span class="number">1</span>][<span class="number">1</span>]) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s: argument must be a PID or %%jobid\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    doid = atoi(&amp;argv[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isdigit</span>(argv[<span class="number">1</span>][<span class="number">0</span>]) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s: argument must be a PID or %%jobid\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    doid = atoi(&amp;argv[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> * <span class="title">job</span>;</span></span><br><span class="line">  <span class="keyword">if</span>(jflag)&#123;</span><br><span class="line">    job = getjobjid(jobs, doid);  <span class="comment">//jid</span></span><br><span class="line">    <span class="keyword">if</span>(job == <span class="literal">NULL</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d: No such job\n&quot;</span>, doid);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    job = getjobpid(jobs, doid);  <span class="comment">//pid</span></span><br><span class="line">    <span class="keyword">if</span>(job == <span class="literal">NULL</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;(%d): No such process\n&quot;</span>, doid);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;bg&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    kill(-job-&gt;pid, SIGCONT); <span class="comment">//发送继续命令</span></span><br><span class="line">    job-&gt;state = BG;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>,job-&gt;jid,job-&gt;pid,job-&gt;cmdline);  <span class="comment">//不清楚为什么不换行</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    </span><br><span class="line">    t_pid = fgpid(jobs);   <span class="comment">//找当前的前台作业</span></span><br><span class="line">    <span class="keyword">if</span>(job-&gt;state == ST)&#123;</span><br><span class="line">      kill(-job-&gt;pid, SIGCONT); <span class="comment">//发送继续命令</span></span><br><span class="line">    &#125;</span><br><span class="line">    job-&gt;state = FG;</span><br><span class="line">    pid = job-&gt;pid;</span><br><span class="line">    <span class="keyword">if</span>(t_pid != <span class="number">0</span>)&#123;  <span class="comment">//有前台作业 转为后台</span></span><br><span class="line">      job = getjobpid(jobs, doid);</span><br><span class="line">      job-&gt;state = BG;</span><br><span class="line">    &#125;</span><br><span class="line">    waitfg(pid);  <span class="comment">//等待前台运行</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * waitfg - Block until process pid is no longer the foreground process</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">同一时间只有一个fg作业</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">waitfg</span><span class="params">(<span class="type">pid_t</span> pid)</span> &#123;</span><br><span class="line">  <span class="keyword">while</span>(pid == fgpid(jobs))</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*****************</span></span><br><span class="line"><span class="comment"> * Signal handlers</span></span><br><span class="line"><span class="comment"> *****************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sigchld_handler - The kernel sends a SIGCHLD to the shell whenever</span></span><br><span class="line"><span class="comment"> *     a child job terminates (becomes a zombie), or stops because it</span></span><br><span class="line"><span class="comment"> *     received a SIGSTOP or SIGTSTP signal. The handler reaps all</span></span><br><span class="line"><span class="comment"> *     available zombie children, but doesn&#x27;t wait for any other</span></span><br><span class="line"><span class="comment"> *     currently running children to terminate.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  响应 停止信号 处理函数  </span></span><br><span class="line"><span class="comment">  回收所有僵尸进程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigchld_handler</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">  <span class="type">int</span> olderrno = errno;</span><br><span class="line">  <span class="type">sigset_t</span> mask_all,prev_all;</span><br><span class="line">  <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> status; <span class="comment">//获取返回状态</span></span><br><span class="line">  sigfillset(&amp;mask_all);</span><br><span class="line">  <span class="comment">//回收所有的僵尸进程</span></span><br><span class="line">  <span class="keyword">while</span>((pid = waitpid(<span class="number">-1</span>,&amp;status,WNOHANG | WUNTRACED))&gt;<span class="number">0</span>)&#123;  <span class="comment">//如果都没终止返回0 有一个被终止 返回终止pid</span></span><br><span class="line">    <span class="keyword">if</span> (WIFEXITED(status))  &#123;  <span class="comment">//正常终止</span></span><br><span class="line">      sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev_all);</span><br><span class="line">      deletejob(jobs, pid);</span><br><span class="line">      sigprocmask(SIG_SETMASK, &amp;prev_all, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(WIFSIGNALED(status))  &#123;  <span class="comment">//正常终止</span></span><br><span class="line">      sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev_all);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Job [%d] (%d) terminated by signal %d\n&quot;</span>, pid2jid(pid), pid, WTERMSIG(status));</span><br><span class="line">      deletejob(jobs, pid);</span><br><span class="line">      sigprocmask(SIG_SETMASK, &amp;prev_all, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(WIFSTOPPED(status))  &#123;  <span class="comment">//正常暂停</span></span><br><span class="line">      sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev_all);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Job [%d] (%d) stopped by signal %d\n&quot;</span>, pid2jid(pid), pid, WSTOPSIG(status));</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> * <span class="title">fgjob</span> =</span> getjobpid(jobs, pid);  <span class="comment">//查找前台进程指针</span></span><br><span class="line">      fgjob-&gt;state = ST;</span><br><span class="line">      sigprocmask(SIG_SETMASK, &amp;prev_all, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  errno = olderrno;  </span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sigint_handler - The kernel sends a SIGINT to the shell whenver the</span></span><br><span class="line"><span class="comment"> *    user types ctrl-c at the keyboard.  Catch it and send it along</span></span><br><span class="line"><span class="comment"> *    to the foreground job.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">SIGINT 信号只会传递给前台进程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigint_handler</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">  <span class="type">int</span> olderrno = errno;</span><br><span class="line">  <span class="type">pid_t</span> pid;</span><br><span class="line">  pid = fgpid(jobs);</span><br><span class="line">  kill(-pid, sig);  <span class="comment">//发送给前台作业</span></span><br><span class="line">  errno = olderrno;  </span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sigtstp_handler - The kernel sends a SIGTSTP to the shell whenever</span></span><br><span class="line"><span class="comment"> *     the user types ctrl-z at the keyboard. Catch it and suspend the</span></span><br><span class="line"><span class="comment"> *     foreground job by sending it a SIGTSTP.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigtstp_handler</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">  <span class="type">int</span> olderrno = errno;</span><br><span class="line">  <span class="type">pid_t</span> pid;</span><br><span class="line">  pid = fgpid(jobs);</span><br><span class="line">  kill(-pid, sig);  <span class="comment">//发送给前台作业</span></span><br><span class="line">  errno = olderrno;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************</span></span><br><span class="line"><span class="comment"> * End signal handlers</span></span><br><span class="line"><span class="comment"> *********************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//补充函数</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">Fork</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">    unix_error(<span class="string">&quot;Fork error&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> environ[])</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (execve(filename, argv, environ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: Command not found.\n&quot;</span>, filename);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************************************</span></span><br><span class="line"><span class="comment"> * Helper routines that manipulate the job list</span></span><br><span class="line"><span class="comment"> **********************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* clearjob - Clear the entries in a job struct */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clearjob</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *job)</span> &#123;</span><br><span class="line">  job-&gt;pid = <span class="number">0</span>;</span><br><span class="line">  job-&gt;jid = <span class="number">0</span>;</span><br><span class="line">  job-&gt;state = UNDEF;</span><br><span class="line">  job-&gt;cmdline[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* initjobs - Initialize the job list */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initjobs</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">    clearjob(&amp;jobs[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* maxjid - Returns largest allocated job ID */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxjid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i, max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">    <span class="keyword">if</span> (jobs[i].jid &gt; max)</span><br><span class="line">      max = jobs[i].jid;</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* addjob - Add a job to the job list */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">addjob</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs, <span class="type">pid_t</span> pid, <span class="type">int</span> state, <span class="type">char</span> *cmdline)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pid &lt; <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (jobs[i].pid == <span class="number">0</span>) &#123;</span><br><span class="line">      jobs[i].pid = pid;</span><br><span class="line">      jobs[i].state = state;</span><br><span class="line">      jobs[i].jid = nextjid++;</span><br><span class="line">      <span class="keyword">if</span> (nextjid &gt; MAXJOBS)</span><br><span class="line">        nextjid = <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">strcpy</span>(jobs[i].cmdline, cmdline);</span><br><span class="line">      <span class="keyword">if</span> (verbose) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Added job [%d] %d %s\n&quot;</span>, jobs[i].jid, jobs[i].pid, jobs[i].cmdline);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Tried to create too many jobs\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* deletejob - Delete a job whose PID=pid from the job list */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deletejob</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs, <span class="type">pid_t</span> pid)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pid &lt; <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (jobs[i].pid == pid) &#123;</span><br><span class="line">      clearjob(&amp;jobs[i]);</span><br><span class="line">      nextjid = maxjid(jobs) + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* fgpid - Return PID of current foreground job, 0 if no such job */</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fgpid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">    <span class="keyword">if</span> (jobs[i].state == FG)</span><br><span class="line">      <span class="keyword">return</span> jobs[i].pid;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* getjobpid  - Find a job (by PID) on the job list */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="type">job_t</span> *<span class="title function_">getjobpid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs, <span class="type">pid_t</span> pid)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pid &lt; <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">    <span class="keyword">if</span> (jobs[i].pid == pid)</span><br><span class="line">      <span class="keyword">return</span> &amp;jobs[i];</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* getjobjid  - Find a job (by JID) on the job list */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="type">job_t</span> *<span class="title function_">getjobjid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs, <span class="type">int</span> jid)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (jid &lt; <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">    <span class="keyword">if</span> (jobs[i].jid == jid)</span><br><span class="line">      <span class="keyword">return</span> &amp;jobs[i];</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* pid2jid - Map process ID to job ID */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pid2jid</span><span class="params">(<span class="type">pid_t</span> pid)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pid &lt; <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">    <span class="keyword">if</span> (jobs[i].pid == pid) &#123;</span><br><span class="line">      <span class="keyword">return</span> jobs[i].jid;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* listjobs - Print the job list */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">listjobs</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (jobs[i].pid != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) &quot;</span>, jobs[i].jid, jobs[i].pid);</span><br><span class="line">      <span class="keyword">switch</span> (jobs[i].state) &#123;</span><br><span class="line">        <span class="keyword">case</span> BG:</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;Running &quot;</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FG:</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;Foreground &quot;</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ST:</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;Stopped &quot;</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;listjobs: Internal error: job[%d].state=%d &quot;</span>,</span><br><span class="line">                 i, jobs[i].state);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, jobs[i].cmdline);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment"> * end job list helper routines</span></span><br><span class="line"><span class="comment"> ******************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************</span></span><br><span class="line"><span class="comment"> * Other helper routines</span></span><br><span class="line"><span class="comment"> ***********************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * usage - print a help message</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">usage</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Usage: shell [-hvp]\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;   -h   print this message\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;   -v   print additional diagnostic information\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;   -p   do not emit a command prompt\n&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * unix_error - unix-style error routine</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">unix_error</span><span class="params">(<span class="type">char</span> *msg)</span> &#123;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;%s: %s\n&quot;</span>, msg, strerror(errno));</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app_error - application-style error routine</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">app_error</span><span class="params">(<span class="type">char</span> *msg)</span> &#123;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;%s\n&quot;</span>, msg);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Signal - wrapper for the sigaction function</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">handler_t</span> *<span class="title function_">Signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">handler_t</span> *handler)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">action</span>, <span class="title">old_action</span>;</span></span><br><span class="line"></span><br><span class="line">  action.sa_handler = handler;</span><br><span class="line">  sigemptyset(&amp;action.sa_mask); <span class="comment">/* block sigs of type being handled */</span></span><br><span class="line">  action.sa_flags = SA_RESTART; <span class="comment">/* restart syscalls if possible */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sigaction(signum, &amp;action, &amp;old_action) &lt; <span class="number">0</span>)</span><br><span class="line">    unix_error(<span class="string">&quot;Signal error&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> (old_action.sa_handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sigquit_handler - The driver program can gracefully terminate the</span></span><br><span class="line"><span class="comment"> *    child shell by sending it a SIGQUIT signal.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigquit_handler</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Terminating after receipt of SIGQUIT signal\n&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
      </tags>
  </entry>
  <entry>
    <title>git笔记</title>
    <url>/2023/03/08/14-59-55/</url>
    <content><![CDATA[<h1 id="克隆项目到当前文件夹"><a href="#克隆项目到当前文件夹" class="headerlink" title="克隆项目到当前文件夹"></a>克隆项目到当前文件夹</h1><ul>
<li><p>git clone https:// .</p>
</li>
<li><p>注意 .</p>
</li>
</ul>
<h1 id="文件夹初始化为仓库上传"><a href="#文件夹初始化为仓库上传" class="headerlink" title="文件夹初始化为仓库上传"></a>文件夹初始化为仓库上传</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 1. 在当前目录初始化一个新的Git仓库</span><br><span class="line">git init</span><br><span class="line"> </span><br><span class="line"># 2. 添加所有文件到暂存区</span><br><span class="line">git add .</span><br><span class="line"> </span><br><span class="line"># 3. 提交暂存区的内容到本地仓库</span><br><span class="line">git commit -m &quot;Initial commit&quot;</span><br><span class="line"></span><br><span class="line"># 4. 添加远程仓库地址（以GitHub为例，替换成你的远程仓库URL）</span><br><span class="line">git remote add origin https://github.com/username/repository.git</span><br><span class="line"> </span><br><span class="line"># 5. 推送代码到远程仓库，同时设置远程仓库的主分支</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：如果使用https链接上传，需要令牌密码，使用ssh连接上传，只需要本地的ssh密码</p>
</blockquote>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>csapp 笔记汇总</title>
    <url>/2023/03/15/10-59-10/</url>
    <content><![CDATA[<h1 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h1><h2 id="CMU-15-213笔记"><a href="#CMU-15-213笔记" class="headerlink" title="CMU 15-213笔记"></a>CMU 15-213笔记</h2><ul>
<li><a href="/2023/05/24/13-04-09/" title="CSAPP 笔记三 程序的机器级表示">第三章 - 程序的机器级表示</a></li>
<li><a href="/2023/07/06/14-25-42/" title="CSAPP 笔记五 优化程序性能">第五章 - 优化程序性能</a></li>
<li><a href="/2023/07/23/09-27-18/" title="CSAPP 笔记六 存储器层次结构">第六章 - 存储器层次结构</a>
</li>
</ul>
<h2 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h2><p><a href="https://github.com/PKunicor/CsappLab">PKunicor/Csapp lab</a></p>
<h2 id="实验笔记"><a href="#实验笔记" class="headerlink" title="实验笔记"></a>实验笔记</h2><ul>
<li><a href="/2023/03/09/11-54-50/" title="CSAPP 实验I Data Lab">I Data Lab - 位操作，数据表示</a></li>
<li><a href="/2023/03/14/09-43-26/" title="CSAPP 实验II Bomb Lab">II Bomb Lab - 汇编，栈帧与 gdb</a></li>
<li><a href="/2023/03/18/15-54-47/" title="CSAPP 实验III Attack Lab">III Attack Lab - 漏洞是如何被攻击的</a></li>
<li><a href="/2024/03/09/16-34-34/" title="CSAPP 实验IV CacheLab">IV Cache Lab - 实现一个缓存系统</a></li>
<li><a href="/2024/03/14/12-34-42/" title="CSAPP 实验V ShellLab">V Shell Lab - 实现一个Shell</a>
</li>
</ul>
<h1 id="实验指南"><a href="#实验指南" class="headerlink" title="实验指南"></a>实验指南</h1><ul>
<li><p><a href="https://www.bilibili.com/video/BV1iW411d7hd/?spm_id_from=333.788.top_right_bar_window_custom_collection.content.click&amp;vd_source=d5a3522259c17126f1b623c977d04c3e">B站CS15-213翻译课程</a> </p>
</li>
<li><p><a href="https://scs.hosted.panopto.com/Panopto/Pages/Sessions/List.aspx#folderID=%22b96d90ae-9871-4fae-91e2-b1627b43e25e%22">实验课程指导</a> <code>lab重点</code> </p>
</li>
</ul>
<blockquote>
<p>做Lab非常推荐看一下官方给的Lab指导课程，课程里详细介绍了实验上手方式以及需要用到的命令。 </p>
</blockquote>
]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
      </tags>
  </entry>
  <entry>
    <title>天梯赛刷题记录</title>
    <url>/2024/04/04/12-45-10/</url>
    <content><![CDATA[<h1 id="L1-039-古风排版"><a href="#L1-039-古风排版" class="headerlink" title="L1-039. 古风排版"></a>L1-039. 古风排版</h1><p>中国的古人写文字，是从右向左竖向排版的。本题就请你编写程序，把一段文字按古风排版。</p>
<p>输入格式：</p>
<p>输入在第一行给出一个正整数N（&lt;100），是每一列的字符数。第二行给出一个长度不超过1000的非空字符串，以回车结束。</p>
<p>输出格式：</p>
<p>按古风格式排版给定的字符串，每列N个字符（除了最后一列可能不足N个）</p>
<p>输入样例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">This is a test case</span><br></pre></td></tr></table></figure>
<p>输出样例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">asa T</span><br><span class="line">st ih</span><br><span class="line">e tsi</span><br><span class="line"> ce s</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法比赛</tag>
        <tag>c++</tag>
        <tag>算法模板</tag>
      </tags>
  </entry>
  <entry>
    <title>macOS使用ssh登陆WSL2的ubuntu</title>
    <url>/2023/03/07/14-58-00/</url>
    <content><![CDATA[<h1 id="ssh-登录wsl-ubuntu"><a href="#ssh-登录wsl-ubuntu" class="headerlink" title="ssh 登录wsl ubuntu"></a>ssh 登录wsl ubuntu</h1><h2 id="固定wsl2的ip地址"><a href="#固定wsl2的ip地址" class="headerlink" title="固定wsl2的ip地址"></a>固定wsl2的ip地址</h2><p>wsl2的ip地址每次都会改变，所以一直要重新设置防火墙端口，通过脚本，每次管理员运行脚本固定ip，就不需要重复设置防火墙端口。</p>
<ul>
<li>优化之后固定wsl2 IP:192.168.120.181,运行脚本,转发端口,设置防火墙,自动命令</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@echo off</span><br><span class="line">setlocal enabledelayedexpansion</span><br><span class="line"></span><br><span class="line">::先停掉wsl实例</span><br><span class="line">wsl --shutdown</span><br><span class="line">::重新拉起，启动ssh服务</span><br><span class="line">wsl -u root -d Ubuntu-20.04 service ssh start</span><br><span class="line">:: 固定IP</span><br><span class="line">wsl -u root ip addr | findstr &quot;192.168.120.181&quot; &gt; nul</span><br><span class="line">if !errorlevel! equ 0 (</span><br><span class="line">   echo wsl ip has set</span><br><span class="line">) else (</span><br><span class="line">   wsl -u root ip addr add 192.168.120.181/24 broadcast 192.168.120.0 dev eth0 label eth0:1</span><br><span class="line">   echo set wsl ip success: 192.168.120.181</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">::windows作为wsl的宿主，在wsl的固定IP的同一网段也给安排另外一个IP</span><br><span class="line">ipconfig | findstr &quot;192.168.120.100&quot; &gt; nul</span><br><span class="line">if !errorlevel! equ 0 (</span><br><span class="line">    echo windows ip has set</span><br><span class="line">) else (</span><br><span class="line">    netsh interface ip add address &quot;vEthernet (WSL)&quot; 192.168.120.100 255.255.255.0</span><br><span class="line">    echo set windows ip success: 192.168.120.100</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">::windows的2222端口转发到ubuntu</span><br><span class="line">netsh interface portproxy add v4tov4 listenaddress=0.0.0.0 listenport=2222 connectaddress=192.168.120.181 connectport=2222</span><br><span class="line">::防火墙开启入站规则</span><br><span class="line">::netsh advfirewall firewall add rule name=WSL2 dir=in action=allow protocol=TCP localport=2222</span><br><span class="line"></span><br><span class="line">pause</span><br></pre></td></tr></table></figure>
<ul>
<li><p>管理员模式运行脚本后直接连接</p>
</li>
<li><p>连接 ip为<code>windows的地址</code></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh name@ip -p2222</span><br></pre></td></tr></table></figure>
<h2 id="ssh服务器命令"><a href="#ssh服务器命令" class="headerlink" title="ssh服务器命令"></a>ssh服务器命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo service ssh restart</span><br><span class="line">sudo service ssh start</span><br><span class="line">sudo service ssh stop</span><br><span class="line">sudo service ssh status</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="wsl命令"><a href="#wsl命令" class="headerlink" title="wsl命令"></a>wsl命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wsl -- hostname -I    #显示wsl的ip</span><br><span class="line">wsl -l -v             #列出当前linux版本状态</span><br><span class="line">wsl --shutdown        #关闭linux</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>ssh</tag>
        <tag>mac</tag>
        <tag>ubuntu</tag>
        <tag>wsl2</tag>
      </tags>
  </entry>
  <entry>
    <title>人体姿态估计算法演变历史</title>
    <url>/2024/04/26/13-54-29/</url>
    <content><![CDATA[<h1 id="人体姿态估计算法演变过程"><a href="#人体姿态估计算法演变过程" class="headerlink" title="人体姿态估计算法演变过程"></a>人体姿态估计算法演变过程</h1><h2 id="传统视觉算法"><a href="#传统视觉算法" class="headerlink" title="传统视觉算法"></a>传统视觉算法</h2><p>基于两种，一种采用电磁标记坐标，另一种采用基于视觉的无标记分析<sup><a href="#fn_1" id="reffn_1">1</a></sup>。<br>研究可以分为两大类：基于模型（或生成）和无模型（或判别）方法。基于模型的方法采用先验的人体。姿态估计过程包括建模和估计。建模是似然函数的构造，考虑了相机模型、图像描述符、人体模型和匹配函数以及（物理）约束。</p>
<h3 id="基于生成模型方法"><a href="#基于生成模型方法" class="headerlink" title="基于生成模型方法"></a>基于生成模型方法</h3><p><strong>建模</strong><br>建模阶段的目标是在给定一组参数的情况下构建给出图像可能性的函数,参数包括，身体配置，体型和外观参数以及相机视角。</p>
<p>基于模型的方法使用人体模型，其中包括运动学结构和身体尺寸。此外，还使用一个函数描述了给定模型参数的人体如何在图像域中出现。图像通常不是使用原始的视觉输入，而是用边缘、颜色区域或轮廓来描述。需要视觉输入和人体模型生成外观之间的匹配函数来评估模型实例化对视觉输入的解释程度。</p>
<p><strong>运动学模型</strong></p>
<ul>
<li>运动学模型有关节组成，关节包含多个自由度(DOF),指示关节可以在多少个方向上移动。</li>
</ul>
<h3 id="基于无模型判别方法"><a href="#基于无模型判别方法" class="headerlink" title="基于无模型判别方法"></a>基于无模型判别方法</h3><h1 id="人体姿态估计算法"><a href="#人体姿态估计算法" class="headerlink" title="人体姿态估计算法"></a>人体姿态估计算法</h1><h2 id="传统计算机视觉方法-1990-2000"><a href="#传统计算机视觉方法-1990-2000" class="headerlink" title="传统计算机视觉方法 1990-2000"></a>传统计算机视觉方法 1990-2000</h2><h3 id="直接线性变换算法DLT-Direct-Linear-Transform"><a href="#直接线性变换算法DLT-Direct-Linear-Transform" class="headerlink" title="直接线性变换算法DLT(Direct Linear Transform)"></a>直接线性变换算法DLT(Direct Linear Transform)</h3><p>&gt;</p>
<blockquote>
<p>d</p>
</blockquote>
<h3 id="透视n点-PnP-算法-Perspective-n-Point"><a href="#透视n点-PnP-算法-Perspective-n-Point" class="headerlink" title="透视n点(PnP) 算法(Perspective-n-Point)"></a>透视n点(PnP) 算法(Perspective-n-Point)</h3><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1].Pope, R. 《Vision-based human motion analysis: An overview》. Computer Vision and Image Understanding 108, 期 1–2 (2007年): 4–18. <a href="https://doi.org/10.1016/J.CVIU.2006.10.016">https://doi.org/10.1016/J.CVIU.2006.10.016</a>.</p>
]]></content>
      <categories>
        <category>人体姿态估计</category>
      </categories>
      <tags>
        <tag>人体姿态估计, 论文</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习笔记一 单变量线性回归</title>
    <url>/2024/04/18/15-34-48/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.04.18：初稿</li>
</ul>
<h1 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h1><ul>
<li><a href="/2024/04/18/15-40-33/" title="机器笔记汇总">吴恩达机器学习 - 笔记汇总</a>
</li>
</ul>
<h1 id="1-引言（Introduction）"><a href="#1-引言（Introduction）" class="headerlink" title="1 引言（Introduction）"></a>1 引言（Introduction）</h1><h2 id="1-1-Welcome"><a href="#1-1-Welcome" class="headerlink" title="1.1 Welcome"></a>1.1 Welcome</h2><p>随着互联网数据不断累积，硬件不断升级迭代，在这个信息爆炸的时代，机器学习已被应用在各行各业中，可谓无处不在。</p>
<h2 id="1-2-什么是机器学习（What-is-Machine-Learning）"><a href="#1-2-什么是机器学习（What-is-Machine-Learning）" class="headerlink" title="1.2 什么是机器学习（What is Machine Learning）"></a>1.2 什么是机器学习（What is Machine Learning）</h2><ol>
<li><p>机器学习定义<br> 这里主要有两种定义：</p>
<ul>
<li><p>Arthur Samuel (1959). Machine Learning:<br>Field of study that gives computers the ability to learn without being explicitly programmed.<br>这个定义有点不正式但提出的时间最早，来自于一个懂得计算机编程的下棋菜鸟。他编写了一个程序，但没有显式地编程每一步该怎么走，而是让计算机自己和自己对弈，并不断地计算布局的好坏，来判断什么情况下获胜的概率高，从而积累经验，好似学习，最后，这个计算机程序成为了一个比他自己还厉害的棋手。</p>
</li>
<li><p>Tom Mitchell (1998) Well-posed Learning Problem:<br>A computer program is said to learn from experience E with respect to some <strong>task T</strong> and some <strong>performance measure P</strong>, if its performance on T, as measured by P, improves with <strong>experience E</strong>.<br>Tom Mitchell 的定义更为现代和正式。在过滤垃圾邮件这个例子中，电子邮件系统会根据用户对电子邮件的标记（是/不是垃圾邮件）不断学习，从而提升过滤垃圾邮件的准确率，定义中的三个字母分别代表：</p>
<ul>
<li>T(Task): 过滤垃圾邮件任务。</li>
<li>P(Performance): 电子邮件系统过滤垃圾邮件的准确率。</li>
<li>E(Experience): 用户对电子邮件的标记。<blockquote>
<p>类似监督学习</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li>机器学习算法<br>主要有两种机器学习的算法分类<ol>
<li>监督学习</li>
<li>无监督学习<br>还有一些算法也属于机器学习领域，诸如：</li>
</ol>
<ul>
<li>半监督学习: 介于监督学习于无监督学习之间</li>
<li>推荐算法: </li>
<li>强化学习: 通过观察来学习如何做出动作，每个动作都会对环境有所影响，而环境的反馈又可以引导该学习算法。</li>
<li>迁移学习: 某个领域应用到另个领域</li>
</ul>
</li>
</ol>
<h2 id="1-3-监督学习（Supervised-Learning）"><a href="#1-3-监督学习（Supervised-Learning）" class="headerlink" title="1.3 监督学习（Supervised Learning）"></a>1.3 监督学习（Supervised Learning）</h2><p>监督学习，即为教计算机如何去完成预测任务（有反馈），预先给一定数据量的输入<strong>和对应的结果</strong>即训练集，建模拟合，最后让计算机预测未知数据的结果。<br>监督学习一般有两种：</p>
<ol>
<li><p>回归问题（Regression）<br>回归问题即为预测一系列的<strong>连续值</strong>。<br>在房屋价格预测的例子中，给出了一系列的房屋面积数据，根据这些数据来预测任意面积的房屋价格。给出照片-年龄数据集，预测给定照片的年龄。</p>

</li>
<li><p>分类问题（Classification）<br>分类问题即为预测一系列的<strong>离散值</strong>。<br>即根据数据预测被预测对象属于哪个分类。<br>视频中举了癌症肿瘤这个例子，针对诊断结果，分别分类为良性或恶性。还例如垃圾邮件分类问题，也同样属于监督学习中的分类问题。</p>
<img src="/2024/04/18/15-34-48/20180105_194839.png" class="">
</li>
</ol>
<p>视频中提到<strong>支持向量机</strong>这个算法，旨在解决当特征量很大的时候（特征即如癌症例子中的肿块大小，颜色，气味等各种特征），计算机内存一定会不够用的情况。<strong>支持向量机能让计算机处理无限多个特征。</strong></p>
<h2 id="1-4-无监督学习（Unsupervised-Learning）"><a href="#1-4-无监督学习（Unsupervised-Learning）" class="headerlink" title="1.4 无监督学习（Unsupervised Learning）"></a>1.4 无监督学习（Unsupervised Learning）</h2><p>相对于监督学习，训练集不会有人为标注的结果（无反馈），我们<strong>不会给出</strong>结果或<strong>无法得知</strong>训练集的结果是什么样，而是单纯由计算机通过无监督学习算法自行分析，从而“得出结果”。计算机可能会把特定的数据集归为几个不同的簇，故叫做聚类算法。</p>
<p>无监督学习一般分为两种：</p>
<ol>
<li>聚类（Clustering）<ul>
<li>新闻聚合</li>
<li>DNA 个体聚类</li>
<li>天文数据分析</li>
<li>市场细分</li>
<li>社交网络分析</li>
</ul>
</li>
<li>非聚类（Non-clustering）<ul>
<li>鸡尾酒问题</li>
</ul>
</li>
</ol>
<p><strong>新闻聚合</strong></p>
<p>在例如谷歌新闻这样的网站中，每天后台都会收集成千上万的新闻，然后将这些新闻分组成一个个的新闻专题，这样一个又一个聚类，就是应用了无监督学习的结果。</p>
<p><strong>鸡尾酒问题</strong></p>
 <img src="/2024/04/18/15-34-48/20180105_201639.png" class="">
<p>在鸡尾酒会上，大家说话声音彼此重叠，几乎很难分辨出面前的人说了什么。我们很难对于这个问题进行数据标注，而这里的通过机器学习的无监督学习算法，就可以将说话者的声音同背景音乐分离出来。</p>
<h1 id="2-单变量线性回归（Linear-Regression-with-One-Variable）"><a href="#2-单变量线性回归（Linear-Regression-with-One-Variable）" class="headerlink" title="2 单变量线性回归（Linear Regression with One Variable）"></a>2 单变量线性回归（Linear Regression with One Variable）</h1><h2 id="2-1-模型表示（Model-Representation）"><a href="#2-1-模型表示（Model-Representation）" class="headerlink" title="2.1 模型表示（Model Representation）"></a>2.1 模型表示（Model Representation）</h2><ol>
<li>房价预测训练集</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>Size in $feet^2$ ($x$)</th>
<th>Price ($) in 1000’s($y$)</th>
</tr>
</thead>
<tbody>
<tr>
<td>2104</td>
<td>460</td>
</tr>
<tr>
<td>1416</td>
<td>232</td>
</tr>
<tr>
<td>1534</td>
<td>315</td>
</tr>
<tr>
<td>852</td>
<td>178</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
</div>
<p>房价预测训练集中，同时给出了输入 $x$ 和输出结果 $y$，即给出了人为标注的<strong>“正确结果”</strong>，且预测的量是连续的，属于监督学习中的回归问题。</p>
<ol>
<li><p><strong>问题解决模型</strong></p>
<img src="/2024/04/18/15-34-48/20180105_212048.png" class="">
</li>
</ol>
<p>其中 $h$ 代表结果函数，也称为<strong>假设（hypothesis）</strong> 。假设函数根据输入（房屋的面积），给出预测结果输出（房屋的价格），即是一个 $X\to Y$ 的映射。</p>
<p>$h_\theta(x)=\theta_0+\theta_1x$，为解决房价问题的一种可行表达式。</p>
<blockquote>
<p>$x$: 特征/输入变量。</p>
</blockquote>
<p>上式中，$\theta$ 为参数，$\theta$ 的变化才决定了输出结果，不同以往，这里的 $x$ 被我们<strong>视作已知</strong>（不论是数据集还是预测时的输入），所以怎样解得 $\theta$ 以更好地拟合数据，成了求解该问题的最终问题。</p>
<p>单变量，即只有一个特征（如例子中房屋的面积这个特征）。</p>
<h2 id="2-2-代价函数（Cost-Function）"><a href="#2-2-代价函数（Cost-Function）" class="headerlink" title="2.2 代价函数（Cost Function）"></a>2.2 代价函数（Cost Function）</h2><blockquote>
<p>李航《统计学习方法》一书中，损失函数与代价函数两者为<strong>同一概念</strong>，未作细分区别，全书没有和《深度学习》一书一样混用，而是统一使用<strong>损失函数</strong>来指代这类类似概念。</p>
<p>吴恩达（Andrew Ng）老师在其公开课中对两者做了细分。</p>
<p><strong>损失函数</strong>（Loss/Error Function）: 计算<strong>单个</strong>样本的误差。</p>
<p><strong>代价函数</strong>（Cost Function）: 计算整个训练集<strong>所有损失函数之和的平均值</strong></p>
</blockquote>
<p>我们的目的在于求解预测结果 $h$ 最接近于实际结果 $y$ 时 $\theta$ 的取值，则问题可表达为<strong>求解 $\sum\limits_{i=1}^{m}(h_\theta(x^{(i)})-y^{(i)})$ 的最小值</strong>。</p>
<blockquote>
<p>$m$: 训练集中的样本总数</p>
<p>$y$: 目标变量/输出变量</p>
<p>$\left(x, y\right)$: 训练集中的实例</p>
<p>$\left(x^{\left(i\right)},y^{\left(i\right)}\right)$: 训练集中的第 $i$ 个样本实例</p>
</blockquote>
<img src="/2024/04/18/15-34-48/20180105_224648.png" class="">
<p>上图展示了当 $\theta$ 取不同值时，$h_\theta\left(x\right)$ 对数据集的拟合情况，蓝色虚线部分代表<strong>建模误差</strong>。</p>
<p>为了求解最小值，引入代价函数（Cost Function）概念，用于度量建模误差。考虑到要计算最小值，应用二次函数对求和式建模，即应用统计学中的平方损失函数（最小二乘法）：</p>
<p>$$<br>J(\theta_0, \theta_1)= \dfrac{ 1 }{ 2m } \displaystyle \sum_ {i=1}^m\left(\hat{y}_{i}-y_{i} \right)^2=\dfrac{1}{2m}\displaystyle\sum_{i=1}^m\left(h_\theta(x_{i})-y_{i}\right)^2<br>$$</p>
<blockquote>
<p>$\hat{y}$: $y$ 的预测值</p>
<p>系数 $\frac{1}{2}$ 存在与否都不会影响结果，这里是为了在应用梯度下降时便于求解，平方的导数会抵消掉 $\frac{1}{2}$ 。</p>
</blockquote>
<p>讨论到这里，我们的问题就转化成了<strong>求解 $J\left( \theta_0, \theta_1  \right)$ 的最小值</strong>。</p>
<h2 id="2-3-代价函数-直观理解1（Cost-Function-Intuition-I）"><a href="#2-3-代价函数-直观理解1（Cost-Function-Intuition-I）" class="headerlink" title="2.3 代价函数 - 直观理解1（Cost Function - Intuition I）"></a>2.3 代价函数 - 直观理解1（Cost Function - Intuition I）</h2><p>根据上节视频，列出如下定义：</p>
<ul>
<li>假设函数（Hypothesis）: $h_\theta(x)=\theta_0+\theta_1x$</li>
<li>参数（Parameters）: $\theta_0, \theta_1$</li>
<li>代价函数（Cost Function）: $J\left( \theta_0, \theta_1  \right)=\frac{1}{2m}\sum\limits_{i=1}^{m}{ { {\left( { {h}_{\theta } }\left( { {x}^{(i)} } \right)-{ {y}^{(i)} } \right)}^{2} } }$</li>
<li>目标（Goal）: $\underset{\theta_0, \theta_1}{\text{minimize} } J \left(\theta_0, \theta_1 \right)$</li>
</ul>
<p>为了直观理解代价函数到底是在做什么，先假设 $\theta_0 = 0$，并假设训练集有三个数据，分别为$\left(1, 1\right), \left(2, 2\right), \left(3, 3\right)$，这样在平面坐标系中绘制出 $h_\theta\left(x\right)$ ，并分析 $J\left(\theta_0, \theta_1\right)$ 的变化。</p>
<img src="/2024/04/18/15-34-48/20180106_085915.png" class="">
<p>右图 $J\left(\theta_0, \theta_1\right)$ 随着 $\theta_1$ 的变化而变化，可见<strong>当 $\theta_1 = 1$ 时，$J\left(\theta_0, \theta_1 \right) = 0$，取得最小值，</strong>对应于左图青色直线，即函数 $h$ 拟合程度最好的情况。</p>
<h2 id="2-4-代价函数-直观理解2（Cost-Function-Intuition-II）"><a href="#2-4-代价函数-直观理解2（Cost-Function-Intuition-II）" class="headerlink" title="2.4 代价函数 - 直观理解2（Cost Function - Intuition II）"></a>2.4 代价函数 - 直观理解2（Cost Function - Intuition II）</h2><p>给定数据集：<br><img src="/2024/04/18/15-34-48/20180106_091307.png" class=""></p>
<p>参数在 $\theta_0$ 不恒为 $0$ 时代价函数 $J\left(\theta\right)$ 关于 $\theta_0, \theta_1$ 的3-D图像，图像中的高度为代价函数的值。</p>
<img src="/2024/04/18/15-34-48/20180106_090904.png" class="">
<p>由于3-D图形不便于标注，所以将3-D图形转换为<strong>轮廓图（contour plot）</strong>，下面用轮廓图（下图中的右图）来作直观理解，其中相同颜色的一个圈代表着同一高度（同一 $J\left(\theta\right)$ 值）。</p>
<p>$\theta_0 = 360, \theta_1 =0$ 时：</p>
<img src="/2024/04/18/15-34-48/0f38a99c8ceb8aa5b90a5f12136fdf43.png" class="">
<p>大概在 $\theta_0 = 0.12, \theta_1 =250$ 时：</p>
<img src="/2024/04/18/15-34-48/20180106_092119.png" class="">
<p>上图中最中心的点（红点），近乎为图像中的最低点，也即代价函数的最小值，此时对应 $h_\theta\left(x\right)$ 对数据的拟合情况如左图所示。</p>
<h2 id="2-5-梯度下降（Gradient-Descent）"><a href="#2-5-梯度下降（Gradient-Descent）" class="headerlink" title="2.5 梯度下降（Gradient Descent）"></a>2.5 梯度下降（Gradient Descent）</h2><p>在特征量很大的情况下，即便是借用计算机来生成图像，人工的方法也很难读出 $J\left(\theta\right)$ 的最小值，并且大多数情况无法进行可视化，故引入<strong>梯度下降（Gradient Descent）方法，让计算机自动找出最小化代价函数时对应的 $\theta$ 值。</strong></p>
<p>梯度下降背后的思想是：开始时，我们随机选择一个参数组合$\left( {\theta_{0} },{\theta_{1} },……,{\theta_{n} } \right)$即起始点，计算代价函数，然后寻找下一个能使得代价函数下降最多的参数组合。不断迭代，直到找到一个<strong>局部最小值（local minimum）</strong>，由于下降的情况只考虑当前参数组合周围的情况，所以无法确定当前的局部最小值是否就是<strong>全局最小值（global minimum）</strong>，不同的初始参数组合，可能会产生不同的局部最小值。</p>
<p>下图根据不同的起始点，产生了两个不同的局部最小值。</p>
<img src="/2024/04/18/15-34-48/db48c81304317847870d486ba5bb2015.jpg" class="">
<p>视频中举了下山的例子，即我们在山顶上的某个位置，为了下山，就不断地看一下周围<strong>下一步往哪走</strong>下山比较快，然后就<strong>迈出那一步</strong>，一直重复，直到我们到达山下的某一处<strong>陆地</strong>。</p>
<p>梯度下降公式：</p>
<p>$$<br>\begin{split}<br>&amp; \text{Repeat until convergence:} \; \lbrace \\<br>&amp;{ {\theta }_{j} }:={ {\theta }_{j} }-\alpha \frac{\partial }{\partial { {\theta }_{j} } }J\left( {\theta_{0} },{\theta_{1} }  \right) \\<br>\rbrace<br>\end{split}<br>$$</p>
<blockquote>
<p>“-”来源于：<strong>正值向左移动减少，负值向右移动增加</strong><br>${\theta }_{j}$: 第 $j$ 个特征参数</p>
<p>”:=“: 赋值操作符</p>
<p>$\alpha$: 学习速率（learning rate）, $\alpha &gt; 0$</p>
<p>$\frac{\partial }{\partial { {\theta }_{j} } }J\left( \theta_0, \theta_j  \right)$: $J\left( \theta_0, \theta_j \right)$ 的偏导</p>
</blockquote>
<p>公式中，学习速率决定了参数值变化的速率即”<strong>走多少距离</strong>“，而偏导这部分决定了下降的方向即”<strong>下一步往哪里</strong>“走（当然实际上的走多少距离是由偏导值给出的，学习速率起到调整后决定的作用），收敛处的局部最小值又叫做极小值，即”<strong>陆地</strong>“。</p>
<img src="/2024/04/18/15-34-48/20180106_101659.png" class="">
<p>注意，在计算时要<strong>批量更新 $\theta$ 值</strong>，即如上图中的左图所示，否则结果上会有所出入，原因不做细究。</p>
<h2 id="2-6-梯度下降直观理解（Gradient-Descent-Intuition）"><a href="#2-6-梯度下降直观理解（Gradient-Descent-Intuition）" class="headerlink" title="2.6 梯度下降直观理解（Gradient Descent Intuition）"></a>2.6 梯度下降直观理解（Gradient Descent Intuition）</h2><p>该节探讨 $\theta_1$ 的梯度下降更新过程，即 $\theta_1 := \theta_1 - \alpha\frac{d}{d\theta_1}J\left(\theta_1\right)$。</p>
<img src="/2024/04/18/15-34-48/20180106_184926.png" class="">
<p>直线的斜率，表示了函数 $J\left(\theta\right)$ 在初始点处有<strong>正斜率</strong>，也就是说它有<strong>正导数</strong>，会<strong>向左边移动</strong>。不断重复，直到收敛。</p>
<p>初始 $\theta$ 值（初始点）是任意的。</p>
<p>对于学习速率 $\alpha$，需要选取一个合适的值才能使得梯度下降算法运行良好。</p>
<ul>
<li><p>学习速率过小图示：</p>
<img src="/2024/04/18/15-34-48/20180106_190944.png" class="">
<p>收敛的太慢，需要更多次的迭代。</p>
</li>
<li><p>学习速率过大图示：</p>
<img src="/2024/04/18/15-34-48/20180106_191023.png" class="">
<p>可能越过最低点，甚至导致无法收敛。</p>
</li>
</ul>
<p><strong>学习速率只需选定即可</strong>，不需要动态改变，随着斜率越来越接近于0，代价函数的变化幅度会越来越小，直到收敛到局部极小值。</p>
<p>代价函数随着迭代的进行，变化的幅度越来越小。</p>
<img src="/2024/04/18/15-34-48/20180106_191956.png" class="">
<h2 id="2-7-线性回归中的梯度下降（Gradient-Descent-For-Linear-Regression）"><a href="#2-7-线性回归中的梯度下降（Gradient-Descent-For-Linear-Regression）" class="headerlink" title="2.7 线性回归中的梯度下降（Gradient Descent For Linear Regression）"></a>2.7 线性回归中的梯度下降（Gradient Descent For Linear Regression）</h2><p>线性回归模型</p>
<ul>
<li>$h_\theta(x)=\theta_0+\theta_1x$</li>
<li>$J\left( \theta_0, \theta_1  \right)=\frac{1}{2m}\sum\limits_{i=1}^{m}{ { {\left( { {h}_{\theta } }\left( { {x}^{(i)} } \right)-{ {y}^{(i)} } \right)}^{2} } }$</li>
</ul>
<p>梯度下降算法<br>$$<br>\begin{split}<br>  &amp; \text{Repeat until convergence:} \; \lbrace \\<br>  &amp;{ {\theta }_{j} }:={ {\theta }_{j} }-\alpha \frac{\partial }{\partial { {\theta }_{j} } }J\left( {\theta_{0} },{\theta_{1} }  \right) \\<br>  \rbrace<br>  \end{split}<br>$$</p>
<p>直接将线性回归模型公式代入梯度下降公式可得出公式</p>
<img src="/2024/04/18/15-34-48/20180106_203726.png" class="">
<p>当 $j = 0, j = 1$ 时，<strong>线性回归中代价函数求导的推导过程（：</strong></p>
<p>$$<br>\begin{split}<br>\frac{\partial}{\partial\theta_j} J(\theta_1, \theta_1)&amp;=\frac{\partial}{\partial\theta_j} \left(\frac{1}{2m}\sum\limits_{i=1}^{m}{ {\left( { {h}_{\theta } }\left( { {x}^{(i)} } \right)-{ {y}^{(i)} } \right)}^{2} } \right)\\<br>&amp;=\left(\frac{1}{2m}*2\sum\limits_{i=1}^{m}{ {\left( { {h}_{\theta } }\left( { {x}^{(i)} } \right)-{ {y}^{(i)} } \right)} } \right)*\frac{\partial}{\partial\theta_j}{ {\left( { {h}_{\theta } }\left( { {x}^{(i)} } \right)-{ {y}^{(i)} } \right)} } \\<br>&amp;=\left(\frac{1}{m}\sum\limits_{i=1}^{m}{ {\left( { {h}_{\theta } }\left( { {x}^{(i)} } \right)-{ {y}^{(i)} } \right)} } \right)*\frac{\partial}{\partial\theta_j} {\left( \theta_0 + \theta_1{x_1^{(i)} }-{ {y}^{(i)} } \right)}<br>\end{split}<br>$$</p>
<p>所以当 $j = 0$ 时：</p>
<p>$$<br>\frac{\partial}{\partial\theta_0} J(\theta)=\frac{1}{m}\sum\limits_{i=1}^{m}{ {\left( { {h}_{\theta } }\left( { {x}^{(i)} } \right)-{ {y}^{(i)} } \right)} }<br>$$</p>
<p>所以当 $j = 1$ 时：</p>
<p>$$<br>\frac{\partial}{\partial\theta_1} J(\theta)=\frac{1}{m}\sum\limits_{i=1}^{m}{ {\left( { {h}_{\theta } }\left( { {x}^{(i)} } \right)-{ {y}^{(i)} } \right)} } *x_1^{(i)}<br>$$</p>
<p>上文中所提到的梯度下降，都为批量梯度下降（Batch Gradient Descent），即每次计算都使用<strong>所有</strong>的数据集 $\left(\sum\limits_{i=1}^{m}\right)$ 更新。</p>
<p>由于线性回归函数呈现<strong>碗状</strong>，且<strong>只有一个</strong>全局的最优值，所以函数<strong>一定总会</strong>收敛到全局最小值（学习速率不可过大）。同时，函数 $J$ 被称为<strong>凸二次函数</strong>，而线性回归函数求解最小值问题属于<strong>凸函数优化问题</strong>。</p>
<img src="/2024/04/18/15-34-48/24e9420f16fdd758ccb7097788f879e7.png" class="">
<p>另外，使用循环求解，代码较为冗余，后面会讲到如何使用<strong>向量化（Vectorization）</strong>来简化代码并优化计算，使梯度下降运行的更快更好。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习, 深度学习, 吴恩达</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习笔记二 多变量线性回归</title>
    <url>/2024/04/21/07-10-14/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.04.21：初稿</li>
</ul>
<h1 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h1><ul>
<li><a href="/2024/04/18/15-40-33/" title="机器笔记汇总">吴恩达机器学习 - 笔记汇总</a>
</li>
</ul>
<h1 id="4-多变量线性回归（Linear-Regression-with-Multiple-Variables）"><a href="#4-多变量线性回归（Linear-Regression-with-Multiple-Variables）" class="headerlink" title="4 多变量线性回归（Linear Regression with Multiple Variables）"></a>4 多变量线性回归（Linear Regression with Multiple Variables）</h1><h2 id="4-1-多特征（Multiple-Features）"><a href="#4-1-多特征（Multiple-Features）" class="headerlink" title="4.1 多特征（Multiple Features）"></a>4.1 多特征（Multiple Features）</h2><p>不同维度的多个特征。</p>
<img src="/2024/04/21/07-10-14/20180107_234509.png" class="">
<p>这里由于特征不再只有一个，引入一些新的记号</p>
<blockquote>
<p>$n$: 特征的总数</p>
<p> ${x}^{\left( i \right)}$: 代表样本矩阵中第 $i$ 行，也就是第 $i$ 个训练实例。</p>
<p> ${x}_{j}^{\left( i \right)}$: 代表样本矩阵中第 $i$ 行的第 $j$ 列，也就是第 $i$ 个训练实例的第 $j$ 个特征。</p>
</blockquote>
<p>参照上图，则有 ${x}^{(2)}\text{=}\begin{bmatrix} 1416\\\ 3\\\ 2\\\ 40 \end{bmatrix}, {x}^{(2)}_{1} = 1416$</p>
<blockquote>
<p>全部写成一维向量</p>
</blockquote>
<p>多变量假设函数 $h$ 表示为：$h_{\theta}\left( x \right)={\theta_{0} }+{\theta_{1} }{x_{1} }+{\theta_{2} }{x_{2} }+…+{\theta_{n} }{x_{n} }$</p>
<p>对于 $\theta_0$，和单特征中一样，我们将其看作基础数值。</p>
<p>$$<br>h_\theta\left(x\right)=\begin{bmatrix}\theta_0\; \theta_1\; … \;\theta_n \end{bmatrix}\begin{bmatrix}x_0 \newline x_1 \newline \vdots \newline x_n\end{bmatrix}= \theta^T x<br>$$</p>
<blockquote>
<p>$\theta^T$: $\theta$ 矩阵的转置</p>
<p>$x$: 某个样本的特征向量，$n+1$ 维特征量向量</p>
<p>$x_0$: 为了计算方便我们会假设 $x_0^{(i)} = 1$</p>
</blockquote>
<h2 id="4-2-多变量梯度下降（Gradient-Descent-for-Multiple-Variables）"><a href="#4-2-多变量梯度下降（Gradient-Descent-for-Multiple-Variables）" class="headerlink" title="4.2 多变量梯度下降（Gradient Descent for Multiple Variables）"></a>4.2 多变量梯度下降（Gradient Descent for Multiple Variables）</h2><p>多变量代价函数类似于单变量代价函数，</p>
<p>即 $J\left( {\theta_{0} },{\theta_{1} }…{\theta_{n} } \right)=\frac{1}{2m}\sum\limits_{i=1}^{m}{ { {\left( h_{\theta} \left({x}^{\left( i \right)} \right)-{y}^{\left( i \right)} \right)}^{2} } }$ ，其中 $h_\theta\left(x\right)= \theta^T x$。</p>
<p>前文提到梯度下降对于最小化代价函数的通用性，则多变量梯度下降公式即</p>
<p>\begin{split}<br>&amp; \text{Repeat until convergence:} \; \lbrace \\<br>&amp;{ {\theta }_{j} }:={ {\theta }_{j} }-\alpha \frac{\partial }{\partial { {\theta }_{j} } }J\left( {\theta_{0} },{\theta_{1} }…{\theta_{n} }  \right) \\<br>\rbrace<br>\end{split}</p>
<p>解出偏导得：</p>
<p>\begin{split}<br>&amp; \text{repeat until convergence:} \; \lbrace \\<br>&amp; \theta_j := \theta_j - \alpha \frac{1}{m} \sum\limits_{i=1}^{m} (h_\theta(x^{(i)}) - y^{(i)}) \cdot x_j^{(i)} \; &amp; \text{for j := 0,1…n}\\<br>\rbrace<br>\end{split}</p>
<p>可展开为：</p>
<p>\begin{split}<br>&amp; \text{repeat until convergence:} \; \lbrace \\<br>&amp; \theta_0 := \theta_0 - \alpha \frac{1}{m} \sum\limits_{i=1}^{m} (h_\theta(x^{(i)}) - y^{(i)}) \cdot x_0^{(i)}\\<br>&amp; \theta_1 := \theta_1 - \alpha \frac{1}{m} \sum\limits_{i=1}^{m} (h_\theta(x^{(i)}) - y^{(i)}) \cdot x_1^{(i)} \\<br>&amp; \theta_2 := \theta_2 - \alpha \frac{1}{m} \sum\limits_{i=1}^{m} (h_\theta(x^{(i)}) - y^{(i)}) \cdot x_2^{(i)} \\<br>&amp; \vdots \\<br>&amp; \theta_n := \theta_n - \alpha \frac{1}{m} \sum\limits_{i=1}^{m} (h_\theta(x^{(i)}) - y^{(i)}) \cdot x_n^{(i)} &amp;\\<br>\rbrace<br>\end{split}</p>
<p>当然，同单变量梯度下降一样，计算时需要<strong>同时更新</strong>所有参数。</p>
<p>$h_\theta\left(x\right)= \theta^T x$，则得到同时更新参数的向量化（Vectorization）实现：<br>$$<br>\theta = \theta - \alpha \frac{1}{m}(X^T(X\theta-y))<br>$$</p>
<p><strong>向量化推导过程：</strong></p>
<p>\begin{split}<br>&amp;X = \begin{bmatrix}{ {x}^{(0)} } ^ T \newline { {x}^{(1)} } ^ T \newline \vdots \newline { {x}^{(m)} } ^ T\ \end{bmatrix}<br>&amp;X^T = \begin{bmatrix}{x}^{(0)}\; {x}^{(1)}\; … \;{x}^{(m)} \end{bmatrix}<br>\\<br>&amp;X\theta - y = \begin{bmatrix}{ {x}^{(0)} } ^ T \theta - y\newline { {x}^{(1)} } ^ T \theta -y \newline \vdots \newline { {x}^{(m)} } ^ T\theta -y\ \end{bmatrix} \\<br>&amp;h_\theta\left(x\right)= X\theta<br>\end{split}</p>
<blockquote>
<p>$X$: 是一个秩为1的矩阵？  一次更新一个相同的特征向量？？<br>$X$: 训练集数据，$m\times(n+1)$ 维矩阵（包含基本特征 $x_0=1$）</p>
</blockquote>
<h2 id="4-3-梯度下降实践1-特征值缩放（Gradient-Descent-in-Practice-I-Feature-Scaling）"><a href="#4-3-梯度下降实践1-特征值缩放（Gradient-Descent-in-Practice-I-Feature-Scaling）" class="headerlink" title="4.3 梯度下降实践1-特征值缩放（Gradient Descent in Practice I - Feature Scaling）"></a>4.3 梯度下降实践1-特征值缩放（Gradient Descent in Practice I - Feature Scaling）</h2><p>在应用梯度下降算法实践时，由于各特征值的范围不一，可能会影响代价函数收敛速度。</p>
<p>房屋面积大小和房间数量这两个特征。</p>
<img src="/2024/04/21/07-10-14/20180108_100751.png" class="">
<p>为了优化梯度下降的收敛速度，采用特征缩放的技巧，使各特征值的<strong>范围尽量一致</strong>。</p>
<p>除了以上图人工选择并除以一个参数的方式，<strong>均值归一化（Mean normalization</strong>方法更为便捷，可采用它来对所有特征值统一缩放：</p>
<p> $x_i:=\frac{x_i-average(x)}{maximum(x)-minimum(x)}$, 使得  $x_i \in (-1,1)$</p>
<p>对于特征的范围，并不一定需要使得 $-1 \leqslant x \leqslant 1$，类似于 $1\leqslant x \leqslant 3$ 等也是可取的，而诸如 $-100 \leqslant x \leqslant 100 $，$-0.00001 \leqslant x \leqslant 0.00001$，就显得过大/过小了。</p>
<p>另外注意，一旦采用特征缩放，我们就需对所有的输入采用特征缩放，包括训练集、测试集、预测输入等。</p>
<h2 id="4-4-梯度下降实践2-学习速率（Gradient-Descent-in-Practice-II-Learning-Rate）"><a href="#4-4-梯度下降实践2-学习速率（Gradient-Descent-in-Practice-II-Learning-Rate）" class="headerlink" title="4.4 梯度下降实践2-学习速率（Gradient Descent in Practice II - Learning Rate）"></a>4.4 梯度下降实践2-学习速率（Gradient Descent in Practice II - Learning Rate）</h2><p>通常，有两种方法来确定函数是否收敛</p>
<ul>
<li>多次迭代收敛法<ul>
<li>无法确定需要多少次迭代</li>
<li>较易绘制关于迭代次数的图像</li>
<li>根据图像易预测所需的迭代次数</li>
</ul>
</li>
<li>自动化测试收敛法（比较阈值）<ul>
<li>不易选取阈值</li>
<li>代价函数近乎直线时无法确定收敛情况</li>
</ul>
</li>
</ul>
<p>对于梯度下降，一般采用多次迭代收敛法来得出最小化代价函数的参数值，自动化测试收敛法（如设定 $J\left(\theta\right) &lt; {10}^{-3}$ 时判定收敛）则几乎不会被使用。</p>
<p>我们可以通过绘制<strong>代价函数关于迭代次数的图像</strong>，可视化梯度下降的执行过程，借助直观的图形来发现代价函数趋向于多少时能趋于收敛，依据图像变化情况，确定诸如学习速率的取值，迭代次数的大小等问题。</p>
<img src="/2024/04/21/07-10-14/20180108_103357.png" class="">
<p>对于学习速率 $\alpha$，一般上图展现的为适中情况，下图中，左图可能表明 <strong>$\alpha$ 过大</strong>，代价函数<strong>无法收敛</strong>，右图可能表明 <strong>$\alpha$ 过小</strong>，代价函数<strong>收敛的太慢</strong>。当然，$\alpha$ 足够小时，代价函数在每轮迭代后一定会减少。</p>
<img src="/2024/04/21/07-10-14/20180108_104701.png" class="">
<p>通过不断改变 $\alpha$ 值，绘制并观察图像，并以此来确定合适的学习速率。 尝试时可取 $\alpha$ 如 $\dots\;0,001,\;0.003,\;0.01,\;0.03,\;0.1,\;\dots$</p>
<h2 id="4-5-特征和多项式回归（Features-and-Polynomial-Regression）"><a href="#4-5-特征和多项式回归（Features-and-Polynomial-Regression）" class="headerlink" title="4.5 特征和多项式回归（Features and Polynomial Regression）"></a>4.5 特征和多项式回归（Features and Polynomial Regression）</h2><p>在特征选取时，我们也可以自己归纳总结，定义一个新的特征，用来<strong>取代或拆分</strong>旧的一个或多个特征。比如，对于房屋面积特征来说，我们可以将其拆分为长度和宽度两个特征，反之，我们也可以合并长度和宽度这两个特征为面积这一个特征。</p>
<p>线性回归只能以直线来对数据进行拟合，有时候需要使用<strong>曲线</strong>来对数据进行拟合，即<strong>多项式回归（Polynomial Regression）</strong>。</p>
<p>比如一个二次方模型：$h_{\theta}\left( x \right)={\theta_{0} }+{\theta_{1} }{x_{1} }+{\theta_{2} }{x_{2}^2}$</p>
<p>或者三次方模型：$h_{\theta}\left( x \right)={\theta_{0} }+{\theta_{1} }{x_{1} }+{\theta_{2} }{x_{2}^2}+{\theta_{3} }{x_{3}^3}$ </p>
<p>或者平方根模型： $h_{\theta}\left( x \right)={\theta_{0} }+{\theta_{1} }{x_{1} }+{\theta_{2} }{x_{2}^2}+{\theta_{3} }{\sqrt{x_3} }$</p>
<img src="/2024/04/21/07-10-14/20180108_113132.png" class="">
<p>在使用多项式回归时，要记住非常有必要进行特征缩放，比如 $x_1$ 的范围为 1-1000，那么 $x_1^2$ 的范围则为 1- 1000000，不使用特征缩放的话，范围不一致，也更易影响效率。</p>
<blockquote>
<p>多特征下的特征值缩放按照$x$还是$x^3$ ？</p>
</blockquote>
<h2 id="4-6-正规方程（Normal-Equation）"><a href="#4-6-正规方程（Normal-Equation）" class="headerlink" title="4.6 正规方程（Normal Equation）"></a>4.6 正规方程（Normal Equation）</h2><p>对于一些线性回归问题来说，正规方程法给出了一个更好的解决问题的方式。</p>
<p>正规方程法，即令 $\frac{\partial}{\partial{\theta_{j} } }J\left( {\theta_{j} } \right)=0$ ，通过解析函数的方式直接计算得出参数向量的值  $\theta ={ {\left( {X^T}X \right)}^{-1} }{X^{T} }y$ ，Octave/Matlab 代码： <code>theta = inv(X&#39;*X)*X&#39;*y</code>。</p>
<blockquote>
<p>${X}^{-1}$: 矩阵 $X$ 的逆，在 Octave 中，<code>inv</code> 函数用于计算矩阵的逆，类似的还有 <code>pinv</code> 函数。</p>
<p><code>X&#39;</code>: 在 Octave 中表示矩阵 X 的转置，即 $X^T$</p>
</blockquote>
<p>下表列出了正规方程法与梯度下降算法的对比</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>条件</th>
<th>梯度下降</th>
<th>正规方程</th>
</tr>
</thead>
<tbody>
<tr>
<td>是否需要选取 $\alpha$</td>
<td>需要</td>
<td>不需要</td>
</tr>
<tr>
<td>是否需要迭代运算</td>
<td>需要</td>
<td>不需要</td>
</tr>
<tr>
<td>特征量大时</td>
<td>适用，$O\left(kn^2\right)$</td>
<td>不适用，$(X^TX)^{-1}$ 复杂度 $O\left( { {n}^{3} } \right)$</td>
</tr>
<tr>
<td>适用范围</td>
<td>各类模型</td>
<td>只适用线性模型，且矩阵需可逆</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>一般来说，当 $n$ 超过 10000 时，对于正规方程而言，特征量较大。</li>
<li>梯度下降算法的普适性好，而对于特定的线性回归模型，正规方程是很好的替代品。</li>
</ul>
<p><strong>正规方程法的推导过程</strong>：(同4.2)</p>
<p>\begin{split}<br>J\left( \theta  \right)&amp; =\frac{1}{2m}\sum\limits_{i=1}^{m}{ { {\left( {h_{\theta} }\left( {x^{(i)} } \right)-{y^{(i)} } \right)}^{2} } }\\<br>&amp; =\frac{1}{2m}||X\theta-y||^2 \\<br>&amp; =\frac{1}{2m}(X\theta-y)^T(X\theta-y) \hspace{15cm}<br>\end{split}</p>
<p>展开上式可得</p>
<p>$<br>(X\theta-y)^T = \theta^T X^T - y^T<br>$</p>
<p>$J(\theta )= \frac{1}{2m}\left( { {\theta }^{T} }{ {X}^{T} }X\theta -{ {\theta}^{T} }{ {X}^{T} }y-{ {y}^{T} }X\theta + { {y}^{T} }y \right)$</p>
<p>注意到 ${ {\theta}^{T} }{ {X}^{T} }y$ 与 ${ {y}^{T} }X\theta$ 都为标量，实际上是等价的，则：</p>
<p>$J(\theta) = \frac{1}{2m}[{\theta }^{T}X^TX\theta-2\theta^TX^Ty+y^Ty]$</p>
<p>接下来对$J(\theta )$ 求偏导，根据矩阵的求导法则:</p>
<p>$\frac{d X^TAX}{d X}=2AX$</p>
<p>$\frac{d X^T}{d X}={E}$</p>
<p>$\frac{d AB}{d B}={A^T}$</p>
<p>所以有:</p>
<p>$\frac{\partial J\left( \theta  \right)}{\partial \theta }=\frac{1}{2m}\left(2{ {X}^{T} }X\theta -2{ {X}^{T} }y \right)={ {X}^{T} }X\theta -{ {X}^{T} }y$</p>
<p>令$\frac{\partial J\left( \theta  \right)}{\partial \theta }=0$, 则有<br>$$<br>\theta ={ {\left( {X^{T} }X \right)}^{-1} }{X^{T} }y<br>$$</p>
<blockquote>
<p>求最小值, 极值一定是最小值, 具有实际意义</p>
</blockquote>
<h2 id="4-7-不可逆性正规方程（Normal-Equation-Noninvertibility）"><a href="#4-7-不可逆性正规方程（Normal-Equation-Noninvertibility）" class="headerlink" title="4.7 不可逆性正规方程（Normal Equation Noninvertibility）"></a>4.7 不可逆性正规方程（Normal Equation Noninvertibility）</h2><p>（本部分内容为选讲）</p>
<p>正规方程无法应用于不可逆的矩阵，发生这种问题的概率很小，通常由于</p>
<ul>
<li><p>特征之间线性相关</p>
<p>比如同时包含英寸的尺寸和米为单位的尺寸两个特征，它们是线性相关的</p>
<p>即 ${x_{1} }={x_{2} }*{ {\left( 3.28 \right)}^{2} }$。</p>
</li>
<li><p>特征数量大于训练集的数量 $\left(m \leqslant n \right)$。</p>
</li>
</ul>
<p>如果发现 $X^TX$ 的结果不可逆，可尝试：</p>
<ul>
<li>减少多余/重复特征</li>
<li>增加训练集数量</li>
<li>使用正规化（后文）</li>
</ul>
<p>对于这类不可逆的矩阵，我们称之为<strong>奇异矩阵</strong>或<strong>退化矩阵</strong>。</p>
<p>这种情况下，如果还想使用正规方程法，在Octave中，可以选用 <code>pinv</code> 函数，<code>pinv</code> 区别于 <code>inv</code>，<code>pinv</code> 函数被称为伪逆函数，在矩阵不可逆的时候，使用这个函数仍可正确地计算出 $\theta$ 的值。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习, 深度学习, 吴恩达</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习笔记四 神经网络的表达</title>
    <url>/2024/04/22/13-37-13/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.04.22：初稿</li>
</ul>
<h1 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h1><ul>
<li><a href="/2024/04/18/15-40-33/" title="机器笔记汇总">吴恩达机器学习 - 笔记汇总</a>
</li>
</ul>
<h1 id="8-神经网络：表达（Neural-Networks-Representation）"><a href="#8-神经网络：表达（Neural-Networks-Representation）" class="headerlink" title="8 神经网络：表达（Neural Networks: Representation）"></a>8 神经网络：表达（Neural Networks: Representation）</h1><h2 id="8-1-非线性假设（Non-linear-Hypotheses）"><a href="#8-1-非线性假设（Non-linear-Hypotheses）" class="headerlink" title="8.1 非线性假设（Non-linear Hypotheses）"></a>8.1 非线性假设（Non-linear Hypotheses）</h2><p>理论上我们可以用多项式函数去近似任意函数（泰勒极数（Taylor series）），从而可得到任意问题的拟合曲线。</p>
<p>在实际处理时，特征量通常会很多，如果再构造高阶多项式等，特征数量将会急剧增加，这使得回归模型的复杂度太高，可见并不合适。神经网络无需构造高阶多项式，在特征量很大时也可以处理的很好。</p>
<p>那特征能有多大呢？下面是一个计算机视觉中的例子：</p>
<img src="/2024/04/22/13-37-13/20180115_084326.png" class="">
<p>如上图，如果选取一小块 $50 * 50$ 像素的灰度图片（一个像素只有亮度一个值），选择每个像素点作为特征，则特征总量 $n=2500$（换成 RGB（一个像素有三个值），则 $n = 7500$），如果将其两两组合作为新特征，则特征数量将为 $C_{2500}^{2} \approx 3\ million$。</p>
<h2 id="8-2-神经网络和大脑（Neurons-and-the-Brain）"><a href="#8-2-神经网络和大脑（Neurons-and-the-Brain）" class="headerlink" title="8.2 神经网络和大脑（Neurons and the Brain）"></a>8.2 神经网络和大脑（Neurons and the Brain）</h2><p>脑科学家通过对动物实验，发现大脑中专用于处理听觉信号的脑皮层也能处理其他诸如视觉等信号，即如果切断其与耳朵的联系，将其与眼睛相连，则这块负责听觉的脑皮层区域也能接受并处理视觉信号，从而学会“看”。脑科学家通过这类换源实验，就推论假设大脑的学习算法只有一种（“one learning algorithm” hypothesis）。那么如果能找出这种学习算法并应用于计算机中，那梦想中和人一样的人工智能就成真了。</p>
<p>神经网络就源于<strong>模拟人类大脑</strong>，但其需要的计算量很大。随着计算机硬件性能的提高，神经网络逐渐从衰落变为流行，如今已广泛地被应用在各行各业中。</p>
<p>下图是根据研究做的一些应用（有兴趣可回顾视频）：</p>
<img src="/2024/04/22/13-37-13/20180115_101441.png" class="">
<p>BrainPort  系统：帮助失明人士通过摄像头以及舌尖感官“看”东西</p>
<img src="/2024/04/22/13-37-13/20180115_101442.png" class="">
<p>触觉皮带：在朝北时蜂鸣器会发出声响，可使人拥有方向感（声音信号转换为方向信号）。</p>
<h2 id="8-3-模型表示1（Model-Representation-I）"><a href="#8-3-模型表示1（Model-Representation-I）" class="headerlink" title="8.3 模型表示1（Model Representation I）"></a>8.3 模型表示1（Model Representation I）</h2><p>大脑神经元</p>
<img src="/2024/04/22/13-37-13/20141213201613758.jpg" class="">
<p>想象一下印刷厂中流水线的工人，每个工人都有特定的任务，比如装订，塑封，贴防伪标识等等，工人们看到书本并处理完自己的任务后，就回放回传送带，紧接着传送带就传给下一个环节的工人，如此不断重复从而完成一个又一个环节，直到一本书印制完成。</p>
<p>那么类比一下，把上图中的<strong>细胞核（nucleus）</strong>类比成工人，<strong>轴突（axon）</strong>类比传送带，<strong>树突（dendrite）</strong>则比类比成工人的双眼。一个又一个细胞体，从树突接收需要处理的信息，对其进行处理后，再经由轴突通过电信号把处理完的信息传递出去，直到理解信息的内容。</p>
<p>人工神经网络中，树突对应<strong>输入（input）</strong>，细胞核对应<strong>激活单元（activation unit）</strong>，轴突对应<strong>输出（output）</strong>。</p>
<p>我们一般把神经网络划分为三部分（注意，不是只有三层！），即输入层（input layer），隐藏层（hidden layer）和输出层（output layer）。</p>
<img src="/2024/04/22/13-37-13/20180116_001543.png" class="">
<p>图中的一个圈表示神经网络中的一个激活单元，输入层对应输入单元，隐藏层对应中间单元，输出层则对应输出单元。中间激活单元应用<strong>激活函数</strong>处理数据。</p>
<p>下面列出一些已有概念在神经网络中的别称：</p>
<ul>
<li>$x_0$: 偏置单元（bias unit），$x_0$=1</li>
<li>$\Theta$: 权重（weight），即参数。</li>
<li>激活函数: $g$，即逻辑函数等。</li>
<li>输入层: 对应于训练集中的特征 $x$。</li>
<li>输出层: 对应于训练集中的结果 $y$。</li>
</ul>
<blockquote>
<p>$a^{(j)}_i$: 第 $j$ 层的第 $i$ 个激活单元</p>
<p>$\Theta^{(j)}$: 从第 $j$ 层映射到第 $j+1$ 层时的权重矩阵。</p>
<p>$\Theta^{(j)}_{v,u}$: 从第 $j$ 层的第 $u$ 个单元映射到第 $j+1$ 层的第 $v$ 个单元的权重</p>
<p>$s_j$: 第 $j$ 层的激活单元数目（不包含偏置单元）</p>
</blockquote>
<p>注意：</p>
<ul>
<li><strong>每个单元会作用于下一层的所有单元</strong>（矩阵乘法运算）。</li>
<li>如果第 $j$ 层有 $s_j$ 个单元，第 $j+1$ 层有 $s_{j+1}$ 个单元，$\Theta^{(j)}$ 是一个 $s_{j+1} \times (s_j+1)$ 维的权重矩阵。即每一层的权重矩阵大小都是非固定的。</li>
<li>其中，$+1$ 来自于偏置单元，这样意味着输出层不包含偏置单元，输入层和隐藏层需要增加偏置单元。</li>
</ul>
<p>依据本节所给模型，有：</p>
<p>$Size(\Theta^{(1)})=s_{j+1} \times (s_j + 1) =s_2 \times (s_1 + 1) = 3 \times 4$</p>
<p>$Size(\Theta^{(2)})=s_3 \times (s_2 + 1) = 1 \times 4$</p>
<h2 id="8-4-模型表示2（Model-Representation-II）"><a href="#8-4-模型表示2（Model-Representation-II）" class="headerlink" title="8.4 模型表示2（Model Representation II）"></a>8.4 模型表示2（Model Representation II）</h2><img src="/2024/04/22/13-37-13/20180116_001543.png" class="">
<p>对输入层（Layer 1）的所有激活单元应用激活函数，从而得到隐藏层（Layer 2）中激活单元的值：</p>
<p>$$<br>\begin{split} a_1^{(2)} = g(\Theta_{10}^{(1)}x_0 + \Theta_{11}^{(1)}x_1 + \Theta_{12}^{(1)}x_2 + \Theta_{13}^{(1)}x_3)\\<br>a_2^{(2)} = g(\Theta_{20}^{(1)}x_0 + \Theta_{21}^{(1)}x_1 + \Theta_{22}^{(1)}x_2 + \Theta_{23}^{(1)}x_3)\\<br>a_3^{(2)} = g(\Theta_{30}^{(1)}x_0 + \Theta_{31}^{(1)}x_1 + \Theta_{32}^{(1)}x_2 + \Theta_{33}^{(1)}x_3)<br>\end{split}<br>$$<br>对 Layer 2 中的所有激活单元应用激活函数，从而得到输出：</p>
<p>$h_\Theta(x) = a_1^{(3)} = g(\Theta_{10}^{(2)}a_0^{(2)} + \Theta_{11}^{(2)}a_1^{(2)} + \Theta_{12}^{(2)}a_2^{(2)} + \Theta_{13}^{(2)}a_3^{(2)})$</p>
<p>上面的计算过程被称为<strong>前向传播（Forward propagation）</strong>，即从输入层开始，一层一层地向下计算并传递结果。</p>
<p>再回顾一下逻辑回归：</p>
<p>${h_\theta}\left( x \right)=g\left( {\theta_0}+{\theta_1}{x_1}+{\theta_{2} }{x_{2} }+{\theta_{3} }x_3 \right)$</p>
<p>是不是除了符号表示，其他都完全一样？其实神经网络就好似回归模型，只不过输入变成了中间单元 $a_1^{(j)}, a_2^{(j)}, \dots, a_n^{(j)}$。从输入 $x$ 开始，下一层的每个激活单元都包含了上一层的所有信息（单元值），通过最优化算法不断迭代计算，激活单元能得出关于输入 $x$ 的更多信息，这就好像是在给假设函数加多项式。隐藏层的这些单元好似升级版的初始特征，从而能给出更好的预测。</p>
<p><strong>向量化实现</strong></p>
<p>定义 $a^{(1)}=x=\left[ \begin{matrix}x_0\\ x_1 \\ x_2 \\ x_3 \end{matrix} \right]$，$\Theta^{(1)}=\left[\begin{matrix}\Theta^{(1)}_{10}&amp; \Theta^{(1)}_{11}&amp; \Theta^{(1)}_{12}&amp; \Theta^{(1)}_{13}\\ \Theta^{(1)}_{20}&amp; \Theta^{(1)}_{21}&amp; \Theta^{(1)}_{22}&amp; \Theta^{(1)}_{23}\\ \Theta^{(1)}_{30}&amp; \Theta^{(1)}_{31}&amp; \Theta^{(1)}_{32} &amp; \Theta^{(1)}_{33}\end{matrix}\right]$，</p>
<p>$\begin{split}a_1^{(2)} = g(z_1^{(2)}) \\ a_2^{(2)} = g(z_2^{(2)}) \newline a_3^{(2)} = g(z_3^{(2)}) \newline \end{split}$，$z^{(2)}=\left[ \begin{matrix}z_1^{(2)}\\ z_1^{(2)} \\ z_1^{(2)}\end{matrix} \right]$</p>
<p>则有 $a^{(2)}= g(\Theta^{(1)}a^{(1)})=g(z^{(2)})$</p>
<p>预测结果即 $h_\Theta(x) = a^{(3)} = g(\Theta^{(2)}a^{(2)}) = g(z^{(3)})$</p>
<p>即有 $z^{(j)}_i = \Theta^{(j-1)}_{i,0}a^{(j-1)}_{0}+ \Theta^{(j-1)}_{i,1}a^{(j-1)}_{1}+\dots+ \Theta^{(j-1)}_{i,n}a^{(j-1)}_{n}$，</p>
<p> $z^{(j)} = \Theta^{(j-1)}a^{(j-1)}$，$a^{(j)} = g(z^{(j)})$，通过该式即可计算神经网络中每一层的值。</p>
<p>扩展到所有样本实例：</p>
<p>${ {z}^{\left( 2 \right)} }={ {\Theta }^{\left( 1 \right)} } { {X}^{T} }$，这时 $z^{(2)}$ 是一个 $s_2 \times m$ 维矩阵。</p>
<blockquote>
<p>$m$: 训练集中的样本实例数量</p>
<p>$s_2$: 第二层神经网络中激活单元的数量</p>
</blockquote>
<p>当然，神经网络可有多层，每层的激活单元数量也并不固定：</p>
<img src="/2024/04/22/13-37-13/20180116_105545.png" class="">
<blockquote>
<p>我们习惯于将输入层称为神经网络的第 0 层，如上图的神经网络被称为三层网络。</p>
</blockquote>
<h2 id="8-5-例子和直观理解1（Examples-and-Intuitions-I）"><a href="#8-5-例子和直观理解1（Examples-and-Intuitions-I）" class="headerlink" title="8.5 例子和直观理解1（Examples and Intuitions I）"></a>8.5 例子和直观理解1（Examples and Intuitions I）</h2><p>为了更好的理解神经网络，举例单层神经网络进行逻辑运算的例子。</p>
<p>下面的例子中，$x_1,x_2$ 为二进制数。</p>
<p>逻辑与（AND）运算（都为真值则结果才为真）神经网络：</p>
<img src="/2024/04/22/13-37-13/20180117_000612.png" class="">
<p>$\Theta^{(1)} =\begin{bmatrix}-30 &amp; 20 &amp; 20\end{bmatrix}$，$h_\Theta(x) = g(-30+20x_1+20x_2)$。</p>
<p>回顾 sigmoid 函数图像，根据输入则有上图中右边的表格，即 $h_\theta(x)\approx x_1\ \text{AND}\ x_2$。这样就实现了一个能够进行与运算的神经网络。 </p>
<img src="/2024/04/22/13-37-13/2413fbec8ff9fa1f19aaf78265b8a33b_Logistic_function.png" class="">
<p>再举一例，逻辑或（OR）运算（有一个真值则结果就为真）神经网络：</p>
<img src="/2024/04/22/13-37-13/20180117_000349.png" class="">
<h2 id="8-6-例子和直观理解2（Examples-and-Intuitions-II）"><a href="#8-6-例子和直观理解2（Examples-and-Intuitions-II）" class="headerlink" title="8.6 例子和直观理解2（Examples and Intuitions II）"></a>8.6 例子和直观理解2（Examples and Intuitions II）</h2><p>下面逐步构建复杂一点的神经网络</p>
<img src="/2024/04/22/13-37-13/20180117_004820.png" class="">
<p>如上图，我们分别构建了三个单层神经网络，将这三个网络组合起来，可得到一个新的神经网络，其可完成逻辑运算中的异或（XNOR）操作：</p>
<img src="/2024/04/22/13-37-13/20180116_235545.png" class="">
<p>这里的组合即为 $\text{XNOR}=( \text{x}_1\, \text{AND}\, \text{x}_2 )\, \text{OR} \left( \left( \text{NOT}\, \text{x}_1 \right) \text{AND} \left( \text{NOT}\, \text{x}_2 \right) \right)$</p>
<p>$\Theta^{(1)} =\begin{bmatrix}-30 &amp; 20 &amp; 20 \newline 10 &amp; -20 &amp; -20\end{bmatrix}$，$\Theta^{(2)} =\begin{bmatrix}-10 &amp; 20 &amp; 20\end{bmatrix}$，$\begin{split}&amp; a^{(2)} = g(\Theta^{(1)} \cdot x) \newline&amp; a^{(3)} = g(\Theta^{(2)} \cdot a^{(2)}) \newline&amp; h_\Theta(x) = a^{(3)}\end{split}$</p>
<p>可见，特征值能不断升级，并抽取出更多信息，直到计算出结果。而如此不断组合，我们就可以逐渐构造出越来越复杂、强大的神经网络，比如用于手写识别的神经网络。</p>
<h2 id="8-7-多类别分类（Multiclass-Classification）"><a href="#8-7-多类别分类（Multiclass-Classification）" class="headerlink" title="8.7 多类别分类（Multiclass Classification）"></a>8.7 多类别分类（Multiclass Classification）</h2><p>之前讨论的都是预测结果为单值情况下的神经网络，要实现多类别分类，其实只要修改一下输出层，让输出层包含多个输出单元即可。</p>
<p>举一个 4 分类问题的实例：</p>
<img src="/2024/04/22/13-37-13/20180117_010904.png" class="">
<p>有四种分类情况，那么就让输出层包含 4 个输出单元即可，则 $h_\Theta$ 为 4 维向量。 </p>
<p>神经网络中的多分类算法算是对 one-vs-all 思想的扩展，定义预测结果一共有 4 种情况：</p>
<img src="/2024/04/22/13-37-13/20180117_011331.png" class="">
<p>如果预测结果 $h_\Theta(x) =\begin{bmatrix}0 \newline 0 \newline 1 \newline 0 \newline\end{bmatrix}$，那么表示 $h_\Theta(x)_3$，即分为第 3 类，对应于图中的摩托车（Motorcycle）。</p>
<p><strong>总结一下</strong></p>
<p>多分类问题，要分为 $K$ 类，就在输出层放置 $K$ 个输出单元，对于单个样本实例，预测向量 $h_\Theta(x)$ 为 $K$ 维向量，我们则依据这个预测向量，得出该实例属于哪个类 $y^{(i)}$。注意，神经网络中的预测和结果都是 $K$ 维向量，而不再只是一个实数了。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习, 深度学习, 吴恩达</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习笔记三 多变量线性回归</title>
    <url>/2024/04/22/13-37-10/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.04.22：初稿</li>
</ul>
<h1 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h1><ul>
<li><a href="/2024/04/18/15-40-33/" title="机器笔记汇总">吴恩达机器学习 - 笔记汇总</a>
</li>
</ul>
<h1 id="6-逻辑回归（Logistic-Regression）"><a href="#6-逻辑回归（Logistic-Regression）" class="headerlink" title="6 逻辑回归（Logistic Regression）"></a>6 逻辑回归（Logistic Regression）</h1><h2 id="6-1-分类（Classification）"><a href="#6-1-分类（Classification）" class="headerlink" title="6.1 分类（Classification）"></a>6.1 分类（Classification）</h2><p>在分类问题中，预测的结果是离散值（结果是否属于某一类），逻辑回归算法（Logistic Regression）被用于解决这类分类问题。</p>
<ul>
<li>垃圾邮件判断</li>
<li>金融欺诈判断</li>
<li>肿瘤诊断</li>
</ul>
<p>讨论肿瘤诊断问题：</p>
<img src="/2024/04/22/13-37-10/20180109_144040.png" class="">
<p>肿瘤诊断问题的目的是告诉病人<strong>是否</strong>为恶性肿瘤，是一个<strong>二元分类问题（binary class problems）</strong>，则定义 $ y \in\lbrace 0, 1\rbrace$，其中 0 表示<strong>负向类（negative class）</strong>，代表恶性肿瘤（”-“），1 为<strong>正向类（positive class）</strong>，代表良性肿瘤（”+”）。如图，定义最右边的样本为<strong>偏差项</strong>。</p>
<p>在未加入偏差项时，线性回归算法给出了品红色的拟合直线，若规定</p>
<p>$h_\theta(x) \geqslant 0.5$ ，预测为 $y = 1$，即正向类；</p>
<p>$h_\theta(x) \lt 0.5$ ，预测为 $y = 0$，即负向类。</p>
<p>即以 0.5 为<strong>阈值（threshold）</strong>，则我们就可以根据线性回归结果，得到相对正确的分类结果 $y$。</p>
<p>接下来加入偏差项，线性回归算法给出了靛青色的拟合直线，如果阈值仍然为 0.5，可以看到算法在某些情况下会给出完全错误的结果的。</p>
<p>不仅如此，线性回归算法的值域为全体实数集（$h_\theta(x) \in R$）</p>
<p>逻辑回归算法是一个分类算法，<strong>其输出值永远在 0 到 1 之间</strong>，即 $h_\theta(x) \in (0,1)$。</p>
<h2 id="6-2-假设函数表示（Hypothesis-Representation"><a href="#6-2-假设函数表示（Hypothesis-Representation" class="headerlink" title="6.2 假设函数表示（Hypothesis Representation"></a>6.2 假设函数表示（Hypothesis Representation</h2><p>为了使 $h_\theta(x) \in \left(0, 1\right)$，引入逻辑回归模型，定义假设函数<br>$$<br>h_\theta \left( x \right)=g(z)=g\left(\theta^{T}x \right)<br>$$<br>对比线性回归函数 $h_\theta \left( x \right)=\theta^{T}x$，$g$ 表示逻辑函数logistic function，复合起来，则称为逻辑回归函数。</p>
<p>逻辑函数是 S 形函数，会将所有实数映射到 $(0, 1)$ 范围。</p>
<p>sigmoid 函数（如下图）是逻辑函数的特殊情 况，其公式为 $g\left( z \right)=\frac{1}{1+{ {e}^{-z} } }$。 </p>
<img src="/2024/04/22/13-37-10/2413fbec8ff9fa1f19aaf78265b8a33b_Logistic_function.png" class="">
<p>应用 sigmoid 函数，则逻辑回归模型：$$h_{\theta}(x)=g(\theta^Tx) =\frac{1}{1+e^{-\theta^Tx} }$$</p>
<p>逻辑回归模型中，$h_\theta \left( x \right)$ 的作用是，根据输入 $x$ 以及参数 $\theta$，计算得出”输出 $y=1$“的可能性（estimated probability），概率学中表示为：</p>
<p>$$<br>\begin{split}<br>&amp; h_\theta(x) = P(y=1 | x ; \theta) = 1 - P(y=0 | x ; \theta) \\<br>&amp; P(y = 0 | x;\theta) + P(y = 1 | x ; \theta) = 1<br>\end{split}<br>$$<br>以肿瘤诊断为例，$h_\theta \left( x \right)=0.7$ 表示病人有 $70\%$ 的概率得了恶性肿瘤。</p>
<h2 id="6-3-决策边界（Decision-Boundary）"><a href="#6-3-决策边界（Decision-Boundary）" class="headerlink" title="6.3 决策边界（Decision Boundary）"></a>6.3 决策边界（Decision Boundary）</h2><p>决策边界的概念，可帮助我们更好地理解逻辑回归模型的拟合原理。</p>
<p>在逻辑回归中，有假设函数 $h_\theta \left( x \right)=g(z)=g\left(\theta^{T}x \right)$。</p>
<p>为了得出分类的结果，这里和前面一样，规定以 $0.5$ 为阈值：</p>
<p>$$<br>\begin{split}<br>&amp; h_\theta(x) \geq 0.5 \rightarrow y = 1 \\<br>&amp; h_\theta(x) &lt; 0.5 \rightarrow y = 0 \\<br>\end{split}<br>$$<br>回忆一下 sigmoid 函数的图像：</p>
<img src="/2024/04/22/13-37-10/2413fbec8ff9fa1f19aaf78265b8a33b_Logistic_function.png" class="">
<p>观察可得当 $g(z) \geq 0.5$ 时，有 $z \geq 0$，即 $\theta^Tx \geq 0$。</p>
<p>同线性回归模型的不同点在于：<br>$$<br>\begin{split}<br>z \to +\infty, e^{-\infty} \to 0 \Rightarrow g(z)=1 \\<br>z \to -\infty, e^{\infty}\to \infty \Rightarrow g(z)=0<br>\end{split}<br>$$<br>直观一点来个例子，${h_\theta}\left( x \right)=g\left( {\theta_0}+{\theta_1}{x_1}+{\theta_{2} }{x_{2} }\right)$ 是下图模型的假设函数：</p>
<img src="/2024/04/22/13-37-10/20180111_000814.png" class="">
<p>根据上面的讨论，要进行分类，那么只要 $ {\theta_0}+{\theta_1}{x_1}+{\theta_{2} }{x_{2} }\geq0$ 时，就预测 $y = 1$，即预测为正向类。</p>
<p>如果取 $\theta = \begin{bmatrix} -3\\1\\1\end{bmatrix}$，则有 $z = -3+{x_1}+{x_2}$，当 $z \geq 0$ 即 ${x_1}+{x_2} \geq 3$ 时，易绘制图中的品红色直线即<strong>决策边界</strong>，为正向类（以红叉标注的数据）给出 $y=1$ 的分类预测结果。</p>
<p>上面讨论了逻辑回归模型中线性拟合的例子，下面则是一个多项式拟合的例子，和线性回归中的情况也是类似的。</p>
<p>为了拟合下图数据，建模多项式假设函数：</p>
<p>$$<br>{h_\theta}\left( x \right)=g\left( {\theta_0}+{\theta_1}{x_1}+{\theta_{2} }{x_{2} }+{\theta_{3} }x_{1}^{2}+{\theta_{4} }x_{2}^{2} \right)<br>$$<br>这里取 $\theta = \begin{bmatrix} -1\\0\\0\\1\\1\end{bmatrix}$，决策边界对应了一个在原点处的单位圆（${x_1}^2+{x_2}^2 = 1$），如此便可给出分类结果，如图中品红色曲线：</p>
<img src="/2024/04/22/13-37-10/20180111_000653.png" class="">
<p>当然，通过一些更为复杂的多项式，还能拟合那些图像显得非常怪异的数据，使得决策边界形似碗状、爱心状等等。</p>
<p>简单来说，决策边界就是<strong>分类的分界线</strong>。</p>
<h2 id="6-4-代价函数（Cost-Function）"><a href="#6-4-代价函数（Cost-Function）" class="headerlink" title="6.4 代价函数（Cost Function）"></a>6.4 代价函数（Cost Function）</h2><p>那我们怎么知道决策边界是啥样？$\theta$ 多少时能很好的拟合数据？当然，见招拆招，总要来个 $J(\theta)$。</p>
<p>如果直接套用线性回归的代价函数： $J\left( {\theta} \right)=\frac{1}{2m}\sum\limits_{i=1}^{m}{ { {\left( h_{\theta} \left({x}^{\left( i \right)} \right)-{y}^{\left( i \right)} \right)}^{2} } }$</p>
<p>其中 $h_\theta(x) = g\left(\theta^{T}x \right)$，可绘制关于 $J(\theta)$ 的图像，如下图</p>
<img src="/2024/04/22/13-37-10/20180111_080314.png" class="">
<p><strong>同济高数教材关于凸函数的定义是反的</strong><br>回忆线性回归中的平方损失函数，其是一个二次凸函数（碗状），二次凸函数的重要性质是只有一个局部最小点即全局最小点。上图中有许多局部最小点，这样将使得梯度下降算法无法确定收敛点是全局最优。</p>
<img src="/2024/04/22/13-37-10/20180111_080514.png" class="">
<p>如果此处的损失函数也是一个凸函数，是否也有同样的性质，从而最优化？这类讨论凸函数最优值的问题，被称为<strong>凸优化问题（Convex optimization）</strong>。</p>
<p>当然，损失函数不止平方损失函数一种。</p>
<p>对于逻辑回归，更换平方损失函数为<strong>对数损失函数</strong>，可由统计学中的最大似然估计方法推出代价函数 $J(\theta)$：</p>
<p>$$<br>\begin{split}<br>&amp; J(\theta) = \dfrac{1}{m} \sum_{i=1}^m \mathrm{Cost}(h_\theta(x^{(i)}),y^{(i)}) \\<br>&amp; \mathrm{Cost}(h_\theta(x),y) = -\log(h_\theta(x)) \; &amp; \text{if y = 1} \\<br>&amp; \mathrm{Cost}(h_\theta(x),y) = -\log(1-h_\theta(x)) \; &amp; \text{if y = 0}<br>\end{split}<br>$$<br>则有关于 $J(\theta)$ 的图像如下：</p>
<img src="/2024/04/22/13-37-10/20180111_080614.png" class="">
<p>如左图，当训练集的结果为 $y=1$（正样本）时，随着假设函数趋向于 $1$，代价函数的值会趋于 $0$，即意味着拟合程度很好。如果假设函数此时趋于 $0$，则会给出一个<strong>很高的代价</strong>，拟合程度<strong>差</strong>，算法会根据其迅速纠正 $\theta$ 值，右图 $y=0$ 同理。</p>
<p>区别于平方损失函数，对数损失函数也是一个凸函数，但没有局部最优值。</p>
<h2 id="6-5-简化的成本函数和梯度下降（Simplified-Cost-Function-and-Gradient-Descent）"><a href="#6-5-简化的成本函数和梯度下降（Simplified-Cost-Function-and-Gradient-Descent）" class="headerlink" title="6.5 简化的成本函数和梯度下降（Simplified Cost Function and Gradient Descent）"></a>6.5 简化的成本函数和梯度下降（Simplified Cost Function and Gradient Descent）</h2><p>不分类讨论，对于二元分类问题，我们可把代价函数<strong>简化</strong>为一个函数：<br>$Cost\left( {h_\theta}\left( x \right),y \right)=-y\times log\left( {h_\theta}\left( x \right) \right)-(1-y)\times log\left( 1-{h_\theta}\left( x \right) \right)$</p>
<p>成本函数：<br>$J(\theta) = - \frac{1}{m} \displaystyle \sum_{i=1}^m [y^{(i)}\log (h_\theta (x^{(i)})) + (1 - y^{(i)})\log (1 - h_\theta(x^{(i)}))]$</p>
<p>向量化实现：$J(\theta)$应该是一个对角线矩阵</p>
<p>$h = g(X\theta)$，$J(\theta) = \frac{1}{m} \cdot \left(-y^{T}\log(h)-(1-y)^{T}\log(1-h)\right)$</p>
<p>为了最优化 $\theta$，仍使用梯度下降法，算法同线性回归中一致：</p>
<p>$$<br>\begin{split}<br>&amp; \text{Repeat until convergence:} \; \lbrace \\<br>&amp;{ {\theta }_{j} }:={ {\theta }_{j} }-\alpha \frac{\partial }{\partial { {\theta }_{j} } }J\left( {\theta}  \right) \\<br>\rbrace<br>\end{split}<br>$$</p>
<p>解出偏导得：</p>
<p>$$<br>\begin{split}<br>&amp; \text{Repeat until convergence:} \; \lbrace \\<br>&amp; \theta_j := \theta_j - \alpha \frac{1}{m} \sum\limits_{i=1}^{m} (h_\theta(x^{(i)}) - y^{(i)}) \cdot x_j^{(i)} \; &amp; \text{for j := 0,1…n}\\<br>\rbrace<br>\end{split}<br>$$</p>
<p>注意，虽然形式上梯度下降算法同线性回归一样，但其中的假设函不同，即$h_\theta(x) = g\left(\theta^{T}x \right)$，不过求导后的结果也相同。</p>
<p>向量化实现：$\theta := \theta - \frac{\alpha}{m} X^{T} (g(X \theta ) - y)$</p>
<p><strong>逻辑回归中代价函数求导的推导过程：</strong><br>$$<br>J(\theta) = - \frac{1}{m} \displaystyle \sum_{i=1}^m [y^{(i)}\log (h_\theta (x^{(i)})) + (1 - y^{(i)})\log (1 - h_\theta(x^{(i)}))]<br>$$<br>令 $f(\theta) = { {y}^{(i)} }\log \left( {h_\theta}\left( { {x}^{(i)} } \right) \right)+\left( 1-{ {y}^{(i)} } \right)\log \left( 1-{h_\theta}\left( { {x}^{(i)} } \right) \right)$</p>
<p>以及, $h_\theta(x) = g(z)$，$g(z) = \frac{1}{1+e^{(-z)} }$，则</p>
<p>$$<br>\begin{split}<br>f(\theta) &amp;= { {y}^{(i)} }\log \left( \frac{1}{1+{ {e}^{-z} } } \right)+\left( 1-{ {y}^{(i)} } \right)\log \left( 1-\frac{1}{1+{ {e}^{-z} } } \right) \\<br>&amp;= -{ {y}^{(i)} }\log \left( 1+{ {e}^{-z} } \right)-\left( 1-{ {y}^{(i)} } \right)\log \left( 1+{ {e}^{z} } \right)<br>\end{split}<br>$$</p>
<p>以及，$z=\theta^Tx^{(i)}$，对 $\theta_j$ 求偏导，则没有 $\theta_j$ 的项求偏导即为 $0$，都消去，则得：</p>
<p>$$<br>\frac{\partial z}{\partial {\theta_{j} } }=\frac{\partial }{\partial {\theta_{j} } }\left( \theta^Tx^{(i)}  \right)=x^{(i)}_j<br>$$<br>所以有：</p>
<p>$$<br>\begin{split}<br>\frac{\partial }{\partial {\theta_{j} } }f\left( \theta  \right)&amp;=\frac{\partial }{\partial {\theta_{j} } }[-{ {y}^{(i)} }\log \left( 1+{ {e}^{-z} } \right)-\left( 1-{ {y}^{(i)} } \right)\log \left( 1+{ {e}^{z} } \right)] \\<br>&amp;=-{ {y}^{(i)} }\frac{\frac{\partial }{\partial {\theta_{j} } }\left(-z \right) e^{-z} }{1+e^{-z} }-\left( 1-{ {y}^{(i)} } \right)\frac{\frac{\partial }{\partial {\theta_{j} } }\left(z \right){e^{z} } }{1+e^{z} } \\<br>&amp;=-{ {y}^{(i)} }\frac{-x^{(i)}_je^{-z} }{1+e^{-z} }-\left( 1-{ {y}^{(i)} } \right)\frac{x^{(i)}_j}{1+e^{-z} } \\<br>&amp;=\left({ {y}^{(i)} }\frac{e^{-z} }{1+e^{-z} }-\left( 1-{ {y}^{(i)} } \right)\frac{1}{1+e^{-z} }\right)x^{(i)}_j \\<br>&amp;=\left({ {y}^{(i)} }\frac{e^{-z} }{1+e^{-z} }-\left( 1-{ {y}^{(i)} } \right)\frac{1}{1+e^{-z} }\right)x^{(i)}_j \\<br>&amp;=\left(\frac{ { {y}^{(i)} }(e^{-z}+1)-1}{1+e^{-z} }\right)x^{(i)}_j \\<br>&amp;={({ {y}^{(i)} }-\frac{1}{1+{ {e}^{-z} } })x_j^{(i)} } \\<br>&amp;={\left({ {y}^{(i)} }-{h_\theta}\left( { {x}^{(i)} } \right)\right)x_j^{(i)} } \\<br>&amp;=-{\left({h_\theta}\left( { {x}^{(i)} } \right)-{ {y}^{(i)} }\right)x_j^{(i)} }<br>\end{split}<br>$$</p>
<p>则可得代价函数的导数：</p>
<p>$$<br>\frac{\partial }{\partial {\theta_{j} } }J(\theta) = -\frac{1}{m}\sum\limits_{i=1}^{m}{\frac{\partial }{\partial {\theta_{j} } }f(\theta)}=\frac{1}{m} \sum\limits_{i=1}^{m} (h_\theta(x^{(i)}) - y^{(i)}) \cdot x_j^{(i)}<br>$$</p>
<h2 id="6-6-进阶优化（Advanced-Optimization）"><a href="#6-6-进阶优化（Advanced-Optimization）" class="headerlink" title="6.6 进阶优化（Advanced Optimization）"></a>6.6 进阶优化（Advanced Optimization）</h2><p>我们编写代码给出代价函数及其偏导数然后传入梯度下降算法中，接下来算法则会为我们最小化代价函数给出参数的最优解。这类算法被称为<strong>最优化算法（Optimization Algorithms）</strong>，梯度下降算法不是唯一的最小化算法。</p>
<p>一些最优化算法：</p>
<ul>
<li>梯度下降法（Gradient Descent）</li>
<li>共轭梯度算法（Conjugate gradient）</li>
<li>牛顿法和拟牛顿法（Newton’s method &amp; Quasi-Newton Methods）<ul>
<li>DFP算法</li>
<li>局部优化法（BFGS）</li>
<li>有限内存局部优化法（L-BFGS）</li>
</ul>
</li>
<li>拉格朗日乘数法（Lagrange multiplier）</li>
</ul>
<p>比较梯度下降算法：一些最优化算法虽然会更为复杂，难以调试，不过这些算法通常效率更高，并无需选择学习速率 $\alpha$。</p>
<p>Octave/Matlab 中对这类高级算法做了封装，易于调用。</p>
<p>假设有 $J(\theta) = (\theta_1-5)^2 + (\theta_2-5)^2$，要求参数 $\theta=\begin{bmatrix} \theta_1\\\theta_2\end{bmatrix}$的最优值。</p>
<p>下面为 Octave/Matlab 求解最优化问题的代码实例：</p>
<ol>
<li>创建一个函数以返回代价函数及其偏导数：</li>
</ol>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[jVal, gradient]</span> = <span class="title">costFunction</span><span class="params">(theta)</span></span></span><br><span class="line">  <span class="comment">% code to compute J(theta)</span></span><br><span class="line">  jVal=(theta(<span class="number">1</span>)<span class="number">-5</span>)^<span class="number">2</span>+(theta(<span class="number">2</span>)<span class="number">-5</span>)^<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">% code to compute derivative of J(theta)</span></span><br><span class="line">  gradient=<span class="built_in">zeros</span>(<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">  </span><br><span class="line">  gradient(<span class="number">1</span>)=<span class="number">2</span>*(theta(<span class="number">1</span>)<span class="number">-5</span>);</span><br><span class="line">  gradient(<span class="number">2</span>)=<span class="number">2</span>*(theta(<span class="number">2</span>)<span class="number">-5</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ol>
<li>将 <code>costFunction</code> 函数及所需参数传入最优化函数 <code>fminunc</code>，以求解最优化问题：</li>
</ol>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">options = optimset(<span class="string">&#x27;GradObj&#x27;</span>, <span class="string">&#x27;on&#x27;</span>, <span class="string">&#x27;MaxIter&#x27;</span>, <span class="number">100</span>);</span><br><span class="line">initialTheta = <span class="built_in">zeros</span>(<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">   [optTheta, functionVal, exitFlag] = fminunc(@costFunction, initialTheta, options);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>&#39;GradObj&#39;, &#39;on&#39;</code>: 启用梯度目标参数（则需要将梯度传入算法）</p>
<p><code>&#39;MaxIter&#39;, 100</code>: 最大迭代次数为 100 次</p>
<p><code>@xxx</code>: Octave/Matlab 中的函数指针</p>
<p><code>optTheta</code>: 最优化得到的参数向量</p>
<p><code>functionVal</code>: 引用函数最后一次的返回值</p>
<p><code>exitFlag</code>: 标记代价函数是否收敛</p>
</blockquote>
<p>注：Octave/Matlab 中可以使用 <code>help fminunc</code> 命令随时查看函数的帮助文档。</p>
<ol>
<li>返回结果</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">optTheta =</span><br><span class="line"></span><br><span class="line">     5</span><br><span class="line">     5</span><br><span class="line"></span><br><span class="line">functionVal = 0</span><br><span class="line"></span><br><span class="line">exitFlag = 1</span><br></pre></td></tr></table></figure>
<h2 id="6-7-多类别分类-一对多（Multiclass-Classification-One-vs-all）"><a href="#6-7-多类别分类-一对多（Multiclass-Classification-One-vs-all）" class="headerlink" title="6.7 多类别分类: 一对多（Multiclass Classification: One-vs-all）"></a>6.7 多类别分类: 一对多（Multiclass Classification: One-vs-all）</h2><p>一直在讨论二元分类问题，这里谈谈多类别分类问题（比如天气预报）。</p>
<img src="/2024/04/22/13-37-10/20180112_001720.png" class="">
<p>原理是，转化多类别分类问题为<strong>多个二元分类问题</strong>，这种方法被称为 One-vs-all。</p>
<p>正式定义：$h_\theta^{\left( i \right)}\left( x \right)=p\left( y=i|x;\theta  \right), i=\left( 1,2,3….k \right)$</p>
<blockquote>
<p>$h_\theta^{\left( i \right)}\left( x \right)$: 输出 $y=i$（属于第 $i$ 个分类）的可能性</p>
<p>$k$: 类别总数，如上图 $k=3$。</p>
</blockquote>
<p>注意多类别分类问题中 $h_\theta(x)$ 的结果不再只是一个实数而是一个向量，如果类别总数为 $k$，现在 $h_\theta(x)$ 就是一个 $k$ 维向量。</p>
<p>对于某个样本实例，需计算所有的 $k$ 种分类情况得到 $h_\theta(x)$，然后看分为哪个类别时预测输出的值最大，就说它输出属于哪个类别，即 $y = \mathop{\max}\limits_i\,h_\theta^{\left( i \right)}\left( x \right)$。</p>
<h1 id="7-正则化（Regularization）"><a href="#7-正则化（Regularization）" class="headerlink" title="7 正则化（Regularization）"></a>7 正则化（Regularization）</h1><h2 id="7-1-过拟合问题（The-Problem-of-Overfitting）"><a href="#7-1-过拟合问题（The-Problem-of-Overfitting）" class="headerlink" title="7.1 过拟合问题（The Problem of Overfitting）"></a>7.1 过拟合问题（The Problem of Overfitting）</h2><p>对于拟合的表现，可以分为三类情况：</p>
<ul>
<li><p><strong>欠拟合（Underfitting）</strong></p>
<p>无法很好的拟合训练集中的数据，预测值和实际值的误差很大，这类情况被称为欠拟合。拟合模型比较简单（特征选少了）时易出现这类情况。</p>
</li>
<li><p><strong>优良的拟合（Just right）</strong></p>
<p>不论是训练集数据还是不在训练集中的预测数据，都能给出较为正确的结果。</p>
</li>
<li><p><strong>过拟合（Overfitting）</strong></p>
<p>能很好甚至完美拟合训练集中的数据，即 $J(\theta) \to 0$，但是对于不在训练集中的<strong>新数据</strong>，预测值和实际值的误差会很大，<strong>泛化能力弱</strong>，这类情况被称为过拟合。拟合模型过于复杂（特征选多了）时易出现这类情况。</p>
</li>
</ul>
<p>线性模型中的拟合情况（左图欠拟合，右图过拟合）：<br><img src="/2024/04/22/13-37-10/20180112_091654.png" class=""></p>
<p>逻辑分类模型中的拟合情况：<br><img src="/2024/04/22/13-37-10/20180112_092027.png" class=""></p>
<p>为了度量拟合表现，引入：</p>
<ul>
<li><p>偏差（bias）</p>
<p>指模型的预测值与真实值的<strong>偏离程度</strong>。偏差越大，预测值偏离真实值越厉害。偏差低意味着能较好地反应训练集中的数据情况。</p>
</li>
<li><p>方差（Variance）</p>
<p>指模型预测值的<strong>离散程度或者变化范围</strong>。方差越大，数据的分布越分散，函数波动越大，泛化能力越差。方差低意味着拟合曲线的稳定性高，波动小。</p>
</li>
</ul>
<p>据此，我们有对同一数据的各类拟合情况如下图：<br><img src="/2024/04/22/13-37-10/20180112_085630.png" class=""></p>
<p>据上图，高偏差意味着欠拟合，高方差意味着过拟合。</p>
<p>我们应尽量使得拟合模型处于低方差（较好地拟合数据）状态且同时处于低偏差（较好地预测新值）的状态。</p>
<p>避免过拟合的方法有：</p>
<ul>
<li>减少特征的数量<ul>
<li>手动选取需保留的特征</li>
<li>使用模型选择算法来选取合适的特征（如 PCA 算法）</li>
<li>减少特征的方式易丢失有用的特征信息</li>
</ul>
</li>
<li>正则化（Regularization）<ul>
<li>可保留所有参数（许多有用的特征都能轻微影响结果）</li>
<li>减少/惩罚各参数大小（magnitude），以减轻各参数对模型的影响程度</li>
<li>当有很多参数对于模型只有轻微影响时，正则化方法的表现很好</li>
</ul>
</li>
</ul>
<h2 id="7-2-代价函数（Cost-Function）"><a href="#7-2-代价函数（Cost-Function）" class="headerlink" title="7.2 代价函数（Cost Function）"></a>7.2 代价函数（Cost Function）</h2><p>很多时候由于特征数量过多，过拟合时我们很难选出要保留的特征，这时候应用正则化方法则是很好的选择。</p>
<p>上文中，$\theta_0 + \theta_1x + \theta_2x^2 + \theta_3x^3 + \theta_4x^4$ 这样一个复杂的多项式较易过拟合，在不减少特征的情况下，<strong>如果能消除类似于 $\theta_3x^3$、$\theta_4x^4$ 等复杂部分，那复杂函数就变得简单了</strong>。</p>
<p>为了保留各个参数的信息，不修改假设函数，改而修改代价函数：</p>
<ul>
<li>消除方式为如果使代价函数足够小，$\lambda$等于1000时，$\theta_3$就需要约等于0，消除了这个特征的影响。</li>
</ul>
<p>$$<br>min_\theta\ \dfrac{1}{2m}\sum_{i=1}^m (h_\theta(x^{(i)}) - y^{(i)})^2 + 1000\cdot\theta_3^2 + 1000\cdot\theta_4^2<br>$$</p>
<p>上式中，我们在代价函数中增加了 $\theta_3$、$\theta_4$ 的惩罚项（penalty term）$1000\cdot\theta_3^2 + 1000\cdot\theta_4^2$，如果要最小化代价函数，那么势必需要极大地<strong>减小 $\theta_3$、$\theta_4$</strong>，从而使得假设函数中的 $\theta_3x^3$、$\theta_4x^4$ 这两项的参数非常小，就相当于没有了，假设函数也就<strong>变得简单</strong>了，从而在保留各参数的情况下避免了过拟合问题。</p>
<img src="/2024/04/22/13-37-10/20180114_090054.png" class="">
<p>根据上面的讨论，有时也无法决定要减少哪个参数，故统一惩罚除了 $\theta_0$ 外的所有参数。</p>
<p>代价函数：</p>
<p>$$<br>J\left( \theta  \right)=\frac{1}{2m}[\sum\limits_{i=1}^{m}{ { {({h_\theta}({ {x}^{(i)} })-{ {y}^{(i)} })}^{2} }+\lambda \sum\limits_{j=1}^{n}{\theta_{j}^{2} }]}<br>$$</p>
<blockquote>
<p>$\lambda$: 正则化参数（Regularization Parameter），$\lambda &gt; 0$</p>
<p>$\sum\limits_{j=1}^{n}$: 不惩罚基础参数 $\theta_0$</p>
<p>$\lambda \sum\limits_{j=1}^{n}{\theta_{j}^{2} }$: 正则化项</p>
</blockquote>
<p>$\lambda$ 正则化参数类似于学习速率，也需要我们自行对其选择一个合适的值。</p>
<ul>
<li>过大<ul>
<li>导致模型欠拟合（假设可能会变成近乎 $x = \theta_0$ 的直线）</li>
<li>无法正常去过拟问题</li>
<li>梯度下降可能无法收敛</li>
</ul>
</li>
<li>过小<ul>
<li>无法避免过拟合（等于没有）</li>
</ul>
</li>
</ul>
<blockquote>
<p>正则化符合奥卡姆剃刀（Occam’s razor）原理。在所有可能选择的模型中，能够很好地解释已知数据并且十分简单才是最好的模型，也就是应该选择的模型。从贝叶斯估计的角度来看，正则化项对应于模型的先验概率。可以假设复杂的模型有较大的先验概率，简单的模型有较小的先验概率。</p>
<p>正则化是结构风险最小化策略的实现，是去过拟合问题的典型方法，虽然看起来多了个一参数多了一重麻烦，后文会介绍自动选取正则化参数的方法。模型越复杂，正则化参数值就越大。比如，正则化项可以是模型参数向量的范数。</p>
</blockquote>
<h2 id="7-3-线性回归正则化（Regularized-Linear-Regression）"><a href="#7-3-线性回归正则化（Regularized-Linear-Regression）" class="headerlink" title="7.3 线性回归正则化（Regularized Linear Regression）"></a>7.3 线性回归正则化（Regularized Linear Regression）</h2><p>应用正则化的线性回归梯度下降算法：</p>
<p>$$<br>\begin{split}<br>&amp; \text{Repeat}\ \lbrace \\<br>&amp; \ \ \ \ \theta_0 := \theta_0 - \alpha\ \frac{1}{m}\ \sum_{i=1}^m (h_\theta(x^{(i)}) - y^{(i)})x_0^{(i)} \\<br>&amp; \ \ \ \ \theta_j := \theta_j - \alpha\ \left[ \left( \frac{1}{m}\ \sum_{i=1}^m (h_\theta(x^{(i)}) - y^{(i)})x_j^{(i)} \right) + \frac{\lambda}{m}\theta_j \right], \ \ \ j \in \lbrace 1,2…n\rbrace\\<br>&amp; \rbrace<br>\end{split}<br>$$<br>也可以移项得到更新表达式的另一种表示形式</p>
<p>$$<br>\theta_j := \theta_j(1 - \alpha\frac{\lambda}{m}) - \alpha\frac{1}{m}\sum_{i=1}^m(h_\theta(x^{(i)}) - y^{(i)})x_j^{(i)}<br>$$</p>
<blockquote>
<p>$\frac{\lambda}{m}\theta_j$: 正则化项</p>
</blockquote>
<p>应用正则化的正规方程法：</p>
<p>$$<br>\begin{split}<br>&amp; \theta = \left( X^TX + \lambda \cdot L \right)^{-1} X^Ty \\<br>&amp; \text{where}\ \ L = \begin{bmatrix} 0 &amp; &amp; &amp; &amp; \\<br>&amp; 1 &amp; &amp; &amp; \\<br>&amp; &amp; 1 &amp; &amp; \\<br>&amp; &amp; &amp; \ddots &amp; \\<br>&amp; &amp; &amp; &amp; 1 \\ \end{bmatrix}<br>\end{split}<br>$$</p>
<blockquote>
<p>$\lambda\cdot L$: 正则化项</p>
<p>$L$: 第一行第一列为 $0$ 的 $n+1$ 维单位矩阵</p>
</blockquote>
<p>Octave 代码：<br><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; L = <span class="built_in">eye</span>(<span class="number">5</span>)</span><br><span class="line">&gt;&gt; L(<span class="number">1</span>,<span class="number">1</span>) = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">L =</span><br><span class="line"></span><br><span class="line">     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">1</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>前文提到正则化可以解决正规方程法中不可逆的问题，即增加了 $\lambda \cdot L$ 正则化项后，可以保证 $X^TX + \lambda \cdot L$ 可逆（invertible），即便 $X^TX$ 不可逆（non-invertible）。 </p>
<h2 id="7-4-逻辑回归正则化（Regularized-Logistic-Regression）"><a href="#7-4-逻辑回归正则化（Regularized-Logistic-Regression）" class="headerlink" title="7.4 逻辑回归正则化（Regularized Logistic Regression）"></a>7.4 逻辑回归正则化（Regularized Logistic Regression）</h2><p>为逻辑回归的代价函数添加正则化项：</p>
<p>$$<br>J(\theta) = - \frac{1}{m} \sum_{i=1}^m \large[ y^{(i)}\ \log (h_\theta (x^{(i)})) + (1 - y^{(i)})\ \log (1 - h_\theta(x^{(i)}))\large] + \frac{\lambda}{2m}\sum_{j=1}^n \theta_j^2<br>$$<br>前文已经证明过逻辑回归和线性回归的代价函数的求导结果是一样的，此处通过给正则化项添加常数 $\frac{1}{2}$，则其求导结果也就一样了。</p>
<p>从而有应用正则化的逻辑回归梯度下降算法：</p>
<p>$$<br>\begin{split}<br>&amp; \text{Repeat}\ \lbrace \\<br>&amp; \ \ \ \ \theta_0 := \theta_0 - \alpha\ \frac{1}{m}\ \sum_{i=1}^m (h_\theta(x^{(i)}) - y^{(i)})x_0^{(i)} \\<br>&amp; \ \ \ \ \theta_j := \theta_j - \alpha\ \left[ \left( \frac{1}{m}\ \sum_{i=1}^m (h_\theta(x^{(i)}) - y^{(i)})x_j^{(i)} \right) + \frac{\lambda}{m}\theta_j \right], \ \ \ j \in \lbrace 1,2…n\rbrace\\<br>&amp; \rbrace \end{split}<br>$$</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习, 深度学习, 吴恩达</tag>
      </tags>
  </entry>
  <entry>
    <title>机器笔记汇总</title>
    <url>/2024/04/18/15-40-33/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.04.18：初稿</li>
</ul>
<h1 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h1><ul>
<li><a href="/2024/04/18/15-34-48/" title="机器学习笔记一 单变量线性回归">机器学习笔记一 单变量线性回归</a></li>
<li><a href="/2024/04/21/07-10-14/" title="机器学习笔记二 多变量线性回归">机器学习笔记二 多变量线性回归</a></li>
<li><a href="/2024/04/22/13-37-10/" title="机器学习笔记三 多变量线性回归">机器学习笔记三 多变量线性回归</a></li>
<li><a href="/2024/04/22/13-37-13/" title="机器学习笔记四 神经网络的表达">机器学习笔记四 神经网络的表达</a></li>
<li><a href="/2024/04/23/12-43-40/" title="机器学习笔记五 神经网络的学习">机器学习笔记五 神经网络的学习</a>
</li>
</ul>
<blockquote>
<p>先学习一部分，之后遇到了再具体学习，暂停之后学习动手学深度学习。</p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习, 深度学习, 吴恩达</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习笔记五 神经网络的学习</title>
    <url>/2024/04/23/12-43-40/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.04.23：初稿</li>
</ul>
<h1 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h1><ul>
<li><a href="/2024/04/18/15-40-33/" title="机器笔记汇总">吴恩达机器学习 - 笔记汇总</a>
</li>
</ul>
<h1 id="9-神经网络-学习（Neural-Networks-Learning）"><a href="#9-神经网络-学习（Neural-Networks-Learning）" class="headerlink" title="9 神经网络: 学习（Neural Networks: Learning）"></a>9 神经网络: 学习（Neural Networks: Learning）</h1><h2 id="9-1-代价函数（Cost-Function）"><a href="#9-1-代价函数（Cost-Function）" class="headerlink" title="9.1 代价函数（Cost Function）"></a>9.1 代价函数（Cost Function）</h2><p>神经网络的分类问题有两种：</p>
<ul>
<li><p>二元分类问题（0/1分类）</p>
<p>只有一个输出单元（$K=1$）</p>
</li>
<li><p>多元（$K$）分类问题</p>
<p>输出单元不止一个（$K\gt1$）</p>
</li>
</ul>
<p>神经网络的代价函数公式：</p>
<p>$h_\Theta(x) = a^{(L)} = g(\Theta^{(L-1)}a^{(L-1)}) = g(z^{(L)})$</p>
<p>$$ \begin{split} J(\Theta) = - \frac{1}{m} \sum_{i=1}^m \sum_{k=1}^K \left[y^{(i)}_k \log ((h_\Theta (x^{(i)}))_k) + (1 - y^{(i)}_k)\log (1 - (h_\Theta(x^{(i)}))_k)\right] + \frac{\lambda}{2m}\sum_{l=1}^{L-1} \sum_{i=1}^{s_l} \sum_{j=1}^{s_{l+1} } ( \Theta_{j,i}^{(l)})^2\end{split}$$</p>
<blockquote>
<p>$L$: 神经网络的总层数</p>
<p>$s_l$: 第 $l$ 层激活单元的数量（不包含偏置单元）</p>
<p>$h_\Theta(x)_k$: 分为第 $k$ 个分类($k^{th}$)的概率 $P(y=k | x ; \Theta) $</p>
<p>$K$: 输出层的输出单元数量，即类数 - 1</p>
<p>$y_k^{(i)}$: 第 $i$ 个训练样本的第 $k$ 个分量值</p>
<p>$y$: $K$ 维向量</p>
</blockquote>
<p>对照下逻辑回归中的代价函数：</p>
<p>$$<br>J(\theta) = - \frac{1}{m} \sum_{i=1}^m [ y^{(i)}\ \log (h_\theta (x^{(i)})) + (1 - y^{(i)})\ \log (1 - h_\theta(x^{(i)}))] + \frac{\lambda}{2m}\sum_{j=1}^n \theta_j^2<br>$$</p>
<p>在神经网络的代价函数中，</p>
<ul>
<li>左边的变化实际上是为了求解 $K$ 分类问题，即公式会对每个样本特征都运行 $K$ 次，并依次给出分为第 $k$ 类的概率，$h_\Theta(x)\in \mathbb{R}^{K}, y \in \mathbb{R}^{K}$。</li>
<li>右边的正则化项比较容易理解，每一层有多维矩阵 $\Theta^{(l)}\in \mathbb{R}^{(s_l + 1)\times s_{l+1} }$，从左到右看这个三次求和式 $\sum\limits_{l=1}^{L-1}\sum\limits_{i=1}^{s_l}\sum\limits_{j=1}^{s_{l+1} }$ ，就是对每一层间的多维矩权重 $\Theta^{(l)}$ ，依次平方后求取其除了偏置权重部分的和值，并循环累加即得结果。</li>
</ul>
<blockquote>
<p>$\mathbb{R}^{m}$: 即 $m$ 维向量</p>
<p>$\mathbb{R}^{m\times n}$: 即 $m \times n$ 维矩阵</p>
</blockquote>
<p>再次可见，神经网络背后的思想是和逻辑回归一样的，但由于计算复杂，实际上神经网络的代价函数 $J(\Theta)$ 是一个非凸（non-convex）函数。</p>
<h2 id="9-2-反向传播算法（Backpropagation-Algorithm）"><a href="#9-2-反向传播算法（Backpropagation-Algorithm）" class="headerlink" title="9.2 反向传播算法（Backpropagation Algorithm）"></a>9.2 反向传播算法（Backpropagation Algorithm）</h2><p>类似于回归模型中的梯度下降算法，为了求解神经网络最优化问题，我们也要计算 $\frac{\partial}{\partial\Theta}J(\Theta)$，以此 $\underset{\Theta}{\text{minimize} }J(\Theta)$ 。</p>
<p>在神经网络中，代价函数看上去虽然不复杂，但要注意到其中 $h_\Theta(x)$ 的求取实际上是由前向传播算法求得，即需从输入层开始，根据每层间的权重矩阵 $\Theta$ 依次计算激活单元的值 $a$。 在最优化代价函数时，我们必然也需要最优化每一层的权重矩阵，再次强调一下，<strong>算法最优化的是权重，而不是输入</strong>。</p>

<p><strong>反向传播算法</strong>用于计算每一层权重矩阵的偏导 $\frac{\partial}{\partial\Theta}J(\Theta)$，算法实际上是对代价函数求导的拆解。</p>
<ol>
<li><p>对于给定训练集 $\lbrace (x^{(1)}, y^{(1)}) \cdots (x^{(m)}, y^{(m)})\rbrace$ ，初始化每层间的误差和矩阵 $\Delta$，即令所有的 $\Delta^{(l)}_{i,j}=0$，使得每个 $\Delta^{(l)}$ 为一个全零矩阵。</p>
</li>
<li><p>接下来遍历所有样本实例，对于每一个样本实例，有下列步骤：</p>
<ol>
<li><p>运行前向传播算法，得到初始预测 $a^{(L)}=h_\Theta(x)$ 。</p>
</li>
<li><p>运行反向传播算法，从输出层开始计算每一层预测的<strong>误差（error）</strong>，以此来求取偏导。</p>

<p>输出层的误差即为预测与训练集结果的之间的差值：$\delta^{(L)} = a^{(L)} - y$，</p>
<p>对于隐藏层中每一层的误差，都通过上一层的误差来计算：</p>
<p>$\delta^{(l)} = (\Theta^{(l)})^T\delta^{(l+1)} .*\ \frac{\partial a^{(l)} }{\partial z^{(l)} }\; \; \; \; \;  \text{for }l := L-1, L-2,\dots,2.$</p>
<p>隐藏层中，$a^{(l)}$ 即为增加偏置单元后的 $g(z^{(l)})$，$a^{(l)}$ 与 $\Theta^{(l)}$ 维度匹配，得以完成矩阵运算。</p>
<p>即对于隐藏层，有 $a^{(l)} = (g(z^{(l)})$ 添加偏置单元 $a^{(l)}_0 = 1)$</p>
<p>解得 $\frac{\partial}{\partial z^{(l)} }g(z^{(l)})=g’(z^{(l)})=g(z^{(l)}) .* \ (1-g(z^{(l)}))$，</p>
<p>则有 $\delta^{(l)} = (\Theta^{(l)})^T\delta^{(l+1)} .<em>\ a^{(l)} .</em>\ (1-a^{(l)}), \ \ a^{(l)}_0 = 1$。</p>
<blockquote>
<p>$\delta^{(l)}$ 求导前的公式不同于视频内容，经核实为视频内容错误。推导请阅下节。</p>
</blockquote>
<p>根据以上公式计算依次每一层的误差 $\delta^{(L)}, \delta^{(L-1)},\dots,\delta^{(2)}$。</p>
</li>
<li><p>依次求解并累加误差 $\Delta^{(l)}_{i,j} := \Delta^{(l)}_{i,j} + a_j^{(l)} \delta_i^{(l+1)}$，向量化实现即 $\Delta^{(l)} := \Delta^{(l)} + \delta^{(l+1)}(a^{(l)})^T$</p>
</li>
</ol>
</li>
<li><p>遍历全部样本实例，求解完 $\Delta$ 后，最后则求得偏导 $\frac \partial {\partial \Theta_{i,j}^{(l)} } J(\Theta)=D_{i,j}^{(l)}$</p>
<ul>
<li>$D^{(l)}_{i,j} := \dfrac{1}{m}\left(\Delta^{(l)}_{i,j} + \lambda\Theta^{(l)}_{i,j}\right)$, if $j\neq0$,</li>
<li>$D^{(l)}_{i,j} := \dfrac{1}{m}\Delta^{(l)}_{i,j}$, if $j=0$.（对应于偏置单元）</li>
</ul>
</li>
</ol>
<blockquote>
<p>$\delta^{(l)}$: 第 $l$ 层的误差向量</p>
<p>$\delta^{(l)}_i$: 第 $l$ 层的第 $i$ 个激活单元的误差</p>
<p>$\Delta^{(l)}_{i,j}$: 从第 $l$ 层的第 $j$ 个单元映射到第 $l+1$ 层的第 $i$ 个单元的权重代价的偏导（所有样本实例之和）</p>
<p>$D^{(l)}_{i,j}$: $\Delta^{(l)}_{i,j}$ 的样本均值与正则化项之和</p>
<p>注：无需计算 $\delta^{(1)}$，因为输入没有误差。</p>
</blockquote>
<p>这就是反向传播算法，即从输出层开始不断<strong>向前迭代</strong>，根据<strong>上一层</strong>的误差依次计算当前层的误差，以求得代价函数的偏导。</p>
<blockquote>
<p>应用反向传播（BP）算法的神经网络被称为 BP 网络，也称前馈网络（向前反馈）。</p>
</blockquote>
<p>《机器学习》一书中提到的 BP 网络强大之处：</p>
<blockquote>
<p>任何布尔函数都可由两层神经网络准确表达，但所需的中间单元的数量随输入呈指数级增长;</p>
<p>任何连续函数都可由两层神经网络以任意精度逼近;</p>
<p>任何函数都可由三层神经网络以任意程度逼近。</p>
</blockquote>
<h2 id="9-3-直观理解反向传播（Backpropagation-Intuition）"><a href="#9-3-直观理解反向传播（Backpropagation-Intuition）" class="headerlink" title="9.3 直观理解反向传播（Backpropagation Intuition）"></a>9.3 直观理解反向传播（Backpropagation Intuition）</h2><p>这节给出了反向传播算法中误差的数学意义：</p>
<p>$cost(t) =y^{(t)} \ \log (h_\Theta (x^{(t)})) + (1 - y^{(t)})\ \log (1 - h_\Theta(x^{(t)}))$</p>
<p>$\delta_j^{(l)} = \dfrac{\partial}{\partial z_j^{(l)} } cost(t)$</p>
<p>视频内容实际在上文都涉及到了，上节也做了解释：</p>
<blockquote>
<p>反向传播算法，即从输出层开始不断<strong>向前迭代</strong>，根据<strong>上一层</strong>的误差依次计算当前层的误差，以求得代价函数的偏导。</p>
</blockquote>
<p>前文提到输入层没有偏差，所以没有 $\delta^{(1)}$，同样的，偏置单元的值始终为 1，也没有误差，故一般会选择<strong>忽略偏置单元项的误差</strong>。</p>
<p><strong>神经网络中代价函数求导的推导过程</strong>：</p>
<p>代价函数无正则化项时：</p>
<p>$\begin{split} J(\Theta) = - \frac{1}{m} \sum_{i=1}^m \left[y^{(i)} \log ((h_\Theta (x^{(i)}))) + (1 - y^{(i)})\log (1 - (h_\Theta(x^{(i)})))\right] \end{split}$</p>
<p>再次的，为了方便起见，这里假设样本只有一个，则有：</p>
<p>$\begin{split} J(\Theta) = -\left[y \log ((h_\Theta (x))) + (1 - y)\log (1 - (h_\Theta(x)))\right] \end{split}$</p>
<p>忆及 $h_\Theta(x) = a^{(L)} = g(z^{(L)})$，$g(z) = \frac{1}{1+e^{(-z)} }$，代入后整理后可得：</p>
<p>$J(\Theta) ={y}\log \left( 1+{ {e}^{-z^{(L)} }} \right)+\left( 1-{y} \right)\log \left( 1+{ {e}^{z^{(L)} }} \right)$</p>

<p>再次为了便于计算，我们用到如上图这个三层（输入层一般不计数）神经网络。</p>
<p>忆及 $z^{(l)} = \Theta^{(l-1)}a^{(l-1)}$，我们有 $h_\Theta(x)=a^{(4)}= g(z^{(4)})=g(\Theta^{(3)}a^{(3)})$</p>
<p>观察考虑各变量与 $\Theta^{(3)}$ 之间的关系，有 $J(\Theta) \rightarrow  a^{(4)}\rightarrow z^{(4)}\rightarrow \Theta^{(3)}$</p>
<p>要计算 $J(\Theta)$ 的偏导，就要按照关系不断往前看，每一次回头看，就称为一次反向传播。</p>
<p>把回头看的关系说的“微积分一点”，那就是 $\Theta^{(3)}$ 的微小改变会引起 $z^{(4)}$ 的改变， $z^{(4)}$ 的微小改变会引起 $a^{(4)}$ 的改变，$a^{(4)}$ 的微小改变又会引起 $ J(\Theta)$ 的改变，关系方向也可以反过来写：$\Theta^{(3)} \rightarrow z^{(4)} \rightarrow a^{(4)} \rightarrow J(\Theta) $。</p>
<p>令 $\delta^{(l)} = \frac{\partial}{\partial z^{(l)} } J(\Theta)$，则有 $J(\Theta)$ 关于 $\Theta^{(3)}$ 的偏导：</p>
<p>$\frac{\partial}{\partial\Theta^{(3)} } J(\Theta) = \frac{\partial J(\Theta)}{\partial z^{(4)} }   \frac{\partial z^{(4)} }{\partial\Theta^{(3)} } = \delta^{(4)}\frac{\partial z^{(4)} }{\partial\Theta^{(3)} }$</p>
<p>再次忆及 $z^{(l)} = \Theta^{(l-1)}a^{(l-1)}$，则 $\frac{\partial z^{(4)} }{\partial\Theta^{(3)} } = a^{(3)}$</p>
<p>则对于输出层，我们证得 $\frac{\partial}{\partial\Theta^{(3)} } J(\Theta) =  a^{(3)}\delta^{(4)}$。</p>
<p>再次忆及 $g(z) = \frac{1}{1+e^{-z} }$，$a^{(L)}=g(z^{(L)})$</p>
<p>$\delta^{(4)}=\frac{\partial}{\partial z^{(4)} }J(\Theta)={ {y} }\frac{-e^{-z^{(4)} }}{1+e^{-z^{(4)} }}+\left( 1-{ {y} } \right)\frac{ {e^{z^{(4)} }} }{1+e^{z^{(4)} }} = g(z^{(4)}) - y = a^{(4)}-y$</p>
<p>即证得 $\delta^{(4)} = a^{(4)}-y$</p>
<p>对于任意的输出层 $L$ 及 $\Theta^{(L-1)}$，有 $J(\Theta) \rightarrow  a^{(L)}\rightarrow z^{(L)}\rightarrow \Theta^{(L-1)}$ 关系不变，故证得：<br>$$<br>\frac{\partial}{\partial\Theta^{(L-1)} } J(\Theta) =  a^{(L-1)}\delta^{(L)}, \ \ \delta^{(L)} = a^{(L)}-y<br>$$<br>好了，接下来来看一下 $J(\Theta)$ 关于 $\Theta^{(2)}$ 的偏导</p>
<p>仍然观察考虑各变量与 $\Theta^{(2)}$ 之间的关系，有 $J(\Theta)\rightarrow a^{(4)} \rightarrow z^{(4)} \rightarrow    a^{(3)} \rightarrow z^{(3)} \rightarrow\Theta^{(2)}$ </p>
<p>$\frac{\partial}{\partial \Theta^{(2)} }J(\Theta) = \frac{\partial J(\Theta)}{\partial z^{(3)} } \frac{\partial z^{(3)} }{\partial \Theta^{(2)} }=\delta^{(3)} \frac{\partial z^{(3)} }{\partial \Theta^{(2)} }=  a^{(2)}\delta^{(3)}$</p>
<p>$\delta^{(3)} = \frac{\partial}{\partial z^{(3)} }J(\Theta) =\frac{\partial J(\Theta)}{\partial z^{(4)} } \frac{\partial z^{(4)} }{\partial a^{(3)} }\frac{\partial a^{(3)} }{\partial z^{(3)} } = \delta^{(4)}\frac{\partial z^{(4)} }{\partial a^{(3)} }\frac{\partial a^{(3)} }{\partial z^{(3)} }$</p>
<p>易求得 $\frac{\partial z^{(4)} }{\partial a^{(3)} }=\Theta^{(3)}$</p>
<p>$g’(z) =\frac{e^{-z} }{(1+e^{-z})^2}=\frac{(1+e^{-z})-1}{(1+e^{-z})^2}=\frac{1}{1+e^{-z} }-\frac{1}{(1+e^{-z})^2}=g(z)(1-g(z))$</p>
<p>即 $g’(z^{(l)})=g(z^{(l)}) .* \ (1-g(z^{(l)}))$</p>
<p>有 $a^{(l)} = (g(z^{(l)})$ 添加偏置单元 $a^{(l)}_0 = 1)$，则 $\frac{\partial a^{(3)} }{\partial z^{(3)} }=a^{(3)} .*\ (1-a^{(3)})$，</p>
<blockquote>
<p>证明时为先求导后添加偏置单元，与前向传播算法顺序一致，实际实现时，求导和添加偏置单元的顺序可作调换，由于一般选择忽略偏置单元的误差，所以并不影响结果。</p>
</blockquote>
<p>即证得 $\delta^{(3)}=(\Theta^{(3)})^T\delta^{(4)}.*(a^{(3)})’=(\Theta^{(3)})^T\delta^{(4)}.*\ a^{(3)} .*\ (1-a^{(3)})$</p>
<p>对于任意的隐藏层 $l + 1$ 及权重矩阵 $\Theta^{(l)}$，有 $J(\Theta)\rightarrow a^{(L)} \rightarrow z^{(L)} \rightarrow \dots \rightarrow a^{(l+1)} \rightarrow z^{(l+1)} \rightarrow\Theta^{(l)}$ 关系不变，故证得：</p>
<p>$$<br>\frac{\partial}{\partial\Theta^{(l)} } J(\Theta) =  a^{(l)}\delta^{(l+1)}, \ \ \delta^{(l)} = (\Theta^{(l)})^T\delta^{(l+1)}.*\ a^{(l)} .*\ (1-a^{(l)})\; \; \; \; \;  \text{for }l := L-1, L-2,\dots,2.<br>$$</p>
<p>再添回为了计算方便去掉的 $\frac{1}{m}$ 和正则化项（时刻记住偏置单元不正则化）等，即可得上节中 $J(\Theta)$ 的偏导。</p>
<h2 id="9-4-实现注意点-参数展开（Implementation-Note-Unrolling-Parameters）"><a href="#9-4-实现注意点-参数展开（Implementation-Note-Unrolling-Parameters）" class="headerlink" title="9.4 实现注意点: 参数展开（Implementation Note: Unrolling Parameters）"></a>9.4 实现注意点: 参数展开（Implementation Note: Unrolling Parameters）</h2><p>在 Octave/Matlab 中，如果要使用类似于 <code>fminunc</code> 等高级最优化函数，其函数参数、函数返回值等都为且只为向量，而由于神经网络中的权重是多维矩阵，所以需要用到参数展开这个技巧。</p>
<p>说白了，这个技巧就是把多个矩阵转换为一个长长的向量，便于传入函数，之后再根据矩阵维度，转回矩阵即可。</p>
<p>Octave 代码：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 多个矩阵展开为一个向量</span></span><br><span class="line">Theta1 = <span class="built_in">ones</span>(<span class="number">11</span>, <span class="number">10</span>);    <span class="comment">% 创建维度为 11 * 10 的矩阵</span></span><br><span class="line">Theta2 = <span class="built_in">ones</span>(<span class="number">2</span>, <span class="number">4</span>) * <span class="number">2</span>;  <span class="comment">% 创建维度为 2 * 4 的矩阵</span></span><br><span class="line">ThetaVec = [Theta1(:); Theta2(:)]; <span class="comment">% 将上面两个矩阵展开为向量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 从一个向量重构还原回多个矩阵</span></span><br><span class="line">Theta1 = <span class="built_in">reshape</span>(ThetaVec(<span class="number">1</span>:<span class="number">110</span>), <span class="number">11</span>, <span class="number">10</span>)</span><br><span class="line">Theta2 = <span class="built_in">reshape</span>(ThetaVec(<span class="number">111</span>:<span class="number">118</span>), <span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment">% Theta2 = reshape(ThetaVec(111:(111 + 2 * 4) - 1), 2, 4)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>reshape(A,m,n)</code>: 将向量 A 重构为 m * n 维矩阵。</p>
</blockquote>
<h2 id="9-5-梯度检验（Gradient-Checking）"><a href="#9-5-梯度检验（Gradient-Checking）" class="headerlink" title="9.5 梯度检验（Gradient Checking）"></a>9.5 梯度检验（Gradient Checking）</h2><p>由于神经网络模型中的反向传播算法较为复杂，在小细节非常容易出错，从而无法得到最优解，故引入梯度检验。</p>
<p>梯度检验采用数值估算（Numerical estimation）梯度的方法，被用于验证反向传播算法的正确性。</p>

<p>把视 $\Theta$ 为一个实数，数值估算梯度的原理如上图所示，即有 $\dfrac{\partial}{\partial\Theta}J(\Theta) \approx \dfrac{J(\Theta + \epsilon) - J(\Theta - \epsilon)}{2\epsilon}$</p>
<p>其中，$\epsilon$ 为极小值，由于太小时容易出现数值运算问题，一般取 $10^{-4}$。</p>
<p>对于矩阵 $\Theta$，有 $\dfrac{\partial}{\partial\Theta_j}J(\Theta) \approx \dfrac{J(\Theta_1, \dots, \Theta_j + \epsilon, \dots, \Theta_n) - J(\Theta_1, \dots, \Theta_j - \epsilon, \dots, \Theta_n)}{2\epsilon}$</p>
<p>Octave 代码：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">epsilon = <span class="number">1e-4</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:n,</span><br><span class="line">  thetaPlus = theta;</span><br><span class="line">  thetaPlus(<span class="built_in">i</span>) += epsilon;</span><br><span class="line">  thetaMinus = theta;</span><br><span class="line">  thetaMinus(<span class="built_in">i</span>) -= epsilon;</span><br><span class="line">  gradApprox(<span class="built_in">i</span>) = (J(thetaPlus) - J(thetaMinus))/(<span class="number">2</span>*epsilon);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>在得出 gradApprox 梯度向量后，将其同之前计算的偏导 $D$ 比较，如果相等或很接近，即说明算法没有问题。</p>
<p>在确认算法<strong>没有问题后</strong>（一般只需运行一次），由于数值估计的梯度检验效率很低，所以一定要<strong>禁用它</strong>。</p>
<h2 id="9-6-随机初始化（Random-Initialization）"><a href="#9-6-随机初始化（Random-Initialization）" class="headerlink" title="9.6 随机初始化（Random Initialization）"></a>9.6 随机初始化（Random Initialization）</h2><p>逻辑回归中，初始参数向量全为 0 没什么问题，在神经网络中，情况就不一样了。</p>
<p>初始权重如果全为 0，忆及 $z^{(l)} = \Theta^{(l-1)}a^{(l-1)}$，则隐藏层除了偏置单元，都为 0，而每个单元求导的值也都一样，这就相当于是在不断<strong>重复计算同一结果</strong>，也就是算着算着，一堆特征在每一层都变成只有一个特征（虽然有很多单元，但值都相等），这样，神经网络的性能和效果都会大打折扣，故需要随机初始化初始权重。</p>
<p>随机初始化权重矩阵也为实现细节之一，用于打破对称性（Symmetry Breaking），使得 $\Theta^{(l)}_{ij} \in [-\epsilon,\epsilon]$ 。</p>
<p>Octave 代码：</p>
<p>当然，初始权重的波动也不能太大，一般限定在极小值 $\epsilon$ 范围内，即 $\Theta^{(l)}_{i,j} \in [-\epsilon, \epsilon]$。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">If the dimensions of Theta1 is <span class="number">10</span>x11, Theta2 is <span class="number">10</span>x11 and Theta3 is <span class="number">1</span>x11.</span><br><span class="line"></span><br><span class="line">Theta1 = <span class="built_in">rand</span>(<span class="number">10</span>,<span class="number">11</span>) * (<span class="number">2</span> * INIT_EPSILON) - INIT_EPSILON;</span><br><span class="line">Theta2 = <span class="built_in">rand</span>(<span class="number">10</span>,<span class="number">11</span>) * (<span class="number">2</span> * INIT_EPSILON) - INIT_EPSILON;</span><br><span class="line">Theta3 = <span class="built_in">rand</span>(<span class="number">1</span>,<span class="number">11</span>) * (<span class="number">2</span> * INIT_EPSILON) - INIT_EPSILON;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>rand(m,n)</code>: 返回一个在区间 $(0,1)$ 内均匀分布的随机矩阵。</p>
<p>$\epsilon$: 和梯度下降中的 $\epsilon$ 没有联系，这里只是一个任意实数，给定了权重矩阵初始化值的范围。</p>
</blockquote>
<h2 id="9-7-综合起来（Putting-It-Together）"><a href="#9-7-综合起来（Putting-It-Together）" class="headerlink" title="9.7 综合起来（Putting It Together）"></a>9.7 综合起来（Putting It Together）</h2><p>一般来说，应用神经网络有如下步骤：</p>
<ol>
<li><p>神经网络的建模（后续补充）</p>
<ul>
<li>选取特征，确定特征向量 $x$ 的维度，即输入单元的数量。</li>
<li>鉴别分类，确定预测向量 $h_\Theta(x)$ 的维度，即输出单元的数量。</li>
<li>确定隐藏层有几层以及每层隐藏层有多少个隐藏单元。</li>
</ul>
<blockquote>
<p>默认情况下，隐藏层至少要有一层，也可以有多层，层数越多一般意味着效果越好，计算量越大。</p>
</blockquote>
</li>
<li><p>训练神经网络</p>
<ol>
<li><p>随机初始化初始权重矩阵</p>
</li>
<li><p>应用前向传播算法计算初始预测</p>
</li>
<li><p>计算代价函数 $J(\Theta)$ 的值</p>
</li>
<li><p>应用后向传播宣发计算 $J(\Theta)$ 的偏导数</p>
</li>
<li><p>使用梯度检验检查算法的正确性，别忘了用完就禁用它</p>
</li>
<li><p>丢给最优化函数最小化代价函数</p>
<blockquote>
<p>由于神经网络的代价函数非凸，最优化时不一定会收敛在全局最小值处，高级最优化函数能确保收敛在某个<strong>局部</strong>最小值处。</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<h2 id="9-8-自主驾驶（Autonomous-Driving）"><a href="#9-8-自主驾驶（Autonomous-Driving）" class="headerlink" title="9.8 自主驾驶（Autonomous Driving）"></a>9.8 自主驾驶（Autonomous Driving）</h2>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习, 深度学习, 吴恩达</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机视觉概论 什么是计算机视觉</title>
    <url>/2024/04/27/08-38-57/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.04.27：初稿</li>
</ul>
<h2 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h2><ul>
<li><a href="/2024/04/27/08-42-03/" title="Ud810 Intro-to-cv 笔记汇总">计算机视觉概率-笔记汇总</a>
</li>
</ul>
<h2 id="计算机视觉不是图像处理"><a href="#计算机视觉不是图像处理" class="headerlink" title="计算机视觉不是图像处理"></a>计算机视觉不是图像处理</h2><h3 id="大脑进行构造图像"><a href="#大脑进行构造图像" class="headerlink" title="大脑进行构造图像"></a>大脑进行构造图像</h3><p><strong>球的运动</strong></p>
<img src="/2024/04/27/08-38-57/QQ20240427-084559@2x.png" class="">
<p>小球做了相同的运动，只有阴影移动不同，我们认为小球飞起来了</p>
<img src="/2024/04/27/08-38-57/QQ20240427-084850@2x.png" class="">
<p>大脑在描述看到的视觉</p>
<h3 id="计算机视觉是什么"><a href="#计算机视觉是什么" class="headerlink" title="计算机视觉是什么"></a>计算机视觉是什么</h3><img src="/2024/04/27/08-38-57/QQ20240427-085557@2x.png" class="">
<p>计算机视觉: 计算模型，算法，真实图像的三种思考方式三角形</p>
<h3 id="课程简介"><a href="#课程简介" class="headerlink" title="课程简介"></a>课程简介</h3><ol>
<li>介绍</li>
<li>计算机视觉的图像处理</li>
<li>相机和相机模型的几何结构以及多视角</li>
<li>图像特征与匹配</li>
<li>图像如何形成，光与纹理，传感器如何形成图像</li>
<li>图像运动序列</li>
<li>图像运动跟踪</li>
<li>分类和识别</li>
<li>计算机视觉简单的模式识别 </li>
<li>人类视觉系统-生物方向</li>
</ol>
<h3 id="课程作业"><a href="#课程作业" class="headerlink" title="课程作业"></a>课程作业</h3><p>一共8次作业，PS1是简单的图像处理，PS2-8是课程设计作业。</p>
<p>使用Python-OpenCV，不需要matlab</p>
<ul>
<li>代码必须自己写，要理解相关代码</li>
<li>为什么要写书中存在的代码？<br>“当代码不起作用的时候，才会知道为什么”<br>书中的代码通常不起作用或效果不佳。</li>
</ul>
<h3 id="软件相关"><a href="#软件相关" class="headerlink" title="软件相关"></a>软件相关</h3><p>计算机视觉相关图像处理<br>使用Python和OpenCV，完成课程作业。</p>
]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>计算机视觉，图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>人体姿态估计相关链接</title>
    <url>/2024/04/26/12-29-38/</url>
    <content><![CDATA[<h1 id="人体姿态估计"><a href="#人体姿态估计" class="headerlink" title="人体姿态估计"></a>人体姿态估计</h1><h2 id="github仓库"><a href="#github仓库" class="headerlink" title="github仓库"></a>github仓库</h2><h2 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h2><ul>
<li><a href="https://2d3d.ai">2030AI-Peter</a><ul>
<li><a href="https://2d3d.ai/index.php/2020/06/14/human-pose-estimation-hrnet/">HPE沙漏模型 HRNet + HigherHRNet</a></li>
</ul>
</li>
</ul>
<h2 id="知乎"><a href="#知乎" class="headerlink" title="知乎"></a>知乎</h2><h2 id="网页"><a href="#网页" class="headerlink" title="网页"></a>网页</h2><ul>
<li><a href="https://blog.roboflow.com/pose-estimation-algorithms-history/">姿态估计算法：历史与演变</a><blockquote>
<p>从传统算法到深度学习算法</p>
</blockquote>
</li>
</ul>
<h2 id="youtube"><a href="#youtube" class="headerlink" title="youtube"></a>youtube</h2><ul>
<li><a href="https://www.youtube.com/playlist?list=PLoEMreTa9CNmPGaVQYDWydc2ZmEt6zdrV">Pose Estimation | Applied Deep Learning</a><blockquote>
<p>解读深度学习算法的相关论文</p>
</blockquote>
</li>
</ul>
<h2 id="课题组"><a href="#课题组" class="headerlink" title="课题组"></a>课题组</h2><h3 id="北京大学王亦洲"><a href="#北京大学王亦洲" class="headerlink" title="北京大学王亦洲"></a>北京大学王亦洲</h3><blockquote>
<p>三维人体姿态估计</p>
</blockquote>
<h3 id="北京大学刘宏"><a href="#北京大学刘宏" class="headerlink" title="北京大学刘宏"></a>北京大学刘宏</h3><ul>
<li>课题组 <a href="https://robotics.pkusz.edu.cn/">网页</a></li>
</ul>
<h4 id="李文豪-博士生"><a href="#李文豪-博士生" class="headerlink" title="李文豪-博士生"></a>李文豪-博士生</h4><ul>
<li>个人简介<a href="https://vegetebird.github.io/">主页</a><blockquote>
<p>3D人体姿态估计</p>
</blockquote>
</li>
</ul>
<h3 id="哈工大张盛平"><a href="#哈工大张盛平" class="headerlink" title="哈工大张盛平"></a>哈工大张盛平</h3><ul>
<li>课题组 <a href="https://homepage.hit.edu.cn/zhangshengping">网页</a><blockquote>
<p>3D人体姿态估计</p>
</blockquote>
</li>
</ul>
<h3 id="厦门大学曾鸣"><a href="#厦门大学曾鸣" class="headerlink" title="厦门大学曾鸣"></a>厦门大学曾鸣</h3><ul>
<li>课题组<a href="https://vcg.xmu.edu.cn/">网页</a></li>
</ul>
<h4 id="郑英林-博士生MSRA"><a href="#郑英林-博士生MSRA" class="headerlink" title="郑英林-博士生MSRA"></a>郑英林-博士生MSRA</h4><ul>
<li>个人简介<a href="https://yinglinzheng.netlify.app/">主页</a><blockquote>
<p>多人人体姿态估计，人脸识别</p>
</blockquote>
</li>
</ul>
<h1 id="相关工具"><a href="#相关工具" class="headerlink" title="相关工具"></a>相关工具</h1><h2 id="论文可视化探索"><a href="#论文可视化探索" class="headerlink" title="论文可视化探索"></a>论文可视化探索</h2><p><a href="https://www.connectedpapers.com/">connectedpapers</a></p>
]]></content>
      <categories>
        <category>人体姿态估计</category>
      </categories>
      <tags>
        <tag>人体姿态估计, HPE, 工具, 论文</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 实验IV CacheLab</title>
    <url>/2024/03/09/16-34-34/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.03.09：初稿</li>
</ul>
<h1 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h1><ul>
<li><a href="/2023/03/15/10-59-10/" title="csapp 笔记汇总">CSAPP - 笔记汇总</a></li>
<li><a href="/2023/03/09/11-54-50/" title="CSAPP 实验I Data Lab">I Data Lab - 位操作，数据表示</a></li>
<li><a href="/2023/03/14/09-43-26/" title="CSAPP 实验II Bomb Lab">II Bomb Lab - 汇编，栈帧与 gdb</a></li>
<li><a href="/2023/03/18/15-54-47/" title="CSAPP 实验III Attack Lab">III Attack Lab - 漏洞是如何被攻击的</a></li>
<li><a href="/2024/03/09/16-34-34/" title="CSAPP 实验IV CacheLab">IV Cache Lab - 实现一个缓存系统</a></li>
<li><a href="/2024/03/14/12-34-42/" title="CSAPP 实验V ShellLab">V Shell Lab - 实现一个Shell</a>
</li>
</ul>
<h1 id="任务目标"><a href="#任务目标" class="headerlink" title="任务目标"></a>任务目标</h1><p>CacheLab实验，第一部分需要模拟Cache计算命中，未命中次数，第二部分实现代码优化，减少未命中次数。</p>
<h1 id="相关内容"><a href="#相关内容" class="headerlink" title="相关内容"></a>相关内容</h1><ol>
<li><p>Cache</p>
<blockquote>
<img src="/2024/03/09/16-34-34/QQ20240309-165258@2x.png" class="">
<p>不需要关注 <code>b</code> bits，使用LRU替换策略。</p>
<p>Cache是一个二维数组cache[S][E]，S=2^s，组数。</p>
<p>每一个cache行包含：Valid bit， Tag， LRU counter。</p>
<p>用Tag对比E匹配line。</p>
</blockquote>
</li>
<li><p>生成内存调试工具命令: <code>linux&gt; valgrind --log-fd=1 --tool=lackey -v --trace-mem=yes ls -l</code></p>
<blockquote>
<p>参数<code>ls -l</code>：打印输出在文件stdout</p>
<p>格式为<code>[space]operation address,size</code>，除了I操作外，前都有一个空格</p>
<p>操作：I-instruction load，L-data load，S-data store， M-data modify。M包含L，S。</p>
<p>address：64-bit 16进制</p>
<p>size：字节数</p>
</blockquote>
</li>
</ol>
<h1 id="题目及解法"><a href="#题目及解法" class="headerlink" title="题目及解法"></a>题目及解法</h1><h2 id="Part-A-Writing-a-Cache-Simulator"><a href="#Part-A-Writing-a-Cache-Simulator" class="headerlink" title="Part A Writing a Cache Simulator"></a>Part A Writing a Cache Simulator</h2><p>完成<code>csim.c</code>文件，使用<code>valgrind</code>生成测试数据，输出命中，未命中和替换次数，输出格式为<code>hits:4 misses:5 evictions:3</code>。</p>
<h3 id="相关内容-1"><a href="#相关内容-1" class="headerlink" title="相关内容"></a>相关内容</h3><ul>
<li><p>修改<code>csim.c</code>文件</p>
</li>
<li><p>可参考的二进制文件<code>csim-ref</code>，使用命令<code>./csim-ref [-hv] -s &lt;s&gt; -E &lt;E&gt; -b &lt;b&gt; -t &lt;tracefile&gt;</code></p>
<blockquote>
<p>参数：v-打印内存追踪记录</p>
</blockquote>
</li>
<li><p>自动评分工具<code>test-csim</code></p>
</li>
<li><p>建议代码像参考模拟器显示输出，方便测试。</p>
</li>
<li><p>使用<code>getopt</code>分析命令行参数。需包含头文件<getopt.h>，<unistd.h>，<stdlib.h>。可以获取函数参数。</p>
</li>
<li><p>使用<code>fscanf</code>按行读取文件</p>
</li>
<li><p>使用<code>malloc</code>，<code>free</code>，防止内存泄漏</p>
</li>
<li><p>使用<code>printSummary(hit_count, miss_count, eviction_count);</code>，打印输出</p>
</li>
<li><p>数据是对齐，且不会出现跨块访问。</p>
</li>
</ul>
<h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSetbits 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxLine 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxBytebits 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Myline</span>&#123;</span></span><br><span class="line">  <span class="type">int</span> valid; <span class="comment">//有效位</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> tag;   <span class="comment">//tag标记  十进制</span></span><br><span class="line">  <span class="type">int</span> lru_num;   <span class="comment">// 最近使用标记 0 - (E - 1)</span></span><br><span class="line">&#125;Myline;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Mycache</span>&#123;</span></span><br><span class="line">  <span class="type">int</span> S;            <span class="comment">// set 大小</span></span><br><span class="line">  <span class="type">int</span> E;            <span class="comment">// line 大小</span></span><br><span class="line">  <span class="type">int</span> B;            <span class="comment">//偏移大小</span></span><br><span class="line">  <span class="type">int</span> size_Tag;     <span class="comment">// tag bits = 64 - s- b</span></span><br><span class="line">  Myline **<span class="built_in">set</span>;    <span class="comment">//set数组</span></span><br><span class="line">&#125;Mycache;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//get command line arguments</span></span><br><span class="line"><span class="comment">//p_s s的指针   p_E E的指针   p_b b的指针    fn 文件名</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Mygetopt</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[], <span class="type">int</span> *p_s, <span class="type">int</span> *p_E, <span class="type">int</span> *p_b, <span class="type">char</span> *fn, <span class="type">int</span> *flag_v)</span>;   </span><br><span class="line"><span class="comment">//16进制转换十进制</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="title function_">Hex2dec</span><span class="params">(<span class="type">char</span> *hex)</span>;</span><br><span class="line"><span class="comment">//返回tag</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="title function_">GetDecTag</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> dec, <span class="type">int</span> s, <span class="type">int</span> b)</span>;</span><br><span class="line"><span class="comment">//返回组号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">GetDecSetNum</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> dec, <span class="type">int</span> s, <span class="type">int</span> b)</span>;</span><br><span class="line"><span class="comment">//返回这个dec地址下当前偏移量开始剩余的字节数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">GetDecRestByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> dec, <span class="type">int</span> s, <span class="type">int</span> b, <span class="type">int</span> B)</span>;</span><br><span class="line"><span class="comment">//初始化set</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Initset</span><span class="params">(Mycache *mc)</span>;</span><br><span class="line"><span class="comment">//处理最近未使用</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">GetminLRU</span><span class="params">(Myline *<span class="built_in">set</span>, <span class="type">int</span> E)</span>;</span><br><span class="line"><span class="comment">//是否set满了</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">IsFullSet</span><span class="params">(Myline *<span class="built_in">set</span>, <span class="type">int</span> E)</span>;</span><br><span class="line"><span class="comment">//命中处理  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HitDeal</span><span class="params">(Myline *<span class="built_in">set</span>, <span class="type">int</span> E, <span class="type">int</span> Eindex)</span>;</span><br><span class="line"><span class="comment">//未命中 加载cache</span></span><br><span class="line"><span class="comment">// 有空余line加载</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MissLoadDeal</span><span class="params">(Myline *<span class="built_in">set</span>, <span class="type">int</span> E, <span class="type">int</span> Eindex, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> dec_tag)</span>;</span><br><span class="line"><span class="comment">//line替换</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MissEvictionDeal</span><span class="params">(Myline *<span class="built_in">set</span>, <span class="type">int</span> E, <span class="type">int</span> delindex, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> dec_tag)</span>;</span><br><span class="line"><span class="comment">//访问处理   返回1 hit   2  miss  3 miss eviction</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">LoadDeal</span><span class="params">(Myline *<span class="built_in">set</span>, <span class="type">int</span> E, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> now_tag, <span class="type">int</span> flag_v)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">StoreDeal</span><span class="params">(Myline *<span class="built_in">set</span>, <span class="type">int</span> E, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> now_tag, <span class="type">int</span> flag_v)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ModifyDeal</span><span class="params">(Myline *<span class="built_in">set</span>, <span class="type">int</span> E, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> now_tag, <span class="type">int</span> flag_v)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  FILE *fp;</span><br><span class="line">  <span class="type">int</span> hit_count, miss_count, eviction_count;</span><br><span class="line">  <span class="type">int</span> s, E, b;</span><br><span class="line">  <span class="type">int</span> flag_v = <span class="number">0</span>;     <span class="comment">//opt v 的标记</span></span><br><span class="line">  <span class="type">char</span> *file_name;</span><br><span class="line">  <span class="type">char</span> optcache = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  <span class="type">char</span> ignorechar = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  <span class="type">char</span> hex[<span class="number">65</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="type">int</span> size = <span class="number">0</span>;        <span class="comment">//个数</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> dec;</span><br><span class="line"></span><br><span class="line">  hit_count = <span class="number">0</span>;</span><br><span class="line">  miss_count = <span class="number">0</span>;</span><br><span class="line">  eviction_count = <span class="number">0</span>;</span><br><span class="line">  Mycache cache;</span><br><span class="line">  file_name = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * <span class="number">30</span>);</span><br><span class="line">  Mygetopt(argc, argv, &amp;s, &amp;E, &amp;b, file_name, &amp;flag_v);</span><br><span class="line">  cache.S = <span class="built_in">pow</span>(<span class="number">2</span>, s);</span><br><span class="line">  cache.E = E;</span><br><span class="line">  cache.B = <span class="built_in">pow</span>(<span class="number">2</span>, b);</span><br><span class="line">  cache.size_Tag = <span class="number">64</span> - s - b;</span><br><span class="line">  Initset(&amp;cache);</span><br><span class="line"></span><br><span class="line">  fp = fopen(file_name, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">fscanf</span>(fp, <span class="string">&quot; %c %[^,]%c%d&quot;</span>, &amp;optcache, hex, &amp;ignorechar, &amp;size) != <span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(optcache == <span class="string">&#x27;I&#x27;</span>)&#123;</span><br><span class="line">      <span class="built_in">fscanf</span>(fp, <span class="string">&quot;%c&quot;</span>, &amp;ignorechar);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag_v == <span class="number">1</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%c %s,%d&quot;</span>, optcache, hex, size);</span><br><span class="line">    &#125;</span><br><span class="line">    dec = Hex2dec(hex);</span><br><span class="line">    <span class="comment">//========处理内存访问</span></span><br><span class="line">    <span class="type">int</span> setnum = <span class="number">0</span>;  <span class="comment">//组号</span></span><br><span class="line">    <span class="type">int</span> flag_kind = <span class="number">0</span>;   <span class="comment">//cache 类型   hit miss  </span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> dectag = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//int restbyte = 0;  // 当前偏移量下剩余的字节数</span></span><br><span class="line">    <span class="comment">//int loadbyte = 0;  //已加载的字节数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> loaddec = dec;   <span class="comment">//当前加载的地址</span></span><br><span class="line">    setnum = GetDecSetNum(loaddec, s, b);</span><br><span class="line">    dectag = GetDecTag(loaddec, s, b);</span><br><span class="line">    <span class="comment">//restbyte = GetDecRestByte(loaddec, s, b, cache.B);   //剩余加载的字节数</span></span><br><span class="line">    flag_kind = LoadDeal(cache.<span class="built_in">set</span>[setnum], E, dectag, flag_v);</span><br><span class="line">    <span class="comment">/*loadbyte += restbyte;</span></span><br><span class="line"><span class="comment">    loaddec += restbyte;   //当前地址加上剩余字节数  如果加载字节数不够  这就是下一个加载地址</span></span><br><span class="line"><span class="comment">    while(loadbyte &lt; size)&#123;</span></span><br><span class="line"><span class="comment">      setnum = GetDecSetNum(loaddec, s, b);</span></span><br><span class="line"><span class="comment">      dectag = GetDecTag(loaddec, s, b);</span></span><br><span class="line"><span class="comment">      LoadDeal(cache.set[setnum], E, dectag, flag_v);</span></span><br><span class="line"><span class="comment">      loadbyte += cache.B;</span></span><br><span class="line"><span class="comment">      loaddec += cache.B;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="keyword">if</span>(flag_kind == <span class="number">1</span>)&#123;</span><br><span class="line">      hit_count++;</span><br><span class="line">      <span class="keyword">if</span>(flag_v == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; hit&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(flag_kind == <span class="number">2</span>)&#123;</span><br><span class="line">        miss_count++;</span><br><span class="line">        <span class="keyword">if</span>(flag_v == <span class="number">1</span>)&#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot; miss&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">        miss_count++;</span><br><span class="line">        eviction_count++;</span><br><span class="line">        <span class="keyword">if</span>(flag_v == <span class="number">1</span>)&#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot; miss eviction&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(optcache == <span class="string">&#x27;M&#x27;</span>)&#123;</span><br><span class="line">      hit_count++;   <span class="comment">//修改  store一定hit</span></span><br><span class="line">      <span class="keyword">if</span>(flag_v == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; hit\n&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(flag_v == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//=====================</span></span><br><span class="line">    <span class="built_in">fscanf</span>(fp, <span class="string">&quot;%c&quot;</span>, &amp;ignorechar);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  printSummary(hit_count, miss_count, eviction_count);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Mygetopt</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[], <span class="type">int</span> *p_s, <span class="type">int</span> *p_E, <span class="type">int</span> *p_b, <span class="type">char</span> *fn, <span class="type">int</span> *flag_v)</span>&#123;</span><br><span class="line">  <span class="type">int</span> opt;</span><br><span class="line">  <span class="keyword">while</span> ((opt = getopt(argc, argv, <span class="string">&quot;vh:s:E:b:t:&quot;</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">        *p_s = atoi(optarg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:</span><br><span class="line">        *p_E = atoi(optarg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">        *p_b = atoi(optarg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line">        <span class="built_in">strcpy</span>(fn, optarg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:</span><br><span class="line">        *flag_v = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="title function_">Hex2dec</span><span class="params">(<span class="type">char</span> *hex)</span>&#123;</span><br><span class="line">  <span class="type">int</span> len = <span class="built_in">strlen</span>(hex);</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> dec = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> pow16 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isdigit</span>(hex[i]))&#123;</span><br><span class="line">      dec += (hex[i] - <span class="string">&#x27;0&#x27;</span>) * pow16;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      dec += (hex[i] - <span class="number">87</span>) * pow16;</span><br><span class="line">    &#125;</span><br><span class="line">    pow16 *= <span class="number">16</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dec;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="title function_">GetDecTag</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> dec, <span class="type">int</span> s, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> dec &gt;&gt; (s + b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">GetDecSetNum</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> dec, <span class="type">int</span> s, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">  <span class="type">int</span> setbits = (<span class="number">1</span> &lt;&lt; s);</span><br><span class="line">  setbits = ~(~setbits + <span class="number">1</span>);</span><br><span class="line">  dec = dec &gt;&gt; (b);</span><br><span class="line">  <span class="keyword">return</span> dec &amp; setbits;   <span class="comment">//返回set组号</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">GetDecRestByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> dec, <span class="type">int</span> s, <span class="type">int</span> b, <span class="type">int</span> B)</span>&#123;</span><br><span class="line">  <span class="type">int</span> Bytebits = <span class="number">1</span> &lt;&lt; b;</span><br><span class="line">  Bytebits = ~(~Bytebits + <span class="number">1</span>);</span><br><span class="line">  dec = dec &amp; Bytebits;   <span class="comment">//剩余偏移量</span></span><br><span class="line">  <span class="keyword">return</span> B - dec;  <span class="comment">//返回剩余的字节数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Initset</span><span class="params">(Mycache *mc)</span>&#123;</span><br><span class="line">  <span class="type">int</span> S = (*mc).S;</span><br><span class="line">  <span class="type">int</span> E = (*mc).E;</span><br><span class="line">  (*mc).<span class="built_in">set</span> = (Myline **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Myline *) * S);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; S; i++)&#123;</span><br><span class="line">    (*mc).<span class="built_in">set</span>[i] = (Myline *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Myline) * E);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; (*mc).S; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; (*mc).E; j++)&#123;</span><br><span class="line">      (*mc).<span class="built_in">set</span>[i][j].valid = <span class="number">0</span>;  <span class="comment">//有效位为0</span></span><br><span class="line">      (*mc).<span class="built_in">set</span>[i][j].lru_num = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">GetminLRU</span><span class="params">(Myline *<span class="built_in">set</span>, <span class="type">int</span> E)</span>&#123;</span><br><span class="line">  <span class="type">int</span> min = <span class="number">1000</span>;</span><br><span class="line">  <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; E; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">set</span>[i].valid == <span class="number">0</span>)&#123;   <span class="comment">// 如果存在一个无效位置 直接返回</span></span><br><span class="line">      k = i;</span><br><span class="line">      <span class="keyword">break</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">set</span>[i].lru_num &lt; min)&#123;  </span><br><span class="line">      min = <span class="built_in">set</span>[i].lru_num;</span><br><span class="line">      k = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">IsFullSet</span><span class="params">(Myline *<span class="built_in">set</span>, <span class="type">int</span> E)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; E; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">set</span>[i].valid == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">HitDeal</span><span class="params">(Myline *<span class="built_in">set</span>, <span class="type">int</span> E, <span class="type">int</span> Eindex)</span>&#123;</span><br><span class="line">  <span class="type">int</span> nowLRU = <span class="built_in">set</span>[Eindex].lru_num;</span><br><span class="line">  <span class="comment">//把比现在要访问的cache set中lrunum大的全部减一  </span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; E; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">set</span>[i].lru_num &gt; nowLRU)&#123;</span><br><span class="line">      <span class="built_in">set</span>[i].lru_num--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">set</span>[Eindex].lru_num = E - <span class="number">1</span>;  <span class="comment">//最新访问的cache LRU设置为最大</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">MissLoadDeal</span><span class="params">(Myline *<span class="built_in">set</span>, <span class="type">int</span> E, <span class="type">int</span> Eindex, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> dec_tag)</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//把比现在要访问的cache set中lrunum大的全部减一  </span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; E; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">set</span>[i].lru_num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">set</span>[i].lru_num--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">set</span>[Eindex].tag = dec_tag;</span><br><span class="line">  <span class="built_in">set</span>[Eindex].valid = <span class="number">1</span>;  </span><br><span class="line">  <span class="built_in">set</span>[Eindex].lru_num = E - <span class="number">1</span>;  <span class="comment">//最新访问的cache LRU设置为最大</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MissEvictionDeal</span><span class="params">(Myline *<span class="built_in">set</span>, <span class="type">int</span> E, <span class="type">int</span> delindex, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> dec_tag)</span>&#123;</span><br><span class="line">  <span class="comment">//将要替换的line命中  改为最近访问过,然后再替换掉tag值</span></span><br><span class="line">  HitDeal(<span class="built_in">set</span>, E, delindex);</span><br><span class="line">  <span class="built_in">set</span>[delindex].tag = dec_tag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">LoadDeal</span><span class="params">(Myline *<span class="built_in">set</span>, <span class="type">int</span> E, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> now_tag, <span class="type">int</span> flag_v)</span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; E; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">set</span>[i].tag == now_tag &amp;&amp; <span class="built_in">set</span>[i].valid == <span class="number">1</span>)&#123;</span><br><span class="line">      HitDeal(<span class="built_in">set</span>, E, i);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(i == E)&#123;</span><br><span class="line">    <span class="type">int</span> Lindex = GetminLRU(<span class="built_in">set</span>, E);</span><br><span class="line">    <span class="keyword">if</span>(IsFullSet(<span class="built_in">set</span>, E) == <span class="number">1</span>)&#123;</span><br><span class="line">      <span class="comment">//满的  替换</span></span><br><span class="line">      MissEvictionDeal(<span class="built_in">set</span>, E, Lindex, now_tag);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      MissLoadDeal(<span class="built_in">set</span>, E, Lindex, now_tag);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">StoreDeal</span><span class="params">(Myline *<span class="built_in">set</span>, <span class="type">int</span> E, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> now_tag, <span class="type">int</span> flag_v)</span>&#123;</span><br><span class="line">  <span class="comment">//Store 相当于 Load</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ModifyDeal</span><span class="params">(Myline *<span class="built_in">set</span>, <span class="type">int</span> E, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> now_tag, <span class="type">int</span> flag_v)</span>&#123;</span><br><span class="line">  <span class="comment">//int kind = LoadDeal(set, E, now_tag,flag_v);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Part-B-Optimizing-Matrix-Transpose"><a href="#Part-B-Optimizing-Matrix-Transpose" class="headerlink" title="Part B Optimizing Matrix Transpose"></a>Part B Optimizing Matrix Transpose</h2><p>完成<code>trans.c</code>文件，实现一个转置矩阵代码<code>transpose_submit</code>，尽可能少的产生cache未命中。</p>
<h3 id="相关内容-2"><a href="#相关内容-2" class="headerlink" title="相关内容"></a>相关内容</h3><ul>
<li><p>只允许使用最多12个本地int变量，调用函数中一起计算</p>
</li>
<li><p>不允许使用long或者其他存储数值的方法，不允许使用数组</p>
</li>
<li><p>不能递归</p>
</li>
<li><p>使用参考模拟器来测试代码，cache参数为<code>s = 5， E = 1， b = 5</code></p>
</li>
<li><p>int为4个字节。</p>
</li>
<li><p>只有三种形式的矩阵，32*32，64*64，61*67。</p>
</li>
<li><img src="/2024/03/09/16-34-34/QQ20240310-152729@2x.png" class=""> 
<p>矩阵乘法的分块技术</p>
</li>
<li><p>两个数组的第一个数据，在cache中存储到相同位置，数组按照行优先存储，数据是对齐的</p>
</li>
<li><p><code>./test-trans -M 32 -N 32</code> 测试函数 </p>
</li>
<li><p><code>./tracegen -M 64 -N 64 -F 0</code> 输出错误信息 </p>
</li>
</ul>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>数据是对齐的，所以一个cache行包含32个字节，存储8个int数据，cache能存储256个int数据，根据<del><code>3B^2 &lt;&lt; C</code>，块长为B=8</del>。根据<code>2B^2 &lt;&lt; C</code>，块长&lt;=11，由于cache行可以存8个数据，所以选择块长8。</p>
<img src="/2024/03/09/16-34-34/QQ20240310-191918@2x.png" class="">
<p>以32*32的矩阵为例，除了处于对角线上的块会产生冲突不命中，其他块都可以优化不命中情况</p>
<p>以上这种情况对32*32是成立的，64*64和61*67不成立，所以重新思考了这道题的解法，根据data lab中数据的操作都是在内存中进行的。</p>
<p><strong>数组的首地址给出后，行优先数据为一维连续存储形式</strong></p>
<p>这道题可以转换为数组A[N][M]在内存中连续存放，每一个位置x的数根据相同的转换方式保存到数组B[M][N]的位置y，转换公式为<code>i_a = x / M</code>，<code>j_a = x % M</code>，<code>y = j_a * N + i_a * M</code>。于是存储公式为<code>B(y) = A(x)</code>。</p>
<img src="/2024/03/09/16-34-34/QQ20240312-145802@2x.png" class="">
<blockquote>
<p>示意图如上，cache行存2个数据，3*3的数组中，无法直观看出内存区别，而cache的分块目的是为了在内存中读取到cache时减少miss次数，所以我们根据内存进行重排数组，改为5*2的数组。</p>
</blockquote>
<p>所以这道题可以把数组转换为32列的任意数组，由于一行只有32列，远远小于cache的容量256个数据，所以相邻行的上下两个数据不会映射的同一个cache行。</p>
<p>需要把文件放入linux的文件夹中，如果在共享文件夹中会出现运行超时。</p>
<h3 id="32-x-32"><a href="#32-x-32" class="headerlink" title="32 x 32"></a>32 x 32</h3><p>基本步骤：</p>
<ul>
<li><p>重排数组</p>
</li>
<li><p>处理AB数组中x，y映射相同的位置，先用局部变量保存，然后处理这一行的其他数据，最后保存在B数组的中，cache行自动换出。</p>
</li>
</ul>
<p><strong>分析原因</strong></p>
<blockquote>
<p>当<code>A[i][j]</code>与<code>B[j][i]</code>的cache映射相同set内时，取出<code>A[i][j]</code>中的值，写入B数组时会换出A的cache行，导致下次访问A的同一行cache数据时需要继续换出一次。</p>
</blockquote>
<p><strong>解决办法</strong></p>
<blockquote>
<p>用局部变量保存访问冲突的值，等循环结束后，在写入B中。</p>
<p>计算所在行，x表示数组一维连续内存的位置(0开始)，cache 组号<code>s=（x%256 ) / 8;</code></p>
</blockquote>
<p><strong>结果</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> A[N][M], <span class="type">int</span> B[M][N])</span> &#123;</span><br><span class="line">  <span class="comment">//int t_1, t_2, t_3;</span></span><br><span class="line">  <span class="type">int</span> t_4, t_5;</span><br><span class="line">  <span class="type">int</span> i, j, ii, jj;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i += <span class="number">8</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; M; j += <span class="number">8</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (ii = i; ii &lt; ((i + <span class="number">8</span>) &lt; N ? i + <span class="number">8</span> : N); ii++) &#123;</span><br><span class="line">        <span class="comment">//标记没有访问冲突</span></span><br><span class="line">        t_4 = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (jj = j; jj &lt; ((j + <span class="number">8</span>) &lt; M ? j + <span class="number">8</span> : M); jj++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (ii * M + jj == jj * N + ii) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t_4 == <span class="number">-1</span>) &#123;</span><br><span class="line">              t_4 = ii;</span><br><span class="line">              t_5 = jj;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// printf(&quot;**  2-- %d  3--  %d\n&quot;, t_2, t_3);</span></span><br><span class="line">          B[jj][ii] = A[ii][jj];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t_4 != <span class="number">-1</span>) &#123;</span><br><span class="line">          B[t_5][t_4] = A[t_4][t_5];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2024/03/09/16-34-34/QQ20240312-183951@2x.png" class="">
<p>miss数量287，满分</p>
<h3 id="64-x-64"><a href="#64-x-64" class="headerlink" title="64 x 64"></a>64 x 64</h3><p>出现一个cache行中两次相同映射的问题</p>
<p><strong>分析原因</strong></p>
<blockquote>
<p>在32 x 32的数组中，一个cache行为8，块为8x8，一个cache行最多只有对角线的的一个元素冲突miss，但是64x64的数组中，8x8的块中，前四行与后四行冲突miss，所以一个cache行的8个数据中，最多有两个元素冲突miss</p>
</blockquote>
<p><strong>解决办法</strong></p>
<blockquote>
<p>继续添加一个局部变量记录冲突位置，一行遍历完后再处理。</p>
<p>继续出现了只遍历到了32，在64 X 64的数组转换为32列时，行数为128。</p>
</blockquote>
<img src="/2024/03/09/16-34-34/QQ20240312-225626@2x.png" class="">
<p>miss数量为4611，还需要继续调低。</p>
<p><strong>分析原因</strong></p>

<p><del>错误答案</del></p>
<p>64X64中，改了内存排列后，第二行与第一行的转置不在同一cache行内。</p>
<p>按照左上右上，左下，右下顺序。</p>
<p><strong>结果</strong></p>
<img src="/2024/03/09/16-34-34/QQ20240313-183244@2x.png" class="">
<p><strong>分析原因</strong></p>
<blockquote>
<p>没有拿到满分，按照上下划分为两个4X8的数组</p>
<p>下边的4X8数组，一行中的后四列在B数组中会cache冲突行，如图<img src="/2024/03/09/16-34-34/QQ20240313-191649@2x.png" class=""></p>
<p>注意：</p>
<p>上四行转置之后，B数组的下四行正在cache中，为了不换出，先转置A数组的右下，再左下。</p>
</blockquote>
<p><strong>结果</strong></p>
<img src="/2024/03/09/16-34-34/QQ20240313-193617@2x.png" class="">
<p>减少到1547，但是还没有满分。</p>
<p>继续修改</p>
<blockquote>
<p>题目要求减少miss数量，可以利用cache中空闲的地方保存数据  最后在替换出去</p>
<img src="/2024/03/09/16-34-34/QQ20240313-202434@2x.png" class="">
<p>如图，A的上半部分的后四列存到B的后四列中</p>
<img src="/2024/03/09/16-34-34/QQ20240313-202818@2x.png" class="">
<p>下半部分的第一列，先把B数组的第一行后四列保存到下部分的第一行，这样第一个cache就替换完成，依次完成其他行，最后把右下角转置过去。</p>
</blockquote>
<p><strong>结果</strong></p>
<img src="/2024/03/09/16-34-34/QQ20240313-210554@2x.png" class="">
<p>miss数1339，差39次满分，没有找到优化位置。</p>
<h3 id="61-X-67"><a href="#61-X-67" class="headerlink" title="61 X 67"></a>61 X 67</h3><p><strong>结果</strong></p>
<img src="/2024/03/09/16-34-34/QQ20240313-210917@2x.png" class="">
<p><strong>最终得分</strong></p>
<img src="/2024/03/09/16-34-34/QQ20240314-144148@2x.png" class="">
<p>拿到了51.5分，之后有时间再来查代码优化的地方。</p>
]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机视觉概论 相机和图像</title>
    <url>/2024/04/29/16-24-21/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.04.29：初稿</li>
</ul>
<h2 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h2><ul>
<li><a href="/2024/04/27/08-42-03/" title="Ud810 Intro-to-cv 笔记汇总">计算机视觉概率-笔记汇总</a>
</li>
</ul>
<h2 id="透视成像"><a href="#透视成像" class="headerlink" title="透视成像"></a>透视成像</h2><h4 id="建模投影"><a href="#建模投影" class="headerlink" title="建模投影"></a>建模投影</h4><p>坐标系：</p>
<img src="/2024/04/29/16-24-21/QQ20240501-091850@2x.png" class="">
<ul>
<li>Center OF Projection:光学中心，在原点</li>
<li>不用担心翻转，图像放在坐标系前</li>
<li>坐标系符合右手定则，$z$轴指向相机，而不是指向世界</li>
</ul>
<p>坐标转换：<br>$(X,Y,Z)\to(-d\frac XZ,-d\frac YZ,-d)$</p>
<h4 id="齐次坐标-Homogeneous-coordinates"><a href="#齐次坐标-Homogeneous-coordinates" class="headerlink" title="齐次坐标 Homogeneous coordinates"></a>齐次坐标 Homogeneous coordinates</h4><p>二维：<br>$(x,y)\Rightarrow\left[\begin{array}{c}x\\y\\\mathbf{1}\end{array}\right]$</p>
<p>三维：<br>$(x,y,z)\Rightarrow\left[\begin{array}{c}x\\y\\z\\\mathbf{1}\end{array}\right]$</p>
<p>齐次转常规：<br>$\left[\begin{array}{c}x\\y\\z\\w\end{array}\right]\Rightarrow\left(x/w,y/w,z/w\right)$</p>
<p>例子：</p>
<p>\begin{split}<br>\begin{bmatrix}1&amp;0&amp;0&amp;0\\0&amp;1&amp;0&amp;0\\0&amp;0&amp;1/f&amp;0\end{bmatrix}\begin{bmatrix}x\\|&amp;|\\y\\z\\1\end{bmatrix}&amp;=\begin{bmatrix}x\\y\\z/f\end{bmatrix}&amp;\Rightarrow\left(f\frac xz,f\frac yz\right)\\&amp;\Rightarrow\left(u,\nu\right)<br>\end{split}</p>
<p>通过焦距为$f$的投影，投影到世界上某个点$(x,y,z)$的图像中的坐标。<br>焦距：从中心投影到图像的距离</p>
<h4 id="投影的几何性质"><a href="#投影的几何性质" class="headerlink" title="投影的几何性质"></a>投影的几何性质</h4><img src="/2024/04/29/16-24-21/QQ20240501-093454@2x.png" class="">
<ul>
<li>$O$，是投影中心</li>
<li>点，线，投影到点，线</li>
<li>多边形投影会改变</li>
</ul>
<p>平行线会改变：<br><strong>数学解释：</strong><br>三维平行线：<br>$x\left(t\right)=x_0+at\\y\left(t\right)=y_0+bt\\z\left(t\right)=z_0+ct$</p>
<p>投影坐标的投影方程：<br>$x’(t)=\frac{fx}z=\frac{f\left(x_0+at\right)}{z_0+ct}\\y’(t)=\frac{fy}z=\frac{f\left(y_0+bt\right)}{z_0+ct}$</p>
<p>$\begin{split}&amp;\text{In the limit as }t\to\pm\infty\quad x’(t)\to\frac{fa}c,\quad y’(t)\to\frac{fb}c\\&amp;\text{we have (for }c\neq0){:}\end{split}$</p>
<ul>
<li>公式中没有$x_0,y_0,z_0$，直线的起点不重要，直线沿着直线一直向前</li>
<li>不同的直线会汇聚到同一个点，(点不一定相同，取决于视角)</li>
<li>$c$不能为0，如果c为0，意味着平行线与$z$轴垂直，与投影面平行，永远不会相交</li>
</ul>
<p>平行线会在无限远的地方汇聚消失：消失点</p>
<p>三点透视</p>
<img src="/2024/04/29/16-24-21/QQ20240501-094912@2x.png" class="">
<p>人类视觉：Müller-LyerIllusion</p>
<img src="/2024/04/29/16-24-21/QQ20240501-095137@2x.png" class="">
<p>红线哪个更长，透视错觉</p>
<h4 id="其他投影模型"><a href="#其他投影模型" class="headerlink" title="其他投影模型"></a>其他投影模型</h4><p>正交投影： Orthographic<br>特殊的平行投影，假设光源无限远，光是平行的。<br><img src="/2024/04/29/16-24-21/QQ20240501-095431@2x.png" class=""><br>投影矩阵：<br>$\left[\begin{array}{cccc}1&amp;0&amp;0&amp;0\\0&amp;1&amp;0&amp;0\\0&amp;0&amp;0&amp;1\end{array}\right]\left[\begin{array}{c}x\\y\\z\\1\end{array}\right]\boldsymbol{=}\left[\begin{array}{c}x\\y\\1\end{array}\right]\boldsymbol{\Rightarrow}(x,y)$</p>
<p>弱视角投影： Weak perspective<br>缩放投影<br>$\begin{bmatrix}1&amp;0&amp;0&amp;0\\0&amp;1&amp;0&amp;0\\\\0&amp;0&amp;0&amp;1/s\end{bmatrix}\begin{bmatrix}x\\y\\z\\1\end{bmatrix}=\begin{bmatrix}x\\y\\1/s\end{bmatrix}\Rightarrow(sx,sy)$</p>
<ul>
<li>$s$:缩放因子</li>
</ul>
<h2 id="立体几何"><a href="#立体几何" class="headerlink" title="立体几何"></a>立体几何</h2><h4 id="多视角图像"><a href="#多视角图像" class="headerlink" title="多视角图像"></a>多视角图像</h4><img src="/2024/04/29/16-24-21/QQ20240501-100044@2x.png" class="">
<p>结构和深度是模糊的，所以出现了多视角，本质来自投影</p>
<p>人类视觉具有感知深度的能力,主要元素：</p>
<ol>
<li>阴影 shading</li>
<li>纹理 texture</li>
<li>焦点/深度焦点 focus/defocus</li>
<li>移动 motion</li>
</ol>
<h4 id="立体视觉"><a href="#立体视觉" class="headerlink" title="立体视觉"></a>立体视觉</h4><p>两个眼睛看的图像不同，从两个视觉中恢复立体</p>
<p>双视觉图像，中心元素，前后的元素都在像它移动</p>
<p>随机点立体图：</p>
<p>人类可以直接融合双视角图像</p>
<img src="/2024/04/29/16-24-21/QQ20240501-101547@2x.png" class="">
<p>相机是由光学中心(optical center)定义的</p>
<ul>
<li>校准，相机姿态</li>
<li>图像对应点</li>
</ul>
<h4 id="简单的立体系统"><a href="#简单的立体系统" class="headerlink" title="简单的立体系统"></a>简单的立体系统</h4><p>相机的俯视图：</p>
<img src="/2024/04/29/16-24-21/QQ20240501-102205@2x.png" class="">
<p>计算深度的公式：<br>$\begin{split}\frac{B-x_l+x_r}{Z-f}&amp;=\frac BZ\\\\Z = f \frac B{x_l - x_r}\end{split}$</p>
<p>视角差为0，深度为无穷，月亮为什么一直会跟着，因为深度无限远，视角没有变化。</p>
<p>视角差的例子：</p>
<img src="/2024/04/29/16-24-21/QQ20240501-102755@2x.png" class="">
<p>找出两张图，哪个在左边，哪个在右边，从上面的烟囱可以看出，右边图在右方拍摄。<br>红点是一个图像相同位置的点，右图向左移动一直，那个点才能到左图中的窗口点，这就是视角差。</p>
<p>从视差到深度：<br><img src="/2024/04/29/16-24-21/QQ20240501-103010@2x.png" class=""></p>
<p>通过视差图像，亮的地方视差大，暗的地方视差小。<br>根据视差与深度的反比关系，我们可以得到深度。</p>
<p>从深度到视差：<br>因为$y没有变化，视差来源于$x$，所以$D(x,y)$也是x的变化。</p>
<p>$(x’,y’)=(x+D(x,y), y)$</p>
<h2 id="对极几何"><a href="#对极几何" class="headerlink" title="对极几何"></a>对极几何</h2><h4 id="立体对应约束"><a href="#立体对应约束" class="headerlink" title="立体对应约束"></a>立体对应约束</h4><img src="/2024/04/29/16-24-21/QQ20240501-122809@2x.png" class="">
<p>左侧的图像点p，可以点在一条直线上的任意一点，所以它对应在另一个图像中的点，是一条直线上任何一点。这条线成为极线。<br>这就叫做：极线约束 Epipolar constraint</p>
<ul>
<li>基线：相机点和位置点形成的</li>
</ul>
<p>为什么极线约束有用？<br>在极线中找对应另一个图像中的点。</p>
<p>例子：<br><img src="/2024/04/29/16-24-21/QQ20240501-123218@2x.png" class=""><br>极点是一个数学概念，所有的极线会在屏幕外面聚合。</p>
<p>平行图像的例子：<br><img src="/2024/04/29/16-24-21/QQ20240501-123433@2x.png" class=""></p>
<h2 id="立体对应-Stereo-correspondence"><a href="#立体对应-Stereo-correspondence" class="headerlink" title="立体对应 Stereo correspondence"></a>立体对应 Stereo correspondence</h2><p>软约束：对应点之间的关系</p>
<ol>
<li>相似性</li>
<li>唯一性</li>
<li>有序</li>
<li>视差梯度有限-深度变化不会太大</li>
</ol>
<h4 id="相似性"><a href="#相似性" class="headerlink" title="相似性"></a>相似性</h4><img src="/2024/04/29/16-24-21/QQ20240501-135443@2x.png" class="">
<p>强度分布图：匹配位置具有差异</p>
<img src="/2024/04/29/16-24-21/QQ20240501-135637@2x.png" class="">
<p>视差图的相似性:匹配的地方峰值最高</p>
<img src="/2024/04/29/16-24-21/QQ20240501-135743@2x.png" class="">
<p>没有纹理的地方做匹配，没有匹配的地方？<br>原因：窗口太小，没有获得足够的纹理信息。</p>
<p>窗口大小的影响：<br><img src="/2024/04/29/16-24-21/QQ20240501-135937@2x.png" class=""><br>显示的是视差图</p>
<ul>
<li>小窗口，获得了树干信息</li>
<li>大窗口，树干和背景融合到了一起</li>
</ul>
<h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>单一固体中：<br>左图中的点 $a,b,c$，在右图中有相同的顺序$a,b,c$。</p>
<p>例外：在一个透明的表面<br><img src="/2024/04/29/16-24-21/QQ20240501-140403@2x.png" class=""><br>顺序会改变</p>
<p>例外：狭窄的遮挡<br><img src="/2024/04/29/16-24-21/QQ20240501-140508@2x.png" class=""></p>
<p>立体的最新技术:<br>优化算法的两种方法：</p>
<ol>
<li>一次扫描一条线</li>
<li>在二维图像中，多扫描一条垂直的线</li>
</ol>
<h4 id="动态规划公式"><a href="#动态规划公式" class="headerlink" title="动态规划公式"></a>动态规划公式</h4><img src="/2024/04/29/16-24-21/QQ20240501-141156@2x.png" class="">
<p>假设已知左上角像素在右图中对应的位置。</p>
<ul>
<li>一对一：两个图中像素点都存在</li>
<li>左遮挡：左图可见，而右图不可见<br>左边的像素被映射到右边同一像素位置，所以看不见</li>
<li>右遮挡：相似</li>
</ul>
<h4 id="立体相似度"><a href="#立体相似度" class="headerlink" title="立体相似度"></a>立体相似度</h4><p>什么是一个好的立体相似：</p>
<ol>
<li>数据质量</li>
<li>平滑度，相邻像素差异最小<img src="/2024/04/29/16-24-21/QQ20240501-141943@2x.png" class="">
Data term:  $E_\text{ data }=\sum_i\left(W_1(i)-W_2(i+D(i))\right)^2$<br>Smoothness term: $E_\text{ smooth }=\sum_{\text{ neighbors }i,j}\rho\left(D(i)-D(j)\right)$</li>
</ol>
<p>Total energy：$E = \alpha E_{_{\mathrm{data}}}(I_{_1},I_{_2},D)+ \beta E_{_{\mathrm{smooth}}}(D)$</p>
<p>找到一个使总体能量最小的参数。</p>
<p>更好的算法：<br>将图分割算法应用到立体相似处理。</p>
<h2 id="外置相机校准"><a href="#外置相机校准" class="headerlink" title="外置相机校准"></a>外置相机校准</h2><h4 id="几何相机标准"><a href="#几何相机标准" class="headerlink" title="几何相机标准"></a>几何相机标准</h4><p>两个方面：</p>
<ol>
<li>任何的世界坐标系</li>
<li>从3D到2D的相机坐标系<img src="/2024/04/29/16-24-21/QQ20240501-142833@2x.png" class="">
从世界坐标系转换到相机坐标系</li>
</ol>
<h4 id="刚体变换"><a href="#刚体变换" class="headerlink" title="刚体变换"></a>刚体变换</h4><p>刚体有6个自由度：<br><img src="/2024/04/29/16-24-21/QQ20240501-143138@2x.png" class=""></p>
<ol>
<li>一个点可以定位刚体：$(x,y,z)$，三个自由度</li>
<li>加一个点，在矢量方向，经纬度，加两个自由度</li>
<li>可以旋转，加一个自由度</li>
</ol>
<h4 id="符号-F-amp-P"><a href="#符号-F-amp-P" class="headerlink" title="符号 F&amp;P"></a>符号 F&amp;P</h4><img src="/2024/04/29/16-24-21/QQ20240501-143635@2x.png" class="">
<p>$^AP=\left(\begin{array}{c}^Ax\\^Ay\\^Az\\\end{array}\right)\Leftrightarrow\overline{OP}=\left(\begin{array}{c}^Ax\cdot\overline{i}\\\end{array}\right)+\left(\begin{array}{c}^Ay\cdot\overline{j}\\\end{array}\right)+\left(\begin{array}{c}^Az\cdot\overline{k}\\\end{array}\right)$</p>
<ul>
<li>上标代表所在坐标系</li>
</ul>
<img src="/2024/04/29/16-24-21/QQ20240501-143832@2x.png" class="">
<p>坐标转换：已知了两个坐标原点之间的向量<br>$^BP=^AP+^B\left(O_A\right)$<br>或<br>$^BP=2^B\left(O_A\right)+2^AP$<br>就是向量加法</p>
<p>齐次坐标法：<br>\begin{split}\left[\begin{array}{c}^BP\\1\end{array}\right]=\left[\begin{array}{cc}K^BO_A\\0^T&amp;1\end{array}\right]\left[\begin{array}{c}^AP\\1\end{array}\right]\end{split}</p>
<p>变换可逆</p>
<h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><img src="/2024/04/29/16-24-21/QQ20240501-144200@2x.png" class="">
<p>坐标原点重合<br>$\overrightarrow{OP}=\begin{pmatrix}i_A&amp;&amp;j_A&amp;&amp;k_A\end{pmatrix}\left(\begin{array}{c}A\\X\\\\A\\y\\\\A\\z\end{array}\right)=\begin{pmatrix}i_B&amp;&amp;j_B&amp;&amp;k_B\end{pmatrix}\left(\begin{array}{c}B\\X\\\\B\\z\end{array}\right)$</p>
<p>转换公式：基变换</p>
<p>$^BP=_A^BR^AP$<br>$_A^BR$: 在B的坐标系中描述A</p>
<p>旋转不可交换</p>
<h4 id="刚体变换-1"><a href="#刚体变换-1" class="headerlink" title="刚体变换"></a>刚体变换</h4><img src="/2024/04/29/16-24-21/QQ20240501-144753@2x.png" class="">
<p>$^BP=\frac BAR^AP+^BO_A$<br>将坐标点旋转到B坐标系，加上加上A坐标系在B坐标系中的偏移量。</p>
<p>从世界坐标到相机坐标的转换：<br><img src="/2024/04/29/16-24-21/QQ20240501-145316@2x.png" class=""></p>
<h2 id="相机内部校准"><a href="#相机内部校准" class="headerlink" title="相机内部校准"></a>相机内部校准</h2><p>从3D相机坐标到2D图像坐标</p>
<h4 id="实际的参数"><a href="#实际的参数" class="headerlink" title="实际的参数"></a>实际的参数</h4><img src="/2024/04/29/16-24-21/QQ20240501-145813@2x.png" class="">
<p>\begin{split}&amp;u = \alpha \frac{x}{z}-\alpha \cot(\theta ) \frac{y}{z}+u_{_0}\\&amp;\nu=\frac\beta{\sin(\theta)}\quad\frac{y}z+\nu_0\end{split}</p>
<ul>
<li>光学中心不在图像中间</li>
<li>坐标系不垂直</li>
<li>长宽像素缩放比不相同</li>
</ul>
<p>改善转换方程：<br>齐次坐标法：</p>
<p>\begin{split}<br>\begin{pmatrix}z^*u\\\\z^*\\\\nu\\\\z\end{pmatrix}=\begin{pmatrix}\alpha&amp;-\alpha\cot(\theta)&amp;u_0&amp;0\\\\0&amp;\frac{\beta}{\sin(\theta)}&amp;\nu_0&amp;0\\\\0&amp;0&amp;1&amp;0\end{pmatrix}\begin{pmatrix}x\\\\y\\\\z\\\\1\end{pmatrix}\\\vec{p^{\prime}}=K^c\vec{p}<br>\end{split}</p>
<p>5个自由度：<br><img src="/2024/04/29/16-24-21/QQ20240501-150253@2x.png" class=""></p>
<h4 id="结合内部参数和外部参数"><a href="#结合内部参数和外部参数" class="headerlink" title="结合内部参数和外部参数"></a>结合内部参数和外部参数</h4><img src="/2024/04/29/16-24-21/QQ20240501-150413@2x.png" class="">
<h4 id="相机的全部参数"><a href="#相机的全部参数" class="headerlink" title="相机的全部参数"></a>相机的全部参数</h4><p>11个自由度：<br><img src="/2024/04/29/16-24-21/QQ20240501-150520@2x.png" class=""></p>
<h2 id="使用光谱校准相机"><a href="#使用光谱校准相机" class="headerlink" title="使用光谱校准相机"></a>使用光谱校准相机</h2><h4 id="校准方法"><a href="#校准方法" class="headerlink" title="校准方法"></a>校准方法</h4><p>利用已知点进行校准</p>
<p>切割法校准：<br>获取一些已知点，建立世界坐标系，测量设置点的坐标在世界中的相对位置，然后回恢复校准坐标。</p>
<h4 id="齐次校准"><a href="#齐次校准" class="headerlink" title="齐次校准"></a>齐次校准</h4><img src="/2024/04/29/16-24-21/QQ20240501-151052@2x.png" class="">
<p>坐标系下的直线校准：<br><img src="/2024/04/29/16-24-21/QQ20240502-121531@2x.png" class=""></p>
<p><strong>SVD分解</strong>:奇异值分解</p>
<img src="/2024/04/29/16-24-21/QQ20240502-121634@2x.png" class="">
<img src="/2024/04/29/16-24-21/QQ20240502-121827@2x.png" class="">
<p>非齐次方法</p>
<h2 id="误差函数"><a href="#误差函数" class="headerlink" title="误差函数"></a>误差函数</h2><p>$\text{minimize }E=\sum_id(x_i^\prime,\hat{x}_i^\prime)$</p>
<p>如果有复杂的映射：<br>$\min_\mathbf{M}\sum_id(x_i^{\prime},\mathbf{MX}_i)$<br>用参数$M$修正</p>
<h4 id="黄金标准算法："><a href="#黄金标准算法：" class="headerlink" title="黄金标准算法："></a>黄金标准算法：</h4><p>标准归一化：<br>$\tilde{\mathbf{X}}_i=\mathbf{U}\mathbf{X}_i\tilde{\mathbf{x}}_i=\mathbf{T}\mathbf{x}_i$</p>
<p>$\min_\mathbf{M}\sum_id\left(\tilde{\mathbf{x}}_i,\tilde{\mathbf{M}}\tilde{\mathbf{X}}_i\right)$</p>
<p>$\mathbf{M}=\mathbf{T}^{-1}\tilde{\mathbf{M}}\mathbf{U}$</p>
<p>类似特征向量，转换为标准正交基上</p>
<h4 id="从M中找3D相机中心"><a href="#从M中找3D相机中心" class="headerlink" title="从M中找3D相机中心"></a>从M中找3D相机中心</h4><p>直接的方法：<br>如果能找到一个点$C$， 使得$\textbf{M C = 0}$，就是相机中心。<br>原理：<br>$\mathbf{X}=\lambda\mathbf{P}+(1-\lambda)\mathbf{C}$<br>$\mathbf{x}=\mathbf{M}\mathbf{X}=\lambda\mathbf{M}\mathbf{P}+(1-\lambda)\mathbf{M}\mathbf{C}$</p>
<p>简单的方法：<br>$\mathbf{C}=\begin{pmatrix}-\mathbf{Q}^{-1}\mathbf{b}\\\\1\end{pmatrix}$</p>
<h4 id="多平面校准"><a href="#多平面校准" class="headerlink" title="多平面校准"></a>多平面校准</h4><p>目前最常使用的：</p>
<p>优点：</p>
<ol>
<li>只需要一张纸</li>
<li>不需要知道相机内部参数</li>
<li>代码是公开的</li>
</ol>
<h2 id="多视角"><a href="#多视角" class="headerlink" title="多视角"></a>多视角</h2><h4 id="图像到图像投影"><a href="#图像到图像投影" class="headerlink" title="图像到图像投影"></a>图像到图像投影</h4><p>2D变换：<br><img src="/2024/04/29/16-24-21/QQ20240502-123620@2x.png" class=""></p>
<p>特殊投影变换：<br>变换：<br><img src="/2024/04/29/16-24-21/QQ20240502-123832@2x.png" class=""></p>
<p>刚体变换：<br><img src="/2024/04/29/16-24-21/QQ20240502-123903@2x.png" class=""></p>
<p>相似变换：<br><img src="/2024/04/29/16-24-21/QQ20240502-123927@2x.png" class=""></p>
<p>仿射变换：Affine transform<br><img src="/2024/04/29/16-24-21/QQ20240502-123942@2x.png" class=""></p>
<p>一般投影变换：<br><img src="/2024/04/29/16-24-21/QQ20240502-124130@2x.png" class=""></p>
<h2 id="马赛克"><a href="#马赛克" class="headerlink" title="马赛克"></a>马赛克</h2><p>平面图：<br><img src="/2024/04/29/16-24-21/QQ20240502-124454@2x.png" class=""><br>射线上任一点，投影到平面上，都是交点重合。</p>
<h4 id="图像重影"><a href="#图像重影" class="headerlink" title="图像重影"></a>图像重影</h4><p>相机中心相同，拍摄了两张照片：<br><img src="/2024/04/29/16-24-21/QQ20240502-124653@2x.png" class=""></p>
<p>全景图像：<br>保存相机中心不变，移动水平角度，拍摄照片，重合起来就是全景图像。</p>
<p>自然几何：<br><img src="/2024/04/29/16-24-21/QQ20240502-125002@2x.png" class=""><br>将图像投影到大平面上，组成全景图像，重叠部分混合。</p>
<p>相同位置的不同坐标：<br><img src="/2024/04/29/16-24-21/QQ20240502-125348@2x.png" class=""></p>
<p>关键是求解：<br><img src="/2024/04/29/16-24-21/QQ20240502-125433@2x.png" class=""></p>
<p>转换图像(图像扭曲)：是一种插值<br><img src="/2024/04/29/16-24-21/QQ20240502-125553@2x.png" class=""></p>
<p>全景图像方法：可以用于去除图像中元素<br><img src="/2024/04/29/16-24-21/QQ20240502-125804@2x.png" class=""></p>
<h4 id="3D图像"><a href="#3D图像" class="headerlink" title="3D图像"></a>3D图像</h4><img src="/2024/04/29/16-24-21/QQ20240502-125917@2x.png" class="">
<h4 id="两种图像扭曲方法"><a href="#两种图像扭曲方法" class="headerlink" title="两种图像扭曲方法"></a>两种图像扭曲方法</h4><p>向前扭曲：错误方式<br><img src="/2024/04/29/16-24-21/QQ20240502-130407@2x.png" class=""></p>
<p>像素离散化时，某一点的像素位置移动了，需要分散给其他像素。<br><img src="/2024/04/29/16-24-21/QQ20240502-130543@2x.png" class=""></p>
<p>反向扭曲：<br><img src="/2024/04/29/16-24-21/QQ20240502-130652@2x.png" class=""></p>
<p>中间像素的插值法：<br><img src="/2024/04/29/16-24-21/QQ20240502-130719@2x.png" class=""></p>
<h2 id="投影几何"><a href="#投影几何" class="headerlink" title="投影几何"></a>投影几何</h2><p>基本平面知识</p>
<h2 id="基本矩阵"><a href="#基本矩阵" class="headerlink" title="基本矩阵"></a>基本矩阵</h2><img src="/2024/04/29/16-24-21/QQ20240502-131351@2x.png" class="">
<img src="/2024/04/29/16-24-21/QQ20240502-131523@2x.png" class="">
<img src="/2024/04/29/16-24-21/QQ20240502-131532@2x.png" class="">
<h2 id="基础矩阵"><a href="#基础矩阵" class="headerlink" title="基础矩阵"></a>基础矩阵</h2><h4 id="弱校准"><a href="#弱校准" class="headerlink" title="弱校准"></a>弱校准</h4><img src="/2024/04/29/16-24-21/QQ20240502-131844@2x.png" class="">
<img src="/2024/04/29/16-24-21/QQ20240502-131901@2x.png" class="">
<img src="/2024/04/29/16-24-21/QQ20240502-131918@2x.png" class="">
]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>计算机视觉，图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>Ud810 Intro-to-cv 笔记汇总</title>
    <url>/2024/04/27/08-42-03/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.04.27：初稿</li>
</ul>
<h2 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h2><ul>
<li><a href="/2024/04/27/08-38-57/" title="计算机视觉概论 什么是计算机视觉">计算机视觉概率笔记-第一章 什么是计算机视觉</a></li>
<li><a href="/2024/04/27/09-07-10/" title="计算机视觉概论 计算机视觉的图像处理">计算机视觉概率笔记-第二章 计算机视觉的图像处理</a></li>
<li><a href="/2024/04/29/16-24-21/" title="计算机视觉概论 相机和图像">计算机视觉概率笔记-第三章 相机和图像</a></li>
<li><a href="/2024/05/02/13-20-59/" title="计算机视觉概论 图像特征">计算机视觉概率笔记-第四章 图像特征</a></li>
<li><a href="/2024/05/03/12-11-15/" title="计算机视觉概论 光反射成像，亮度，阴影">计算机视觉概率笔记-第四章 图像</a>
</li>
</ul>
<h2 id="课程简介"><a href="#课程简介" class="headerlink" title="课程简介"></a>课程简介</h2><ol>
<li>介绍</li>
<li>计算机视觉的图像处理</li>
<li>相机和相机模型的几何结构以及多视角</li>
<li>图像特征与匹配</li>
<li>图像如何形成，光与纹理，传感器如何形成图像</li>
<li>图像运动序列</li>
<li>图像运动跟踪</li>
<li>分类和识别</li>
<li>计算机视觉简单的模式识别 </li>
<li>人类视觉系统-生物方向</li>
</ol>
<h2 id="课程PPT，作业"><a href="#课程PPT，作业" class="headerlink" title="课程PPT，作业"></a>课程PPT，作业</h2><p>链接：<a href="https://docs.google.com/spreadsheets/d/1ecUGIyhYOfQPi3HPXb-7NndrLgpX_zgkwsqzfqHPaus/pubhtml">UD810</a></p>
]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>计算机视觉，图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>00-深度学习预告</title>
    <url>/2024/04/23/11-01-00/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.04.24：初稿</li>
</ul>
<h2 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h2><ul>
<li><a href="/2024/04/24/12-18-34/" title="动手学深度学习笔记汇总">动手学深度学习笔记汇总</a>
</li>
</ul>
<h2 id="00-预告"><a href="#00-预告" class="headerlink" title="00-预告"></a>00-预告</h2><h3 id="1-学习深度学习关键是动手"><a href="#1-学习深度学习关键是动手" class="headerlink" title="1. 学习深度学习关键是动手"></a>1. 学习深度学习关键是动手</h3><ul>
<li>深度学习是人工智能最热的领域</li>
<li>核心是神经网络</li>
<li>神经网络是一门语言</li>
<li><p>应该像学习Python/C++一样学习深度学习</p>
<h3 id="2-参考书目《动手学深度学习》"><a href="#2-参考书目《动手学深度学习》" class="headerlink" title="2. 参考书目《动手学深度学习》"></a>2. 参考书目《动手学深度学习》</h3></li>
<li><p>是一本深度学习的教科书</p>
<ul>
<li><p>覆盖90年代至今的重要模型</p>
</li>
<li><p>每一章是一个Jupyter记事本</p>
<ul>
<li>提供所有模型的完整实现</li>
<li>在真实数据上运行</li>
</ul>
</li>
<li><p><strong>原书链接</strong>：<a href="https://zh.d2l.ai/">动手学深度学习(原书中文版)</a></p>
</li>
<li><p><strong>项目链接</strong>：<a href="https://github.com/d2l-ai/d2l-zh">Github项目</a></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>英文版：2019年推出<br>重写了所有章节</p>
<ul>
<li>加入50%新内容(如Transformer)<br>Numpy/MXNet, Pytorch和TensorFlow2.0的代码实现</li>
</ul>
</li>
</ul>
<ul>
<li>课程对应网站：<a href="https://courses.d2l.ai/zh-v2/">课程主页</a>(包含原视频<strong>课件</strong>等资源)</li>
</ul>
<ul>
<li>b站<strong>视频</strong>网站：<a href="https://space.bilibili.com/1567748478/channel/seriesdetail?sid=358497">视频合集</a></li>
</ul>
<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h3><ul>
<li>如何学习深度学习——动手跑代码</li>
<li>课程资源：书籍、视频、课件等</li>
</ul>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>01-深度学习课程安排</title>
    <url>/2024/04/23/11-01-01/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.04.24：初稿</li>
</ul>
<h2 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h2><ul>
<li><a href="/2024/04/24/12-18-34/" title="动手学深度学习笔记汇总">动手学深度学习笔记汇总</a>
</li>
</ul>
<h2 id="01-课程安排"><a href="#01-课程安排" class="headerlink" title="01-课程安排"></a>01-课程安排</h2><h3 id="1-课程目标"><a href="#1-课程目标" class="headerlink" title="1. 课程目标"></a>1. 课程目标</h3><ul>
<li>介绍深度学习经典和最新模型<ul>
<li>LeNet, ResNet, LSTM, BERT, …</li>
</ul>
</li>
<li>机器学习基础<ul>
<li>损失函数、目标函数、过拟合、优化</li>
</ul>
</li>
<li>实践<ul>
<li>使用Pytorch实现介绍的知识点</li>
<li>在真实数据上体验算法效果</li>
</ul>
</li>
</ul>
<h3 id="2-内容"><a href="#2-内容" class="headerlink" title="2. 内容"></a>2. 内容</h3><blockquote>
<p>深度学习基础：线性神经网络，多层感知机</p>
<p>卷积神经网络：LeNet, AlexNet, VGG, Inception, ResNet</p>
<p>循环神经网络：RNN，GRU，LSTM，seq2seq</p>
<p>注意力机制：Attention， Transformer</p>
<p>优化算法：SGD，Momentum，Adam</p>
<p>高性能计算：并行，多GPU，分布式</p>
<p>计算机视觉：目标检测，语义分割</p>
<p>自然语言处理：词嵌入，BERT</p>
</blockquote>
<h3 id="3-学到什么"><a href="#3-学到什么" class="headerlink" title="3. 学到什么"></a>3. 学到什么</h3><ul>
<li>What：深度学习有哪些技术，以及哪些技术可以帮你解决问题</li>
<li>How：如何实现（产品 or paper）和调参（精度or速度）</li>
<li>Why：背后的原因（直觉、数学）</li>
</ul>
<h3 id="4-基本要求"><a href="#4-基本要求" class="headerlink" title="4. 基本要求"></a>4. 基本要求</h3><ul>
<li><strong>AI相关从业人员</strong>（产品经理等）：掌握What，知道名词，能干什么</li>
<li><strong>数据科学家、工程师</strong>：掌握What、How，手要快，能出活</li>
<li><strong>研究员、学生</strong>：掌握What、How、Why，除了知道有什么和怎么做，还要知道为什么，思考背后的原因，做出新的突破</li>
</ul>
<h3 id="5-课程资源"><a href="#5-课程资源" class="headerlink" title="5. 课程资源"></a>5. 课程资源</h3><ul>
<li>课程主页：<a href="https://courses.d2l.ai/zh-v2/">https://courses.d2l.ai/zh-v2/</a></li>
<li>教材：<a href="https://zh-v2.d2l.ai/">https://zh-v2.d2l.ai/</a></li>
<li>课程论坛讨论：<a href="https://discuss.d2l.ai/c/chinese-version/16">https://discuss.d2l.ai/c/chinese-version/16</a></li>
<li>Pytorch论坛：<a href="https://discuss.pytorch.org/">https://discuss.pytorch.org/</a></li>
<li>b站视频合集：[<a href="https://space.bilibili.com/1567748478/channel/seriesdetail?sid=358497](">https://space.bilibili.com/1567748478/channel/seriesdetail?sid=358497](</a></li>
</ul>
<h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h3><ul>
<li>课程目标、内容和要求</li>
<li>相关课程资源链接</li>
</ul>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机视觉概论 计算机视觉的图像处理</title>
    <url>/2024/04/27/09-07-10/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.04.27：初稿</li>
</ul>
<h2 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h2><ul>
<li><a href="/2024/04/27/08-42-03/" title="Ud810 Intro-to-cv 笔记汇总">计算机视觉概率-笔记汇总</a>
</li>
</ul>
<h2 id="图像作为函数"><a href="#图像作为函数" class="headerlink" title="图像作为函数"></a>图像作为函数</h2><h4 id="理解图像函数"><a href="#理解图像函数" class="headerlink" title="理解图像函数"></a>理解图像函数</h4><img src="/2024/04/27/09-07-10/QQ20240427-092957@2x.png" class="">
<p>通常我们认为图像就是看到的东西，实际上，图像是一个函数$I(x, y)$，值为像素值。</p>
<img src="/2024/04/27/09-07-10/QQ20240427-093048@2x.png" class="">
<p>上面两种形式是一个相同的函数，只是展示方式不同。</p>
<p>对图像做平滑处理，函数变为：<br><img src="/2024/04/27/09-07-10/QQ20240427-093326@2x.png" class=""></p>
<p>对图像做模糊处理，函数变为：<br><img src="/2024/04/27/09-07-10/QQ20240427-093357@2x.png" class=""></p>
<h4 id="图像函数"><a href="#图像函数" class="headerlink" title="图像函数"></a>图像函数</h4><p>$f(x, y)$：是图像在点$(x, y)$处的光强度或值<br>限制$x$,$y$的范围，以及强度的范围：$f:[a, b] x[c, d] \rightarrow[\min , \max ]$</p>
<blockquote>
<p>图像定义：$x$为列，$y$为行, 原点在图像左上角</p>
</blockquote>
<p>图像范围不是0-255，而是0-1，0为黑，1为白，最小值为黑色，最大值为白色，甚至可以存在负值图像。</p>
<blockquote>
<p>黑白定义来源光的强度，值越大，强度越高，为白色</p>
</blockquote>
<p>彩色图像：</p>
<p>\begin{split}<br>f(x, y)=\left[\begin{array}{l}<br>r(x, y) \\<br>g(x, y) \\<br>b(x, y)<br>\end{array}\right]<br>\end{split}</p>
<p>每个像素为一个向量，RGB：值分别为，红，绿，蓝的颜色强度。</p>
<h4 id="真实的菲利斯"><a href="#真实的菲利斯" class="headerlink" title="真实的菲利斯"></a>真实的菲利斯</h4><img src="/2024/04/27/09-07-10/QQ20240427-095451@2x.png" class="">
<p>这与眼睛看到的图像是相同的函数。</p>
<h4 id="数字图像"><a href="#数字图像" class="headerlink" title="数字图像"></a>数字图像</h4><p>Sample：采样，对2D图像进行采样, 即像素<br>Quantize：量化，用一个有限数量的位数来表示它</p>
<blockquote>
<p>量化使用浮点图像？</p>
</blockquote>
<img src="/2024/04/27/09-07-10/QQ20240427-095943@2x.png" class="">
<p>图像由$(x,y)$确定，而计算中的$(i,j)$，为行，列值，与$x$,$y$，相反。</p>
<p>有时图像也可用一维信号表示。</p>
<h4 id="图像是矩阵存储"><a href="#图像是矩阵存储" class="headerlink" title="图像是矩阵存储"></a>图像是矩阵存储</h4><blockquote>
<p>课程使用的MATLAB，目前多使用OpenCV，所以不记笔记。</p>
</blockquote>
<h4 id="图像噪声"><a href="#图像噪声" class="headerlink" title="图像噪声"></a>图像噪声</h4><p>$\vec{I}^{\prime}(x, y)=\vec{I}(x, y)+\vec{\eta}(x, y)$</p>
<img src="/2024/04/27/09-07-10/QQ20240427-100924@2x.png" class="">
<p>椒盐噪声: 产生黑白像素点</p>
<img src="/2024/04/27/09-07-10/QQ20240427-101112@2x.png" class="">
<p>脉冲噪声: 产生白色像素点</p>
<img src="/2024/04/27/09-07-10/QQ20240427-101206@2x.png" class="">
<p>高斯噪声或正态分布噪声: 产生某些正态分布或某些高斯分布独立同分布的值</p>
<h4 id="Sigma-对高斯噪声的影响"><a href="#Sigma-对高斯噪声的影响" class="headerlink" title="Sigma 对高斯噪声的影响"></a>Sigma 对高斯噪声的影响</h4><img src="/2024/04/27/09-07-10/QQ20240427-101547@2x.png" class="">
<p>不同sigma的图像函数。</p>
<ul>
<li>噪声有什么意思？<br>“零”<br>对于负值图像，错误的想法是0是黑色，255是白色，黑色白色，只是值范围内的最小值与最大值，0代表的是两者之间，灰色。非常小的sigma，是一个恒灰函数。</li>
<li>不同的sigma对应不同的图像值范围，(0-255), sigma5是合理的。</li>
</ul>
<h2 id="过滤和噪声"><a href="#过滤和噪声" class="headerlink" title="过滤和噪声"></a>过滤和噪声</h2><h4 id="如何过滤高斯噪声"><a href="#如何过滤高斯噪声" class="headerlink" title="如何过滤高斯噪声"></a>如何过滤高斯噪声</h4><p>采用平滑图像，在一维像素中，周围像素平均值设置为当前像素值，可以消除噪声。</p>
<h4 id="平均值的假设"><a href="#平均值的假设" class="headerlink" title="平均值的假设"></a>平均值的假设</h4><ul>
<li>真实像素值可能与周围像素值相近</li>
<li>每个像素的噪声相互独立<br>意味着如果取噪声的平均值，噪声将为0</li>
</ul>
<h4 id="加权移动平均线"><a href="#加权移动平均线" class="headerlink" title="加权移动平均线"></a>加权移动平均线</h4><img src="/2024/04/27/09-07-10/QQ20240427-103425@2x.png" class="">
<p>非均匀权重：距离像素越近，权重越大，可以使图像更平滑。</p>
<h4 id="2D-移动平均线"><a href="#2D-移动平均线" class="headerlink" title="2D 移动平均线"></a>2D 移动平均线</h4><img src="/2024/04/27/09-07-10/1.png" class="">
<p>简单的平均权重</p>
<img src="/2024/04/27/09-07-10/QQ20240427-103933@2x.png" class="">
<p>移动平均之后的结果</p>
<h4 id="相关过滤"><a href="#相关过滤" class="headerlink" title="相关过滤"></a>相关过滤</h4><p>上述过滤为统一权重过滤，公式为：<br>核的size： 2 * k + 1；</p>
<p>$G[i, j]=\frac{1}{(2 k+1)^2} \sum_{u=-k}^k \sum_{v=-k}^k F[i+u, j+v]$</p>
<p>非均值权重的公式为：<br>$G[i, j]=\sum_{u=-k}^k \sum_{v=-k}^k H[u, v] F[i+u, j+v]$</p>
<h4 id="平均滤波器"><a href="#平均滤波器" class="headerlink" title="平均滤波器"></a>平均滤波器</h4><img src="/2024/04/27/09-07-10/QQ20240427-104618@2x.png" class="">
<p>均值平滑后的结果：<br><img src="/2024/04/27/09-07-10/QQ20240427-104655@2x.png" class=""></p>
<p>效果不好的原因：<br>  如果一个两点失去了焦点，看起来就像是：<br><img src="/2024/04/27/09-07-10/QQ20240427-104815@2x.png" class=""></p>
<h4 id="高斯过滤"><a href="#高斯过滤" class="headerlink" title="高斯过滤"></a>高斯过滤</h4><p>高斯函数：<br><img src="/2024/04/27/09-07-10/QQ20240427-105107@2x.png" class=""></p>
<p>高斯过滤后的图像：更加平滑<br><img src="/2024/04/27/09-07-10/QQ20240427-105212@2x.png" class=""><br>不会出现尖锐的部分</p>
<h4 id="方差与标准差"><a href="#方差与标准差" class="headerlink" title="方差与标准差"></a>方差与标准差</h4><p>sigma越大，模糊程度越高, 是高斯的高度，平方是高斯的方差。<br>关注的有两点，矩阵大小和sigma的值。<br>高斯过滤:<br>不同的sigma：<br><img src="/2024/04/27/09-07-10/QQ20240427-105612@2x.png" class=""><br>sigma越大，过滤的内容越多。</p>
<p>不同的内核大小：<br><img src="/2024/04/27/09-07-10/QQ20240427-105651@2x.png" class=""></p>
<p>内核更大，平滑效果越好，</p>
<h4 id="两种高斯直线"><a href="#两种高斯直线" class="headerlink" title="两种高斯直线"></a>两种高斯直线</h4><img src="/2024/04/27/09-07-10/QQ20240427-110026@2x.png" class="">
<ul>
<li>sigma越大，噪音越大</li>
<li>高斯过滤，相同平滑量的噪声量较小的会更加平滑</li>
</ul>
<blockquote>
<p>两个sigma对应不同阶段的参数</p>
</blockquote>
<h2 id="线性算子和卷积"><a href="#线性算子和卷积" class="headerlink" title="线性算子和卷积"></a>线性算子和卷积</h2><p>线性变换特点：可加性, 倍乘性</p>
<p>线性算子如何影响整个图像？</p>
<p>脉冲函数：<br><img src="/2024/04/27/09-07-10/QQ20240427-131003@2x.png" class=""><br>脉冲是一个很小的信号，体积为1。</p>
<p>输入一个脉冲，在黑盒中输出一个响应。<br><img src="/2024/04/27/09-07-10/QQ20240427-131216@2x.png" class=""></p>
<p>如果知道黑盒如何影响单个脉冲，就可以解释影响整个图像。</p>
<h4 id="过滤脉冲信号"><a href="#过滤脉冲信号" class="headerlink" title="过滤脉冲信号"></a>过滤脉冲信号</h4><img src="/2024/04/27/09-07-10/QQ20240427-131451@2x.png" class="">
<p>展示了脉冲过滤的翻转情况，假设中心元素为脉冲元素e。</p>
<h4 id="互相关和卷积"><a href="#互相关和卷积" class="headerlink" title="互相关和卷积"></a>互相关和卷积</h4><p><strong>互相关</strong><br>直接应用过滤器：<br>$G[i, j]=\sum_{u=-k}^k \sum_{v=-k}^k H[u, v] F[i+u, j+v]$</p>
<p>$G=H \otimes F$</p>
<p><strong>卷积</strong><br>翻转上下，左右：</p>
<blockquote>
<p>相当于先把核进行上下左右翻转，然后在应用过滤器：</p>
</blockquote>
<p>$G[i, j]=\sum_{u=-k}^k \sum_{v=-k}^k H[u, v] F[i-u, j-v]$</p>
<p>$G=H \star F$</p>
<p>翻转过程为：(*为了方便看到翻转效果)<br><img src="/2024/04/27/09-07-10/QQ20240427-132224@2x.png" class=""></p>
<img src="/2024/04/27/09-07-10/QQ20240427-132133@2x.png" class="">
<p>卷积实际是一种物理学</p>
<ul>
<li>在对称滤波器中，两种操作都是结果都是相同的</li>
<li>只有在非对称滤波器中，才能看到区别</li>
</ul>
<p><strong>卷积的性质</strong></p>
<ul>
<li>线性运算</li>
<li>结合律</li>
<li>交换律</li>
<li>单位脉冲和整个脉冲操作相同</li>
<li>微分性质<br>卷积的导数等于第一个元素的导数与第二个元素的卷积<br>$\frac\partial{\partial x}(f*g)=\frac{\partial f}{\partial x}*g$<br>边缘检测和梯度查找会用到</li>
</ul>
<h4 id="计算的复杂性和可分离性"><a href="#计算的复杂性和可分离性" class="headerlink" title="计算的复杂性和可分离性"></a>计算的复杂性和可分离性</h4><img src="/2024/04/27/09-07-10/QQ20240427-134946@2x.png" class="">
<p>乘法的操作次数需要：$N<em>N</em>W*W$</p>
<p>线性可分离核：<br><img src="/2024/04/27/09-07-10/QQ20240427-135116@2x.png" class=""><br>假设其他位置元素为0，结果为一列向量乘行向量。</p>
<p>可分离卷积操作：<br>$G=H*F=(C*R)*F=C*(R*F)$<br>乘法操作次数为：$2{\cdot}W{\cdot}N^2&lt;&lt;W^2{\cdot}N^2$</p>
<h4 id="边界问题"><a href="#边界问题" class="headerlink" title="边界问题"></a>边界问题</h4><p>过滤器会不会从边界掉下去？<br>一共有三种边界处理方式：<br><img src="/2024/04/27/09-07-10/QQ20240427-140836@2x.png" class=""></p>
<p>具体的方法：</p>
<ul>
<li><p>剪辑-clip filter<br>假设边缘是黑的，结果会让边缘变暗，因为黑色渗入了</p>
<img src="/2024/04/27/09-07-10/QQ20240427-141058@2x.png" class="">
</li>
<li><p>环绕法-wrap around<br>与傅里叶分析有关<br>假设图片一周围绕的像素与图像边缘有关：右边填充为左边的图像，上边填充为下边的图像</p>
<img src="/2024/04/27/09-07-10/QQ20240427-141413@2x.png" class="">
<p>过滤效果：</p>
<img src="/2024/04/27/09-07-10/QQ20240427-141603@2x.png" class="">
<p>图像的上边缘会泛红，来源于下边</p>
<blockquote>
<p>类似一种周期性信号，但是在图像过滤中效果不好</p>
</blockquote>
</li>
<li><p>边缘复制法-copy edge<br>填充复制图像边缘</p>
<img src="/2024/04/27/09-07-10/QQ20240427-141754@2x.png" class="">
<p>效果: 图像基本保持不变，是一个合理的结果</p>
<img src="/2024/04/27/09-07-10/QQ20240427-141927@2x.png" class=""> 
</li>
<li><p>反射法-reflect across edge<br>填充的是边缘的反射</p>
<img src="/2024/04/27/09-07-10/QQ20240427-142124@2x.png" class=""> 
<p>效果也是很好：</p>
<img src="/2024/04/27/09-07-10/QQ20240427-142207@2x.png" class=""> 
</li>
</ul>
<h4 id="联联系线性滤波器"><a href="#联联系线性滤波器" class="headerlink" title="联联系线性滤波器"></a>联联系线性滤波器</h4><p>用脉冲对图像过滤，得到的还是原图像：<br><img src="/2024/04/27/09-07-10/QQ20240427-142606@2x.png" class=""></p>
<p>使用向右移动了一位的脉冲，过滤结果：<strong>图中进行的是相关操作</strong><br><img src="/2024/04/27/09-07-10/QQ20240427-142802@2x.png" class=""></p>
<blockquote>
<p>取向左还是向右，取决于做相关还是卷积操作：</p>
</blockquote>
<p>模糊的平滑滤镜：<br><img src="/2024/04/27/09-07-10/QQ20240427-143056@2x.png" class=""></p>
<p>特殊的过滤器：(脉冲的两倍，减去模糊)<br><img src="/2024/04/27/09-07-10/QQ20240427-143220@2x.png" class=""></p>
<blockquote>
<p>锐化图像，强调差异<br>  应用：<br>  <img src="/2024/04/27/09-07-10/QQ20240427-143339@2x.png" class=""> </p>
</blockquote>
<p>非锐化滤镜:(unsharp mask)<br>类似冲洗胶片，将白光照射，得到底片的负片。</p>
<p>对应上图的锐化：底片的负片减去模糊的部分，得到的是更清晰的图片。</p>
<p>模糊的部分是不清晰的蒙版，加入图像后得到了更清晰的图像。</p>
<h4 id="其他类型的噪音与对应的非线性过滤器"><a href="#其他类型的噪音与对应的非线性过滤器" class="headerlink" title="其他类型的噪音与对应的非线性过滤器"></a>其他类型的噪音与对应的非线性过滤器</h4><p>高斯噪音与椒盐噪音<br><img src="/2024/04/27/09-07-10/QQ20240427-144017@2x.png" class=""><br>过滤的本质是从周围的像素点找一个局部平均值替换。</p>
<p>当噪音趋于0时，可以很好的过滤噪音，如果把完全随机的值加入图像，就需要其他过滤方法，比如中值过滤器。</p>
<p>中值过滤器：(median filter)<br>将中间的白色像素90，替换为中值，非线性的，不可以复原.<br><img src="/2024/04/27/09-07-10/QQ20240427-145325@2x.png" class=""> </p>
<p>对椒盐噪音效果很好：<br><img src="/2024/04/27/09-07-10/QQ20240427-145558@2x.png" class=""> </p>
<p>非线性的过滤：<br><img src="/2024/04/27/09-07-10/QQ20240427-145725@2x.png" class=""><br>有时也称为边缘保留</p>
<blockquote>
<p>相对于均值过滤，它保留了图像像素边缘非平滑。</p>
</blockquote>
<h2 id="过滤用作模式匹配"><a href="#过滤用作模式匹配" class="headerlink" title="过滤用作模式匹配"></a>过滤用作模式匹配</h2><p>归一化相关性<br>两件事：1. 对过滤器进行标准化。2.用过滤器将box内的像素变为标准差为1。</p>
<h4 id="1D-信号"><a href="#1D-信号" class="headerlink" title="1D 信号"></a>1D 信号</h4><img src="/2024/04/27/09-07-10/QQ20240427-153302@2x.png" class=""> 
<p>用所示的滤波器，对信号进行归一化相关：<br>滤波器来源于信号的某一段，在此处，归一化相关后得到峰值。</p>
<blockquote>
<p>原理，在归一化处理后的正负图像中，乘一个自己相同的滤波器，得到的值最大，负负为正。峰值处：正值与正值对齐，负值与负值对齐。</p>
</blockquote>
<p>对应于图像：<br><img src="/2024/04/27/09-07-10/QQ20240427-154142@2x.png" class=""> </p>
<p>相关后的图像函数图，在相似位置的值为峰值<br><img src="/2024/04/27/09-07-10/QQ20240427-154201@2x.png" class=""> </p>
<blockquote>
<p>解释了过滤器如何用作模式匹配。</p>
</blockquote>
<h4 id="模式识别"><a href="#模式识别" class="headerlink" title="模式识别"></a>模式识别</h4><p>简单的例子：<br><img src="/2024/04/27/09-07-10/QQ20240428-104609@2x.png" class=""> </p>
<p>使用相关性进行检测：<br><img src="/2024/04/27/09-07-10/QQ20240428-104723@2x.png" class=""> </p>
<p>最亮的点就是检测到的位置。</p>
<p>沃尔多在哪里？<br><img src="/2024/04/27/09-07-10/QQ20240428-104903@2x.png" class=""> </p>
<img src="/2024/04/27/09-07-10/QQ20240428-104923@2x.png" class="">
<p>相同的结果：找到最亮的点。</p>
<p>图像不同的情况：<br><img src="/2024/04/27/09-07-10/QQ20240428-105048@2x.png" class=""> </p>
<img src="/2024/04/27/09-07-10/QQ20240428-104923@2x.png" class="">
<blockquote>
<p>匹配错误。</p>
</blockquote>
<h2 id="边缘检测：梯度"><a href="#边缘检测：梯度" class="headerlink" title="边缘检测：梯度"></a>边缘检测：梯度</h2><p>如果事先不知道要找的图像模板，如何在图像中找到有用的信息，图像的特征。</p>
<p>简化图像：</p>
<p>图中的所有信息大多来源于边缘。</p>
<img src="/2024/04/27/09-07-10/QQ20240428-105632@2x.png" class="">
<p>边缘：<br><img src="/2024/04/27/09-07-10/QQ20240428-105718@2x.png" class=""></p>
<p>上图中分别有深度边缘，阴影边缘，颜色的边缘，形状的边缘。</p>
<img src="/2024/04/27/09-07-10/QQ20240428-105810@2x.png" class="">
<p>图中包含了纹理边缘。</p>
<p>边缘检测：<br>找出图像函数的边缘像素：<br><img src="/2024/04/27/09-07-10/QQ20240428-110004@2x.png" class=""></p>
<p>从高度函数中可以看到，急剧变化的位置就是边缘像素。</p>
<p>边缘检测的问题：</p>
<ol>
<li>边缘有多大</li>
<li>变化的范围是多少</li>
</ol>
<p><strong>导数和边缘</strong></p>
<img src="/2024/04/27/09-07-10/QQ20240428-110311@2x.png" class="">
<p>右图中的一阶导数函数图，极值点对应的就是图像边缘像素。</p>
<p><strong>什么是梯度</strong></p>
<img src="/2024/04/27/09-07-10/QQ20240428-111127@2x.png" class="">
<p>梯度是：图像变化最快的方向。大小是单位长度上变化的强度。</p>
<p>图像的梯度：$\nabla f = [\frac{\partial f}{\partial x},\frac{\partial f}{\partial y}]$</p>
<p>梯度的方向：$\theta^2=\tan^{-1}(\frac{\partial f}{\partial y}/\frac{\partial f}{\partial x})$</p>
<p>边缘变化的强度：$\left\|\nabla f\right\|=\sqrt{(\frac{\partial f}{\partial x})^2+(\frac{\partial f}{\partial y})^2}$</p>
<p>幅度检测：</p>
<p>离散梯度：（在离散数中，极限无法靠近，只能使用有限差分）<br>定义为：<br>\begin{split}<br>\frac{\partial f\left(x,y\right)}{\partial x}&amp;\approx\frac{f\left(x+1,y\right)-f\left(x,y\right)}1\\&amp;\approx f\left(x+1,y\right)-f\left(x,y\right)<br>\end{split}</p>
<p>梯度是对$x$，还是$y$做偏导？<br><img src="/2024/04/27/09-07-10/QQ20240428-111919@2x.png" class=""></p>
<p>上图中可以看出，在垂直方向对x的梯度可以求出边缘像素，但是在水平方向的边缘像素效果不好。<strong>上图是一个对x的有限差分</strong><br>上图也是一个正负图，负数为黑色，正数为白色，零是灰色。</p>
<p><strong>图像的偏导数</strong><br><img src="/2024/04/27/09-07-10/QQ20240428-112419@2x.png" class=""><br>很容易可以看出：左边是对x的偏导图，右边是对y的偏导图。</p>
<p>使用的相关过滤器：</p>
<ul>
<li>对x：将右边的像素减去左边的像素，增强对比。</li>
<li>对y：有两种，取决于想让y上升还是下降</li>
</ul>
<p>离散梯度：使用运算符$H$实现<br>由公式可以得出，梯度为左边的像素减去自己的像素。<br><img src="/2024/04/27/09-07-10/QQ20240428-113714@2x.png" class=""></p>
<ul>
<li>第一种运算符：没有中间元素，且只输出了右边的梯度</li>
<li>第二种运算符：输出左边和右边的梯度平均值<br>公式推导：</li>
</ul>
<p>\begin{split}<br>\frac{\partial f\left(x,y\right)}{\partial x} \\<br>&amp;\approx\frac{1}{2}\{(f\left(x+1,y\right)-f\left(x,y\right) + f\left(x,y\right)-f\left(x - 1,y\right)\}\\<br>&amp;\approx\frac{1}{2}\{f\left(x+1,y\right)-f\left(x - 1,y\right)\}<br>\end{split}</p>
<p>经典的边缘算法：Sobel算子<br><img src="/2024/04/27/09-07-10/QQ20240428-123328@2x.png" class=""></p>
<ul>
<li>$S_x$：左右和左上右上，左下右下的方向导数。</li>
<li>$S_y$：同理</li>
</ul>
<p>梯度：$\nabla\mathbf{I}=[\mathbf{g}_\mathbf{X}\quad\mathbf{g}_\mathbf{y}]^\mathbf{T}$<br>强度：$\mathrm{g=(g_X^2+g_y^2)^{1/2}}$<br>方向：$\theta=\operatorname{atan2}(\mathfrak{g}_\mathrm{y},\mathfrak{g}_\mathrm{x})$</p>
<p>Sobel古老的例子：X windows</p>
<img src="/2024/04/27/09-07-10/QQ20240428-123839@2x.png" class="">
<blockquote>
<p>右边的图像是做了阀值化thresholded</p>
</blockquote>
<p>著名的边缘算子：<br><img src="/2024/04/27/09-07-10/QQ20240428-123955@2x.png" class=""></p>
<h4 id="现实世界"><a href="#现实世界" class="headerlink" title="现实世界"></a>现实世界</h4><p>上述算子在现实中不会起作用，噪声太多。<br><img src="/2024/04/27/09-07-10/QQ20240428-124215@2x.png" class=""><br>所以必须先处理噪音，在边缘化。</p>
<p>解决方案：平滑<br><img src="/2024/04/27/09-07-10/QQ20240428-124357@2x.png" class=""><br>山峰就是边缘像素。</p>
<p><strong>算子的线性结合性</strong><br>利用卷积的求导公式: $\frac\partial{\partial x}(f*g)=\frac{\partial f}{\partial x}*g$</p>
<img src="/2024/04/27/09-07-10/QQ20240428-124636@2x.png" class="">
<p><strong>二阶导数</strong></p>
<img src="/2024/04/27/09-07-10/QQ20240428-124732@2x.png" class="">
<blockquote>
<p>零强度的位置就是边缘像素，不需要再找峰值了</p>
</blockquote>
<h2 id="2D边缘检测"><a href="#2D边缘检测" class="headerlink" title="2D边缘检测"></a>2D边缘检测</h2><h4 id="二维高斯滤波器的导数"><a href="#二维高斯滤波器的导数" class="headerlink" title="二维高斯滤波器的导数"></a>二维高斯滤波器的导数</h4><img src="/2024/04/27/09-07-10/QQ20240428-125006@2x.png" class="">
<ul>
<li>公式：$(I\otimes g)\otimes h=I\otimes(g\otimes h)$<br>根据结合性</li>
<li>$h$: 只对x求导</li>
<li>$g$: 高斯平滑</li>
</ul>
<p>高斯滤波器的导数：<br><img src="/2024/04/27/09-07-10/QQ20240428-125509@2x.png" class=""></p>
<ul>
<li>左图：可以看出是一个相关操作,因为往右增为正方向。</li>
<li>右图：</li>
</ul>
<p>sigma的大小：<br><img src="/2024/04/27/09-07-10/QQ20240428-125956@2x.png" class=""> </p>
<p>不同的sigma对于图像边缘的影响：较小的值，有精细的特征,而较大的值仅仅检测到较大尺度的边缘。</p>
<h4 id="如何找到边缘？"><a href="#如何找到边缘？" class="headerlink" title="如何找到边缘？"></a>如何找到边缘？</h4><p>Canny算子:</p>
<ol>
<li>对高斯图像进行滤波</li>
<li>找幅度最大的方向，进行非极大值抑制，即细化操作</li>
<li>连接操作，将边缘连接起来<br>定义了两个阀值：极大阀值和极小阀值</li>
</ol>
<p>原图：<br><img src="/2024/04/27/09-07-10/QQ20240428-130730@2x.png" class=""> </p>
<p>梯度图：<br><img src="/2024/04/27/09-07-10/QQ20240428-130742@2x.png" class=""> </p>
<p>阀值处理图：消除一部分梯度够高的像素<br><img src="/2024/04/27/09-07-10/QQ20240428-130804@2x.png" class=""> </p>
<p>细化处理：(非极大值抑制)<br><img src="/2024/04/27/09-07-10/QQ20240428-130903@2x.png" class=""> </p>
<p>做法：某个局部有很多梯度点，只保留极值最高的点，抑制非极大值</p>
<p>为什么要进行细化操作：<br><img src="/2024/04/27/09-07-10/QQ20240428-131216@2x.png" class=""> </p>
<p>超过阀值的粗部分,只保留极大值，细化为一条直线。</p>
<img src="/2024/04/27/09-07-10/QQ20240428-131343@2x.png" class="">
<p>在梯度方向找到极大值</p>
<p>另一个问题：下巴的边缘没有检测出来？<br><img src="/2024/04/27/09-07-10/QQ20240428-131520@2x.png" class=""><br>阀值太高，下巴的梯度没有通过阀值。</p>
<p>Canny阀值滞后:</p>
<ol>
<li>用高阀值检测边缘,找出强边缘像素</li>
<li>连接成强边缘</li>
<li>应用低阀值找出弱边缘像素</li>
<li>把强边缘延长到弱像素上<blockquote>
<p>如果一条边缘上只有弱边缘像素，就不是一个需要的边缘<br>强边缘可能会穿过一些弱边缘像素</p>
</blockquote>
</li>
</ol>
<p>Canny 算子的结果：<br><img src="/2024/04/27/09-07-10/QQ20240428-132327@2x.png" class=""></p>
<p>什么样的边缘图是好的？取决于你想用什么样的边缘图。</p>
<h4 id="简单的二维边缘检测滤波器"><a href="#简单的二维边缘检测滤波器" class="headerlink" title="简单的二维边缘检测滤波器"></a>简单的二维边缘检测滤波器</h4><img src="/2024/04/27/09-07-10/QQ20240428-132553@2x.png" class="">
<p>偏导有多种顺序</p>
<p><strong>拉普拉斯算子</strong>用于求二阶偏导</p>
<img src="/2024/04/27/09-07-10/QQ20240428-132734@2x.png" class="">
<p>公式：$\nabla^2h^2=\frac{\partial^2f}{\partial x^2}+\frac{\partial^2f}{\partial y^2}$</p>
<ul>
<li>$\nabla^2$: 拉普拉斯算子</li>
<li>0为边缘像素</li>
</ul>
<h2 id="霍夫变换（Hough-transform）-直线"><a href="#霍夫变换（Hough-transform）-直线" class="headerlink" title="霍夫变换（Hough transform）:直线"></a>霍夫变换（Hough transform）:直线</h2><p>如何找到任意形状？</p>
<h4 id="参数模型（Parametric-model）"><a href="#参数模型（Parametric-model）" class="headerlink" title="参数模型（Parametric model）"></a>参数模型（Parametric model）</h4><p>参数模型是一个类</p>
<p>直线匹配：<br><img src="/2024/04/27/09-07-10/QQ20240428-133955@2x.png" class=""></p>
<p>边缘图：<br><img src="/2024/04/27/09-07-10/QQ20240428-133947@2x.png" class=""><br>困难：</p>
<ul>
<li>有很其他形状,多种模型</li>
<li>线不连续</li>
<li>噪音</li>
</ul>
<p>投票：</p>
<ol>
<li>每个像素点对有用模型投票</li>
<li>找出最高的模型</li>
</ol>
<blockquote>
<p>原因：有很多无效的像素点，但只要有真正的像素点投票是有效的，选出匹配的模型，就可以淘汰掉噪音。</p>
</blockquote>
<p>拟合直线的几个问题？</p>
<ol>
<li>给定一些点，哪些是一条线</li>
<li>有多少条线</li>
<li>有哪些点是属于线的</li>
</ol>
<p>霍夫变换：一种投票技术，可以解决上面的问题</p>
<ul>
<li>每个边缘点都会投票给兼容的线</li>
<li>找票数最多线</li>
<li>追踪票，可以找到属于线的点有哪些</li>
</ul>
<h4 id="霍夫空间Hough-parameter-space"><a href="#霍夫空间Hough-parameter-space" class="headerlink" title="霍夫空间Hough (parameter) space"></a>霍夫空间Hough (parameter) space</h4><img src="/2024/04/27/09-07-10/QQ20240428-135111@2x.png" class="">
<p>对于一个点$(x,y)$，穿过这个点的直线为:$y_0=mx_0+b$，$m$,$b$为任意值。<br>所以对应霍夫空间的函数为：$b^2=-x_0m^2+y_0$</p>
<blockquote>
<p>将空间中的一点，对应到霍夫空间中的一条直线</p>
</blockquote>
<img src="/2024/04/27/09-07-10/QQ20240428-135421@2x.png" class="">
<ul>
<li>霍夫空间中的交点，对应的参数，是过两点的直线</li>
<li>这就是从点中找线的方法</li>
</ul>
<p><strong>霍夫算法</strong></p>
<img src="/2024/04/27/09-07-10/QQ20240428-135710@2x.png" class="">
<p>点对应于霍夫空间中的线：</p>
<ul>
<li>每个点都对自己经过的分区投票</li>
<li>票数最多的就是线<blockquote>
<p>具有偏差</p>
</blockquote>
</li>
</ul>
<p>为了防止出现垂直直线的表示，采用极坐标法表示图像</p>
<img src="/2024/04/27/09-07-10/QQ20240428-140007@2x.png" class="">
<ul>
<li>$d$:原点到点距离</li>
<li>$\theta$: 表示到$x$轴的角度</li>
<li>$\quad x\cos\theta+y\sin\theta=d$</li>
</ul>
<blockquote>
<p>可以表示任何的直线<br>图像空间中的点是霍夫空间中的正弦曲线</p>
</blockquote>
<h4 id="基本霍夫变换算法"><a href="#基本霍夫变换算法" class="headerlink" title="基本霍夫变换算法"></a>基本霍夫变换算法</h4><p>霍夫累加器数组（收集投票的数组）：<br><img src="/2024/04/27/09-07-10/QQ20240428-140657@2x.png" class=""></p>
<p>霍夫算法：<br><img src="/2024/04/27/09-07-10/QQ20240428-140911@2x.png" class=""></p>
<p>霍夫变化的复杂性：<br>空间复杂性和时间复杂性都很大</p>
<p>直线的霍夫空间：<br>无噪音的直线<br><img src="/2024/04/27/09-07-10/QQ20240428-141342@2x.png" class=""><br>最亮的点：是像素最多的直线</p>
<p>正方形的霍夫空间：<br><img src="/2024/04/27/09-07-10/QQ20240428-141150@2x.png" class=""></p>
<h4 id="噪音对霍夫变化的影响"><a href="#噪音对霍夫变化的影响" class="headerlink" title="噪音对霍夫变化的影响"></a>噪音对霍夫变化的影响</h4><img src="/2024/04/27/09-07-10/QQ20240428-141725@2x.png" class="">
<p>峰值不明确了</p>
<p>更多的噪音：<br><img src="/2024/04/27/09-07-10/QQ20240428-141839@2x.png" class=""></p>
<h4 id="霍夫变化的扩展"><a href="#霍夫变化的扩展" class="headerlink" title="霍夫变化的扩展"></a>霍夫变化的扩展</h4><p>使用<strong>梯度</strong>优化霍夫变换算法<br><img src="/2024/04/27/09-07-10/QQ20240428-142259@2x.png" class=""></p>
<blockquote>
<p>优化的霍夫变换的地方？</p>
</blockquote>
<p>扩展二：<br>改变阀值<br>扩展三：<br>改变投票箱的大小<br>扩展四：<br>相同的操作可以用的其他形状</p>
<blockquote>
<p>课上的算法对现实是不起作用的<br>论文中的算法也是不起作用，要把故事讲得好听<br>关键是理解原理</p>
</blockquote>
<h2 id="霍夫变换（Hough-transform）-圆"><a href="#霍夫变换（Hough-transform）-圆" class="headerlink" title="霍夫变换（Hough transform）:圆"></a>霍夫变换（Hough transform）:圆</h2><p>圆的方程：$\left(x_i-a\right)^2+\left(y_i-b\right)^2=r^2$</p>
<p>圆的霍夫空间：<br><img src="/2024/04/27/09-07-10/QQ20240429-091353@2x.png" class=""></p>
<p>使用更大的投票箱：<br><img src="/2024/04/27/09-07-10/QQ20240429-091756@2x.png" class=""></p>
<h4 id="圆的霍夫变换"><a href="#圆的霍夫变换" class="headerlink" title="圆的霍夫变换"></a>圆的霍夫变换</h4><p>投票箱在3D空间中：<br><img src="/2024/04/27/09-07-10/QQ20240429-091605@2x.png" class=""></p>
<p>梯度优化：<br><img src="/2024/04/27/09-07-10/QQ20240429-092109@2x.png" class=""></p>
<ul>
<li>过这点的圆心只可能在：点和圆心的连线，即梯度垂线上</li>
<li>这样就过滤掉其他位置的圆心投票</li>
</ul>
<p>算法：<br><img src="/2024/04/27/09-07-10/QQ20240429-091847@2x.png" class=""></p>
<h4 id="投票的实用技巧"><a href="#投票的实用技巧" class="headerlink" title="投票的实用技巧"></a>投票的实用技巧</h4><ul>
<li>剪枝，不要投没用得票</li>
<li>选一个合理的投票网格<ul>
<li>太大，投的错误太多</li>
<li>太小，噪音会影响</li>
</ul>
</li>
<li>投票给临近的投票箱，类似累加器平滑</li>
<li>使用梯度优化投票</li>
</ul>
<h4 id="优点缺点"><a href="#优点缺点" class="headerlink" title="优点缺点"></a>优点缺点</h4><p>优点：</p>
<ul>
<li>每个像素投票都是独立的，不受遮挡影响</li>
<li>噪音也不影响</li>
<li>可以在单图像找多形状</li>
</ul>
<p>缺点：</p>
<ul>
<li>参数的复杂性</li>
<li>非常规形状，投票很复杂</li>
</ul>
<h2 id="广义霍夫变换"><a href="#广义霍夫变换" class="headerlink" title="广义霍夫变换"></a>广义霍夫变换</h2><h4 id="非分析模型"><a href="#非分析模型" class="headerlink" title="非分析模型"></a>非分析模型</h4><p>霍夫表：<br>用于给非规则形状投票</p>
<p>建表：<br><img src="/2024/04/27/09-07-10/QQ20240429-093857@2x.png" class=""></p>
<ul>
<li>$c$：是一个定位点</li>
<li>$r$：位移矢量</li>
<li>$\theta_1$： 梯度</li>
<li>把$r$放入由$\theta$索引的表</li>
</ul>
<p>识别：</p>
<img src="/2024/04/27/09-07-10/QQ20240429-093933@2x.png" class="">
<ul>
<li>计算边界点的梯度方向$\theta$</li>
<li>在表格中找出所有该方向的位移向量</li>
<li>给位移向量的终点投票？</li>
</ul>
<p>样例：</p>
<img src="/2024/04/27/09-07-10/QQ20240429-101040@2x.png" class="">
<p>底部的边有相同的$\theta$，但是不一样的位移，对所有的位移投票。</p>
<img src="/2024/04/27/09-07-10/QQ20240429-101252@2x.png" class="">
<p>当下这个像素点的位移图，来源于它相同$\theta$的投票，做了平移，他们公用一个索引点，最终底部的所有像素点投票得出了一条直线。</p>
<img src="/2024/04/27/09-07-10/QQ20240429-101605@2x.png" class="">
<p>这条直线中，中心的投票数是最多的，通过对另一条边做相同操作，交点为中心点。</p>
<p>算法：默认不知道方向</p>
<img src="/2024/04/27/09-07-10/QQ20240429-102147@2x.png" class="">
<p>不知道比例：<br><img src="/2024/04/27/09-07-10/QQ20240429-102238@2x.png" class=""></p>
<p><strong>识别中的应用</strong><br>基于视觉代码的索引：<br><img src="/2024/04/27/09-07-10/QQ20240429-102508@2x.png" class=""></p>
<p>生成代码块：<br><img src="/2024/04/27/09-07-10/QQ20240429-102615@2x.png" class=""><br>像素按蔟分类</p>
<p>生成特征：<br><img src="/2024/04/27/09-07-10/QQ20240429-102705@2x.png" class=""></p>
<p>生成位移投票：<br><img src="/2024/04/27/09-07-10/QQ20240429-102750@2x.png" class=""><br>在投票箱中，相同特征的投票数量就是特征的个数。<br>看轮胎投了几票</p>
<h2 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h2><p>计算视觉将图像视为数据，而不是信号，但频率分析的思想很有用。</p>
<p>basis sets：标准基(线代的定义)</p>
<p>应用到图像的标准基：<br>把图像视为非常大的空间中的点，例如一个N*N的图像，可以认为是一个一维的向量。<br>另一种做法：<br><img src="/2024/04/27/09-07-10/QQ20240429-140527@2x.png" class=""></p>
<ul>
<li>同一位置的图像：类似正弦余弦</li>
</ul>
<p>上面就是<strong>傅里叶基</strong>，递增的是频率</p>
<h4 id="正弦和"><a href="#正弦和" class="headerlink" title="正弦和"></a>正弦和</h4><p>公式：$A\sin(\omega x^2+\varphi^2)$<br>共有三个自由度：</p>
<ul>
<li>$A$：幅度</li>
<li>$\omega$：频率</li>
<li>$\varphi$：相位</li>
</ul>
<img src="/2024/04/27/09-07-10/QQ20240429-141002@2x.png" class="">
<p>频率是最重要的，频率越高，摆动速度越快</p>
<h4 id="时间和频率"><a href="#时间和频率" class="headerlink" title="时间和频率"></a>时间和频率</h4><p>$g(t)=\sin(2\pi ft)+\frac13\sin(2\pi(3f)t)$<br><img src="/2024/04/27/09-07-10/QQ20240429-141307@2x.png" class=""></p>
<p>一种绘制光谱的方式</p>
<img src="/2024/04/27/09-07-10/QQ20240429-141409@2x.png" class="">
<p>f越大，越接近方波</p>
<p>方波的正弦公式：$A\sum\limits_{k=1}^{\infty}\frac{1}{k}\sin\left(2\pi kt\right)$<br>图像：<br><img src="/2024/04/27/09-07-10/QQ20240429-141517@2x.png" class=""><br>不考虑相位</p>
<h4 id="傅里叶变换-1"><a href="#傅里叶变换-1" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h4><p>$f(x)\longrightarrow\boxed{\begin{array}{c}\text{Fourier}\\\text{Transform}\end{array}}\longrightarrow F(\omega)$</p>
<p>复数：$\begin{aligned}F\left(\omega\right)&amp;=R\left(\omega\right)+iI\left(\omega\right)\end{aligned}$<br>性质：</p>
<ul>
<li>$A = \pm\sqrt{R \left( \omega \right)^2 + I \left( \omega \right)^2}$</li>
<li>$\varphi^2=\tan^{-1}\frac{I\left(\omega\right)}{R\left(\omega\right)}$</li>
</ul>
<p>虚部是奇函数-正弦，实部是偶函数-余弦。</p>
<h4 id="计算傅里叶变换"><a href="#计算傅里叶变换" class="headerlink" title="计算傅里叶变换"></a>计算傅里叶变换</h4><p>基本性质：<br>$\int_{-\infty}^\infty\sin(ax+\phi)\sin(bx+\varphi)dx=0,\mathrm{~if~}a\neq b$</p>
<p>$\int_{-\infty}^\infty\sin(\alpha x+\phi)\sin(\alpha x+\varphi)dx=\pm\infty$</p>
<p>例子：<br>假设一个展开为余弦的函数：<br>$f\left(x\right)=\cos\left(2\pi\omega x\right)$</p>
<p>$C\left(u\right)=\int_{-\infty}^{\infty}f\left(x\right)\cos\left(2\pi ux\right)dx$</p>
<ul>
<li>如果$u == \omega$：积分为无穷</li>
<li>如果$u \neq \omega$：积分为0 </li>
</ul>
<p>得到脉冲图：<br><img src="/2024/04/27/09-07-10/QQ20240429-143042@2x.png" class=""></p>
<p>被称作与余弦对应的脉冲</p>
<p>如果是正弦，左边将会是负的脉冲：$\sin(-x) = -\sin(x)$</p>
<h4 id="傅里叶变换通用定义"><a href="#傅里叶变换通用定义" class="headerlink" title="傅里叶变换通用定义"></a>傅里叶变换通用定义</h4><p>定义：$F\left(u^2\right)=\int_{-\infty}^{\infty}f\left(x^2\right)e^{-i2\pi ux}dx$<br>其中：$e^{ik}=\text{ cos }k+i\sin k\quad i=\sqrt{-1}$</p>
<p>作用：从空间域转换到频域</p>
<p>傅里叶逆变换：$f\left(x\right)=\int_{-\infty}^\infty F\left(u\right)e^{i2\pi ux}du$<br>可以恢复信号</p>
<h4 id="频谱"><a href="#频谱" class="headerlink" title="频谱"></a>频谱</h4><p>常用频谱：<br><img src="/2024/04/27/09-07-10/QQ20240429-144050@2x.png" class=""><br>最后一个是幂频谱</p>
<p>频谱图：<br><img src="/2024/04/27/09-07-10/QQ20240429-144135@2x.png" class=""></p>
<p>局限性：<br>傅里叶级数积分有界</p>
<h4 id="傅里叶变换到傅里叶级数"><a href="#傅里叶变换到傅里叶级数" class="headerlink" title="傅里叶变换到傅里叶级数"></a>傅里叶变换到傅里叶级数</h4><p>级数：$F\left(k\right)=\frac1N\sum_{x=0}^{x=N-1}f\left(x\right)e^{-i\frac{2\pi kx}N}$</p>
<p>积分的另一种写法：离散化</p>
<h4 id="二维的傅里叶"><a href="#二维的傅里叶" class="headerlink" title="二维的傅里叶"></a>二维的傅里叶</h4><p>$F\left(u,\nu\right)=\int_{-\infty}^\infty\int_{-\infty}^\infty f\left(x,y\right)e^{-i2\pi\left(ux+\nu y\right)}dxdy\frac12$</p>
<p>离散：$F\left(k_x,k_y\right)=\frac1N\sum_{x=0}^{x=N-1}\sum_{y=0}^{y=N-1}f\left(x,y\right)e^{-i\frac{2\pi\left(k_xx+k_yy\right)}N}$</p>
<p>例子：<br>一个正弦曲线，处于特定的频率， 仅仅有垂直线组成：<br><img src="/2024/04/27/09-07-10/QQ20240429-144821@2x.png" class=""></p>
<p>右图是它的傅里叶频谱和功能谱。<br>亮点就是频率的尖峰</p>
<p>一个余弦曲线，频率更快：<br><img src="/2024/04/27/09-07-10/QQ20240429-145050@2x.png" class=""></p>
<blockquote>
<p>频率分量更高，峰值靠外</p>
</blockquote>
<p>线性：傅里叶变换是一个线性变换<br><img src="/2024/04/27/09-07-10/QQ20240429-145222@2x.png" class=""></p>
<h4 id="真实图像的光谱"><a href="#真实图像的光谱" class="headerlink" title="真实图像的光谱"></a>真实图像的光谱</h4><img src="/2024/04/27/09-07-10/QQ20240429-145348@2x.png" class="">
<blockquote>
<p>自然图像有相同的光谱<br>重建图像才需要相位<br>用部分光谱重建图像，图像的变化如右图<br>高频率：告诉边缘在哪里，高频越亮，越清晰<br>明亮线垂直于轮廓线</p>
</blockquote>
<img src="/2024/04/27/09-07-10/QQ20240429-145542@2x.png" class="">
<p>人造场景：</p>
<img src="/2024/04/27/09-07-10/QQ20240429-145613@2x.png" class="">
<p>思考：</p>
<ul>
<li>如果不是周期函数，光谱会有倾斜</li>
<li></li>
</ul>
<h2 id="频率分析中的卷积"><a href="#频率分析中的卷积" class="headerlink" title="频率分析中的卷积"></a>频率分析中的卷积</h2><h4 id="傅里叶变换与卷积"><a href="#傅里叶变换与卷积" class="headerlink" title="傅里叶变换与卷积"></a>傅里叶变换与卷积</h4><p>卷积：$g = f * h$<br>傅里叶变换：<br>\begin{split}<br>G\left(u\right)&amp;=\int_{-\infty}^{\infty}g\left(x\right)e^{-i2\pi ux}dx \\<br>&amp;=\int_{-\infty}^\infty\int_{-\infty}^\infty f\left(\tau\right)h\left(x-\tau\right)e^{-i2\pi ux}d\tau dx \\<br>&amp;=\int_{-\infty}^\infty\int_{-\infty}^\infty\left[f\left(\tau\right)e^{-i2\pi u\tau}d\tau\right]\left[h\left(x-\tau\right)e^{-i2\pi u\left(x-\tau\right)}dx\right] \\<br>&amp;=\int_{-\infty}^{\infty}\left[f\left(\tau\right)e^{-i2\pi u\tau}d\tau\right]\int_{-\infty}^{\infty}\left[h\left(x^{\prime}\right)e^{-i2\pi ux^{\prime}}dx^{\prime}\right] \\<br>&amp;=F\left(\begin{array}{c}u\\\end{array}\right)H\left(\begin{array}{c}u\\\end{array}\right)<br>\end{split}</p>
<img src="/2024/04/27/09-07-10/QQ20240429-152239@2x.png" class="">
<p><strong>空间中乘积$\Leftrightarrow$频率空间中卷积</strong></p>
<blockquote>
<p>大掩码的空间域卷积很复杂，用快速傅里叶变换可以转换为频率域乘法，避免卷积。</p>
</blockquote>
<h4 id="平滑和模糊中的应用"><a href="#平滑和模糊中的应用" class="headerlink" title="平滑和模糊中的应用"></a>平滑和模糊中的应用</h4><img src="/2024/04/27/09-07-10/QQ20240429-152734@2x.png" class="">
<img src="/2024/04/27/09-07-10/QQ20240429-152812@2x.png" class="">
<p><strong>瘦高斯的傅里叶是胖的</strong><br>原因：<br>如果高斯很瘦，就希望保留所有的频率，傅里叶就很胖。<br>高斯很胖，模糊了一切，就只保留一点点低频率，几乎没有高频率。<br>作用：<br>保存低频率，降低高频率。</p>
<blockquote>
<p>空间采样频率越低，傅里叶频率越高.<br>傅里叶的放缩原理</p>
</blockquote>
<p>效果图；<br><img src="/2024/04/27/09-07-10/QQ20240429-153249@2x.png" class=""></p>
<h4 id="傅里叶变换的性质"><a href="#傅里叶变换的性质" class="headerlink" title="傅里叶变换的性质"></a>傅里叶变换的性质</h4><img src="/2024/04/27/09-07-10/QQ20240429-153642@2x.png" class="">
<p>傅里叶对：<br><img src="/2024/04/27/09-07-10/QQ20240429-153804@2x.png" class=""></p>
<h2 id="混叠-Aliasing"><a href="#混叠-Aliasing" class="headerlink" title="混叠 Aliasing"></a>混叠 Aliasing</h2><p>傅里叶基是如何混叠的？</p>
<h4 id="脉冲串的概念"><a href="#脉冲串的概念" class="headerlink" title="脉冲串的概念"></a>脉冲串的概念</h4><p>脉冲串的傅里叶变换是另一个脉冲串<br><img src="/2024/04/27/09-07-10/QQ20240429-154529@2x.png" class=""></p>
<blockquote>
<p>空间中脉冲距离越远，频率中脉冲越接近</p>
</blockquote>
<h4 id="采样和重构"><a href="#采样和重构" class="headerlink" title="采样和重构"></a>采样和重构</h4><img src="/2024/04/27/09-07-10/QQ20240429-154812@2x.png" class="">
<p>采样是计算机如何存储连续信号提出的,如何重建原始信号？<br><img src="/2024/04/27/09-07-10/QQ20240429-154933@2x.png" class=""></p>
<p>在离散位置如何将信号连续起来。</p>
<p>样例：<br><img src="/2024/04/27/09-07-10/QQ20240429-155039@2x.png" class=""></p>
<p>采样密度不够，无法恢复图像。</p>
<p>如何防止锯齿出现？<br>过滤高频率，降低采样量。</p>
<h4 id="脉冲"><a href="#脉冲" class="headerlink" title="脉冲"></a>脉冲</h4><p>一维脉冲函数：$comb_M[x]=\sum_{k=-\infty}^{\infty}\delta[x-kM]$<br>图像：<br><img src="/2024/04/27/09-07-10/QQ20240429-155942@2x.png" class=""></p>
<p>二维脉冲函数：$comb_{M,N}(x,y)\equiv\sum_{k=-\infty}^\infty\sum_{l=-\infty}^\infty\delta\left(x-kM,y-lN\right)$<br>傅里叶变换：<br>$\sum_{k=-\infty}^n\sum_{l=-\infty}^n\delta\left(x-kM,y-lN\right)\Leftrightarrow\frac1{MN}\sum_{k=-\infty}^\infty\sum_{l=-\infty}^\infty\delta\left(u-\frac kM,\nu-\frac lN\right)$</p>
<h4 id="采样低频信号"><a href="#采样低频信号" class="headerlink" title="采样低频信号"></a>采样低频信号</h4><img src="/2024/04/27/09-07-10/QQ20240429-160402@2x.png" class="">
<p>采样：连续信号乘离散梳函数</p>
<p>如果功能频率$W$满足：$W&lt;\frac1{2M}$，就可以恢复。</p>
<blockquote>
<p>这里有一些采样定理的内容</p>
</blockquote>
<h4 id="采样高频信号"><a href="#采样高频信号" class="headerlink" title="采样高频信号"></a>采样高频信号</h4><img src="/2024/04/27/09-07-10/QQ20240429-160831@2x.png" class="">
<p>高频信号采样重叠了，采样之前，必须去处高频，以防重叠。</p>
<p>如何去处高频？<br><strong>梳状滤波器</strong><br><img src="/2024/04/27/09-07-10/QQ20240429-161033@2x.png" class=""></p>
<h4 id="图像中的重叠"><a href="#图像中的重叠" class="headerlink" title="图像中的重叠"></a>图像中的重叠</h4><p>图像缩小，如果直接丢掉行列，图像会变小。放大图像后，图像不像是缩小的图像，很模糊。</p>
<p>正确的做法是：用高斯滤波。<br><img src="/2024/04/27/09-07-10/QQ20240429-161449@2x.png" class=""><br>高斯滤波做了抗锯齿，所以效果更好。</p>
<h4 id="对比度敏感"><a href="#对比度敏感" class="headerlink" title="对比度敏感"></a>对比度敏感</h4><img src="/2024/04/27/09-07-10/QQ20240429-161728@2x.png" class="">
<p>人类的视觉对高频不敏感。</p>
<h4 id="JPEG"><a href="#JPEG" class="headerlink" title="JPEG"></a>JPEG</h4><p>DCT：离散余弦变换<br>不保留高频信息，降低图像质量时，只保存低频率信息。</p>
]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>计算机视觉，图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机视觉概论 图像特征</title>
    <url>/2024/05/02/13-20-59/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.05.02：初稿</li>
</ul>
<h2 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h2><ul>
<li><a href="/2024/04/27/08-42-03/" title="Ud810 Intro-to-cv 笔记汇总">计算机视觉概率-笔记汇总</a>
</li>
</ul>
<h2 id="特征检测"><a href="#特征检测" class="headerlink" title="特征检测"></a>特征检测</h2><p>一种寻找对应关系的方法</p>
<h4 id="图像点匹配问题"><a href="#图像点匹配问题" class="headerlink" title="图像点匹配问题"></a>图像点匹配问题</h4><p>Local Features：局部特征<br>目标：在其他图像中找到点的精确位置</p>
<p>特征匹配的过程：</p>
<ol>
<li>检测一些兴趣点(特征)</li>
<li>匹配两张图中的特征点</li>
<li>使用对应点，对齐图像</li>
</ol>
<img src="/2024/05/02/13-20-59/QQ20240502-132909@2x.png" class="">
<p>特征匹配的问题：</p>
<ol>
<li>独立的特征， 需要重复检测器</li>
<li>重复相似匹配，使用特征描述符descriptor</li>
</ol>
<h4 id="好的特征"><a href="#好的特征" class="headerlink" title="好的特征"></a>好的特征</h4><p>可重复性：Repeatability/Precision<br>好的特征应该在同一场景的不同图片中被检测出来</p>
<p>显著性/可匹配性：Saliency/Matchability<br>有不同的区分描述</p>
<p>紧凑型和效率：Compactness and efficiency<br>比图像像素更少的特征</p>
<p>局部性：Locality<br>描述具有好的局部性,可以解决遮挡</p>
<h2 id="寻找角点"><a href="#寻找角点" class="headerlink" title="寻找角点"></a>寻找角点</h2><p>一个白墙上有一个黑色方块：<br>黑块不是一个好特征，无法定位。<br>边缘也不是好特征，角是一个好特征。</p>
<img src="/2024/05/02/13-20-59/QQ20240502-142106@2x.png" class="">
<p>角是一个梯度变换的地方。</p>
<h4 id="哈里斯角-Harris-Corners"><a href="#哈里斯角-Harris-Corners" class="headerlink" title="哈里斯角 Harris Corners:"></a>哈里斯角 Harris Corners:</h4><p>$E\left(u,\nu\right)=\sum_{x,y}w\left(x,y\right)\left[I\left(x+u,y+\nu\right)-I\left(x,y\right)\right]^{2}$</p>
<ul>
<li>$w\left(x,y\right)$ 是一个窗口<img src="/2024/05/02/13-20-59/QQ20240502-142537@2x.png" class="">
</li>
</ul>
<p>哈里斯角图：</p>
<img src="/2024/05/02/13-20-59/QQ20240502-142639@2x.png" class="">
<ul>
<li>误差为0，是黑色</li>
<li>左图中红色方块是角图中心，误差为0，绿色移动后，出现误差</li>
</ul>
<p>哈里斯角在很小的移动会产生误差：<br>二阶泰勒展开：<br>$F\left(\delta x\right)\approx F\left(0\right)+\delta x\cdot\frac{dF\left(0\right)}{dx}+\frac12\delta x^2\cdot\frac{d^2F\left(0\right)}{dx^2}$</p>
<p>二维泰勒展开：<br><img src="/2024/05/02/13-20-59/QQ20240502-143009@2x.png" class=""></p>
<p>推导过程：<br>$E_u\left(u,\nu\right)=\sum_{x,y}2w\left(x,y\right)\left[I\left(x+u,y+\nu\right)-I\left(x,y\right)\right]I_x\left(x+u,y+v\right)$</p>
<p>$\begin{split}<br>E_{\textit{ u }\nu}\left(u,\nu\right)&amp; =\sum_{x,y}2w(x,y)I_y(x+u,y+v)I_x(x+u,y+v) \\<br>&amp;+\sum_{x,y}2w(x,y)\Big[I(x+u,y+v)-I(x,y)\Big]I_{xy}(x+u,y+v)<br>\end{split}$</p>
<p>$\begin{split}E_{u\nu}(u,\nu)&amp;=\sum_{x,y}2w(x,y)I_y(x+u,y+v)I_x(x+u,y+v)\\&amp;+\sum_{x,y}2w(x,y)\Big[I(x+u,y+v)-I(x,y)\Big]I_{xy}(x+u,y+v)\end{split}$</p>
<p>带入点$(0,0)$，消去得：</p>
<p>$E\left(u ,\nu\right) \approx \begin{bmatrix}u&amp;\nu\end{bmatrix} M\quad\begin{bmatrix}u\\\nu\end{bmatrix}$</p>
<p>$M=\sum_{x,y}w(x,y)\begin{bmatrix}I_x^2&amp;&amp;I_xI_y\\I_xI_y&amp;&amp;I_y^2\end{bmatrix}$</p>
<p>当没有权重$w(x,y)$时：</p>
<p>$M=\begin{bmatrix}\sum I_xI_x&amp;\sum I_xI_y\\\sum I_xI_y&amp;\sum I_yI_y\end{bmatrix}=\sum\left(\begin{bmatrix}I_x\\I_y\end{bmatrix}-\begin{bmatrix}I_x&amp;I_y\end{bmatrix}\right)=\sum\nabla I\left(\nabla I\right)^T$</p>
<p>其中$\nabla I$：是一个秩为1的列向量，所有等式右边是一个秩为1的二阶方阵。</p>
<p>? 必须让窗口内所有方向都有梯度，才可以求和后得到一个满秩矩阵？？</p>
<h4 id="解释二阶近似方程"><a href="#解释二阶近似方程" class="headerlink" title="解释二阶近似方程"></a>解释二阶近似方程</h4><p>代数表达式：椭圆方程<br>$\sum I_x^2u^2+2\sum I_xI_yu\nu+\sum I_y^2\nu^2=k$</p>
<p>椭圆图：<br><img src="/2024/05/02/13-20-59/QQ20240502-145419@2x.png" class=""></p>
<p>考虑，窗口内的梯度永远是水平或垂直，所有$I_xI_y$为0。<br>化简：<br>$M=\sum_{x,y}w(x,y)\begin{bmatrix}I_x^2&amp;&amp;I_xI_y\\I_xI_y&amp;&amp;I_y^2\end{bmatrix}=\begin{bmatrix}\lambda&amp;0\\0&amp;\lambda_2\end{bmatrix}$</p>
<p>$M$可以被相似对角化：<br>$M~=~R^{-1}\left[\begin{array}{cc}\lambda&amp;0\\0&amp;\lambda_2\end{array}\right]R$</p>
<p>特征值的作用：<br><img src="/2024/05/02/13-20-59/QQ20240502-145313@2x.png" class=""><br>在短边处：变换很快，长边处变换速度很慢，需要移动很多才有变化。</p>
<h4 id="解释特征值"><a href="#解释特征值" class="headerlink" title="解释特征值"></a>解释特征值</h4><p>计算哈里斯矩阵：<br><img src="/2024/05/02/13-20-59/QQ20240502-150536@2x.png" class=""></p>
<ul>
<li>平坦区域：flat<br>梯度为0，怎么移动都不会变化。</li>
<li>如果一个特征值特别大<br>朝这个方向的边缘移动，变换很快</li>
<li>两个特征值大小相似<br>角：在任何方向变化相同</li>
</ul>
<h4 id="哈里斯响应函数："><a href="#哈里斯响应函数：" class="headerlink" title="哈里斯响应函数："></a>哈里斯响应函数：</h4><p>$R=\det(M^2)-\alpha\mathrm{~trace}(M)^2=\lambda_1\lambda_2-\alpha(\lambda_1+\lambda_2)^2$<br>$\alpha$:特别小 0.04 to 0.06</p>
<p>$R$取决于特征值，但不需要计算特征值，<br>原因：</p>
<ul>
<li>角：两个特征值都很大，$R$正的大数</li>
<li>边：一个特征值很大,$R$是负的大数</li>
<li>平坦：$R$ 的绝对值很小</li>
</ul>
<h4 id="哈里斯函数如何工作"><a href="#哈里斯函数如何工作" class="headerlink" title="哈里斯函数如何工作"></a>哈里斯函数如何工作</h4><p>低纹理区域：<br><img src="/2024/05/02/13-20-59/QQ20240502-151651@2x.png" class=""></p>
<p>边缘区域：<br><img src="/2024/05/02/13-20-59/QQ20240502-151730@2x.png" class=""></p>
<p>高纹理区域：<br><img src="/2024/05/02/13-20-59/QQ20240502-151825@2x.png" class=""></p>
<h4 id="哈里斯检测器算法："><a href="#哈里斯检测器算法：" class="headerlink" title="哈里斯检测器算法："></a>哈里斯检测器算法：</h4><img src="/2024/05/02/13-20-59/QQ20240502-152016@2x.png" class="">
<p>例子：<br><img src="/2024/05/02/13-20-59/QQ20240502-152156@2x.png" class=""></p>
<p>响应函数图：<br><img src="/2024/05/02/13-20-59/QQ20240502-152223@2x.png" class=""></p>
<p>非极大值抑制：<br><img src="/2024/05/02/13-20-59/QQ20240502-152309@2x.png" class=""></p>
<p>局部最大值的像素点：<br><img src="/2024/05/02/13-20-59/QQ20240502-152430@2x.png" class=""></p>
<p>在原图中的位置：<br><img src="/2024/05/02/13-20-59/QQ20240502-152454@2x.png" class=""></p>
<p>最终发现很多相同的特征点。</p>
<h2 id="尺度不变性-Scale-invariance"><a href="#尺度不变性-Scale-invariance" class="headerlink" title="尺度不变性  Scale invariance"></a>尺度不变性  Scale invariance</h2><h4 id="哈里斯检测器的一些特性"><a href="#哈里斯检测器的一些特性" class="headerlink" title="哈里斯检测器的一些特性"></a>哈里斯检测器的一些特性</h4><ul>
<li>对于旋转不变</li>
<li>图像强度：加法乘法不改变<br>加法：导数不变<br>乘法：导数整体变化</li>
<li>缩放，会改变</li>
</ul>
<h4 id="尺度不变性的检测"><a href="#尺度不变性的检测" class="headerlink" title="尺度不变性的检测"></a>尺度不变性的检测</h4><img src="/2024/05/02/13-20-59/QQ20240502-153839@2x.png" class="">
<p>增大窗口，保持尺度不变</p>
<p>领域大小对函数的影响：<br><img src="/2024/05/02/13-20-59/QQ20240502-154050@2x.png" class=""><br>$S_1$, $S_2$，具有相同的缩放比例</p>
<h4 id="一个好的尺寸检测函数"><a href="#一个好的尺寸检测函数" class="headerlink" title="一个好的尺寸检测函数"></a>一个好的尺寸检测函数</h4><img src="/2024/05/02/13-20-59/QQ20240502-154434@2x.png" class="">
<img src="/2024/05/02/13-20-59/QQ20240502-154635@2x.png" class="">
<p>拉普拉斯差和高斯差几乎相同，选择高斯简化计算。</p>
<h4 id="关键点定位"><a href="#关键点定位" class="headerlink" title="关键点定位"></a>关键点定位</h4><p><strong>SIFT</strong>: Scale Invariant Feature Transform<br>尺度不变特征变换<br><img src="/2024/05/02/13-20-59/QQ20240502-154917@2x.png" class=""><br>取不同尺寸的图像，不断模糊图像，两两相减，计算他们的高斯图像差异。<br>像素与周围九个像素比较，以及不同比例邻居上的比较，的看是不是极值。</p>
<img src="/2024/05/02/13-20-59/QQ20240502-155145@2x.png" class="">
<p>例子：<br><img src="/2024/05/02/13-20-59/QQ20240502-155601@2x.png" class=""></p>
<p><strong>哈里斯-拉普拉斯算法：</strong><br>先试用哈里斯角点检测<br>然后在看尺度方向上的拉普拉斯算子，找空间极值</p>
<h2 id="特征描述"><a href="#特征描述" class="headerlink" title="特征描述"></a>特征描述</h2><p>描述符：对领域进行描述</p>
<ul>
<li>独特：不同的点有不同的描述符</li>
<li>可区分</li>
<li>几乎相同</li>
</ul>
<h3 id="SIFT-Scale-Invariant-Feature-Detection"><a href="#SIFT-Scale-Invariant-Feature-Detection" class="headerlink" title="SIFT: Scale Invariant Feature Detection"></a>SIFT: Scale Invariant Feature Detection</h3><p>尺度不变特征变换</p>
<p>思想：</p>
<ul>
<li>图像内容是一组特征：对于平移，旋转,放缩等图像处理操作是不变的</li>
<li>描述符是稳健的</li>
</ul>
<img src="/2024/05/02/13-20-59/QQ20240503-094607@2x.png" class="">
<h4 id="总体SIFT识别过程"><a href="#总体SIFT识别过程" class="headerlink" title="总体SIFT识别过程"></a>总体SIFT识别过程</h4><ol>
<li>确定关键点尺寸</li>
<li>定位关键点</li>
<li>找到领域的局部的方向</li>
<li>关键点描述</li>
</ol>
<img src="/2024/05/02/13-20-59/QQ20240503-094908@2x.png" class="">
<p>右图中的方向箭头，就是局部方向。</p>
<h4 id="计算局部方向"><a href="#计算局部方向" class="headerlink" title="计算局部方向"></a>计算局部方向</h4><img src="/2024/05/02/13-20-59/QQ20240503-095051@2x.png" class="">
<p>图中是方向直方图</p>
<p>找到一个峰值，就是主导方向，我们需要使用的方向，以这个方向为北方。</p>
<h4 id="关键点描述符"><a href="#关键点描述符" class="headerlink" title="关键点描述符"></a>关键点描述符</h4><p>标准化：<br>旋转到新的北方朝上<br>放缩到相同尺寸</p>
<p>SIFT特征向量：<br><img src="/2024/05/02/13-20-59/QQ20240503-095512@2x.png" class=""><br>右图是一个：2X2的图，最好是使用4X4的直方图，一个里面有8个方向，叠加到一起，一个特征会有128个向量<br>将所有的向量，标准化到内积为1。</p>
<p>梯度：直方图加权梯度，方向最大的权最高</p>
<p>评估SIFT描述符:<br>通常一个直方图有8个方向，采用4X4的直方图，向量长128。</p>
<h3 id="匹配特征点"><a href="#匹配特征点" class="headerlink" title="匹配特征点"></a>匹配特征点</h3><p>如何在两个图的特征中，找到匹配的特征点？</p>
<h4 id="最邻近算法匹配"><a href="#最邻近算法匹配" class="headerlink" title="最邻近算法匹配"></a>最邻近算法匹配</h4><p>best-bin-first 算法基于k-d树</p>
<img src="/2024/05/02/13-20-59/QQ20240503-101702@2x.png" class="">
<h4 id="基于小波的散列"><a href="#基于小波的散列" class="headerlink" title="基于小波的散列"></a>基于小波的散列</h4><img src="/2024/05/02/13-20-59/QQ20240503-101843@2x.png" class="">
<p>小波：是一种接近滤波器的形式，从三个滤波器里输出三个数。</p>
<p>思想类似局部敏感哈希：<br><img src="/2024/05/02/13-20-59/QQ20240503-102231@2x.png" class=""><br>考虑了空间两点的距离</p>
<h4 id="例子-3D物体识别"><a href="#例子-3D物体识别" class="headerlink" title="例子 3D物体识别"></a>例子 3D物体识别</h4><img src="/2024/05/02/13-20-59/QQ20240503-102435@2x.png" class="">
<p>从测试图中匹配：<br><img src="/2024/05/02/13-20-59/QQ20240503-102518@2x.png" class=""></p>
<h4 id="例子-遮挡下的识别"><a href="#例子-遮挡下的识别" class="headerlink" title="例子 遮挡下的识别"></a>例子 遮挡下的识别</h4><p>通过部分关键点，预测其他点去哪里了。</p>
<h2 id="鲁棒误差函数"><a href="#鲁棒误差函数" class="headerlink" title="鲁棒误差函数"></a>鲁棒误差函数</h2><p>SSD：差的平方和<br>NN: 最近邻居</p>
<h4 id="Lowe-a-better-way"><a href="#Lowe-a-better-way" class="headerlink" title="Lowe a better way"></a>Lowe a better way</h4><img src="/2024/05/02/13-20-59/QQ20240503-104558@2x.png" class="">
<p>意义：<br>如果最佳匹配被遮挡了，第一和第二匹配相差不大，说明没有找到正确的匹配。</p>
<h3 id="模型拟合"><a href="#模型拟合" class="headerlink" title="模型拟合"></a>模型拟合</h3><h4 id="最小二乘线拟合-Typical-least-squares-line-fitting"><a href="#最小二乘线拟合-Typical-least-squares-line-fitting" class="headerlink" title="最小二乘线拟合 Typical least squares line fitting"></a>最小二乘线拟合 Typical least squares line fitting</h4><p>机器学习内容<br>只是$y$方向上的拟合。</p>
<h4 id="总体最小二乘法"><a href="#总体最小二乘法" class="headerlink" title="总体最小二乘法"></a>总体最小二乘法</h4><p>$ax+by=d$<br>$E=\sum_{i=1}^n(ax_i+by_i-d)^2$<br><img src="/2024/05/02/13-20-59/QQ20240503-105511@2x.png" class=""></p>
<p>推导公式：<br>\begin{split}<br>\frac{\partial E}{\partial d}=\sum_{i=1}^n-2\left(ax_i+by_i-d\right)=0\\<br>\Rightarrow d=\frac an\sum_{i=1}^nx_i+\frac bn\sum_{i=1}^nx_i=a\overline{x}+b\overline{y}<br>\end{split}</p>
<p>\begin{split}<br>&amp;E = \sum_{i=1}^{n}(a (x_{i}-\overline{x})+b (y_{i}-<br>\overline{y}))^{2}\\<br>&amp;=\left\|\begin{bmatrix}x_{i}-\overline{x}&amp;y_{i}-<br>\overline{y}\\<br>\vdots&amp;\vdots&amp;\vdots\\<br>\lfloor x_{i}-\overline{x}&amp;y_{i}-\overline{y}\rfloor<br>\end{bmatrix}\begin{bmatrix}a\\<br>b\end{bmatrix}\right\|^{2} \\<br>&amp;=\left(U \mathbf{h}\right)^{T}\left(U \mathbf{h}\right)\\<br>&amp;\frac{dE}{d\mathbf{h}}=2(U^TU)\mathbf{h}=0<br>\end{split}</p>
<img src="/2024/05/02/13-20-59/QQ20240503-110151@2x.png" class="">
<ul>
<li>实际测量点$(x,y)$ 等于真实点$(u,v)$垂直于$a,b$方向上的偏动。</li>
<li>符合高斯噪声</li>
</ul>
<h3 id="鲁棒估计器"><a href="#鲁棒估计器" class="headerlink" title="鲁棒估计器"></a>鲁棒估计器</h3><p>求一个最小化：$\sum_i\rho\left(r_i\left(x_i,\theta_1\right);<br>\sigma_1\right)$</p>
<ul>
<li>$r_i\left(x_i,\theta_1\right)$：代表残差值,该点距离拟合曲线的距离</li>
<li>$\rho$：有尺度参数$\sigma$鲁棒函数</li>
</ul>
<p>一种鲁棒函数：<br><img src="/2024/05/02/13-20-59/QQ20240503-110931@2x.png" class=""></p>
<ul>
<li>当$u$很小的时候：</li>
<li>当$u$很大的时候：误差很大</li>
</ul>
<h2 id="RANSAC算法-RANdom-SAmple-Consensus"><a href="#RANSAC算法-RANdom-SAmple-Consensus" class="headerlink" title="RANSAC算法 RANdom SAmple Consensus"></a>RANSAC算法 RANdom SAmple Consensus</h2><h3 id="一般模型"><a href="#一般模型" class="headerlink" title="一般模型"></a>一般模型</h3><p>选取模型的最小集点数量：<br>距离阀值：<br>$f(d)=\frac{\sqrt{2}e^{-(\frac{d^2}{2\sigma^2})} }<br>{\sqrt{\pi}\sigma},d\geq0$</p>
<h4 id="计算N"><a href="#计算N" class="headerlink" title="计算N"></a>计算N</h4><img src="/2024/05/02/13-20-59/QQ20240503-112533@2x.png" class="">
<p>模型所需的样本点数：<br>$N &gt; \log(1 - p ) / \log(1 - (1 - e )^S )$</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>两个匹配的特征：<br><img src="/2024/05/02/13-20-59/QQ20240503-113228@2x.png" class=""></p>
<ul>
<li>有5个特征匹配，2个不匹配，认为这两张图是相同的，错误</li>
<li>因为匹配特征中有噪音</li>
</ul>
<p>RANSAC算法<br><img src="/2024/05/02/13-20-59/QQ20240503-113151@2x.png" class=""></p>
<ul>
<li>去除高斯噪音，选择平均值</li>
</ul>
<h4 id="RANSAC算法-循环"><a href="#RANSAC算法-循环" class="headerlink" title="RANSAC算法 循环"></a>RANSAC算法 循环</h4><img src="/2024/05/02/13-20-59/QQ20240503-113501@2x.png" class="">
]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>计算机视觉，图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机视觉概论 光反射成像，亮度，阴影</title>
    <url>/2024/05/03/12-11-15/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.05.03：初稿</li>
</ul>
<h2 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h2><ul>
<li><a href="/2024/04/27/08-42-03/" title="Ud810 Intro-to-cv 笔记汇总">计算机视觉概率-笔记汇总</a>
</li>
</ul>
<h2 id="图像的成像"><a href="#图像的成像" class="headerlink" title="图像的成像"></a>图像的成像</h2><h3 id="表面纹理"><a href="#表面纹理" class="headerlink" title="表面纹理"></a>表面纹理</h3><img src="/2024/05/03/12-11-15/QQ20240505-101936@2x.png" class="">
<p>图像由：一小块表面法线，表面折射率，照明组成。</p>
<h4 id="辐射率"><a href="#辐射率" class="headerlink" title="辐射率"></a>辐射率</h4><img src="/2024/05/03/12-11-15/QQ20240505-102048@2x.png" class="">
<p>辐射率：单位面积上吸收的能量<br>单位：瓦每平方米 $Wm^{-2}Sr^{-1}$</p>
<p>到达表面的能量：E<br>单位：$Wm^{-2}$</p>
<img src="/2024/05/03/12-11-15/QQ20240505-102428@2x.png" class="">
<h4 id="双向反射分布函数-BRDF"><a href="#双向反射分布函数-BRDF" class="headerlink" title="双向反射分布函数 BRDF"></a>双向反射分布函数 BRDF</h4><p>入射，反射<br><img src="/2024/05/03/12-11-15/QQ20240505-102527@2x.png" class=""><br><img src="/2024/05/03/12-11-15/QQ20240505-102622@2x.png" class=""></p>
<p>BRDF公式：$f(\theta_i,\varphi_i;\theta_r,\varphi_r)=\frac{L^{surface}(\theta_r,\varphi_r)}{E^{surface}(\theta_i,\varphi_i)}$<br>反射与入射的比例</p>
<p>重要属性：<br>交换光源和照相机，比例不变：<br>$f(\theta_i,\varphi_i;\theta_r,\varphi_r)=f(\theta_r,\varphi_r;\theta_i,\varphi_i)$</p>
<p>旋转对称性：<br>$f(\theta_i,\varphi_i;\theta_r,\varphi_r)=f(\theta_i,\theta_r,\varphi_i-\varphi_r)$<br>表明公式与绝对角度无关，只有他们之间的相对角度有关。</p>
<h3 id="反射模型"><a href="#反射模型" class="headerlink" title="反射模型"></a>反射模型</h3><p>漫反射<br><img src="/2024/05/03/12-11-15/QQ20240505-103332@2x.png" class=""></p>
<p>镜面反射<br><img src="/2024/05/03/12-11-15/QQ20240505-103403@2x.png" class=""></p>
<p>反射光强度</p>
<img src="/2024/05/03/12-11-15/QQ20240505-103443@2x.png" class="">
<h4 id="Lambertian-BRDF"><a href="#Lambertian-BRDF" class="headerlink" title="Lambertian BRDF"></a>Lambertian BRDF</h4><p>所有方向看起来一样亮</p>
<img src="/2024/05/03/12-11-15/QQ20240505-103722@2x.png" class="">
<p>光的反射是按照角度衰减的。<br>为什么看到的光亮度相同？<br>因为垂直角度看到的面积小，但亮度高，接近平行的面积大，亮度低，总体看起来亮度相同。</p>
<img src="/2024/05/03/12-11-15/QQ20240505-104119@2x.png" class="">
<p>光的反射率是一个常数<br>$albedo$:$f\left(\theta_i,\varphi_i;\theta_r,\varphi_r\right)=\rho_d$</p>
<p>表面辐射：$L=\rho_d I\cos\theta_i=\rho_d I ( \vec{n} \cdot\vec{s})$</p>
<p>镜面BRDF：<br><img src="/2024/05/03/12-11-15/QQ20240505-104452@2x.png" class=""><br>BRDF:$f(\theta_i,\phi_i;\theta_v,\phi_v)=\rho_s\delta(\theta_i-\theta_v)\delta(\phi_i+\pi-\phi_v)$<br>表面辐射：$L=I\rho_S\delta(\theta_i-\theta_v)\delta(\varphi_i+\pi-\varphi_v)$</p>
<p>另一种写法：$L=I\rho_s\delta(\vec{m}-\vec{v})\mathrm{~or~}I\rho_s\delta(\vec{n}-\vec{h})$<br>$\vec{h}$：半角</p>
<h4 id="光泽BRDF-Glossy"><a href="#光泽BRDF-Glossy" class="headerlink" title="光泽BRDF  Glossy"></a>光泽BRDF  Glossy</h4><img src="/2024/05/03/12-11-15/QQ20240505-104912@2x.png" class="">
<p>表面辐射：$L=I\rho_s(\vec{m}\cdot\vec{v})^k$</p>
<h3 id="Phong-反射模型"><a href="#Phong-反射模型" class="headerlink" title="Phong 反射模型"></a>Phong 反射模型</h3><img src="/2024/05/03/12-11-15/QQ20240505-105128@2x.png" class="">
<h2 id="亮度"><a href="#亮度" class="headerlink" title="亮度"></a>亮度</h2><h4 id="亮度假设"><a href="#亮度假设" class="headerlink" title="亮度假设"></a>亮度假设</h4><img src="/2024/05/03/12-11-15/QQ20240505-105533@2x.png" class="">
<img src="/2024/05/03/12-11-15/QQ20240505-105617@2x.png" class="">
<p>实际上两个方块的亮度是相同的，但大脑一直在补偿阴影。</p>
<img src="/2024/05/03/12-11-15/QQ20240505-105812@2x.png" class="">
<img src="/2024/05/03/12-11-15/QQ20240505-105812@2x.png" class="">
<p>亮度：等于反射率乘能量<br><img src="/2024/05/03/12-11-15/QQ20240505-110117@2x.png" class=""></p>
<h3 id="蒙德里安世界-The-Mondrian-world"><a href="#蒙德里安世界-The-Mondrian-world" class="headerlink" title="蒙德里安世界 The Mondrian world"></a>蒙德里安世界 The Mondrian world</h3><p>计算机的假设：</p>
<ol>
<li>光是缓慢变化的</li>
<li>反射率是常数</li>
<li>物体之间的反射率变化急剧<img src="/2024/05/03/12-11-15/QQ20240505-110352@2x.png" class="">
</li>
</ol>
<p>强度恒定的斑块：<br><img src="/2024/05/03/12-11-15/QQ20240505-110431@2x.png" class=""></p>
<p>假设光照强度是低频的，缓慢变化。<br>边缘的反射率是恒定的。<br>图像相加？：<br><img src="/2024/05/03/12-11-15/QQ20240505-110637@2x.png" class=""></p>
<p>如何恢复反射率：<br><img src="/2024/05/03/12-11-15/QQ20240505-110754@2x.png" class=""></p>
<h4 id="视网膜色素-Land’s-Retinex-Theory"><a href="#视网膜色素-Land’s-Retinex-Theory" class="headerlink" title="视网膜色素 Land’s Retinex Theory"></a>视网膜色素 Land’s Retinex Theory</h4><p>展示了人类如何感知不同色素<br>目标：消除缓慢变化<br>$\log(L(x,y))~=~\log(R(x,y))~+~\log(E(x,y))$<br>高通滤波保留高波，去掉阀值。</p>
<p>一维亮度：<br><img src="/2024/05/03/12-11-15/QQ20240505-111110@2x.png" class=""><br>处理阀值，整合成反射率，但是多一个常数。<br><img src="/2024/05/03/12-11-15/QQ20240505-111242@2x.png" class=""></p>
<p>例子：彩色视网膜<br><img src="/2024/05/03/12-11-15/QQ20240505-111441@2x.png" class=""><br>重新校准强度</p>
<h4 id="颜色恒定率，强度恒定率"><a href="#颜色恒定率，强度恒定率" class="headerlink" title="颜色恒定率，强度恒定率"></a>颜色恒定率，强度恒定率</h4><img src="/2024/05/03/12-11-15/QQ20240505-111924@2x.png" class="">
<p>颜色恒定率：某种颜色，在不用光照下，仍然可以看到颜色<br>强度恒定率：在不同环境，可以感知相同的强度。</p>
<h2 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h2><h3 id="阴影的形状"><a href="#阴影的形状" class="headerlink" title="阴影的形状"></a>阴影的形状</h3><p>阴影作为恢复形状的提示</p>
<h4 id="反射率图"><a href="#反射率图" class="headerlink" title="反射率图"></a>反射率图</h4><img src="/2024/05/03/12-11-15/QQ20240506-093432@2x.png" class="">
<img src="/2024/05/03/12-11-15/QQ20240506-093505@2x.png" class="">
<p>曲线法向量：$\mathbf{n}=\frac N{\left\|N\right\|}=\frac{t_x\times t_y}{\left\|t_x\times t_y\right\|}=\frac1{\sqrt{p^2+q^2+1}}\left(p,q,1\right)^T$</p>
<h4 id="高斯球和梯度空间投影"><a href="#高斯球和梯度空间投影" class="headerlink" title="高斯球和梯度空间投影"></a>高斯球和梯度空间投影</h4><p>存在从所有法线到高斯球的映射：<br><img src="/2024/05/03/12-11-15/QQ20240506-093838@2x.png" class=""><br><img src="/2024/05/03/12-11-15/QQ20240506-093909@2x.png" class=""><br><img src="/2024/05/03/12-11-15/QQ20240506-093921@2x.png" class=""></p>
<h4 id="源向量梯度空间和法向量梯度空间"><a href="#源向量梯度空间和法向量梯度空间" class="headerlink" title="源向量梯度空间和法向量梯度空间"></a>源向量梯度空间和法向量梯度空间</h4><img src="/2024/05/03/12-11-15/QQ20240506-094225@2x.png" class="">
<p>单位法向量：$\mathbf{n=\frac N{|N|}=\frac{(p,q,1)}{\sqrt{p^2+q^2+1}}}$</p>
<p>单位源向量：$\mathbf{s}=\frac{\mathbf{S}}{|\mathbf{S}|}=\frac{(p_S,q_S,1)}{\sqrt{p_S^2+q_S^2+1}}$</p>
<p>向量夹角：$\cos\theta_i=\mathbf{n}\cdot\mathbf{s}=\frac{(pp_S+qq_S+1)}{\sqrt{p^2+q^2+1}\sqrt{p_S^2+q_S^2+1}}$</p>
<h3 id="阴影形状的定义"><a href="#阴影形状的定义" class="headerlink" title="阴影形状的定义"></a>阴影形状的定义</h3><img src="/2024/05/03/12-11-15/QQ20240506-094504@2x.png" class="">
<h4 id="朗伯案例"><a href="#朗伯案例" class="headerlink" title="朗伯案例"></a>朗伯案例</h4><img src="/2024/05/03/12-11-15/QQ20240506-094718@2x.png" class="">
<p>反射图：<br><img src="/2024/05/03/12-11-15/QQ20240506-094852@2x.png" class=""></p>
<p>Iso 亮度轮廓：<br><img src="/2024/05/03/12-11-15/QQ20240506-094911@2x.png" class=""></p>
<h3 id="光度立体"><a href="#光度立体" class="headerlink" title="光度立体"></a>光度立体</h3><p>相同的物体，不同的光照<br><img src="/2024/05/03/12-11-15/QQ20240506-095328@2x.png" class=""></p>
<img src="/2024/05/03/12-11-15/QQ20240506-095430@2x.png" class="">
<img src="/2024/05/03/12-11-15/QQ20240506-095508@2x.png" class="">
<img src="/2024/05/03/12-11-15/QQ20240506-095523@2x.png" class="">
<p>最终pq空间图：<br><img src="/2024/05/03/12-11-15/QQ20240506-095554@2x.png" class=""></p>
]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>计算机视觉，图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>03-深度学习安装</title>
    <url>/2024/04/23/11-01-03/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.04.24：初稿</li>
</ul>
<h2 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h2><ul>
<li><a href="/2024/04/24/12-18-34/" title="动手学深度学习笔记汇总">动手学深度学习笔记汇总</a>
</li>
</ul>
<h2 id="03-安装"><a href="#03-安装" class="headerlink" title="03-安装"></a>03-安装</h2><h3 id="1-安装python"><a href="#1-安装python" class="headerlink" title="1.安装python"></a>1.安装python</h3><p>首先前提是安装python，这里推荐安装python3.8 输入命令 <strong><em>sudo apt install python3.8</em></strong> 即可</p>
<h3 id="2-安装Miniconda-Anaconda"><a href="#2-安装Miniconda-Anaconda" class="headerlink" title="2.安装Miniconda/Anaconda"></a>2.安装Miniconda/Anaconda</h3><ul>
<li><p>然后第二步，安装 Miniconda（如果已经安装conda或者Miniconda，则可以跳过该步骤)。</p>
<h4 id="2-1-安装Miniconda"><a href="#2-1-安装Miniconda" class="headerlink" title="2.1 安装Miniconda"></a>2.1 安装Miniconda</h4><ul>
<li>安装MIniconda的好处是可以创建很多虚拟环境，并且不同环境之间互相不会有依赖关系，对日后的项目有帮助，如果只想在本地安装的话，不装Miniconda只使用pip即可，第二步可以跳过。</li>
<li>如果是Windows系统，输入命令 <strong><em>wget <a href="https://repo.anaconda.com/miniconda/Miniconda3-py38_4.10.3-Windows-x86_64.exe">https://repo.anaconda.com/miniconda/Miniconda3-py38_4.10.3-Windows-x86_64.exe</a></em></strong></li>
<li>如果是macOS，输入命令 <strong><em>wget <a href="https://repo.anaconda.com/miniconda/Miniconda3-py38_4.10.3-MacOSX-x86_64.sh">https://repo.anaconda.com/miniconda/Miniconda3-py38_4.10.3-MacOSX-x86_64.sh</a></em></strong> 之后要输入命令 <strong><em>sh Miniconda3-py38_4.10.3-MacOSX-x86_64.sh -b</em></strong></li>
<li>如果是Linux系统，输入命令 <strong><em>wget <a href="https://repo.anaconda.com/miniconda/Miniconda3-py38_4.10.3-Linux-x86_64.sh">https://repo.anaconda.com/miniconda/Miniconda3-py38_4.10.3-Linux-x86_64.sh</a></em></strong> 之后输入命令 <strong><em>sh Miniconda3-py38_4.10.3-Linux-x86_64.sh -b</em></strong></li>
<li>以上都是基于python3.8版本，对于其他版本，可以访问 <strong><em><a href="https://docs.conda.io/en/latest/miniconda.html">https://docs.conda.io/en/latest/miniconda.html</a></em></strong> ，下载对应版本即可。</li>
</ul>
<h4 id="2-2-Miniconda环境操作"><a href="#2-2-Miniconda环境操作" class="headerlink" title="2.2 Miniconda环境操作"></a>2.2 Miniconda环境操作</h4><ul>
<li>对于第一次安装Miniconda的，要初始化终端shell，输入命令 <strong><em>~/miniconda3/bin/conda init</em></strong></li>
<li>这样我们就可以使用 <strong><em>conda create —name d2l python=3.8 -y</em></strong> 来创建一个名为xxx的环境，这里命名为d2l</li>
<li>打开xxx环境命令: <strong><em>conda activate xxx</em></strong> ；关闭命令：<strong><em>conda deactivate xxx</em></strong>。对于基础conda环境不用添加名</li>
</ul>
</li>
</ul>
<h3 id="3-安装Pytorch-d2l-jupyter包"><a href="#3-安装Pytorch-d2l-jupyter包" class="headerlink" title="3.安装Pytorch, d2l, jupyter包"></a>3.安装Pytorch, d2l, jupyter包</h3><ul>
<li><p>第三步，安装深度学习框架和<code>d2l</code>软件包</p>
<p>在安装深度学习框架之前，请先检查你的计算机上是否有可用的GPU（为笔记本电脑上显示器提供输出的GPU不算）。 例如，你可以查看计算机是否装有NVIDIA GPU并已安装<a href="https://developer.nvidia.com/cuda-downloads">CUDA</a>。 如果你的机器没有任何GPU，没有必要担心，因为你的CPU在前几章完全够用。 但是，如果你想流畅地学习全部章节，请提早获取GPU并且安装深度学习框架的GPU版本。</p>
<ul>
<li><p>你可以按如下方式安装PyTorch的CPU或GPU版本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install torch==1.8.1</span><br><span class="line">pip install torchvision==0.9.1</span><br></pre></td></tr></table></figure>
</li>
<li><p>也可以访问官网 <strong><em><a href="https://pytorch.org/get-started/locally/">https://pytorch.org/get-started/locally/</a></em></strong> 选择适合自己电脑pytorch版本下载!</p>
</li>
<li>
</li>
<li><p>本课程的jupyter notebook代码详见 <strong><em><a href="https://zh-v2.d2l.ai/d2l-zh.zip">https://zh-v2.d2l.ai/d2l-zh.zip</a></em></strong></p>
</li>
<li><p>下载jupyter notebook ：输入命令 <strong><em>pip install jupyter notebook</em></strong> （若pip失灵可以尝试pip3），输入密命令 <strong><em>jupyter notebook</em></strong> 即可打开。</p>
</li>
</ul>
</li>
</ul>
<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><ul>
<li>本节主要介绍<strong>安装Miniconda</strong>、<strong>CPU环境下的Pytorch</strong>和其它课程所需<strong>软件包</strong>(d2l, jupyter)。对于前面几节来说，CPU已经够用了。<ul>
<li>如果您<strong>已经安装</strong>了Miniconda/Anaconda, Pytorch框架和jupyter记事本, 您只需再安装<strong>d2l包</strong>，就可以跳过本节视频了<strong>开启深度学习之旅</strong>了; 如果希望后续章节在<strong>GPU下跑深度学习</strong>, 可以<strong>新建环境</strong>安装<strong>CUDA版本的Pytorch</strong>。</li>
<li>如果需要在Windows下<strong>安装CUDA和Pytorch</strong>(cuda版本)，用<strong>本地GPU跑深度学习</strong>，可以参考李沐老师<a href="https://www.zhihu.com/zvideo/1363284223420436480">Windows下安装CUDA和Pytorch跑深度学习</a>，如果网慢总失败的同学可以参考<a href="https://www.zhihu.com/question/425647129/answer/2278290137">cuda11.0如何安装pytorch？ - Glenn1Q84的回答 - 知乎</a>。当然，如果不方便在本地进行配置(如无GPU, GPU显存过低等)，也可以选择<a href="https://colab.research.google.com/">Colab</a>(需要科学上网)，或其它<strong>云服务器</strong>GPU跑深度学习。</li>
<li>如果pip安装比较慢，可以用镜像源安装：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install torch torchvision -i http://mirrors.aliyun.com/pypi/simple/  --trusted-host mirrors.aliyun.com</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>如果安装时经常报错, 可以参考课程评论区部分。</li>
</ul>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>02-深度学习介绍</title>
    <url>/2024/04/23/11-01-02/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.04.24：初稿</li>
</ul>
<h2 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h2><ul>
<li><a href="/2024/04/24/12-18-34/" title="动手学深度学习笔记汇总">动手学深度学习笔记汇总</a>
</li>
</ul>
<h2 id="02-深度学习介绍"><a href="#02-深度学习介绍" class="headerlink" title="02-深度学习介绍"></a>02-深度学习介绍</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><h4 id="1-1-AI地图"><a href="#1-1-AI地图" class="headerlink" title="1.1 AI地图"></a>1.1 AI地图</h4><p>首先画一个简单的人工智能地图：</p>
<img src="/2024/04/23/11-01-02/02-01.png" class="">
<ul>
<li><p>x轴表示不同的模式or方法：最早的是符号学，接下来是概率模型，之后是机器学习</p>
</li>
<li><p>y轴表示可以达到的层次：由底部向上依次是</p>
<blockquote>
<p>感知：了解是什么，比如能够可以看到物体，如面前的一块屏幕</p>
<p>推理：基于感知到的现象，想象或推测未来会发生什么</p>
<p>知识：根据看到的数据或者现象，形成自己的知识</p>
<p>规划：根据学习到的知识，做出长远的规划</p>
</blockquote>
</li>
</ul>
<h4 id="1-2-AI地图解读"><a href="#1-2-AI地图解读" class="headerlink" title="1.2 AI地图解读"></a>1.2 AI地图解读</h4><ul>
<li><p>问题领域的一个简单分类</p>
<ul>
<li><p><strong>自然语言处理</strong>：</p>
<ul>
<li>停留在比较简单的<strong>感知</strong>层面，比如自然语言处理用的比较多的机器翻译，给一句中文翻译成英文，很多时候是人的潜意识里面大脑感知的一个问题。一般来说，人可以几秒钟内反应过来的东西，属于感知范围。</li>
<li>自然语言处理最早使用的方法是<strong>符号学</strong>，由于语言具有符号性；之后一段时间比较流行的有<strong>概率模型</strong>，以及现在也用的比较多的<strong>机器学习</strong>。</li>
</ul>
</li>
<li><p><strong>计算机视觉</strong>：</p>
<ul>
<li>在简单的感知层次之上，可以对图片做一些<strong>推理</strong>。 </li>
<li>图片里都是一些像素，很难用符号学解释，所以一般采用<strong>概率模型</strong>和<strong>机器学习</strong>。</li>
</ul>
</li>
<li><p><strong>深度学习</strong></p>
<ul>
<li>机器学习的一种，更深层的神经网络。</li>
<li>可以做计算机视觉，自然语言处理，强化学习等。</li>
</ul>
</li>
</ul>
</li>
<li><p>过去八年最热的方向，也是本课程关心的重点：</p>
<ul>
<li>深度学习+计算机视觉 / 自然语言处理</li>
</ul>
</li>
</ul>
<p>本节课只关注AI中的一小部分领域，即深度学习背景下的视觉和自然语言处理相关的基础应用。</p>
<hr>
<h3 id="2-深度学习的应用"><a href="#2-深度学习的应用" class="headerlink" title="2. 深度学习的应用"></a>2. 深度学习的应用</h3><h4 id="2-1-图片分类"><a href="#2-1-图片分类" class="headerlink" title="2.1 图片分类"></a>2.1 图片分类</h4><p>深度学习最早是在图片分类上有比较大的突破，ImageNet是一个比较大的图片分类数据集，</p>
<img src="/2024/04/23/11-01-02/02-02.png" class="">
<p><code>x轴</code>：年份      <code>y轴</code>：错误率     <code>圆点</code>：表示某年份某研究工作/paper的错误率  <a href="https://image-net.org/">IMAGENET</a>   <a href="https://qz.com/1034972/the-data-that-changed-the-direction-of-ai-research-and-possibly-the-world/">数据来源</a></p>
<blockquote>
<p>在2010年时，错误率比较高，最好的工作错误率也在26%、%27左右；</p>
<p>在2012年，有团队首次使用深度学习将错误率降到25%以下；</p>
<p>在接下来几年中，使用深度学习可以将误差降到很低。</p>
<p>2017年基本所有的团队可以将错误率降到5%以下，基本可以达到人类识别图片的精度。</p>
</blockquote>
<h4 id="2-2-物体检测和分割"><a href="#2-2-物体检测和分割" class="headerlink" title="2.2 物体检测和分割"></a>2.2 物体检测和分割</h4><p>当你不仅仅想知道图片里有什么内容，还想知道物体是什么，在什么位置，这就是<strong>物体检测</strong>。<strong>物体分割</strong>是指每一个像素属于什么，属于飞机还是属于人(如下图)，这是图像领域更深层次的一个应用。<br><img src="/2024/04/23/11-01-02/02-03.png" class=""></p>
<h4 id="2-3-样式迁移"><a href="#2-3-样式迁移" class="headerlink" title="2.3 样式迁移"></a>2.3 样式迁移</h4><p>原图片+想要迁移的风格=风格迁移后的图片，加了一个可以根据输入改变图片风格的滤镜。<br><img src="/2024/04/23/11-01-02/02-04.png" class=""></p>
<h4 id="2-4-人脸合成"><a href="#2-4-人脸合成" class="headerlink" title="2.4 人脸合成"></a>2.4 人脸合成</h4><p>下图中所有的人脸都是假的，由机器合成的图片：<br><img src="/2024/04/23/11-01-02/02-05.png" class=""></p>
<h4 id="2-5-文字生成图片"><a href="#2-5-文字生成图片" class="headerlink" title="2.5 文字生成图片"></a>2.5 文字生成图片</h4><ol>
<li><p>描述：一个胡萝卜宝宝遛狗的图片。</p>
</li>
<li><p>描述：一个牛油果形状的靠背椅。</p>
<img src="/2024/04/23/11-01-02/02-06.png" class="">
</li>
</ol>
<h4 id="2-6-文字生成"><a href="#2-6-文字生成" class="headerlink" title="2.6 文字生成"></a>2.6 文字生成</h4><blockquote>
<p>示例1：</p>
<p>问题输入：如何举行一个有效的董事会议 </p>
<p>机器输出：生成篇章回答</p>
<p>示例2：</p>
<p>输入：将Students从School这个table中选出来</p>
<p>输出：用于查询的SQL语言</p>
</blockquote>
<img src="/2024/04/23/11-01-02/02-07.png" class="">
<h4 id="2-7-无人驾驶"><a href="#2-7-无人驾驶" class="headerlink" title="2.7 无人驾驶"></a>2.7 无人驾驶</h4><p>识别车、道路以及各种障碍物等，并规划路线。</p>
<img src="/2024/04/23/11-01-02/02-08.png" class="">
<h4 id="2-8-案例研究——广告点击"><a href="#2-8-案例研究——广告点击" class="headerlink" title="2.8 案例研究——广告点击"></a>2.8 案例研究——广告点击</h4><blockquote>
<p>用户输入想要搜索的广告内容，如：baby toy</p>
<p>网站呈现最具有效益的广告(用户更可能点击，且给网站带来更高经济效益)</p>
</blockquote>
<img src="/2024/04/23/11-01-02/02-09.png" class="">
<h5 id="2-8-1-步骤"><a href="#2-8-1-步骤" class="headerlink" title="2.8.1 步骤"></a>2.8.1 步骤</h5><img src="/2024/04/23/11-01-02/02-10.png" class="">
<ol>
<li>触发：用户输入关键词，机器先找到一些相关的广告</li>
<li>点击率预估：   利用机器学习的模型预测用户对广告的点击率</li>
<li>排序：利用点击率x竞价的结果进行排序呈现广告，排名高的在前面呈现</li>
</ol>
<h5 id="2-8-2-模型的预测与训练"><a href="#2-8-2-模型的预测与训练" class="headerlink" title="2.8.2 模型的预测与训练"></a>2.8.2 模型的<mark>预测与训练</mark></h5><p>上述步骤的第二步中涉及到模型预测用户的点击率，具体过程如下：<br><img src="/2024/04/23/11-01-02/02-11.png" class=""></p>
<p><strong>模型预测</strong></p>
<p>数据 (待预测广告) → 特征提取 → 模型 → 点击率预测</p>
<p><strong>模型训练</strong></p>
<p>训练数据 (过去广告展现和用户点击) → 特征(X)和用户点击(Y) → 喂给模型训练</p>
<h5 id="2-8-3-完整的故事"><a href="#2-8-3-完整的故事" class="headerlink" title="2.8.3 完整的故事"></a>2.8.3 完整的故事</h5><img src="/2024/04/23/11-01-02/02-12.png" class="">
<p><strong><font color="Navy">领域专家</font></strong>：对特定的应用有比较深的了解，根据展现情况以及用户点击分析用户的行为，期望模型对应用做一些拟合，符合真实数据和分析情况。</p>
<p><strong><font color="Navy">数据科学家</font></strong>：利用数据训练模型，训练后模型投入使用，进行预测呈现。</p>
<p><strong><font color="Navy">AI专家</font></strong>：应用规模扩大，用户数量增多，模型更加复杂，需要进一步提升精度和性能。</p>
<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><ul>
<li>通过AI地图，课程从纵向和横向两个维度解读了深度学习在重要问题领域的概况。</li>
<li>介绍了深度学习在CV和NLP方面的一些应用</li>
<li>简单分析并研究了深度学习实例——广告点击。</li>
</ul>
<hr>
<h3 id="4-深度学习介绍-Q-amp-A"><a href="#4-深度学习介绍-Q-amp-A" class="headerlink" title="4. 深度学习介绍 Q&amp;A"></a>4. 深度学习介绍 Q&amp;A</h3><p>◆ <strong>Q1：机器学习的可解释性？机器学习在图片分割为什么有效，目前有没有定论？</strong></p>
<blockquote>
<p><font color=MediumSeaGreen>A1</font>：模型的可解释性不管是深度学习还是机器学习都是非常受人关注的点，因为这像是一个黑盒，训练了一个模型，也不知道为什么work或者为什么不work。对于深度学习来说，模型的<strong>可解释性</strong>是做得不够好的；对于机器学习来说，我们对简单的模型可以理解，但当模型变得很深的时候，几乎只能放弃理解的过程。</p>
<p>特别地，<strong>为什么有效</strong>和<strong>可解释性</strong>是两个不同的概念，所有提出的新模型都会解释一下为什么有效，可解释性是说人是不是能理解这个模型，理解模型为什么工作是一个方面，还需要知道它什么时候不工作以及在什么地方会出现偏差。</p>
<p>目前来说，一个模型在一个应用/领域上为什么可以工作，会有一些解释，我们会在解释不同的模型的时候给大家进行讲解。</p>
</blockquote>
<p>◆ <strong>Q2：领域专家是什么意思？</strong></p>
<blockquote>
<p><font color=MediumSeaGreen>A2</font>：举个例子，比如我要做农业上的物体识别，我种了一棵树，想要看今年的收成怎么样，我有很多很多土地，用人去一个个查看很费力，于是我用一个无人机，将农作物的情况拍下来，假设得到了树的一些图片，而数据科学家不知道农作物什么样的情况是好，什么样是坏，于是<strong>领域专家进行解释</strong>，比如多少叶子算是好，什么样不好。同时<strong>数据科学家</strong>将领域专家的<strong>问题翻译</strong>成机器学习能做的任务。所以可以认为<strong>领域专家</strong>是<strong>提需求</strong>的人<strong>甲方</strong>，而<strong>数据科学家</strong>是<strong>乙方</strong>。</p>
</blockquote>
<p>◆ <strong>Q3：MXNet的GPU版本的安装必须要卸载CPU版本的吗？</strong></p>
<blockquote>
<p><font color=MediumSeaGreen>A3</font>：是的，但我们的课程是<strong>基于Pytorch</strong>，Pytorch会不一样一些。</p>
</blockquote>
<p>◆ <strong>Q4：深度学习无法用数学规范表述，只能用直觉理解是吗？</strong></p>
<blockquote>
<p><font color=MediumSeaGreen>A4</font>：不一定，深度学习模型可以用<strong>数学形式表示</strong>，接下来也会讲到很多数学的东西，但是说具体用数学解释它<strong>为什么工作</strong>，<strong>为什么不工作</strong>，这个是目前我们做的不好的地方。</p>
</blockquote>
<p>◆ <strong>Q5：符号学可以和机器学习融合起来吗？</strong></p>
<blockquote>
<p><font color=MediumSeaGreen>A5</font>：确实是可以的。目前来说，<strong>符号学</strong>在<strong>深度学习</strong>有一些新的进展，以前说符号学就是做一些符号上的推理，目前<strong>深度学习如图神经网络</strong>，可以做一些比较复杂的推理。</p>
</blockquote>
<p>◆ <strong>Q6：数据科学家和AI专家的主要区别在哪里？</strong></p>
<blockquote>
<p><font color=MediumSeaGreen>A6</font>：我觉得没有太多区别。数据科学家很多时候关注的是给一个数据，赶紧出一个模型，能工作就好了，<strong>关注</strong>的是如何把领域专家的一个实际的业务问题，变成一个机器学习能做的任务，训练成一个还不错的模型。<strong>AI专家也可能是数据科学家</strong>，也就是说其不仅要训练出来一个模型能用，而且会<strong>关心</strong>如何把模型精度做得很高，或者可以说，<strong>资深数据科学家可以认为是AI专家</strong>。</p>
<p>数据科学家可以有<strong>两条路线</strong>，一个是<strong>不断开拓新领域</strong>，比如机器学习在农业上的应用，在医疗上的应用等，这个是<strong>往广的走</strong>，<strong>往深的走</strong>的话可以称为是AI专家，在某一块方面了解得很深。</p>
</blockquote>
<p>◆ <strong>Q7：MAC是不是可以支持Pytorch？</strong></p>
<blockquote>
<p><font color=MediumSeaGreen>A7</font>：可以。</p>
</blockquote>
<p>◆ <strong>Q8：说自然语言处理仅仅停留在感知层面似乎不太合适？因为语言的理解和产出不仅仅是感知，也涉及到语言知识和世界知识，也涉及到规划，比如机器规划下一步要做什么。</strong></p>
<blockquote>
<p><font color=MediumSeaGreen>A8</font>：确实是这样，语言当然是一个很复杂的过程，我只是想说，自然语言处理我们做得还很一般，虽然能做一些感知以外的东西，但是我感觉是说，<strong>不如</strong>深度学习特别机器学习，在图片上的应用做得好一些。当然AI地图上也只是一个<strong>大致的分类</strong>，大家不用特别纠结。</p>
</blockquote>
<p>◆ <strong>Q9：请问老师有考虑后面讲一讲如何寻找自己领域的paper的经验吗？</strong></p>
<blockquote>
<p><font color=MediumSeaGreen>A9</font>：这是一个很好的问题，因为大家如果现在去读paper的话，可能每天都有一百篇paper出来，你怎么样去找到你想要的paper，总不能天天看朋友圈推文，这样只能知道别人读过的paper，不会有自己<strong>独特的见解</strong>，怎么样找到自己感兴趣和有启发性的论文，后面有机会和大家分享一下我的做法。</p>
</blockquote>
<p>◆ <strong>Q10：以无人驾驶为例，误判率在不断下降，但误判的影响还是很严重的，有可能从已有的判断case(样例)得到修正，从而完全避免这样的错误吗？</strong></p>
<blockquote>
<p><font color=MediumSeaGreen>A10</font>：<strong>无人驾驶</strong>中，任何一次出现的错误，都可能带来毁灭性的灾难。大家可能看到，特斯拉今天撞了，明天又撞了。所以说，无人驾驶对于<strong>错误率</strong>确实是非常注重的。</p>
<p>机器学习在学术界现在有很多关于<strong>uncertainty</strong>或者<strong>robustness</strong>的研究，就是说模型在数据偏移或者极端情况下会不会给出很不好的答案，我们不会特别深入去讲这个事情，但是无人驾驶这一块确实会通过大量的技术，比如说把不同的模型融合在一起，不是仅仅train一个模型，用多个模型来做投票。汽车有很多雷达、摄像头，它会通过不同的传感器来进行模型的融合，从而降低误差。</p>
<p>我们这个课程不会特别地讲，因为涉及到评价无人驾驶的特别技术，但在竞赛中我们会给大家看到如何通过<strong>融合多个模型提升精度</strong>的做法。</p>
</blockquote>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>06-矩阵计算</title>
    <url>/2024/04/23/11-01-06/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.04.24：初稿</li>
</ul>
<h2 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h2><ul>
<li><a href="/2024/04/24/12-18-34/" title="动手学深度学习笔记汇总">动手学深度学习笔记汇总</a>
</li>
</ul>
<h2 id="06-矩阵计算"><a href="#06-矩阵计算" class="headerlink" title="06-矩阵计算"></a>06-矩阵计算</h2><h3 id="1-导数的概念及几何意义"><a href="#1-导数的概念及几何意义" class="headerlink" title="1. 导数的概念及几何意义"></a>1. 导数的概念及几何意义</h3><h4 id="1-1-标量导数"><a href="#1-1-标量导数" class="headerlink" title="1.1 标量导数"></a>1.1 标量导数</h4><ul>
<li>导数是切线的斜率</li>
</ul>
<img src="/2024/04/23/11-01-06/06-01.png" class="">
<ul>
<li>指向值变化最大的方向</li>
</ul>
<img src="/2024/04/23/11-01-06/06-02.png" class="">
<h4 id="1-2-亚导数"><a href="#1-2-亚导数" class="headerlink" title="1.2 亚导数"></a>1.2 亚导数</h4><ul>
<li>将导数拓展到不可微的函数，在不可导的点的导数可以用一个范围内的数表示</li>
</ul>
<img src="/2024/04/23/11-01-06/06-03.png" class="">
<h3 id="2-函数与标量，向量，矩阵"><a href="#2-函数与标量，向量，矩阵" class="headerlink" title="2. 函数与标量，向量，矩阵"></a>2. 函数与标量，向量，矩阵</h3><p>该部分结合课程视频和参考文章进行总结（参考了知乎文章：<a href="https://zhuanlan.zhihu.com/p/263777564">矩阵求导的本质与分子布局、分母布局的本质（矩阵求导——本质篇） - 知乎 (zhihu.com)</a>）</p>
<ul>
<li>当f，input为不同形式时，f(input)结果的表达形式</li>
</ul>
<h4 id="2-1-f-为是一个标量"><a href="#2-1-f-为是一个标量" class="headerlink" title="2.1 f 为是一个标量"></a>2.1 f 为是一个标量</h4><h5 id="2-1-1-input是一个标量"><a href="#2-1-1-input是一个标量" class="headerlink" title="2.1.1 input是一个标量"></a>2.1.1 input是一个标量</h5><img src="/2024/04/23/11-01-06/06-04.png" class="">
<h5 id="2-1-2-input是一个向量"><a href="#2-1-2-input是一个向量" class="headerlink" title="2.1.2 input是一个向量"></a>2.1.2 input是一个向量</h5><img src="/2024/04/23/11-01-06/06-05.png" class="">
<img src="/2024/04/23/11-01-06/06-06.png" class="">
<h5 id="2-1-3-input是一个矩阵"><a href="#2-1-3-input是一个矩阵" class="headerlink" title="2.1.3 input是一个矩阵"></a>2.1.3 input是一个矩阵</h5><img src="/2024/04/23/11-01-06/06-07.png" class="">
<img src="/2024/04/23/11-01-06/06-08.png" class="">
<h4 id="2-2-f是一个向量"><a href="#2-2-f是一个向量" class="headerlink" title="2.2 f是一个向量"></a>2.2 f是一个向量</h4><ul>
<li><strong>f</strong>是由若干个f(标量)组成的向量</li>
</ul>
<h5 id="2-2-1-input是一个标量"><a href="#2-2-1-input是一个标量" class="headerlink" title="2.2.1 input是一个标量"></a>2.2.1 input是一个标量</h5><img src="/2024/04/23/11-01-06/06-09.png" class="">
<h5 id="2-2-2-input是一个向量"><a href="#2-2-2-input是一个向量" class="headerlink" title="2.2.2 input是一个向量"></a>2.2.2 input是一个向量</h5><img src="/2024/04/23/11-01-06/06-10.png" class="">
<img src="/2024/04/23/11-01-06/06-11.png" class="">
<h5 id="2-2-3-input是一个矩阵"><a href="#2-2-3-input是一个矩阵" class="headerlink" title="2.2.3 input是一个矩阵"></a>2.2.3 input是一个矩阵</h5><img src="/2024/04/23/11-01-06/06-12.png" class="">
<img src="/2024/04/23/11-01-06/06-13.png" class="">
<h4 id="2-3-F是一个矩阵"><a href="#2-3-F是一个矩阵" class="headerlink" title="2.3 F是一个矩阵"></a>2.3 F是一个矩阵</h4><ul>
<li><strong>F</strong>是一个由若干<strong>f</strong>组成的一个矩阵</li>
</ul>
<h5 id="2-3-1-input是一个标量"><a href="#2-3-1-input是一个标量" class="headerlink" title="2.3.1 input是一个标量"></a>2.3.1 input是一个标量</h5><img src="/2024/04/23/11-01-06/06-14.png" class="">
<h5 id="2-3-2-input是一个向量"><a href="#2-3-2-input是一个向量" class="headerlink" title="2.3.2 input是一个向量"></a>2.3.2 input是一个向量</h5><img src="/2024/04/23/11-01-06/06-15.png" class="">
<img src="/2024/04/23/11-01-06/06-16.png" class="">
<h5 id="2-3-3-input是一个向量"><a href="#2-3-3-input是一个向量" class="headerlink" title="2.3.3 input是一个向量"></a>2.3.3 input是一个向量</h5><img src="/2024/04/23/11-01-06/06-17.png" class="">
<img src="/2024/04/23/11-01-06/06-18.png" class="">
<h3 id="3-求导的本质"><a href="#3-求导的本质" class="headerlink" title="3. 求导的本质"></a>3. 求导的本质</h3><img src="/2024/04/23/11-01-06/06-19.png" class="">
<p><strong>可以将f对x1，x2，x3的偏导分别求出来，即</strong></p>
<img src="/2024/04/23/11-01-06/06-20.png" class="">
<ul>
<li>矩阵求导也是一样的，<strong>本质就是</strong> $function$ 中的<strong>每个</strong>$f$ <strong>分别对变元中的每个元素逐个求偏导，只不过写成了向量、矩阵形式而已。</strong></li>
</ul>
<img src="/2024/04/23/11-01-06/06-21.png" class="">
<p>（课上是按行向量展开的）</p>
<img src="/2024/04/23/11-01-06/06-22.png" class="">
<p><strong>X为矩阵时</strong>，先把矩阵变元$X$进行<strong>转置</strong>，再对<strong>转置后</strong>的<strong>每个位置</strong>的元素逐个求偏导，结果布局和<strong>转置布局一样</strong>。（课上讲的是这种展开方式）</p>
<img src="/2024/04/23/11-01-06/06-23.png" class="">
<ul>
<li>所以，如果 $function$中有 $m$个$f$ (标量)，变元中有 $n$个元素，那么，每个 $f$对变元中的每个元素逐个求偏导后，我们就会产生 $m*n$个结果。</li>
</ul>
<h3 id="4-矩阵求导的布局"><a href="#4-矩阵求导的布局" class="headerlink" title="4. 矩阵求导的布局"></a>4. 矩阵求导的布局</h3><ul>
<li>经过上述对求导本质的推导，关于矩阵求导的问题，实质上就是对求导结果的进一步排布问题<br><strong>对于2.2（f为向量，input也为向量）中的情况，其求导结果有两种排布方式，一种是<code>分子布局</code>，一种是<code>分母布局</code></strong></li>
</ul>
<h5 id="4-1-分子布局"><a href="#4-1-分子布局" class="headerlink" title="4.1 分子布局"></a>4.1 分子布局</h5><p><strong>分子布局</strong>，就是分子是<strong>列向量</strong>形式，分母是<strong>行向量</strong>形式 （课上讲的）</p>
<img src="/2024/04/23/11-01-06/06-24.png" class="">
<h5 id="4-2-分母布局"><a href="#4-2-分母布局" class="headerlink" title="4.2 分母布局"></a>4.2 分母布局</h5><p>2.<strong>分母布局</strong>，就是分母是<strong>列向量</strong>形式，分子是<strong>行向量</strong>形式</p>
<img src="/2024/04/23/11-01-06/06-25.png" class="">
<p><strong>将求导推广到矩阵，由于矩阵可以看作由多个向量所组成，因此对矩阵的求导可以看作先对每个向量进行求导，然后再增加一个维度存放求导结果。</strong></p>
<ul>
<li>例如当F为矩阵，input为矩阵时，F中的每个元素f(标量）求导后均为一个矩阵（按照课上的展开方式），因此每个<strong>f</strong>（包含多个f（标量））求导后为存放多个矩阵的三维形状，再由于矩阵F由多个<strong>f</strong>组成，因此F求导后为存放多个<strong>f</strong>求导结果的四维形状。<br><strong>对于不同f和input求导后的维度情况总结如下图所示（课程中的截图）</strong></li>
</ul>
<img src="/2024/04/23/11-01-06/06-26.png" class="">
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>07-链式法则与自动求导</title>
    <url>/2024/04/23/11-01-07/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.04.24：初稿</li>
</ul>
<h2 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h2><ul>
<li><a href="/2024/04/24/12-18-34/" title="动手学深度学习笔记汇总">动手学深度学习笔记汇总</a>
</li>
</ul>
<h2 id="07-链式法则与自动求导"><a href="#07-链式法则与自动求导" class="headerlink" title="07-链式法则与自动求导"></a>07-链式法则与自动求导</h2><h3 id="1-向量链式法则"><a href="#1-向量链式法则" class="headerlink" title="1. 向量链式法则"></a>1. 向量链式法则</h3><ul>
<li><h4 id="1-1-标量链式法则"><a href="#1-1-标量链式法则" class="headerlink" title="1.1 标量链式法则"></a>1.1 标量链式法则</h4></li>
</ul>
<img src="/2024/04/23/11-01-07/image-01.png" class="">
<ul>
<li><h4 id="1-2-拓展到向量"><a href="#1-2-拓展到向量" class="headerlink" title="1.2 拓展到向量"></a>1.2 拓展到向量</h4><blockquote>
<p>需要注意维数的变化</p>
<p>下图三种情况分别对应：</p>
<ol>
<li>y为标量，x为向量</li>
<li>y为标量，x为矩阵</li>
<li>y、x为矩阵</li>
</ol>
</blockquote>
</li>
</ul>
<img src="/2024/04/23/11-01-07/image-02.png" class="">
<hr>
<h5 id="例1（标量对向量求导）"><a href="#例1（标量对向量求导）" class="headerlink" title="例1（标量对向量求导）"></a>例1（标量对向量求导）</h5><blockquote>
<p>这里应该是用分子布局，所以是X转置</p>
</blockquote>
<p>​                                 <img src="/2024/04/23/11-01-07/image-03.png" class="">   </p>
<h5 id="例2（涉及到矩阵的情况）"><a href="#例2（涉及到矩阵的情况）" class="headerlink" title="例2（涉及到矩阵的情况）"></a>例2（涉及到矩阵的情况）</h5><blockquote>
<p>X是mxn的矩阵,w为n维向量，y为m维向量；<br>z对Xw-y做L2 norm,为标量；<br>过程与例一大体一致；</p>
</blockquote>
<p>​                                   <img src="/2024/04/23/11-01-07/image-04.png" class=""></p>
<hr>
<blockquote>
<p>由于在神经网络动辄几百层，手动进行链式求导是很困难的，因此我们需要借助自动求导</p>
</blockquote>
<hr>
<h3 id="2-自动求导"><a href="#2-自动求导" class="headerlink" title="2. 自动求导"></a>2. 自动求导</h3><ul>
<li><p>含义：计算一个函数在指定值上的导数</p>
</li>
<li><p>自动求导有别于</p>
<ul>
<li><p>符号求导</p>
<img src="/2024/04/23/11-01-07/image-05.png" class="">
</li>
<li><p>数值求导</p>
<img src="/2024/04/23/11-01-07/image-06.png" class="">
</li>
</ul>
</li>
</ul>
<p>为了更好地理解自动求导，下面引入计算图的概念</p>
<h4 id="2-1-计算图"><a href="#2-1-计算图" class="headerlink" title="2.1 计算图"></a>2.1 计算图</h4><ul>
<li><p>将代码分解成操作子</p>
</li>
<li><p>将计算表示成一个<strong>无环图</strong></p>
<blockquote>
<p>下图自底向上其实就类似于链式求导过程</p>
</blockquote>
</li>
</ul>
<img src="/2024/04/23/11-01-07/image-07.png" class="">
<p>​     </p>
<ul>
<li><p>计算图有两种构造方式<br>计算与上图无关</p>
<ul>
<li><p>显示构造</p>
<blockquote>
<p>可以理解为先定义公式再代值</p>
<p>Tensorflow/Theano/MXNet</p>
</blockquote>
<img src="/2024/04/23/11-01-07/image-08.png" class="">
</li>
<li><p>隐式构造</p>
<blockquote>
<p>系统将所有的计算记录下来</p>
<p>Pytorch/MXNet</p>
</blockquote>
<img src="/2024/04/23/11-01-07/image-09.png" class="">
</li>
</ul>
</li>
</ul>
<h4 id="2-2-自动求导的两种模式"><a href="#2-2-自动求导的两种模式" class="headerlink" title="2.2 自动求导的两种模式"></a>2.2 自动求导的两种模式</h4><ul>
<li><p>正向累积</p>
 <img src="/2024/04/23/11-01-07/image-10.png" class="">
</li>
<li><p>反向累积（反向传递back propagation）</p>
<img src="/2024/04/23/11-01-07/image-11.png" class="">
</li>
</ul>
<p>​    <strong>反向累积计算过程</strong></p>
<img src="/2024/04/23/11-01-07/image-12.png" class="">
<blockquote>
<p>反向累积的正向过程：自底向上，需要存储中间结果</p>
<p>反向累积的反向过程：自顶向下，可以去除不需要的枝（图中的x应为w）</p>
<img src="/2024/04/23/11-01-07/image-13.png" class="">
</blockquote>
<h4 id="2-3-复杂度比较"><a href="#2-3-复杂度比较" class="headerlink" title="2.3 复杂度比较"></a>2.3 复杂度比较</h4><ul>
<li><p>反向累积</p>
<ul>
<li>时间复杂度：O(n),n是操作子数<ul>
<li>通常正向和反向的代价类似</li>
</ul>
</li>
<li>空间复杂度：O(n)<ul>
<li>存储正向过程所有的中间结果</li>
</ul>
</li>
</ul>
</li>
<li><p>正向累积</p>
<blockquote>
<p>每次计算一个变量的梯度时都需要将所有节点扫一遍</p>
</blockquote>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-代码部分"><a href="#3-代码部分" class="headerlink" title="3. 代码部分"></a>3. 代码部分</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#对y = x.Tx关于列向量x求导</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">x = torch.arange(<span class="number">4.0</span>)</span><br><span class="line">x</span><br></pre></td></tr></table></figure>
<pre><code>tensor([0., 1., 2., 3.])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#存储梯度</span></span><br><span class="line">x.requires_grad_(<span class="literal">True</span>)<span class="comment">#等价于x = torch.arange(4.0,requires_grad=True)</span></span><br><span class="line">x.grad<span class="comment">#默认值是None</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y = torch.dot(x,x)</span><br><span class="line">y</span><br><span class="line"><span class="comment">#PyTorch隐式地构造计算图，grad_fn用于记录梯度计算</span></span><br></pre></td></tr></table></figure>
<pre><code>tensor(14., grad_fn=&lt;DotBackward0&gt;)
</code></pre><p><strong>通过调用反向传播函数来自动计算y关于x每个分量的梯度</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y.backward()</span><br><span class="line">x.grad</span><br></pre></td></tr></table></figure>
<pre><code>tensor([0., 2., 4., 6.])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x.grad==<span class="number">2</span>*x<span class="comment">#验证</span></span><br></pre></td></tr></table></figure>
<pre><code>tensor([True, True, True, True])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在默认情况下，PyTorch会累积梯度，我们需要清除之前的值</span></span><br><span class="line">x.grad.zero_()<span class="comment">#如果没有这一步结果就会加累上之前的梯度值，变为[1,5,9,13]</span></span><br><span class="line">y = x.<span class="built_in">sum</span>()</span><br><span class="line">y.backward()</span><br><span class="line">x.grad</span><br></pre></td></tr></table></figure>
<pre><code>tensor([1., 1., 1., 1.])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x.grad.zero_()</span><br><span class="line">y=x*x<span class="comment">#哈达玛积，对应元素相乘</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在深度学习中我们一般不计算微分矩阵</span></span><br><span class="line"><span class="comment">#而是计算批量中每个样本单独计算的偏导数之和</span></span><br><span class="line"></span><br><span class="line">y.<span class="built_in">sum</span>().backward()<span class="comment">#等价于y.backword(torch.ones(len(x)))</span></span><br><span class="line">x.grad</span><br></pre></td></tr></table></figure>
<pre><code>tensor([0., 2., 4., 6.])
</code></pre><p><strong>将某些计算移动到记录的计算图之外</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 后可用于用于将神经网络的一些参数固定住</span></span><br><span class="line">x.grad.zero_()</span><br><span class="line">y = x*x</span><br><span class="line">u = y.detach()<span class="comment">#把y当作常数</span></span><br><span class="line">z = u*x</span><br><span class="line"></span><br><span class="line">z.<span class="built_in">sum</span>().backward()</span><br><span class="line">x.grad == u</span><br></pre></td></tr></table></figure>
<pre><code>tensor([True, True, True, True])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x.grad.zero_()</span><br><span class="line">y.<span class="built_in">sum</span>().backward()</span><br><span class="line">x.grad == <span class="number">2</span>*x</span><br></pre></td></tr></table></figure>
<pre><code>tensor([True, True, True, True])
</code></pre><p><strong>即使构建函数的计算图需要用过Python控制流，仍然可以计算得到的变量的梯度</strong></p>
<p><strong>这也是隐式构造的优势，因为它会存储梯度计算的计算图，再次计算时执行反向过程就可以</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a</span>):</span><br><span class="line">    b = a * <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> b.norm()&lt;<span class="number">1000</span>:</span><br><span class="line">        b = b * <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> b.<span class="built_in">sum</span>() &gt; <span class="number">0</span>:</span><br><span class="line">        c = b</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        c = <span class="number">100</span> * b</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line">a = torch.randn(size=(),requires_grad=<span class="literal">True</span>)</span><br><span class="line">d = f(a)</span><br><span class="line">d.backward()</span><br><span class="line"></span><br><span class="line">a.grad == d / a</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="4-自动求导-Q-amp-A"><a href="#4-自动求导-Q-amp-A" class="headerlink" title="4. 自动求导 Q&amp;A"></a>4. 自动求导 Q&amp;A</h3><p><strong><code>Q1：ppt上隐式构造和显式构造看起来为啥差不多？</code></strong></p>
<blockquote>
<p>显式和隐式的差别其实就是数学上求梯度和python求梯度计算上的差别，不用深究</p>
<p>显式构造就是我们数学上正常求导数的求法，先把所有求导的表达式选出来再代值</p>
</blockquote>
<p><strong><code>Q2:需要正向和反向都算一遍吗？</code></strong></p>
<blockquote>
<p>需要正向先算一遍，自动求导时只进行反向就可以，因为正向的结果已经存储</p>
</blockquote>
<p><strong><code>Q3:为什么PyTorch会默认累积梯度</code></strong></p>
<blockquote>
<p>便于计算大批量；方便进一步设计</p>
</blockquote>
<p><strong><code>Q4:为什么深度学习中一般对标量求导而不是对矩阵或向量求导</code></strong></p>
<blockquote>
<p>loss一般都是标量</p>
</blockquote>
<p><strong><code>Q5:为什么获取.grad前需要backward</code></strong></p>
<blockquote>
<p>相当于告诉程序需要计算梯度，因为计算梯度的代价很大，默认不计算</p>
</blockquote>
<p><strong><code>Q6:pytorch或mxnet框架设计上可以实现矢量的求导吗</code></strong></p>
<blockquote>
<p>可以</p>
</blockquote>
<h3 id="5-练习"><a href="#5-练习" class="headerlink" title="5. 练习"></a>5. 练习</h3><p><strong>1.为什么计算二阶导数比一阶导数的开销要更大？</strong></p>
<p>二阶导数是在一阶导数的基础上进行的，开销自然更大</p>
<p><strong>2.在运行反向传播函数之后，立即再次运行它，看看会发生什么。</strong></p>
<p>“RuntimeError: Trying to backward through the graph a second time (or directly access saved tensors after they have already been freed). Saved intermediate values of the graph are freed when you call .backward() or autograd.grad(). Specify retain_graph=True if you need to backward through the graph a second time or if you need to access saved tensors after calling backward.”</p>
<p>说明不能连续两次运行,pytorch使用的是动态计算图,反向传播函数运行一次后计算图就被释放了</p>
<p><strong>只需要在函数接口将参数retain_graph设为True即可</strong></p>
<p>In [51]:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def f(a):</span><br><span class="line">    b = a * 2</span><br><span class="line">    while b.norm()&lt;1000:</span><br><span class="line">        b = b * 2</span><br><span class="line">    if b.sum() &gt; 0:</span><br><span class="line">        c = b</span><br><span class="line">    else:</span><br><span class="line">        c = 100 * b</span><br><span class="line">    return c</span><br><span class="line">a.grad.zero_()</span><br><span class="line">a = torch.randn(size=(),requires_grad=True)#size=0表示a是标量</span><br><span class="line">d = f(a)</span><br><span class="line">#d.backward(retain_graph=True)</span><br><span class="line">#a.grad</span><br><span class="line">d.backward()</span><br><span class="line">a.grad</span><br></pre></td></tr></table></figure>
<p>Out[51]:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tensor(4096.)</span><br></pre></td></tr></table></figure>
<p><strong>3.在控制流的例子中，我们计算d关于a的导数，如果我们将变量a更改为随机向量或矩阵，会发生什么？此时，计算结果f(a)不再是标量。结果会发生什么？我们如何分析这个结果？</strong></p>
<p>backward函数的机制本身不允许张量对张量求导，如果输入是向量或矩阵，需要将其在各个分量上求和，变为标量；所以还需要传入一个与输入同型的张量</p>
<p>In [53]:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def f(a):</span><br><span class="line">    b = a * 2</span><br><span class="line">    while b.norm()&lt;1000:</span><br><span class="line">        b = b * 2</span><br><span class="line">    if b.sum() &gt; 0:</span><br><span class="line">        c = b</span><br><span class="line">    else:</span><br><span class="line">        c = 100 * b</span><br><span class="line">    return c</span><br><span class="line">a.grad.zero_()</span><br><span class="line">a = torch.randn(10,requires_grad=True)</span><br><span class="line">d = f(a)</span><br><span class="line">#d.backward(retain_graph=True)</span><br><span class="line">#a.grad</span><br><span class="line">#d.backward()#RuntimeError: grad can be implicitly created only for scalar outputs</span><br><span class="line">d.sum().backward()#需要加上.sum()否则会报错 </span><br><span class="line">a.grad</span><br></pre></td></tr></table></figure>
<p>Out[53]:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tensor([51200., 51200., 51200., 51200., 51200., 51200., 51200., 51200., 51200.,</span><br><span class="line">        51200.])</span><br></pre></td></tr></table></figure>
<p><strong>4.重新设计一个求控制流梯度的例子。运行并分析结果。</strong></p>
<p>In [56]:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def h(x):</span><br><span class="line">    y = x * x</span><br><span class="line">    while y.norm() &lt; 2500:</span><br><span class="line">        y = y * 2</span><br><span class="line">    if y.sum() &lt; 0:</span><br><span class="line">        c = 100*y</span><br><span class="line">    else:</span><br><span class="line">        c = y</span><br><span class="line">    return c</span><br><span class="line">x.grad.zero_()</span><br><span class="line">x = torch.randn(size=(),requires_grad=True)</span><br><span class="line">y = h(x)</span><br><span class="line">y.backward()</span><br><span class="line">x.grad</span><br></pre></td></tr></table></figure>
<p>Out[56]:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tensor(-3311.5398)</span><br></pre></td></tr></table></figure>
<p><strong>5.使f(x)=sin(x)，绘制f(x)和df(x)/dx的图像，其中后者不使用f’(x)=\cos(x)。</strong></p>
<p>In [66]:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">x = torch.arange(-20,20,0.1,requires_grad=True,dtype=torch.float32)</span><br><span class="line">y = torch.sin(x)</span><br><span class="line">y.sum().backward()</span><br><span class="line">plt.plot(x.detach(),y.detach(),label=&#x27;y=sinx&#x27;)</span><br><span class="line">plt.plot(x.detach(),x.grad,label=&#x27;dy/dx&#x27;)</span><br><span class="line">plt.legend(loc=&#x27;lower right&#x27;)</span><br></pre></td></tr></table></figure>
<p>Out[66]:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;matplotlib.legend.Legend at 0x1d627d00280&gt;</span><br></pre></td></tr></table></figure>
<img src="/2024/04/23/11-01-07/image-14.png" class="">
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>08-线性回归+基础优化算法</title>
    <url>/2024/04/23/11-01-08/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.04.24：初稿</li>
</ul>
<h2 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h2><ul>
<li><a href="/2024/04/24/12-18-34/" title="动手学深度学习笔记汇总">动手学深度学习笔记汇总</a>
</li>
</ul>
<h2 id="线性回归-基础优化算法"><a href="#线性回归-基础优化算法" class="headerlink" title="线性回归+基础优化算法"></a>线性回归+基础优化算法</h2><h3 id="1-线性回归"><a href="#1-线性回归" class="headerlink" title="1.线性回归"></a>1.线性回归</h3><ul>
<li><p>房价预测例子</p>
</li>
<li><p><strong>线性模型</strong></p>
<ul>
<li><p>输入：$x=[x_1,x_2,…,x_n]^T$</p>
</li>
<li><p>线性模型需要确定一个n维权重和一个标量偏差$\omega=[\omega_1,\omega_2,…,\omega_n]^T,b$</p>
</li>
<li><p>输出 ：$y=\omega_1x_1+\omega_2x_2+…+\omega_nx_n+b$，</p>
<p>向量版本的是 $y=&lt;\omega,x&gt;+b$</p>
</li>
<li><p>线性模型可以看作是单层神经网络</p>
<blockquote>
<ul>
<li>神经网络源于神经科学<ul>
<li>最早的神经网络是源自神经科学的，但是时至今日，很多神经网络已经远远高于神经科学，可解释性也不是很强，不必纠结</li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p>衡量估计质量</p>
<ul>
<li><p>我们需要估计模型的预估值和真实值之间的差距，例如房屋售价和股价</p>
</li>
<li><p>假设$y$是真实值，$\tilde{y}$是估计值，我们可以比较</p>
<p>$l(y,\tilde{y})=\frac{1}{2}(y-\tilde{y})^2$，这个叫做<strong>平方损失</strong></p>
</li>
</ul>
</li>
<li><p><strong>训练数据</strong></p>
<ul>
<li><p>收集一些数据点来决定参数值（权重$\omega$和偏差$b$），例如6个月内被卖掉的房子。</p>
</li>
<li><p>这被称之为训练数据</p>
</li>
<li><p>通常越多越好。需要注意的是，现实世界的数据都是有限的，但是为了训练出精确的参数往往需要训练数据越多越好，当训练数据不足的时候，我们还需要进行额外处理。</p>
</li>
<li><p>假设我们有n个样本，记为</p>
<p>$X=[x_1,x_2,…,x_n]^T,y=[y_1,y_2,…y_n]^T$</p>
<p>$X$的每一行是一个样本，$y$的每一行是一个输出的实数值。</p>
</li>
</ul>
</li>
<li><p><strong>参数学习</strong></p>
<ul>
<li><p><strong>训练损失</strong>。但我们训练参数的时候，需要定义一个损失函数来衡量参数的好坏，应用前文提过的平方损失有公式：</p>
<p>$l(X,x,\omega,b)=\frac{1}{2n}\sum_{i=1}^n(y_i-{&lt; x_i, w &gt;}-b)^2=\frac{1}{2n}||y-X\omega-b||^2$</p>
</li>
<li><p><strong>最小化损失来学习参数</strong>。训练参数的目的就是使损失函数的值尽可能小（这意味着预估值和真实值更接近）。最后求得的参数值可表示为：</p>
<p>$\omega^*,b^*=argmin_{\omega,b}l(X,x,\omega,b)$</p>
</li>
</ul>
</li>
<li><p><strong>显示解</strong></p>
<ul>
<li><p>线性回归有显示解，即可以直接矩阵数学运算，得到参数w和b的最优解，而不是用梯度下降，牛顿法等参数优化方式一点点逼近最优解。</p>
</li>
<li><p><strong>推导过程</strong>：</p>
<ul>
<li><p>为了方便矩阵表示和计算，将偏差加入权重，$X\gets[X,1],\omega\gets[\omega,b]$</p>
</li>
<li><p>损失函数是凸函数，最优解满足导数为0，可解出显示解</p>
<p>令$\frac{\partial}{\partial\omega} l(X,y,\omega)=0$</p>
<p>有$\frac{1}{n}(y-X\omega)^TX=0$</p>
<p>解得$\omega^*=(X^TX)^{-1}X^Ty$</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>总结</p>
<ul>
<li>线性回归是对n维输入的加权，外加偏差</li>
<li>使用<strong>平方损失</strong>来衡量预测值和真实值之间的误差</li>
<li><strong>线性回归有显示解</strong></li>
<li>线性回归可以看作单层神经网络</li>
</ul>
</li>
</ul>
<h3 id="2-基础优化算法"><a href="#2-基础优化算法" class="headerlink" title="2.基础优化算法"></a>2.基础优化算法</h3><ul>
<li><p><strong>梯度下降</strong></p>
<ul>
<li>当模型没有显示解的时候，应用梯度下降法逼近最优解。</li>
<li>梯度下降法的具体步骤：<ul>
<li>挑选一个初始值$\omega_0$</li>
<li>重复迭代参数，迭代公式为：$\omega_t=\omega_{t-1}-\lambda\frac{\partial l}{\partial\omega_{t-1} } $<ul>
<li><strong>$-\frac{\partial l}{\partial\omega_{t-1}}$为函数值下降最快的方向，学习率$\lambda$为学习步长。</strong></li>
</ul>
</li>
</ul>
</li>
<li>选择学习率<ul>
<li>学习率$\lambda$为学习步长，代表了沿负梯度方向走了多远，这是超参数（人为指定的的值，不是训练得到的）</li>
<li>学习率不能太大，也不能太小，需要选取适当。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>小批量随机梯度下降</strong></p>
<ul>
<li><p>在整个训练集上算梯度太贵了</p>
<ul>
<li>在实际应用中，很少直接应用梯度下降法，这是因为每次更新都需要计算训练集上所有的样本，耗费时间太长。一个深度神经网络模型，迭代一次可能需要数分钟甚至数小时。</li>
</ul>
</li>
<li><p>为了减少运算代价，我们可以==随机采样==b个样本$i_1,i_2,…,i_b$来近似损失，损失函数为：</p>
<p>​    $\frac{1}{b}\sum_{i\in I_b}l(x_i,y_i,\omega)$ , </p>
<p>其中<strong>b是批量大小(batch size)，也是超参数</strong></p>
</li>
<li><p><strong>选择批量大小</strong></p>
<ul>
<li>b也不能太大：内存消耗增加；浪费计算资源，一个极端的情况是可能会重复选取很多差不多的样本，浪费计算资源</li>
<li>b也不能太小：每次计算量太小，很难以并行，不能最大限度利用GPU资源</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>总结</strong></p>
<ul>
<li>梯度下降通过不断<strong>沿着负梯度方向</strong>更新参数求解</li>
<li>小批量随机梯度下降是深度学习默认的求解算法（简单，稳定）</li>
<li><strong>两个重要的超参数：批量大小（batch size），学习率（lr）</strong></li>
</ul>
</li>
</ul>
<h3 id="3-线性回归的从零开始实现"><a href="#3-线性回归的从零开始实现" class="headerlink" title="3.线性回归的从零开始实现"></a>3.线性回归的从零开始实现</h3><ul>
<li>代码</li>
</ul>
<h3 id="4-新型回归的简洁实现"><a href="#4-新型回归的简洁实现" class="headerlink" title="4.新型回归的简洁实现"></a>4.新型回归的简洁实现</h3><ul>
<li>代码</li>
</ul>
<ul>
<li><strong>1.为什么使用平方损失而不是绝对差值？</strong><ul>
<li>其实差别不大，最开始使用平方损失是因为它可导，现在其实都可以使用。</li>
</ul>
</li>
<li><strong>2.损失为什么要求平均？</strong><ul>
<li>本质上没有关系，但是如果不求平均，梯度的数值会比较大，这时需要学习率除以n。如果不除以n，可能会随着样本数量的增大而让梯度变得很大。</li>
</ul>
</li>
<li><strong>3.不管是梯度下降还是随机梯度下降，怎么找到合适的学习率？</strong><ul>
<li>选择对学习率不敏感的优化方法，比如Adam</li>
<li>合理参数初始化</li>
</ul>
</li>
<li><strong>4.训练过程中，过拟合和欠拟合情况下，学习率和batch_size应该如何调整？</strong><ul>
<li>理论上学习率和batch_size对最后的拟合结果不会有影响</li>
</ul>
</li>
<li><strong>5.深度学习上，设置损失函数的时候，需要考虑正则吗？</strong><ul>
<li>会考虑，但是和损失函数是分开的，深度学习中正则没有太大的用处，有很多其他的技术可以有正则的效果。</li>
</ul>
</li>
<li><strong>6.如果样本大小不是批量数的整数倍，需要随机剔除多余的样本吗？</strong><ul>
<li>就取多余的样本作为一个批次</li>
<li>直接丢弃</li>
<li>从下一个epoch里面补少的样本</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>05-线性代数</title>
    <url>/2024/04/23/11-01-05/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.04.24：初稿</li>
</ul>
<h2 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h2><ul>
<li><a href="/2024/04/24/12-18-34/" title="动手学深度学习笔记汇总">动手学深度学习笔记汇总</a>
</li>
</ul>
<h2 id="05-线性代数"><a href="#05-线性代数" class="headerlink" title="05-线性代数"></a>05-线性代数</h2><h3 id="1-线性代数基础知识"><a href="#1-线性代数基础知识" class="headerlink" title="1. 线性代数基础知识"></a>1. 线性代数基础知识</h3><p>这部分主要是由标量过渡到向量，再从向量拓展到矩阵操作，重点在于理解矩阵层面上的操作</p>
<h4 id="1-1-标量"><a href="#1-1-标量" class="headerlink" title="1.1 标量"></a>1.1 标量</h4><img src="/2024/04/23/11-01-05/05-01.png" class="">
<h4 id="1-2-向量"><a href="#1-2-向量" class="headerlink" title="1.2 向量"></a>1.2 向量</h4><img src="/2024/04/23/11-01-05/05-02.png" class="">
<img src="/2024/04/23/11-01-05/05-03.png" class="">
<h4 id="1-3-矩阵"><a href="#1-3-矩阵" class="headerlink" title="1.3 矩阵"></a>1.3 矩阵</h4><h5 id="1-3-1-矩阵的操作"><a href="#1-3-1-矩阵的操作" class="headerlink" title="1.3.1 矩阵的操作"></a>1.3.1 矩阵的操作</h5><img src="/2024/04/23/11-01-05/05-04.png" class="">
<img src="/2024/04/23/11-01-05/05-05.png" class="">
<img src="/2024/04/23/11-01-05/05-06.png" class="">
<img src="/2024/04/23/11-01-05/05-07.png" class="">
<p>​    (矩阵范数麻烦且不常用，一般用F范数)</p>
<h5 id="1-3-2-特殊矩阵"><a href="#1-3-2-特殊矩阵" class="headerlink" title="1.3.2 特殊矩阵"></a>1.3.2 特殊矩阵</h5><img src="/2024/04/23/11-01-05/05-08.png" class="">
<img src="/2024/04/23/11-01-05/05-09.png" class="">
<img src="/2024/04/23/11-01-05/05-10.png" class="">
<p>​    (深度学习里基本不会涉及到正定、置换矩阵，这里明确个概念就行)</p>
<h5 id="1-3-3-特征向量和特征值"><a href="#1-3-3-特征向量和特征值" class="headerlink" title="1.3.3 特征向量和特征值"></a>1.3.3 特征向量和特征值</h5><ul>
<li><p>数学定义：设A是n阶方阵，如果存在常数<img src="https://images0.cnblogs.com/blog/650633/201407/141700142243782.png" alt="img">及非零n向量x，使得<img src="https://images0.cnblogs.com/blog/650633/201407/141700145536982.png" alt="img">，则称<img src="https://images0.cnblogs.com/blog/650633/201407/141700149439396.png" alt="img">是矩阵A的特征值，x是A属于特征值<img src="https://images0.cnblogs.com/blog/650633/201407/141700153035353.png" alt="img">的特征向量</p>
</li>
<li><p>直观理解：不被矩阵A改变方向的向量x就是A的一个特征向量</p>
<img src="/2024/04/23/11-01-05/05-11.png" class="">
</li>
<li><p>矩阵不一定有特征向量，但是对称矩阵总是可以找到特征向量</p>
</li>
</ul>
<h3 id="2-线性代数实现"><a href="#2-线性代数实现" class="headerlink" title="2. 线性代数实现"></a>2. 线性代数实现</h3><p>这部分主要是应用pytorch实现基本矩阵操作，同样由标量过渡到向量最后拓展到矩阵</p>
<h4 id="2-1-标量"><a href="#2-1-标量" class="headerlink" title="2.1 标量"></a>2.1 标量</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch    <span class="comment"># 应用pytorch框架</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 标量由只有一个元素的张量表示</span></span><br><span class="line">x = torch.tensor([<span class="number">3.0</span>])     <span class="comment"># 单独一个数字表示标量也可以</span></span><br><span class="line">y = torch.tensor([<span class="number">2.0</span>])     <span class="comment"># 单独一个数字表示标量也可以</span></span><br><span class="line"><span class="built_in">print</span>(x + y)    <span class="comment"># tensor([5.])</span></span><br><span class="line"><span class="built_in">print</span>(x * y)    <span class="comment"># tensor([6.])</span></span><br><span class="line"><span class="built_in">print</span>(x / y)    <span class="comment"># tensor([1.5000])</span></span><br><span class="line"><span class="built_in">print</span>(x ** y)   <span class="comment"># tensor([9.]) 指数运算</span></span><br></pre></td></tr></table></figure>
<h4 id="2-2-向量"><a href="#2-2-向量" class="headerlink" title="2.2 向量"></a>2.2 向量</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 向量可以看作是若干标量值组成的列表</span></span><br><span class="line">x = torch.arange(<span class="number">4</span>)     <span class="comment"># tensor([0, 1, 2, 3])</span></span><br><span class="line">                        <span class="comment"># 生成[0, 4)范围内所有整数构成的张量tensor</span></span><br><span class="line"><span class="built_in">print</span>(x[<span class="number">3</span>])             <span class="comment"># tensor(3)</span></span><br><span class="line">                        <span class="comment"># 和列表相似，通过张量的索引访问元素</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(x))           <span class="comment"># 4</span></span><br><span class="line">                        <span class="comment"># 获取张量x的长度</span></span><br><span class="line"><span class="built_in">print</span>(x.shape)          <span class="comment"># torch.Size([4])</span></span><br><span class="line">                        <span class="comment"># 获取张量形状，这里x是只有一个轴的张量因此形状只有一个元素</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="2-3-矩阵"><a href="#2-3-矩阵" class="headerlink" title="2.3 矩阵"></a>2.3 矩阵</h4><h5 id="2-3-1-创建"><a href="#2-3-1-创建" class="headerlink" title="2.3.1 创建"></a>2.3.1 创建</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = torch.arange(<span class="number">6</span>)     <span class="comment"># tensor([0, 1, 2, 3, 4, 5])</span></span><br><span class="line">B = torch.tensor([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">0</span>,<span class="number">4</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]])</span><br><span class="line">C = torch.tensor([[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">                   [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],</span><br><span class="line">                   [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]],</span><br><span class="line">                  [[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">                   [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">                   [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]]])</span><br><span class="line">D = torch.arange(<span class="number">20</span>, dtype=torch.float32)</span><br></pre></td></tr></table></figure>
<h5 id="2-3-2-转置"><a href="#2-3-2-转置" class="headerlink" title="2.3.2 转置"></a>2.3.2 转置</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = torch.arange(<span class="number">6</span>)     <span class="comment"># tensor([0, 1, 2, 3, 4, 5])</span></span><br><span class="line">A = A.reshape(<span class="number">3</span>,<span class="number">2</span>)      <span class="comment"># tensor([[0, 1],</span></span><br><span class="line">                        <span class="comment">#         [2, 3],</span></span><br><span class="line">                        <span class="comment">#         [4, 5]])</span></span><br><span class="line"></span><br><span class="line">A = A.T                 <span class="comment"># 转置 A.T</span></span><br><span class="line">                        <span class="comment"># tensor([[0, 2, 4],</span></span><br><span class="line">                        <span class="comment">#         [1, 3, 5]])</span></span><br></pre></td></tr></table></figure>
<h5 id="2-3-3-reshape"><a href="#2-3-3-reshape" class="headerlink" title="2.3.3 reshape"></a>2.3.3 reshape</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用reshape方法创建一个形状为3 x 2的矩阵A</span></span><br><span class="line">A = torch.arange(<span class="number">6</span>)     <span class="comment"># tensor([0, 1, 2, 3, 4, 5])</span></span><br><span class="line">A = A.reshape(<span class="number">3</span>,<span class="number">2</span>)      <span class="comment"># tensor([[0, 1],</span></span><br><span class="line">                        <span class="comment">#         [2, 3],</span></span><br><span class="line">                        <span class="comment">#         [4, 5]])</span></span><br></pre></td></tr></table></figure>
<p>tips(确定矩阵shape)：</p>
<p>由外层到内层依次去中括号，并记下去掉中括号后此时元素的个数，任选其中一个元素重复上述去括号的操作直到该元素中无中括号，记下的数字从左到右依次排序中间用x连接即为矩阵shape</p>
<h5 id="2-3-4-clone"><a href="#2-3-4-clone" class="headerlink" title="2.3.4 clone"></a>2.3.4 clone</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = torch.arange(<span class="number">20</span>, dtype=torch.float32)</span><br><span class="line">A = A.reshape(<span class="number">5</span>,<span class="number">4</span>)</span><br><span class="line">B = A.clone()   <span class="comment"># 通过分配新内存，将A的一个副本分给B，该边B并不影响A的值</span></span><br><span class="line"><span class="built_in">print</span>(B)        <span class="comment"># tensor([[ 0.,  1.,  2.,  3.],</span></span><br><span class="line">                <span class="comment">#         [ 4.,  5.,  6.,  7.],</span></span><br><span class="line">                <span class="comment">#         [ 8.,  9., 10., 11.],</span></span><br><span class="line">                <span class="comment">#         [12., 13., 14., 15.],</span></span><br><span class="line">                <span class="comment">#         [16., 17., 18., 19.]])</span></span><br></pre></td></tr></table></figure>
<h5 id="2-3-5-sum"><a href="#2-3-5-sum" class="headerlink" title="2.3.5 sum"></a>2.3.5 sum</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = torch.tensor([[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">                   [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],</span><br><span class="line">                   [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]],</span><br><span class="line">                  [[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">                   [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">                   [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]]])</span><br><span class="line"><span class="built_in">print</span>(A.shape)</span><br><span class="line"><span class="comment"># torch.Size([2, 3, 3])</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(A.<span class="built_in">sum</span>())</span><br><span class="line"><span class="comment"># tensor(54)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(A.<span class="built_in">sum</span>(axis=<span class="number">0</span>))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([[ 1,  2,  3],</span></span><br><span class="line"><span class="string">        [ 5,  6,  7],</span></span><br><span class="line"><span class="string">        [ 9, 10, 11]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(A.<span class="built_in">sum</span>(axis=<span class="number">0</span>, keepdims=<span class="literal">True</span>))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([[[ 1,  2,  3],</span></span><br><span class="line"><span class="string">         [ 5,  6,  7],</span></span><br><span class="line"><span class="string">         [ 9, 10, 11]]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(A.<span class="built_in">sum</span>(axis=<span class="number">1</span>))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([[12, 15, 18],</span></span><br><span class="line"><span class="string">        [ 3,  3,  3]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(A.<span class="built_in">sum</span>(axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([[[12, 15, 18]],</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        [[ 3,  3,  3]]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(A.<span class="built_in">sum</span>(axis=<span class="number">2</span>))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([[ 6, 15, 24],</span></span><br><span class="line"><span class="string">        [ 0,  3,  6]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(A.<span class="built_in">sum</span>(axis=<span class="number">2</span>, keepdims=<span class="literal">True</span>))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([[[ 6],</span></span><br><span class="line"><span class="string">         [15],</span></span><br><span class="line"><span class="string">         [24]],</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        [[ 0],</span></span><br><span class="line"><span class="string">         [ 3],</span></span><br><span class="line"><span class="string">         [ 6]]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(A.<span class="built_in">sum</span>(axis=[<span class="number">0</span>,<span class="number">1</span>]))</span><br><span class="line"><span class="comment"># tensor([15, 18, 21])</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(A.<span class="built_in">sum</span>(axis=[<span class="number">0</span>,<span class="number">1</span>], keepdims=<span class="literal">True</span>))</span><br><span class="line"><span class="comment"># tensor([[[15, 18, 21]]])</span></span><br></pre></td></tr></table></figure>
<h5 id="2-3-6-numel"><a href="#2-3-6-numel" class="headerlink" title="2.3.6 numel"></a>2.3.6 numel</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = torch.tensor([[<span class="number">0.</span>,<span class="number">0.</span>,<span class="number">0.</span>],[<span class="number">1.</span>,<span class="number">1.</span>,<span class="number">1.</span>]])</span><br><span class="line"><span class="built_in">print</span>(A.numel())    <span class="comment"># 6 元素个数</span></span><br></pre></td></tr></table></figure>
<h5 id="2-3-7-mean"><a href="#2-3-7-mean" class="headerlink" title="2.3.7 mean"></a>2.3.7 mean</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = torch.tensor([[<span class="number">0.</span>,<span class="number">0.</span>,<span class="number">0.</span>],[<span class="number">1.</span>,<span class="number">1.</span>,<span class="number">1.</span>]])</span><br><span class="line"><span class="built_in">print</span>(A.numel())    <span class="comment"># 6 元素个数</span></span><br><span class="line"><span class="built_in">print</span>(A.<span class="built_in">sum</span>())      <span class="comment"># tensor(3.)</span></span><br><span class="line"><span class="built_in">print</span>(A.mean())     <span class="comment"># tensor(0.5000)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 特定轴</span></span><br><span class="line">A = torch.tensor([[<span class="number">0.</span>,<span class="number">0.</span>,<span class="number">0.</span>],[<span class="number">1.</span>,<span class="number">1.</span>,<span class="number">1.</span>]])</span><br><span class="line"><span class="built_in">print</span>(A.shape[<span class="number">0</span>])       <span class="comment"># 2</span></span><br><span class="line"><span class="built_in">print</span>(A.<span class="built_in">sum</span>(axis=<span class="number">0</span>))    <span class="comment"># tensor([1., 1., 1.])</span></span><br><span class="line"><span class="built_in">print</span>(A.mean(axis=<span class="number">0</span>))   <span class="comment"># tensor([0.5000, 0.5000, 0.5000])	平均值</span></span><br></pre></td></tr></table></figure>
<h5 id="2-3-8-dot"><a href="#2-3-8-dot" class="headerlink" title="2.3.8 dot"></a>2.3.8 dot</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.tensor([<span class="number">0.</span>,<span class="number">1.</span>,<span class="number">2.</span>,<span class="number">3.</span>])</span><br><span class="line">y = torch.tensor([<span class="number">1.</span>,<span class="number">1.</span>,<span class="number">1.</span>,<span class="number">1.</span>])</span><br><span class="line"><span class="built_in">print</span>(torch.dot(x, y))  <span class="comment"># tensor(6.)</span></span><br></pre></td></tr></table></figure>
<h5 id="2-3-9-mm、mv"><a href="#2-3-9-mm、mv" class="headerlink" title="2.3.9 mm、mv"></a>2.3.9 mm、mv</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = torch.tensor([[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">                  [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]])</span><br><span class="line">B = torch.tensor([[<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">                  [<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">                  [<span class="number">0</span>,<span class="number">0</span>]])</span><br><span class="line">x = torch.tensor([<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(torch.mv(A, x))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">向量积</span></span><br><span class="line"><span class="string">tensor([ 9, 36])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(torch.mm(A, B))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">矩阵积</span></span><br><span class="line"><span class="string">tensor([[ 1,  1],</span></span><br><span class="line"><span class="string">        [10, 10]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h5 id="2-3-10-L1、L2、F范数"><a href="#2-3-10-L1、L2、F范数" class="headerlink" title="2.3.10  L1、L2、F范数"></a>2.3.10  L1、L2、F范数</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.tensor([<span class="number">3.0</span>, -<span class="number">4.0</span>])</span><br><span class="line"><span class="built_in">print</span>(torch.<span class="built_in">abs</span>(x).<span class="built_in">sum</span>())   <span class="comment"># 向量的L1范数: tensor(7.)  x中的每个元素绝对值的和</span></span><br><span class="line"><span class="built_in">print</span>(torch.norm(x))        <span class="comment"># 向量的L2范数: tensor(5.)  x中的每个元素平方的和开根号</span></span><br><span class="line"></span><br><span class="line">A = torch.ones((<span class="number">4</span>, <span class="number">9</span>))</span><br><span class="line"><span class="built_in">print</span>(torch.norm(A))        <span class="comment"># 矩阵的F范数:  tensor(6.)  A中的每个元素平方的和开根号</span></span><br></pre></td></tr></table></figure>
<h5 id="2-3-11-运算"><a href="#2-3-11-运算" class="headerlink" title="2.3.11  运算"></a>2.3.11  运算</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = torch.arange(<span class="number">20</span>, dtype=torch.float32)</span><br><span class="line">A = A.reshape(<span class="number">5</span>,<span class="number">4</span>)</span><br><span class="line">B = A.clone()   </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(B)        <span class="comment"># tensor([[ 0.,  1.,  2.,  3.],</span></span><br><span class="line">                <span class="comment">#         [ 4.,  5.,  6.,  7.],</span></span><br><span class="line">                <span class="comment">#         [ 8.,  9., 10., 11.],</span></span><br><span class="line">                <span class="comment">#         [12., 13., 14., 15.],</span></span><br><span class="line">                <span class="comment">#         [16., 17., 18., 19.]])</span></span><br><span class="line">                </span><br><span class="line"><span class="built_in">print</span>(A == B)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([[True, True, True, True],</span></span><br><span class="line"><span class="string">        [True, True, True, True],</span></span><br><span class="line"><span class="string">        [True, True, True, True],</span></span><br><span class="line"><span class="string">        [True, True, True, True],</span></span><br><span class="line"><span class="string">        [True, True, True, True]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(A + B)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([[ 0.,  2.,  4.,  6.],</span></span><br><span class="line"><span class="string">        [ 8., 10., 12., 14.],</span></span><br><span class="line"><span class="string">        [16., 18., 20., 22.],</span></span><br><span class="line"><span class="string">        [24., 26., 28., 30.],</span></span><br><span class="line"><span class="string">        [32., 34., 36., 38.]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(A * B)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([[  0.,   1.,   4.,   9.],</span></span><br><span class="line"><span class="string">        [ 16.,  25.,  36.,  49.],</span></span><br><span class="line"><span class="string">        [ 64.,  81., 100., 121.],</span></span><br><span class="line"><span class="string">        [144., 169., 196., 225.],</span></span><br><span class="line"><span class="string">        [256., 289., 324., 361.]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h5 id="2-3-12-广播"><a href="#2-3-12-广播" class="headerlink" title="2.3.12 广播"></a>2.3.12 广播</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = torch.tensor([[<span class="number">1.</span>,<span class="number">2.</span>,<span class="number">3.</span>],</span><br><span class="line">                  [<span class="number">4.</span>,<span class="number">5.</span>,<span class="number">6.</span>]])</span><br><span class="line">B = A.<span class="built_in">sum</span>(axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(B)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([[ 6.],</span></span><br><span class="line"><span class="string">        [15.]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(A / B)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([[0.1667, 0.3333, 0.5000],</span></span><br><span class="line"><span class="string">        [0.2667, 0.3333, 0.4000]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(A + B)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([[ 7.,  8.,  9.],</span></span><br><span class="line"><span class="string">        [19., 20., 21.]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(A * B)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([[ 6., 12., 18.],</span></span><br><span class="line"><span class="string">        [60., 75., 90.]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>09-softmax回归</title>
    <url>/2024/04/23/11-01-09/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.04.24：初稿</li>
</ul>
<h2 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h2><ul>
<li><a href="/2024/04/24/12-18-34/" title="动手学深度学习笔记汇总">动手学深度学习笔记汇总</a>
</li>
</ul>
<h1 id="09-softmax回归"><a href="#09-softmax回归" class="headerlink" title="09-softmax回归"></a>09-softmax回归</h1><h3 id="1-回归VS分类："><a href="#1-回归VS分类：" class="headerlink" title="1.回归VS分类："></a>1.回归VS分类：</h3><ul>
<li>回归估计一个连续值</li>
<li>分类预测一个离散类别</li>
</ul>
<img src="/2024/04/23/11-01-09/09-01.png" class="">
<h4 id="1-1-从回归到多类分类："><a href="#1-1-从回归到多类分类：" class="headerlink" title="1.1 从回归到多类分类："></a>1.1 从回归到多类分类：</h4><h5 id="回归："><a href="#回归：" class="headerlink" title="回归："></a>回归：</h5><ul>
<li>单连续数值输出</li>
<li>自然区间R</li>
<li>跟真实值的区别作为损失</li>
</ul>
<img src="/2024/04/23/11-01-09/09-02.png" class="">
<h5 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h5><ul>
<li><p>通常多个输出</p>
</li>
<li><p>输出i是预测为第i类的置信度</p>
</li>
</ul>
<img src="/2024/04/23/11-01-09/09-03.png" class="">
<h5 id="均方损失："><a href="#均方损失：" class="headerlink" title="均方损失："></a>均方损失：</h5><ul>
<li><p>对类别进行一位有效编码</p>
<p>$y=[y_{1},y_{2},…,y_{n}]^{T}$<br>$y_{i}=\begin{cases}<br>1&amp;i=y\\<br>2&amp;otherwise<br>\end{cases}$</p>
</li>
<li><p>使用均方损失训练</p>
</li>
<li><p>最大值为预测<br>$<br>\hat{y}=\underset {i}{argmax}\quad o^{i}<br>$</p>
</li>
</ul>
<h5 id="无校验比例"><a href="#无校验比例" class="headerlink" title="无校验比例"></a>无校验比例</h5><ul>
<li><p>对类别进行一位有效编码</p>
</li>
<li><p>最大值为预测<br>$<br>\hat{y}=\underset {i}{argmax}\quad o^{i}<br>$</p>
</li>
<li><p>需要更置信的识别正确类（大余量）<br>$<br>o_y-o_i\geq\Delta(y,i)<br>$</p>
</li>
</ul>
<h5 id="校验比例"><a href="#校验比例" class="headerlink" title="校验比例"></a>校验比例</h5><ul>
<li><p>输出匹配概率（$\hat{y}$非负，和为1）<br>$<br>\hat{y}=softmax(o)<br>$</p>
<p>$<br>\hat{y_i}=\frac{exp(o_i)}{\sum_{k} exp(o_k)}<br>$</p>
</li>
</ul>
<ul>
<li>概率$y$和$\hat{y}$的区别作为损失</li>
</ul>
<h4 id="1-2-Softmax和交叉熵损失"><a href="#1-2-Softmax和交叉熵损失" class="headerlink" title="1.2 Softmax和交叉熵损失"></a>1.2 Softmax和交叉熵损失</h4><ul>
<li><p>交叉熵用来衡量两个概率的区别$H(p,q)=\sum_{i} -p_{i}log(q_i)$</p>
</li>
<li><p>将它作为损失<br>$<br>l(y,\hat{y})=-\sum_{i}y_{i}log\hat{y_{i}}=-log\hat{y_y}<br>$</p>
<blockquote>
<p>推导过程？</p>
</blockquote>
</li>
<li>其梯度是真实概率和预测概率的区别<br>$<br>\partial_{o_{i}}l(y,\hat{y})=softmax(o)_{i}-y_{i}<br>$</li>
</ul>
<blockquote>
<p>Softmax回归是一个多类分类模型</p>
<p>使用Softmax操作子得到每个类的预测置信度</p>
<p>使用交叉熵来衡量和预测标号的区别</p>
</blockquote>
<h3 id="2-损失函数"><a href="#2-损失函数" class="headerlink" title="2.损失函数"></a>2.损失函数</h3><img src="/2024/04/23/11-01-09/09-04.png" class="">
<h4 id="2-1-L2-Loss-均方损失"><a href="#2-1-L2-Loss-均方损失" class="headerlink" title="2.1 L2 Loss  均方损失"></a>2.1 L2 Loss  均方损失</h4><p>$<br>l(y,y^{‘})=\frac{1}{2}(y-y^{‘})^2<br>$</p>
<img src="/2024/04/23/11-01-09/09-05.png" class="">
<blockquote>
<p>蓝色：y=0<br>绿色似然函数,高斯分布<br>损失函数的梯度，一次函数<br>梯度会随着结果逼近而下降</p>
</blockquote>
<h4 id="2-2-L1-Loss-绝对值损失函数"><a href="#2-2-L1-Loss-绝对值损失函数" class="headerlink" title="2.2 L1 Loss  绝对值损失函数"></a>2.2 L1 Loss  绝对值损失函数</h4><p>$<br>l(y,y^{‘})=\lvert y-y^{‘}\rvert<br>$</p>
<img src="/2024/04/23/11-01-09/09-06.png" class="">
<blockquote>
<p>梯度保持不变，但在0处梯度随机</p>
</blockquote>
<h4 id="2-3Huber’s-Robust-Loss-鲁棒损失"><a href="#2-3Huber’s-Robust-Loss-鲁棒损失" class="headerlink" title="2.3Huber’s Robust Loss   鲁棒损失"></a>2.3Huber’s Robust Loss   鲁棒损失</h4><img src="/2024/04/23/11-01-09/09-07.png" class="">
<blockquote>
<p>结合L1 Loss和L2 Loss的优点</p>
</blockquote>
<h3 id="3-图片分类数据集"><a href="#3-图片分类数据集" class="headerlink" title="3.图片分类数据集"></a>3.图片分类数据集</h3><h4 id="3-1-Fashion-MNIST数据集："><a href="#3-1-Fashion-MNIST数据集：" class="headerlink" title="3.1 Fashion-MNIST数据集："></a>3.1 Fashion-MNIST数据集：</h4><ul>
<li><p>读取数据集</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过ToTensor实例将图像数据从PIL类型变换成32位浮点数格式，</span></span><br><span class="line"><span class="comment"># 并除以255使得所有像素的数值均在0～1之间</span></span><br><span class="line"><span class="comment"># 转换为张量形式 trans</span></span><br><span class="line"><span class="comment"># 读取为训练集，测试集，读取为张量形式还不是图片形式</span></span><br><span class="line">trans=transforms.ToTensor()</span><br><span class="line">mnist_train=torchvision.datasets.FashionMNIST(root=<span class="string">&quot;../data&quot;</span>,train=<span class="literal">True</span>,                                              transform=trans,download=<span class="literal">True</span>)</span><br><span class="line">mnist_test=torchvision.datasets.FashionMNIST(root=<span class="string">&quot;../data&quot;</span>,train=<span class="literal">False</span>,                                             transform=trans,download=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据集内图片大小</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一张图片的shape</span></span><br><span class="line">mnist_train[<span class="number">0</span>][<span class="number">0</span>].shape</span><br><span class="line">torch.Size([<span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>])</span><br></pre></td></tr></table></figure>
<p>表示图片为单通道（黑白）的28X28的图片</p>
</li>
<li><p>两个可视化函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_fashion_mnist_labels</span>(<span class="params">labels</span>):  </span><br><span class="line">  <span class="string">&quot;&quot;&quot;返回Fashion-MNIST数据集的文本标签&quot;&quot;&quot;</span></span><br><span class="line">  text_labels = [<span class="string">&#x27;t-shirt&#x27;</span>, <span class="string">&#x27;trouser&#x27;</span>, <span class="string">&#x27;pullover&#x27;</span>, <span class="string">&#x27;dress&#x27;</span>, <span class="string">&#x27;coat&#x27;</span>,</span><br><span class="line">                 <span class="string">&#x27;sandal&#x27;</span>, <span class="string">&#x27;shirt&#x27;</span>, <span class="string">&#x27;sneaker&#x27;</span>, <span class="string">&#x27;bag&#x27;</span>, <span class="string">&#x27;ankle boot&#x27;</span>]</span><br><span class="line">  <span class="keyword">return</span> [text_labels[<span class="built_in">int</span>(i)] <span class="keyword">for</span> i <span class="keyword">in</span> labels]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show_images</span>(<span class="params">imgs, num_rows, num_cols, titles=<span class="literal">None</span>, scale=<span class="number">1.5</span></span>):  </span><br><span class="line">  <span class="string">&quot;&quot;&quot;绘制图像列表&quot;&quot;&quot;</span></span><br><span class="line">  figsize = (num_cols * scale, num_rows * scale)</span><br><span class="line">  _, axes = d2l.plt.subplots(num_rows, num_cols, figsize=figsize)</span><br><span class="line">  axes = axes.flatten()</span><br><span class="line">  <span class="keyword">for</span> i, (ax, img) <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">zip</span>(axes, imgs)):</span><br><span class="line">      <span class="keyword">if</span> torch.is_tensor(img):</span><br><span class="line">          <span class="comment"># 图片张量</span></span><br><span class="line">          ax.imshow(img.numpy())</span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">          <span class="comment"># PIL图片</span></span><br><span class="line">          ax.imshow(img)</span><br><span class="line">      ax.axes.get_xaxis().set_visible(<span class="literal">False</span>)</span><br><span class="line">      ax.axes.get_yaxis().set_visible(<span class="literal">False</span>)</span><br><span class="line">      <span class="keyword">if</span> titles:</span><br><span class="line">          ax.set_title(titles[i])</span><br><span class="line">  <span class="keyword">return</span> axes</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>显示数据集图像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 画2行每行9个，titles拿出</span><br><span class="line">X,y = next(iter(data.DataLoader(mnist_train,batch_size=18)))</span><br><span class="line">show_images(X.reshape(18,28,28),2,9,titles=get_fashion_mnist_labels(y))</span><br></pre></td></tr></table></figure>
<img src="/2024/04/23/11-01-09/09-08.png" class="">
</li>
</ul>
<ul>
<li>定义load_data_fashion_mnist函数<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_data_fashion_mnist</span>(<span class="params">batch_size, resize=<span class="literal">None</span></span>):  </span><br><span class="line">  <span class="string">&quot;&quot;&quot;下载Fashion-MNIST数据集，然后将其加载到内存中&quot;&quot;&quot;</span></span><br><span class="line">  trans = [transforms.ToTensor()]</span><br><span class="line">  <span class="keyword">if</span> resize:</span><br><span class="line">      trans.insert(<span class="number">0</span>, transforms.Resize(resize))</span><br><span class="line">  trans = transforms.Compose(trans)</span><br><span class="line">  mnist_train = torchvision.datasets.FashionMNIST(</span><br><span class="line">      root=<span class="string">&quot;../data&quot;</span>, train=<span class="literal">True</span>, transform=trans, download=<span class="literal">True</span>)</span><br><span class="line">  mnist_test = torchvision.datasets.FashionMNIST(</span><br><span class="line">      root=<span class="string">&quot;../data&quot;</span>, train=<span class="literal">False</span>, transform=trans, download=<span class="literal">True</span>)</span><br><span class="line">  <span class="keyword">return</span> (data.DataLoader(mnist_train, batch_size, shuffle=<span class="literal">True</span>,</span><br><span class="line">                          num_workers=get_dataloader_workers()),</span><br><span class="line">          data.DataLoader(mnist_test, batch_size, shuffle=<span class="literal">False</span>,</span><br><span class="line">                          num_workers=get_dataloader_workers()))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们通过指定resize参数来测试load_data_fashion_mnist函数的图像大小调整功能。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_iter, test_iter = load_data_fashion_mnist(<span class="number">32</span>, resize=<span class="number">64</span>)</span><br><span class="line"><span class="keyword">for</span> X, y <span class="keyword">in</span> train_iter:</span><br><span class="line">  <span class="built_in">print</span>(X.shape, X.dtype, y.shape, y.dtype)</span><br><span class="line">  <span class="keyword">break</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<h3 id="4-从零实现softmax回归"><a href="#4-从零实现softmax回归" class="headerlink" title="4.从零实现softmax回归"></a>4.从零实现softmax回归</h3><h4 id="softmax"><a href="#softmax" class="headerlink" title="softmax:"></a>softmax:</h4><p>$$<br>softmax(X)_{ij}=\frac{exp(X_{ij})}{\sum_{k} exp(X_{ik})}<br>$$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">softmax</span>(<span class="params">X</span>):</span><br><span class="line">    <span class="comment"># 求每一个元素的指数计算</span></span><br><span class="line">    X_exp = torch.exp(X)</span><br><span class="line">    <span class="comment"># 按行求和</span></span><br><span class="line">    partition = X_exp.<span class="built_in">sum</span>(<span class="number">1</span>, keepdim=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> X_exp / partition</span><br></pre></td></tr></table></figure>
<ol>
<li><p>将图像展平，每个图像看做长度为784的向量，因为数据集有十个类别，所以网络输出维度为10。以此设定参数大小并初始化：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 图片是一个三维的，拉长为一个向量,softmax回归输入为向量</span></span><br><span class="line">num_inputs = <span class="number">784</span></span><br><span class="line">num_outputs = <span class="number">10</span></span><br><span class="line"><span class="comment"># 用高斯回归初始权重，均值0，方差0.01，形状行列为输入输出个数，需要计算梯度</span></span><br><span class="line">W = torch.normal(<span class="number">0</span>, <span class="number">0.01</span>, size=(num_inputs, num_outputs), requires_grad=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 输出需要一个偏移</span></span><br><span class="line">b = torch.zeros(num_outputs, requires_grad=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现softmax回归模型：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">net</span>(<span class="params">X</span>):</span><br><span class="line">    <span class="keyword">return</span> softmax(torch.matmul(X.reshape((-<span class="number">1</span>, W.shape[<span class="number">0</span>])), W) + b)</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现交叉熵损失函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cross_entropy</span>(<span class="params">y_hat, y</span>):</span><br><span class="line">    <span class="keyword">return</span> - torch.log(y_hat[<span class="built_in">range</span>(<span class="built_in">len</span>(y_hat)), y])</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算正确率：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">accuracy</span>(<span class="params">y_hat, y</span>):  </span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算预测正确的数量&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(y_hat.shape) &gt; <span class="number">1</span> <span class="keyword">and</span> y_hat.shape[<span class="number">1</span>] &gt; <span class="number">1</span>:</span><br><span class="line">        y_hat = y_hat.argmax(axis=<span class="number">1</span>)</span><br><span class="line">    cmp = y_hat.<span class="built_in">type</span>(y.dtype) == y</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">float</span>(cmp.<span class="built_in">type</span>(y.dtype).<span class="built_in">sum</span>())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>评估net精度</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">evaluate_accuracy</span>(<span class="params">net, data_iter</span>):  </span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算在指定数据集上模型的精度&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(net, torch.nn.Module):</span><br><span class="line">        net.<span class="built_in">eval</span>()</span><br><span class="line">    metric = Accumulator(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> X, y <span class="keyword">in</span> data_iter:</span><br><span class="line">            metric.add(accuracy(net(X), y), y.numel())</span><br><span class="line">    <span class="keyword">return</span> metric[<span class="number">0</span>] / metric[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Accumulator</span>:  </span><br><span class="line">    <span class="string">&quot;&quot;&quot;在n个变量上累加&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n</span>):</span><br><span class="line">        self.data = [<span class="number">0.0</span>] * n</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, *args</span>):</span><br><span class="line">        self.data = [a + <span class="built_in">float</span>(b) <span class="keyword">for</span> a, b <span class="keyword">in</span> <span class="built_in">zip</span>(self.data, args)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reset</span>(<span class="params">self</span>):</span><br><span class="line">        self.data = [<span class="number">0.0</span>] * <span class="built_in">len</span>(self.data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, idx</span>):</span><br><span class="line">        <span class="keyword">return</span> self.data[idx]</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义训练模型：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train_ch3</span>(<span class="params">net, train_iter, test_iter, loss, num_epochs, updater</span>):  </span><br><span class="line">    <span class="string">&quot;&quot;&quot;训练模型（定义见第3章）&quot;&quot;&quot;</span></span><br><span class="line">    animator = Animator(xlabel=<span class="string">&#x27;epoch&#x27;</span>, xlim=[<span class="number">1</span>, num_epochs], ylim=[<span class="number">0.3</span>, <span class="number">0.9</span>],</span><br><span class="line">                        legend=[<span class="string">&#x27;train loss&#x27;</span>, <span class="string">&#x27;train acc&#x27;</span>, <span class="string">&#x27;test acc&#x27;</span>])</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">        train_metrics = train_epoch_ch3(net, train_iter, loss, updater)</span><br><span class="line">        test_acc = evaluate_accuracy(net, test_iter)</span><br><span class="line">        animator.add(epoch + <span class="number">1</span>, train_metrics + (test_acc,))</span><br><span class="line">    train_loss, train_acc = train_metrics</span><br><span class="line">    <span class="keyword">assert</span> train_loss &lt; <span class="number">0.5</span>, train_loss</span><br><span class="line">    <span class="keyword">assert</span> train_acc &lt;= <span class="number">1</span> <span class="keyword">and</span> train_acc &gt; <span class="number">0.7</span>, train_acc</span><br><span class="line">    <span class="keyword">assert</span> test_acc &lt;= <span class="number">1</span> <span class="keyword">and</span> test_acc &gt; <span class="number">0.7</span>, test_acc</span><br></pre></td></tr></table></figure>
</li>
<li><p>预测：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">predict_ch3</span>(<span class="params">net, test_iter, n=<span class="number">6</span></span>):  </span><br><span class="line">    <span class="string">&quot;&quot;&quot;预测标签（定义见第3章）&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> X, y <span class="keyword">in</span> test_iter:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    trues = d2l.get_fashion_mnist_labels(y)</span><br><span class="line">    preds = d2l.get_fashion_mnist_labels(net(X).argmax(axis=<span class="number">1</span>))</span><br><span class="line">    titles = [true +<span class="string">&#x27;\n&#x27;</span> + pred <span class="keyword">for</span> true, pred <span class="keyword">in</span> <span class="built_in">zip</span>(trues, preds)]</span><br><span class="line">    d2l.show_images(</span><br><span class="line">        X[<span class="number">0</span>:n].reshape((n, <span class="number">28</span>, <span class="number">28</span>)), <span class="number">1</span>, n, titles=titles[<span class="number">0</span>:n])</span><br><span class="line"></span><br><span class="line">predict_ch3(net, test_iter)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<img src="/2024/04/23/11-01-09/09-09.png" class="">
<ol>
<li>动画<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animator</span>: </span><br><span class="line">  <span class="string">&quot;&quot;&quot;在动画中绘制数据&quot;&quot;&quot;</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, xlabel=<span class="literal">None</span>, ylabel=<span class="literal">None</span>, legend=<span class="literal">None</span>, xlim=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">               ylim=<span class="literal">None</span>, xscale=<span class="string">&#x27;linear&#x27;</span>, yscale=<span class="string">&#x27;linear&#x27;</span>,</span></span><br><span class="line"><span class="params">               fmts=(<span class="params"><span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;m--&#x27;</span>, <span class="string">&#x27;g-.&#x27;</span>, <span class="string">&#x27;r:&#x27;</span></span>), nrows=<span class="number">1</span>, ncols=<span class="number">1</span>,</span></span><br><span class="line"><span class="params">               figsize=(<span class="params"><span class="number">3.5</span>, <span class="number">2.5</span></span>)</span>):</span><br><span class="line">      <span class="comment"># 增量地绘制多条线</span></span><br><span class="line">      <span class="keyword">if</span> legend <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">          legend = []</span><br><span class="line">      d2l.use_svg_display()</span><br><span class="line">      self.fig, self.axes = d2l.plt.subplots(nrows, ncols, figsize=figsize)</span><br><span class="line">      <span class="keyword">if</span> nrows * ncols == <span class="number">1</span>:</span><br><span class="line">          self.axes = [self.axes, ]</span><br><span class="line">      <span class="comment"># 使用lambda函数捕获参数</span></span><br><span class="line">      self.config_axes = <span class="keyword">lambda</span>: d2l.set_axes(</span><br><span class="line">          self.axes[<span class="number">0</span>], xlabel, ylabel, xlim, ylim, xscale, yscale, legend)</span><br><span class="line">      self.X, self.Y, self.fmts = <span class="literal">None</span>, <span class="literal">None</span>, fmts</span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, x, y</span>):</span><br><span class="line">      <span class="comment"># 向图表中添加多个数据点</span></span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(y, <span class="string">&quot;__len__&quot;</span>):</span><br><span class="line">          y = [y]</span><br><span class="line">      n = <span class="built_in">len</span>(y)</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(x, <span class="string">&quot;__len__&quot;</span>):</span><br><span class="line">          x = [x] * n</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> self.X:</span><br><span class="line">          self.X = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> self.Y:</span><br><span class="line">          self.Y = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">      <span class="keyword">for</span> i, (a, b) <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">zip</span>(x, y)):</span><br><span class="line">          <span class="keyword">if</span> a <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> b <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">              self.X[i].append(a)</span><br><span class="line">              self.Y[i].append(b)</span><br><span class="line">      self.axes[<span class="number">0</span>].cla()</span><br><span class="line">      <span class="keyword">for</span> x, y, fmt <span class="keyword">in</span> <span class="built_in">zip</span>(self.X, self.Y, self.fmts):</span><br><span class="line">          self.axes[<span class="number">0</span>].plot(x, y, fmt)</span><br><span class="line">      self.config_axes()</span><br><span class="line">      display.display(self.fig)</span><br><span class="line">      display.clear_output(wait=<span class="literal">True</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="5-softmax的简洁实现"><a href="#5-softmax的简洁实现" class="headerlink" title="5.softmax的简洁实现"></a>5.softmax的简洁实现</h3><blockquote>
<p>调用torch内的网络层</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#train_iter 返回一个训练集测试集的迭代器</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line">batch_size=<span class="number">256</span></span><br><span class="line">train_iter,test_iter=d2l.load_data_fashion_mnist(batch_size)</span><br><span class="line">net=nn.Sequential(nn.Flatten(),nn.Linear(<span class="number">784</span>,<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_weights</span>(<span class="params">m</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(m) == nn.Linear:</span><br><span class="line">        nn.init.normal_(m.weight,std=<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line">net.apply(init_weights)</span><br><span class="line">loss=nn.CrossEntropyLoss()</span><br><span class="line">trainer=torch.optim.SGD(net.parameters(),lr=<span class="number">0.1</span>)</span><br><span class="line">num_epochs=<span class="number">10</span></span><br><span class="line">d2l.train_ch3(net,train_iter,test_iter,loss,num_epochs,trainer)</span><br></pre></td></tr></table></figure>
<h3 id="6-softmax回归Q-amp-A"><a href="#6-softmax回归Q-amp-A" class="headerlink" title="6.softmax回归Q&amp;A"></a>6.softmax回归Q&amp;A</h3><p><strong>Q1:softlabel训练策略以及为什么有效？</strong></p>
<blockquote>
<p>softmax用指数很难逼近1，softlabel将正例和负例分别标记为0.9和0.1使结果逼近变得可能，这是一个常用的小技巧。</p>
</blockquote>
<h5 id="Q2-softmax回归和logistic回归？"><a href="#Q2-softmax回归和logistic回归？" class="headerlink" title="Q2:softmax回归和logistic回归？"></a>Q2:softmax回归和logistic回归？</h5><blockquote>
<p>logistic回归为二分类问题，是softmax回归的特例</p>
</blockquote>
<h5 id="Q3-为什么使用交叉熵，而不用相对熵，互信息熵等其他基于信息量的度量？"><a href="#Q3-为什么使用交叉熵，而不用相对熵，互信息熵等其他基于信息量的度量？" class="headerlink" title="Q3:为什么使用交叉熵，而不用相对熵，互信息熵等其他基于信息量的度量？"></a>Q3:为什么使用交叉熵，而不用相对熵，互信息熵等其他基于信息量的度量？</h5><blockquote>
<p>实际上使用哪一种熵的效果区别不大，所以哪种简单就用哪种</p>
</blockquote>
<h5 id="Q4-y-log-hat-y-为什么我们只关心正确类，而不关心不正确的类呢？"><a href="#Q4-y-log-hat-y-为什么我们只关心正确类，而不关心不正确的类呢？" class="headerlink" title="Q4:$y*log\hat{y}$   为什么我们只关心正确类，而不关心不正确的类呢？"></a>Q4:$y*log\hat{y}$   为什么我们只关心正确类，而不关心不正确的类呢？</h5><blockquote>
<p>并不是不关心，而是不正确的的类标号为零，所以算式中不体现，如果使用softlabel策略，就会体现出不正确的类。</p>
</blockquote>
<h5 id="Q5-似然函数曲线是怎么得出来的？有什么参考意义？"><a href="#Q5-似然函数曲线是怎么得出来的？有什么参考意义？" class="headerlink" title="Q5:似然函数曲线是怎么得出来的？有什么参考意义？"></a>Q5:似然函数曲线是怎么得出来的？有什么参考意义？</h5><blockquote>
<p>最小化损失函数也意味着最大化似然函数，似然函数表示统计概率和模型的拟合程度。</p>
</blockquote>
<h5 id="Q6-在多次迭代之后欧如果测试精度出现上升后再下降是过拟合了吗？可以提前终止吗？"><a href="#Q6-在多次迭代之后欧如果测试精度出现上升后再下降是过拟合了吗？可以提前终止吗？" class="headerlink" title="Q6:在多次迭代之后欧如果测试精度出现上升后再下降是过拟合了吗？可以提前终止吗？"></a>Q6:在多次迭代之后欧如果测试精度出现上升后再下降是过拟合了吗？可以提前终止吗？</h5><blockquote>
<p>很有可能是过拟合，可以继续训练来观察是否持续下降</p>
</blockquote>
<h5 id="Q7-cnn网络主要学习到的是纹理还是轮廓还是所有内容的综合？"><a href="#Q7-cnn网络主要学习到的是纹理还是轮廓还是所有内容的综合？" class="headerlink" title="Q7:cnn网络主要学习到的是纹理还是轮廓还是所有内容的综合？"></a>Q7:cnn网络主要学习到的是纹理还是轮廓还是所有内容的综合？</h5><blockquote>
<p>目前认为主要学习到的是纹理信息</p>
</blockquote>
<h5 id="Q8-softmax可解释吗？"><a href="#Q8-softmax可解释吗？" class="headerlink" title="Q8:softmax可解释吗？"></a>Q8:softmax可解释吗？</h5><blockquote>
<p>单纯softmax是可解释的，可以在统计书籍中找到相关的解释。</p>
</blockquote>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>10-多层感知机</title>
    <url>/2024/04/23/11-01-10/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.04.24：初稿</li>
</ul>
<h2 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h2><ul>
<li><a href="/2024/04/24/12-18-34/" title="动手学深度学习笔记汇总">动手学深度学习笔记汇总</a>
</li>
</ul>
<h2 id="多层感知机"><a href="#多层感知机" class="headerlink" title="多层感知机"></a>多层感知机</h2><h3 id="感知机"><a href="#感知机" class="headerlink" title="感知机"></a>感知机</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>从现在的观点来看，感知机实际上就是神经网络中的一个神经单元</p>
<img src="/2024/04/23/11-01-10/%E6%84%9F%E7%9F%A5%E6%9C%BA.png" class="">
<p>感知机能解决二分类问题，但与线性回归和softmax回归有所区别：线性回归与softmax回归的输出均为实数，softmax回归的输出同时还满足概率公理。</p>
<h4 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h4><p>训练感知机的伪代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">initialize w = <span class="number">0</span> <span class="keyword">and</span> b = <span class="number">0</span></span><br><span class="line">repeat</span><br><span class="line">    <span class="comment">#此处表达式小于0代表预测结果错误</span></span><br><span class="line">    <span class="keyword">if</span> y_i[&lt;w,x_i&gt;+b] &lt;= <span class="number">0</span> then</span><br><span class="line">        w=w + yixi</span><br><span class="line">        b=b + yi</span><br><span class="line">    end <span class="keyword">if</span></span><br><span class="line">until <span class="built_in">all</span> classified correctly</span><br></pre></td></tr></table></figure>
<p>可以看出这等价于使用如下损失函数的随机梯度下降（batch_size=1）:<br>$$<br>\ell(y, \boldsymbol x,\boldsymbol w)=max(0,-y&lt;\boldsymbol w,\boldsymbol x&gt;)\\<br>=max(0,-y\boldsymbol w^T\boldsymbol x)<br>$$<br>当预测错误时，偏导数为<br>$$<br>\frac{\partial \ell}{\partial \boldsymbol w}=-y\cdot \boldsymbol x<br>$$</p>
<p>注：此处为了方便计算，将偏置项b归入w中的最后一维，并在特征x中相应的最后一维加入常数1</p>
<h4 id="收敛定理"><a href="#收敛定理" class="headerlink" title="收敛定理"></a>收敛定理</h4><p>设数据在特征空间能被半径为r的圆（球）覆盖，并且分类时有余量（即$\sigma$函数的输入不会取使输出模棱两可的值）$y(\boldsymbol x^T\boldsymbol w)\geq \rho$，若初始参数满足$\|\boldsymbol w\|^2+b^2 \leq 1$，则感知机保证在$\frac{r^2+1}{\rho ^2}$步内收敛</p>
<p><a href="https://zhuanlan.zhihu.com/p/46762820">收敛性的证明</a></p>
<h3 id="线性模型的缺陷"><a href="#线性模型的缺陷" class="headerlink" title="线性模型的缺陷"></a>线性模型的缺陷</h3><p>在前面的课程中我们学习了softmax回归，线性回归，他们有将输入向量与一个权重向量做内积再与一个偏置相加得到一个值的过程：<br>$$<br>O =W^TX+b<br>$$<br>这个过程被称为仿射变换，它是一个带有偏置项的线性变换，它最终产生的模型被称为线性模型，线性模型的特点是只能以线性的方式对特征空间进行划分：</p>
<img src="/2024/04/23/11-01-10/%E7%BA%BF%E6%80%A7%E5%88%92%E5%88%86.png" class="">
<p>然而，这种线性划分依赖于线性假设，是非常不可靠的</p>
<ul>
<li>线性假设意味着单调假设，这是不可靠的：<ul>
<li>对于人体的体温与健康情况的建模，人体在37℃时最为健康，过小过大均有风险，然而这不是单调的</li>
</ul>
</li>
<li>线性假设意味着特征与预测存在线性相关性，这也是不可靠的：<ul>
<li>如果预测一个人偿还债务的可能性，那这个人的资产从0万元增至5万元和从100万元增至105万元对应的偿还债务的可能性的增幅肯定是不相等的，也就是不线性相关的</li>
</ul>
</li>
<li>线性模型的评估标准是有位置依赖性的，这是不可靠的：<ul>
<li>如果需要判断图片中的动物是猫还是狗，对于图片中一个像素的权重的改变永远是不可靠的，因为如果将图片翻转，它的类别不会改变，但是线性模型不具备这种性质，像素的权重将会失效</li>
</ul>
</li>
</ul>
<p>课程中所提到的例子是XOR问题，即希望模型能预测出XOR分类（分割图片中的一三象限与二四象限）：</p>
<img src="/2024/04/23/11-01-10/XOR%E9%97%AE%E9%A2%98.png" class="">
<h3 id="多层感知机-1"><a href="#多层感知机-1" class="headerlink" title="多层感知机"></a>多层感知机</h3><h4 id="XOR问题的多层次解决"><a href="#XOR问题的多层次解决" class="headerlink" title="XOR问题的多层次解决"></a>XOR问题的多层次解决</h4><p>仍以XOR问题为例，XOR问题的一个解决思路是分类两次，先按x轴分类为+和-，再按y轴分类为+和-，最后将两个分类结果相乘，+即为一三象限，-即为二四象限：</p>
<img src="/2024/04/23/11-01-10/%E5%A4%9A%E5%B1%82%E5%88%86%E7%B1%BBXOR1.png" class="">
<img src="/2024/04/23/11-01-10/%E5%A4%9A%E5%B1%82%E5%88%86%E7%B1%BBXOR2.png" class="">
<p>这实际上将信息进行了多层次的传递：</p>
<img src="/2024/04/23/11-01-10/XOR%E4%BF%A1%E6%81%AF%E5%A4%9A%E5%B1%82%E6%AC%A1%E4%BC%A0%E9%80%92.png" class="">
<p>其中蓝色为按X坐标的正负进行的分类，橙色为按Y坐标的正负进行的分类，灰色为将二者信息的综合，这就实现了用多层次的线性模型对非线性进行预测</p>
<h4 id="多层感知机-2"><a href="#多层感知机-2" class="headerlink" title="多层感知机"></a>多层感知机</h4><p>有了XOR问题的解决经验，可以想到如果将多个感知机堆叠起来，形成具有多个层次的结构，如图：</p>
<img src="/2024/04/23/11-01-10/%E5%8D%95%E9%9A%90%E8%97%8F%E5%B1%82.png" class="">
<p>这里的模型称为多层感知机，第一层圆圈$x_1,x_2,x_3,x_4$称为输入（实际上他并非感知机），之后的一层称为隐藏层，由5个感知机构成，他们均以前一层的信息作为输入，最后是输出层，以前一层隐藏层的结果作为输入。除了输入的信息和最后一层的感知机以外，其余的层均称为隐藏层，隐藏层的设置为模型一个重要的超参数，这里的模型有一个隐藏层。</p>
<h4 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h4><p>但是仅仅有线性变换是不够的，如果我们简单的将多个线性变换按层次叠加，由于线性变换的结果仍为线性变换，所以最终的结果等价于线性变换，与单个感知机并无区别，反而加大了模型，浪费了资源，为了防止这个问题，需要对每个单元（感知机）的输出通过激活函数进行处理再交由下一层的感知机进行运算，这些激活函数就是解决非线性问题的关键。</p>
<p><em>激活函数</em>（activation function）通过计算加权和并加上偏置来确定神经元是否应该被激活，它们将输入信号转换为输出的可微运算。大多数激活函数都是非线性的。</p>
<p>主要的激活函数有：</p>
<h5 id="ReLU函数"><a href="#ReLU函数" class="headerlink" title="ReLU函数"></a>ReLU函数</h5><p>最受欢迎的激活函数是<em>修正线性单元</em>（Rectified linear<br>unit，<em>ReLU</em>），因为它实现简单，同时在各种预测任务中表现良好。<strong>ReLU提供了一种非常简单的非线性变换</strong>。给定元素$x$，ReLU函数被定义为该元素与$0$的最大值：<br>$$<br>\operatorname{ReLU}(x) = \max(x, 0)<br>$$<br>ReLU函数通过将相应的活性值设为0，仅保留正元素并丢弃所有负元素。为了直观感受一下，我们可以画出函数的曲线图。正如从图中所看到，激活函数是分段线性的。使用ReLU的原因是，它求导表现得特别好：要么让参数消失，要么让参数通过。这使得优化表现的更好，并且ReLU减轻了困扰以往神经网络的梯度消失问题</p>
<h5 id="sigmoid函数"><a href="#sigmoid函数" class="headerlink" title="sigmoid函数"></a>sigmoid函数</h5><p><strong>对于一个定义域在$\mathbb{R}$中的输入，<em>sigmoid函数</em>将输入变换为区间(0,1)上的输出</strong>。 因此，sigmoid通常称为<em>挤压函数</em>（squashing function）：它将范围$（-\infty, \infty）$中的任意输入压缩到区间（0,1）中的某个值：<br>$$<br>\operatorname{sigmoid}(x) = \frac{1}{1 + e^{-x}}.<br>$$<br>在基于梯度的学习中，sigmoid函数是一个自然的选择，因为它是一个平滑的、可微的阈值单元近似。当我们想要将输出视作二元分类问题的概率时，sigmoid仍然被广泛用作输出单元上的激活函数（你可以将sigmoid视为softmax的特例）。然而，sigmoid在隐藏层中已经较少使用，它在大部分时候被更简单、更容易训练的ReLU所取代。</p>
<h5 id="tanh函数"><a href="#tanh函数" class="headerlink" title="tanh函数"></a>tanh函数</h5><p>与sigmoid函数类似，<strong>tanh(双曲正切)函数也能将其输入压缩转换到区间(-1,1)上</strong>。tanh函数的公式如下：<br>$$<br>\operatorname{tanh}(x) = \frac{1 - e^{-2x}}{1 + e^{-2x}}<br>$$</p>
<h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>还可以使用更多隐藏层的感知机和softmax函数解决分类问题</p>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><ol>
<li>证明一个仅使用ReLU（或pReLU）的多层感知机构造了一个连续的分段线性函数。</li>
</ol>
<blockquote>
<p>绘制出RELU的图像后，我们可以发现，输出值在经过下一层隐藏层的计算后，如果结果小于等于0，则这个数据被舍弃，结果大于0则被保留，类似一个筛选的过程。相当于上一层的输出经过线性变换后在下一层被筛选，线性变换和上述筛选的过程都是连续的，因此就会产生连续而且分段的结果。</p>
</blockquote>
<ol>
<li>构建多个超参数的搜索方法。</li>
</ol>
<blockquote>
<p>有四种主要的策略可用于搜索最佳配置。</p>
<ul>
<li>试错</li>
<li>网格搜索</li>
<li>随机搜索</li>
<li>贝叶斯优化</li>
</ul>
</blockquote>
<p>详见<a href="https://www.jiqizhixin.com/articles/101401">超参数搜索不够高效？这几大策略了解一下</a></p>
<ol>
<li>权重初始化方法</li>
</ol>
<blockquote>
<ol>
<li>全零初始化：在神经网络中，把w初始化为0是不可以的。这是因为如果把w初始化0，那么每一层的神经元学到的东西都是一样的（输出是一样的），而且在BP的时候，每一层内的神经元也是相同的，因为他们的gradient相同，weight<br>update也相同。</li>
<li>随机初始化</li>
<li>Xavier初始化：保持输入和输出的方差一致（服从相同的分布），这样就避免了所有输出值都趋向于0。</li>
<li>He<br>initialization：在ReLU网络中，假定每一层有一半的神经元被激活，另一半为0（x负半轴中是不激活的），所以要保持variance不变，只需要在Xavier的基础上再除以2。</li>
<li>pre-training</li>
</ol>
</blockquote>
<p>详见<a href="https://zhuanlan.zhihu.com/p/72374385">权重/参数初始化</a></p>
<ol>
<li>超参数的调节</li>
</ol>
<blockquote>
<ol>
<li>在mlp中，第一个隐藏的的单元数可能大于输入的个数，每个隐藏层中的单元数由前至后递减，逐渐接近输出的个数。</li>
<li>多数情况下，将mlp的深度设置得较深，而每层的单元数相对较少，这样易于训练，不易过拟合，也利于逐步学习样本特征。</li>
<li>激活函数种类的选择对训练的影响小于其余的因素。</li>
</ol>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>多层感知机使用隐藏层和激活函数来得到非线性模型</p>
</li>
<li><p>常用激活函数：Sigmoid，Tanh，ReLU</p>
</li>
<li><p>使用softmax进行多分类</p>
</li>
<li><p>隐藏层数、大小为超参数</p>
</li>
</ul>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>04-数据读取和操作</title>
    <url>/2024/04/23/11-01-04/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.04.24：初稿</li>
</ul>
<h2 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h2><ul>
<li><a href="/2024/04/24/12-18-34/" title="动手学深度学习笔记汇总">动手学深度学习笔记汇总</a>
</li>
</ul>
<h2 id="04-数据读取和操作"><a href="#04-数据读取和操作" class="headerlink" title="04-数据读取和操作"></a>04-数据读取和操作</h2><h3 id="1-数据操作"><a href="#1-数据操作" class="headerlink" title="1. 数据操作"></a>1. 数据操作</h3><p>为了能够完成各种数据操作，我们需要某种方法来存储和操作数据。通常，我们需要做两件重要的事：</p>
<ol>
<li>获取数据；</li>
<li>将数据读入计算机后对其进行处理。</li>
</ol>
<p>如果没有某种方法来存储数据，那么获取数据是没有意义的。</p>
<p>首先，我们介绍 n 维数组，也称为<strong>张量</strong>（tensor）。PyTorch的<strong>张量类</strong>与Numpy的<code>ndarray</code>类似。但在深度学习框架中应用PyTorch的<strong>张量类</strong>，又比Numpy的<code>ndarray</code>多一些重要功能：</p>
<ol>
<li>tensor可以在很好地支持GPU加速计算，而NumPy仅支持CPU计算；</li>
<li>tensor支持自动微分。</li>
</ol>
<p>这些功能使得张量类更适合深度学习。</p>
<h4 id="1-1-基本操作"><a href="#1-1-基本操作" class="headerlink" title="1.1 基本操作"></a>1.1 基本操作</h4><p>[<strong>张量表示由一些数值组成的数组，这个数组可能有多个维度</strong>]。具有一个轴的张量对应数学上的<strong>向量</strong>（vector）；具有两个轴的张量对应数学上的<strong>矩阵</strong>（matrix）；具有两个轴以上的张量没有特殊的数学名称。</p>
<p>我们可以使用<code>arange</code>创建一个行向量<code>x</code>。这个行向量包含从0开始的前12个整数，它们被<strong>默认创建为浮点数</strong>。张量中的每个值都称为张量的<strong>元素</strong>（element）。例如，张量<code>x</code>中有12个元素。除非额外指定，新的张量默认将存储在内存中，并采用基于CPU的计算。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = torch.arange(<span class="number">12</span>)</span><br><span class="line">	tensor([ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>])</span><br></pre></td></tr></table></figure>
<p>[<strong>可以通过张量的<code>shape</code>属性来访问张量（沿每个轴的长度）的<em>形状</em></strong>]。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.shape</span><br><span class="line">	torch.Size([<span class="number">12</span>])</span><br></pre></td></tr></table></figure>
<p>如果只想知道张量中元素的总数，即形状的所有元素乘积，可以检查它的大小（size）。</p>
<p>因为这里在处理的是一个向量，所以它的<code>shape</code>与它的<code>size</code>相同。在处理更高维度的的张量时，可以用这种方法获取张量中元素的个数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.numel()</span><br><span class="line">	<span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>[<strong>要想改变一个张量的形状而不改变元素数量和元素值，可以调用<code>reshape</code>函数。</strong>]</p>
<p>例如，可以把张量<code>x</code>从形状为（12,）的行向量转换为形状为（3,4）的矩阵。这个新的张量包含与转换前相同的值，但是它被看成一个3行4列的矩阵。值得注意的是，虽然张量的形状发生了改变，但其元素值并没有变。改变张量的形状时，张量中元素的个数不会改变。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>X = x.reshape(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">	tensor([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">        	[ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">        	[ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br></pre></td></tr></table></figure>
<p>我们不需要通过手动指定每个维度来改变形状。如果我们的目标形状是（高度 x 宽度），那么在知道宽度后，高度会被自动计算得出，不必我们自己做除法。我们可以通过<code>-1</code>来调用此自动计算出维度的功能即可以用<code>x.reshape(-1,4)</code>或<code>x.reshape(3,-1)</code>来取代<code>x.reshape(3,4)</code>。</p>
<p>有时，我们希望[<strong>使用全0、全1、其他常量，或者从特定分布中随机采样的数字</strong>]来初始化矩阵。我们可以创建一个形状为（2,3,4）的张量，其中所有元素都设置为0或者1。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.zeros((<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">	tensor([[[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">         	 [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">         	 [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>]],</span><br><span class="line"></span><br><span class="line">        	[[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">         	 [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">         	 [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>]]])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.ones((<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">	tensor([[[<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">         	 [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">         	 [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>]],</span><br><span class="line"></span><br><span class="line">        	[[<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">         	 [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">         	 [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>]]])</span><br></pre></td></tr></table></figure>
<p>有时我们想通过从某个特定的概率分布中随机采样来得到张量中每个元素的值。例如，当我们构造数组来作为神经网络中的参数时，我们通常会随机初始化参数的值。以下代码创建一个形状为（3,4）的张量。其中的每个元素都从均值为0、标准差为1的标准正态分布中随机采样。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.randn(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">	tensor([[ <span class="number">0.1364</span>,  <span class="number">0.3546</span>, -<span class="number">0.9091</span>, -<span class="number">1.8926</span>],</span><br><span class="line">        	[ <span class="number">0.5786</span>, -<span class="number">0.9019</span>, -<span class="number">0.1305</span>, -<span class="number">0.1899</span>],</span><br><span class="line">        	[ <span class="number">0.5696</span>,  <span class="number">1.1626</span>, -<span class="number">0.5987</span>,  <span class="number">0.4085</span>]])</span><br></pre></td></tr></table></figure>
<p>我们还可以[<strong>通过提供包含数值的Python列表（或嵌套列表），来为所需张量中的每个元素赋予确定值</strong>]。在这里，最外层的列表对应于轴0，内层的列表对应于轴1。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.tensor([[<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]])</span><br><span class="line">	tensor([[<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>],</span><br><span class="line">        	[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">        	[<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]])</span><br></pre></td></tr></table></figure>
<h4 id="1-2-简单运算"><a href="#1-2-简单运算" class="headerlink" title="1.2 简单运算"></a>1.2 简单运算</h4><p>我们想在这些数据上执行数学运算，其中最简单且最有用的操作是<strong>按元素</strong>（elementwise）运算。它们将标准标量运算符应用于数组的每个元素。对于将两个数组作为输入的函数，按元素运算将二元运算符应用于两个数组中的每对位置对应的元素。我们可以基于任何从标量到标量的函数来创建按元素函数。我们通过将标量函数升级为按元素向量运算来生成向量值$F: \mathbb{R}^d, \mathbb{R}^d \rightarrow \mathbb{R}^d$。</p>
<p>对于任意具有相同形状的张量，[<strong>常见的标准算术运算符（<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>和`</strong>`）都可以被升级为按元素运算**]。我们可以在同一形状的任意两个张量上调用按元素操作。我们使用逗号来表示一个具有5个元素的元组，其中每个元素都是按元素操作的结果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = torch.tensor([<span class="number">1.0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = torch.tensor([<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x + y, x - y, x * y, x / y, x ** y</span><br><span class="line">	(tensor([ <span class="number">3.</span>,  <span class="number">4.</span>,  <span class="number">6.</span>, <span class="number">10.</span>]),</span><br><span class="line"> 	 tensor([-<span class="number">1.</span>,  <span class="number">0.</span>,  <span class="number">2.</span>,  <span class="number">6.</span>]),</span><br><span class="line"> 	 tensor([ <span class="number">2.</span>,  <span class="number">4.</span>,  <span class="number">8.</span>, <span class="number">16.</span>]),</span><br><span class="line"> 	 tensor([<span class="number">0.5000</span>, <span class="number">1.0000</span>, <span class="number">2.0000</span>, <span class="number">4.0000</span>]),</span><br><span class="line"> 	 tensor([ <span class="number">1.</span>,  <span class="number">4.</span>, <span class="number">16.</span>, <span class="number">64.</span>]))</span><br></pre></td></tr></table></figure>
<p>(<strong>“按元素”方式可以应用更多的计算</strong>)，包括像求幂这样的一元运算符。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.exp(x)</span><br><span class="line">	tensor([<span class="number">2.7183e+00</span>, <span class="number">7.3891e+00</span>, <span class="number">5.4598e+01</span>, <span class="number">2.9810e+03</span>])</span><br></pre></td></tr></table></figure>
<p>[<strong>我们也可以把多个张量<em>连结</em>（concatenate）在一起</strong>]，把它们端对端地叠起来形成一个更大的张量。我们只需要提供张量列表，并给出沿哪个轴连结。下面的例子分别演示了当我们沿行（轴-0，形状的第一个元素）和按列（轴-1，形状的第二个元素）连结两个矩阵时，会发生什么情况。我们可以看到，第一个输出张量的轴-0长度（$6$）是两个输入张量轴-0长度的总和（$3 + 3$）；第二个输出张量的轴-1长度（$8$）是两个输入张量轴-1长度的总和（$4 + 4$）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>X = torch.arange(<span class="number">12</span>, dtype=torch.float32).reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Y = torch.tensor([[<span class="number">2.0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.cat((X, Y), dim=<span class="number">0</span>), torch.cat((X, Y), dim=<span class="number">1</span>)</span><br><span class="line">	(tensor([[ <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>],</span><br><span class="line">         	 [ <span class="number">4.</span>,  <span class="number">5.</span>,  <span class="number">6.</span>,  <span class="number">7.</span>],</span><br><span class="line">         	 [ <span class="number">8.</span>,  <span class="number">9.</span>, <span class="number">10.</span>, <span class="number">11.</span>],</span><br><span class="line">         	 [ <span class="number">2.</span>,  <span class="number">1.</span>,  <span class="number">4.</span>,  <span class="number">3.</span>],</span><br><span class="line">         	 [ <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>,  <span class="number">4.</span>],</span><br><span class="line">         	 [ <span class="number">4.</span>,  <span class="number">3.</span>,  <span class="number">2.</span>,  <span class="number">1.</span>]]),</span><br><span class="line"> 	 tensor([[ <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>,  <span class="number">2.</span>,  <span class="number">1.</span>,  <span class="number">4.</span>,  <span class="number">3.</span>],</span><br><span class="line">         	 [ <span class="number">4.</span>,  <span class="number">5.</span>,  <span class="number">6.</span>,  <span class="number">7.</span>,  <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>,  <span class="number">4.</span>],</span><br><span class="line">         	 [ <span class="number">8.</span>,  <span class="number">9.</span>, <span class="number">10.</span>, <span class="number">11.</span>,  <span class="number">4.</span>,  <span class="number">3.</span>,  <span class="number">2.</span>,  <span class="number">1.</span>]]))</span><br></pre></td></tr></table></figure>
<p>由上述例子可见，当需要按轴-x连结两个张量时，我们就在第x+1层括号内将两张量中的元素相组合。类似地，我们将两个三维张量相连结。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>X = torch.arange(<span class="number">12</span>, dtype=torch.float32).reshape((<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Y = torch.tensor([[[<span class="number">2.0</span>, <span class="number">1</span>], [<span class="number">4</span>, <span class="number">3</span>]], [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]], [[<span class="number">4</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">1</span>]]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.cat((X, Y), dim=<span class="number">0</span>), torch.cat((X, Y), dim=<span class="number">1</span>), torch.cat((X, Y), dim=<span class="number">2</span>)</span><br><span class="line">	(tensor([[[ <span class="number">0.</span>,  <span class="number">1.</span>],</span><br><span class="line">          	  [ <span class="number">2.</span>,  <span class="number">3.</span>]],</span><br><span class="line"> </span><br><span class="line">         	 [[ <span class="number">4.</span>,  <span class="number">5.</span>],</span><br><span class="line">          	  [ <span class="number">6.</span>,  <span class="number">7.</span>]],</span><br><span class="line"> </span><br><span class="line">         	 [[ <span class="number">8.</span>,  <span class="number">9.</span>],</span><br><span class="line">          	  [<span class="number">10.</span>, <span class="number">11.</span>]],</span><br><span class="line"> </span><br><span class="line">         	 [[ <span class="number">2.</span>,  <span class="number">1.</span>],</span><br><span class="line">          	  [ <span class="number">4.</span>,  <span class="number">3.</span>]],</span><br><span class="line"> </span><br><span class="line">         	 [[ <span class="number">1.</span>,  <span class="number">2.</span>],</span><br><span class="line">          	  [ <span class="number">3.</span>,  <span class="number">4.</span>]],</span><br><span class="line"> </span><br><span class="line">         	 [[ <span class="number">4.</span>,  <span class="number">3.</span>],</span><br><span class="line">          	  [ <span class="number">2.</span>,  <span class="number">1.</span>]]]),</span><br><span class="line"> 	 tensor([[[ <span class="number">0.</span>,  <span class="number">1.</span>],</span><br><span class="line">          	  [ <span class="number">2.</span>,  <span class="number">3.</span>],</span><br><span class="line">          	  [ <span class="number">2.</span>,  <span class="number">1.</span>],</span><br><span class="line">          	  [ <span class="number">4.</span>,  <span class="number">3.</span>]],</span><br><span class="line"> </span><br><span class="line">         	 [[ <span class="number">4.</span>,  <span class="number">5.</span>],</span><br><span class="line">          	  [ <span class="number">6.</span>,  <span class="number">7.</span>],</span><br><span class="line">          	  [ <span class="number">1.</span>,  <span class="number">2.</span>],</span><br><span class="line">          	  [ <span class="number">3.</span>,  <span class="number">4.</span>]],</span><br><span class="line"> </span><br><span class="line">         	 [[ <span class="number">8.</span>,  <span class="number">9.</span>],</span><br><span class="line">         	  [<span class="number">10.</span>, <span class="number">11.</span>],</span><br><span class="line">         	  [ <span class="number">4.</span>,  <span class="number">3.</span>],</span><br><span class="line">          	  [ <span class="number">2.</span>,  <span class="number">1.</span>]]]),</span><br><span class="line"> 	 tensor([[[ <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">1.</span>],</span><br><span class="line">          	  [ <span class="number">2.</span>,  <span class="number">3.</span>,  <span class="number">4.</span>,  <span class="number">3.</span>]],</span><br><span class="line"> </span><br><span class="line">        	 [[ <span class="number">4.</span>,  <span class="number">5.</span>,  <span class="number">1.</span>,  <span class="number">2.</span>],</span><br><span class="line">          	  [ <span class="number">6.</span>,  <span class="number">7.</span>,  <span class="number">3.</span>,  <span class="number">4.</span>]],</span><br><span class="line"> </span><br><span class="line">         	 [[ <span class="number">8.</span>,  <span class="number">9.</span>,  <span class="number">4.</span>,  <span class="number">3.</span>],</span><br><span class="line">         	  [<span class="number">10.</span>, <span class="number">11.</span>,  <span class="number">2.</span>,  <span class="number">1.</span>]]]))</span><br></pre></td></tr></table></figure>
<p>有时，我们想[<strong>通过<em>逻辑运算符</em>构建二元张量</strong>]。 以<code>X == Y</code>为例： 对于每个位置，如果<code>X</code>和<code>Y</code>在该位置相等，则新张量中相应项的值为1。 这意味着逻辑语句<code>X == Y</code>在该位置处为真，否则该位置为0。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>X == Y</span><br><span class="line">	tensor([[<span class="literal">False</span>,  <span class="literal">True</span>, <span class="literal">False</span>,  <span class="literal">True</span>],</span><br><span class="line">        	[<span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>],</span><br><span class="line">            [<span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>]])</span><br></pre></td></tr></table></figure>
<p>[<strong>对张量中的所有元素进行求和，会产生一个单元素张量。</strong>]</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>X.<span class="built_in">sum</span>()</span><br><span class="line">	tensor(<span class="number">66.</span>)</span><br></pre></td></tr></table></figure>
<h4 id="1-3-广播机制"><a href="#1-3-广播机制" class="headerlink" title="1.3 广播机制"></a>1.3 广播机制</h4><p>在上面的部分中，我们看到了如何在相同形状的两个张量上执行按元素操作。在某些情况下，[<strong>即使形状不同，我们仍然可以通过调用<em>广播机制</em>（broadcasting mechanism）来执行按元素操作</strong>]。这种机制的工作条件是：两个张量从后开始数，每个维度相等或者其中一个为1。这种机制的工作方式如下：首先，通过适当复制元素来扩展一个或两个数组，以便在转换之后，两个张量具有相同的形状。其次，对生成的数组执行按元素操作。在大多数情况下，我们将沿着数组中长度为1的轴进行广播，如下例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = torch.arange(<span class="number">3</span>).reshape((<span class="number">3</span>, <span class="number">1</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = torch.arange(<span class="number">2</span>).reshape((<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, a + b</span><br><span class="line">	(tensor([[<span class="number">0</span>],</span><br><span class="line">         	 [<span class="number">1</span>],</span><br><span class="line">         	 [<span class="number">2</span>]]),</span><br><span class="line"> 	 tensor([[<span class="number">0</span>, <span class="number">1</span>]]))</span><br><span class="line"> 	 tensor([[<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">        	 [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">        	 [<span class="number">2</span>, <span class="number">3</span>]])</span><br></pre></td></tr></table></figure>
<p>由于<code>a</code>和<code>b</code>分别是$3\times1$和$1\times2$矩阵，如果让它们相加，它们的形状不匹配。我们将两个矩阵<strong>广播</strong>为一个更大的$3\times2$矩阵，矩阵<code>a</code>复制列，矩阵<code>b</code>复制行，然后再按元素相加。需要注意的是，广播机制只能扩展维度，而不能凭空增加张量的维度，例如在计算沿某个轴的均值时，若张量维度不同，则会报错：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>C = torch.arange(<span class="number">24</span>, dtype=torch.float32).reshape(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C / C.<span class="built_in">sum</span>(axis=<span class="number">1</span>)</span><br><span class="line">	RuntimeError: The size of tensor a (<span class="number">3</span>) must <span class="keyword">match</span> the size of tensor b (<span class="number">2</span>) at non-singleton dimension <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>此时我们需要将<code>keepdims</code>设为True，才能正确利用广播机制扩展<code>C.sum(axis=1)</code>的维度：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>C / C.<span class="built_in">sum</span>(axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line">	tensor([[[<span class="number">0.0000</span>, <span class="number">0.0667</span>, <span class="number">0.1111</span>, <span class="number">0.1429</span>],</span><br><span class="line">         	 [<span class="number">0.3333</span>, <span class="number">0.3333</span>, <span class="number">0.3333</span>, <span class="number">0.3333</span>],</span><br><span class="line">         	 [<span class="number">0.6667</span>, <span class="number">0.6000</span>, <span class="number">0.5556</span>, <span class="number">0.5238</span>]],</span><br><span class="line"></span><br><span class="line">        	[[<span class="number">0.2500</span>, <span class="number">0.2549</span>, <span class="number">0.2593</span>, <span class="number">0.2632</span>],</span><br><span class="line">         	 [<span class="number">0.3333</span>, <span class="number">0.3333</span>, <span class="number">0.3333</span>, <span class="number">0.3333</span>],</span><br><span class="line">         	 [<span class="number">0.4167</span>, <span class="number">0.4118</span>, <span class="number">0.4074</span>, <span class="number">0.4035</span>]]])</span><br></pre></td></tr></table></figure>
<h4 id="1-4-索引和切片"><a href="#1-4-索引和切片" class="headerlink" title="1.4 索引和切片"></a>1.4 索引和切片</h4><p>就像在任何其他Python数组中一样，张量中的元素可以通过索引访问。与任何Python数组一样：第一个元素的索引是0，最后一个元素索引是-1；可以指定范围以包含第一个元素和最后一个之前的元素。如下所示，我们[<strong>可以用<code>[-1]</code>选择最后一个元素，可以用<code>[1:3]</code>选择第二个和第三个元素</strong>]：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>X[-<span class="number">1</span>], X[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">	(tensor([ <span class="number">8.</span>,  <span class="number">9.</span>, <span class="number">10.</span>, <span class="number">11.</span>]),</span><br><span class="line"> 	 tensor([[ <span class="number">4.</span>,  <span class="number">5.</span>,  <span class="number">6.</span>,  <span class="number">7.</span>],</span><br><span class="line">         	 [ <span class="number">8.</span>,  <span class="number">9.</span>, <span class="number">10.</span>, <span class="number">11.</span>]]))</span><br></pre></td></tr></table></figure>
<p>我们[<strong>可以用<code>[::2]</code>每间隔一个元素选择一个元素，可以用<code>[::3]</code>每间隔两个元素选择一个元素</strong>]：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>X[::<span class="number">2</span>, ::<span class="number">3</span>]</span><br><span class="line">	tensor([[ <span class="number">0.</span>,  <span class="number">3.</span>],</span><br><span class="line">          	[ <span class="number">8.</span>, <span class="number">11.</span>]])</span><br></pre></td></tr></table></figure>
<p>[<strong>除读取外，我们还可以通过指定索引来将元素写入矩阵。</strong>]</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>X[<span class="number">1</span>, <span class="number">2</span>] = <span class="number">9</span></span><br><span class="line">	tensor([[ <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>],</span><br><span class="line">        	[ <span class="number">4.</span>,  <span class="number">5.</span>,  <span class="number">9.</span>,  <span class="number">7.</span>],</span><br><span class="line">       	 	[ <span class="number">8.</span>,  <span class="number">9.</span>, <span class="number">10.</span>, <span class="number">11.</span>]])</span><br></pre></td></tr></table></figure>
<p>如果我们想[<strong>为多个元素赋值相同的值，我们只需要索引所有元素，然后为它们赋值。</strong>]例如，<code>[0:2, :]</code>访问第1行和第2行，其中“:”代表沿轴1（列）的所有元素。虽然我们讨论的是矩阵的索引，但这也适用于向量和超过2个维度的张量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>X[<span class="number">0</span>:<span class="number">2</span>, :] = <span class="number">12</span></span><br><span class="line">	tensor([[<span class="number">12.</span>, <span class="number">12.</span>, <span class="number">12.</span>, <span class="number">12.</span>],</span><br><span class="line">        	[<span class="number">12.</span>, <span class="number">12.</span>, <span class="number">12.</span>, <span class="number">12.</span>],</span><br><span class="line">       	 	[ <span class="number">8.</span>,  <span class="number">9.</span>, <span class="number">10.</span>, <span class="number">11.</span>]])</span><br></pre></td></tr></table></figure>
<h4 id="1-5-节约内存"><a href="#1-5-节约内存" class="headerlink" title="1.5 节约内存"></a>1.5 节约内存</h4><p>[<strong>如果在后续计算中没有重复使用<code>X</code>，我们也可以使用<code>X[:] = X + Y</code>或<code>X += Y</code>来减少操作的内存开销。</strong>]</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>before = <span class="built_in">id</span>(X)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X += Y</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(X) == before</span><br><span class="line">	<span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h4 id="1-6-转换为其他Python对象"><a href="#1-6-转换为其他Python对象" class="headerlink" title="1.6 转换为其他Python对象"></a>1.6 转换为其他Python对象</h4><p>将深度学习框架定义的张量[<strong>转换为NumPy张量（<code>ndarray</code>）</strong>]很容易，反之也同样容易。torch张量和numpy数组将共享它们的底层内存，就地操作更改一个张量也会同时更改另一个张量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>A = X.numpy()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>B = torch.tensor(A)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(A), <span class="built_in">type</span>(B)</span><br><span class="line">	(numpy.ndarray, torch.Tensor)</span><br></pre></td></tr></table></figure>
<p>要(<strong>将大小为1的张量转换为Python标量</strong>)，我们可以调用<code>item</code>函数或Python的内置函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = torch.tensor([<span class="number">3.5</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, a.item(), <span class="built_in">float</span>(a), <span class="built_in">int</span>(a)</span><br><span class="line">	(tensor([<span class="number">3.5000</span>]), <span class="number">3.5</span>, <span class="number">3.5</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<h3 id="2-数据预处理"><a href="#2-数据预处理" class="headerlink" title="2. 数据预处理"></a>2. 数据预处理</h3><p>为了能用深度学习来解决现实世界的问题，我们经常从预处理原始数据开始，而不是从那些准备好的张量格式数据开始。在Python中常用的数据分析工具中，我们通常使用<code>pandas</code>软件包。像庞大的Python生态系统中的许多其他扩展包一样，<code>pandas</code>可以与张量兼容。本节我们将简要介绍使用<code>pandas</code>预处理原始数据，并将原始数据转换为张量格式的步骤。</p>
<h4 id="2-1-读取数据集"><a href="#2-1-读取数据集" class="headerlink" title="2.1 读取数据集"></a>2.1 读取数据集</h4><p>举一个例子，我们首先(<strong>创建一个人工数据集，并存储在CSV（逗号分隔值）文件</strong>)<code>../data/house_tiny.csv</code>中。以其他格式存储的数据也可以通过类似的方式进行处理。下面我们将数据集按行写入CSV文件中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.makedirs(os.path.join(<span class="string">&#x27;..&#x27;</span>, <span class="string">&#x27;data&#x27;</span>), exist_ok=<span class="literal">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data_file = os.path.join(<span class="string">&#x27;..&#x27;</span>, <span class="string">&#x27;data&#x27;</span>, <span class="string">&#x27;house_tiny.csv&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> <span class="built_in">open</span>(data_file, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>    f.write(<span class="string">&#x27;NumRooms,Alley,Price\n&#x27;</span>)  <span class="comment"># 列名</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>    f.write(<span class="string">&#x27;NA,Pave,127500\n&#x27;</span>)  <span class="comment"># 每行表示一个数据样本</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>    f.write(<span class="string">&#x27;2,NA,106000\n&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>    f.write(<span class="string">&#x27;4,NA,178100\n&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>    f.write(<span class="string">&#x27;NA,NA,140000\n&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>要[<strong>从创建的CSV文件中加载原始数据集</strong>]，我们导入<code>pandas</code>包并调用<code>read_csv</code>函数。该数据集有四行三列。其中每行描述了房间数量（“NumRooms”）、巷子类型（“Alley”）和房屋价格（“Price”）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data = pd.read_csv(data_file)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(data)</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">NumRooms</th>
<th style="text-align:center">Alley</th>
<th style="text-align:center">Price</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">NaN</td>
<td style="text-align:center">Pave</td>
<td style="text-align:center">127500</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">2.0</td>
<td style="text-align:center">NaN</td>
<td style="text-align:center">106000</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">4.0</td>
<td style="text-align:center">NaN</td>
<td style="text-align:center">178100</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">NaN</td>
<td style="text-align:center">NaN</td>
<td style="text-align:center">140000</td>
</tr>
</tbody>
</table>
</div>
<h4 id="2-2-处理缺失值"><a href="#2-2-处理缺失值" class="headerlink" title="2.2 处理缺失值"></a>2.2 处理缺失值</h4><p>“NaN”项代表缺失值。[<strong>为了处理缺失的数据，典型的方法包括<em>插值法</em>和<em>删除法</em>，</strong>]其中插值法用一个替代值弥补缺失值，而删除法则直接忽略缺失值。通过位置索引<code>iloc</code>，我们将<code>data</code>分成<code>inputs</code>和<code>outputs</code>，其中前者为<code>data</code>的前两列，而后者为<code>data</code>的最后一列。对于<code>inputs</code>中缺少的数值，我们用同一列的均值替换“NaN”项。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>inputs, outputs = data.iloc[:, <span class="number">0</span>:<span class="number">2</span>], data.iloc[:, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>inputs = inputs.fillna(inputs.mean(numeric_only=<span class="literal">True</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(inputs)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>numeric_only=True,处理运行bug</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">NumRooms</th>
<th style="text-align:center">Alley</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">3.0</td>
<td style="text-align:center">Pave</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">2.0</td>
<td style="text-align:center">NaN</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">4.0</td>
<td style="text-align:center">NaN</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">3.0</td>
<td style="text-align:center">NaN</td>
</tr>
</tbody>
</table>
</div>
<p>利用删除法，我们删除缺失元素最多的一个样本。首先，<code>data.isnull()</code>矩阵统计每个元素是否缺失，之后在轴-1的方向上将<code>data.isnull()</code>元素求和，得到每个样本缺失元素个数，取得缺失元素个数最大的样本的序号，并将其删除。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>nan_numer = data.isnull().<span class="built_in">sum</span>(axis=<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nan_max_id = nan_numer.idxmax()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data_delete = data.drop([nan_max_id], axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">NumRooms</th>
<th style="text-align:center">Alley</th>
<th style="text-align:center">Price</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">NaN</td>
<td style="text-align:center">Pave</td>
<td style="text-align:center">127500</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">2.0</td>
<td style="text-align:center">NaN</td>
<td style="text-align:center">106000</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">4.0</td>
<td style="text-align:center">NaN</td>
<td style="text-align:center">178100</td>
</tr>
</tbody>
</table>
</div>
<p>一般情况下，利用<code>dropna</code>删除数据，其中•Axis哪个维度How如何删除，‘any’表示有nan即删除，‘all’表示全为nan删除，Thresh有多少个nan删除，Subset在哪些列中查找nan，Inplace是否原地修改。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dropna( axis=<span class="number">0</span>, how=‘<span class="built_in">any</span>’, thresh=<span class="literal">None</span>, subset=<span class="literal">None</span>, inplace=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<p>[<strong>对于<code>inputs</code>中的类别值或离散值，我们将“NaN”视为一个类别。</strong>]由于“巷子类型”（“Alley”）列只接受两种类型的类别值“Pave”和“NaN”，<code>pandas</code>可以自动将此列转换为两列“Alley_Pave”和“Alley_nan”。巷子类型为“Pave”的行会将“Alley_Pave”的值设置为1，“Alley_nan”的值设置为0。缺少巷子类型的行会将“Alley_Pave”和“Alley_nan”分别设置为0和1。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>inputs = pd.get_dummies(inputs, dummy_na=<span class="literal">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(inputs)</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">NumRooms</th>
<th style="text-align:center">Alley_Pave</th>
<th style="text-align:center">Alley_nan</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">3.0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">2.0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">4.0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">3.0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
</div>
<h4 id="2-3-转换为张量格式"><a href="#2-3-转换为张量格式" class="headerlink" title="2.3 转换为张量格式"></a>2.3 转换为张量格式</h4><p>[<strong>现在<code>inputs</code>和<code>outputs</code>中的所有条目都是数值类型，它们可以转换为张量格式。</strong>]</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> torch</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X, y = torch.tensor(inputs.values), torch.tensor(outputs.values)</span><br><span class="line">	(tensor([[<span class="number">3.</span>, <span class="number">1.</span>, <span class="number">0.</span>],</span><br><span class="line">         	 [<span class="number">2.</span>, <span class="number">0.</span>, <span class="number">1.</span>],</span><br><span class="line">         	 [<span class="number">4.</span>, <span class="number">0.</span>, <span class="number">1.</span>],</span><br><span class="line">         	 [<span class="number">3.</span>, <span class="number">0.</span>, <span class="number">1.</span>]], dtype=torch.float64),</span><br><span class="line"> 	 tensor([<span class="number">127500</span>, <span class="number">106000</span>, <span class="number">178100</span>, <span class="number">140000</span>]))</span><br></pre></td></tr></table></figure>
<h3 id="3-Q-amp-A"><a href="#3-Q-amp-A" class="headerlink" title="3. Q&amp;A"></a>3. Q&amp;A</h3><p><strong><code>Q1：reshape和view的区别？</code></strong></p>
<blockquote>
<p>View为浅拷贝，只能作用于连续型张量；Contiguous函数将张量做深拷贝并转为连续型；Reshape在张量连续时和view相同，不连续时等价于先contiguous再view。</p>
</blockquote>
<p><strong><code>Q2：数组计算吃力怎么办？</code></strong></p>
<blockquote>
<p>学习numpy的知识。</p>
</blockquote>
<p><strong><code>Q3：如何快速区分维度？</code></strong></p>
<blockquote>
<p>利用<code>a.shape</code>或<code>a.dim()</code>。</p>
</blockquote>
<p><strong><code>Q4：Tensor和Array有什么区别？</code></strong></p>
<blockquote>
<p>Tensor是数学上定义的张量，Array是计算机概念数组，但在深度学习中有时将Tensor视为多维数组。</p>
</blockquote>
<p><strong><code>Q5：新分配了y的内存，那么之前y对应的内存会自动释放吗？</code></strong></p>
<blockquote>
<p>Python会在不需要时自动释放内存。</p>
</blockquote>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>14-数值稳定性+模型初始化和激活函数</title>
    <url>/2024/04/23/11-01-14/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.04.24：初稿</li>
</ul>
<h2 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h2><ul>
<li><a href="/2024/04/24/12-18-34/" title="动手学深度学习笔记汇总">动手学深度学习笔记汇总</a>
</li>
</ul>
<h2 id="14-数值稳定性-模型初始化和激活函数"><a href="#14-数值稳定性-模型初始化和激活函数" class="headerlink" title="14-数值稳定性+模型初始化和激活函数"></a>14-数值稳定性+模型初始化和激活函数</h2><h3 id="1-数值稳定性"><a href="#1-数值稳定性" class="headerlink" title="1. 数值稳定性"></a>1. 数值稳定性</h3><p>数值稳定性是深度学习中比较重要的点，特别是当神经网络变得很深的时候，数值通常很容易变得不稳定。</p>
<h4 id="1-1-神经网络的梯度"><a href="#1-1-神经网络的梯度" class="headerlink" title="1.1 神经网络的梯度"></a>1.1 神经网络的梯度</h4><img src="/2024/04/23/11-01-14/14-01.png" class="">
<p><strong>考虑d层神经网络</strong></p>
<ul>
<li><p>t表示层数，$h^{t-1}$表示第<em>t-1</em>层的输出，经过一个$f_{t}$函数后，得到第<em>t</em>层的输出。</p>
</li>
<li><p>最终输出y的表示：输入x经过若干层(<em>d</em>层)的函数作用，最后被损失函数作用得到输出y。</p>
</li>
</ul>
<p><strong>计算损失函数<em>L</em>关于第<em>t</em>层参数$W_{t}$的梯度</strong></p>
<ul>
<li><p>由链导法则得到上图中乘积公式</p>
</li>
<li><p>需要进行d-t次<strong>矩阵乘法</strong>（为什么是矩阵乘法？答：由于所有的<em>h</em>都是一些<strong>向量</strong>，导数中分子分母均为向量，所以求导得到的是矩阵，维数为[分子维度]x[分母维度]，可以参考第6节<a href="https://www.bilibili.com/video/BV1eZ4y1w7PY">视频</a>和<a href="./06-矩阵计算.md">笔记</a>）。这也是导致数值稳定性问题的<strong>主要因素</strong>，由于做了太多次的矩阵乘法。</p>
</li>
</ul>
<h4 id="1-2-数值稳定性的常见两个问题"><a href="#1-2-数值稳定性的常见两个问题" class="headerlink" title="1.2 数值稳定性的常见两个问题"></a>1.2 数值稳定性的常见两个问题</h4><p><strong>梯度爆炸</strong></p>
<p>假设梯度都是一些比1大的数比如1.5，做100次乘积之后得到$4\times 10^{17}$，这个数字很容易带来一些浮点数上限的问题（需了解更多请参考计算机系统-计算机中浮点数的存储方式）。</p>
<p><strong>梯度消失</strong></p>
<p>假设梯度都是一些比1小的数比如0.8，做100次乘积之后得到$2\times10^{-10}$，也可能会带来浮点数下溢的问题。</p>
<h4 id="1-3-例子：MLP"><a href="#1-3-例子：MLP" class="headerlink" title="1.3 例子：MLP"></a>1.3 例子：MLP</h4><p>此处我们着重探讨<a href="#11-神经网络的梯度">1.1节</a>中所述的求梯度时所做的d-t次矩阵乘法，并以一个实例MLP来探讨其结果的具体形式。</p>
<img src="/2024/04/23/11-01-14/14-02.png" class="">
<ul>
<li><p>第一行公式，定义$h^{t}$和$h^{t-1}$(均为向量)的函数关系$f_{t}$，第t层的权重矩阵作用于t-1层的输出$h^{t-1}$后经过激活函数$\sigma$得到$h^{t}$，注意激活函数$\sigma$逐元素计算。</p>
</li>
<li><p>第二行公式：这里用到链导法则，激活函数$\sigma$先对内部向量逐元素求导，然后把求导后这个向量变成对角矩阵（可以理解为链导法则中内部向量$W_{t}h_{t-1}$对自身进行求导，变成一个nxn的对角矩阵，更多请参考<a href="https://nndl.github.io/nndl-book.pdf">邱锡鹏 《神经网络与深度学习》</a><sup><a href="#fn_ 图片1" id="reffn_ 图片1"> 图片1</a></sup>）</p>
</li>
</ul>
<img src="/2024/04/23/11-01-14/14-03.png" class="">
<blockquote id="fn_图片1">
<sup>图片1</sup>. 引自<a href="https://nndl.github.io/nndl-book.pdf">邱锡鹏 《神经网络与深度学习》</a>附录：数学基础 <a href="#reffn_图片1" title="Jump back to footnote [图片1] in the text."> &#8617;</a>
</blockquote>
<ul>
<li>视频中<strong>勘误说明</strong>：链导法则中$\frac{\partial W^{t}h^{t-1}}{\partial h^{t-1}}= W^{t}$而不是$\left (W^{t} \right )^{T}$（这点由分子分母维度也容易推出），故最终求导结果包含$W^{t}$，而不是其转置。</li>
</ul>
<h4 id="1-3-梯度爆炸"><a href="#1-3-梯度爆炸" class="headerlink" title="1.3 梯度爆炸"></a>1.3 梯度爆炸</h4><h5 id="1-3-1-使用ReLU作为激活函数"><a href="#1-3-1-使用ReLU作为激活函数" class="headerlink" title="1.3.1 使用ReLU作为激活函数"></a>1.3.1 使用ReLU作为激活函数</h5><img src="/2024/04/23/11-01-14/14-04.png" class="">
<p>由于激活函数Relu求导后或者是1或者是0，变为对角矩阵的斜对角线元素后，与$W^{i}$做乘积，斜对角线为1的部分会使得W中元素保留，最终该连乘式中有一些元素来自$\prod\left ( W^{i} \right )$ ，如果大部分$W^{i}$中 值都大于1，且层数比较大，那么连乘之后可能导致梯度爆炸的问题。</p>
<h5 id="1-3-2-梯度爆炸问题"><a href="#1-3-2-梯度爆炸问题" class="headerlink" title="1.3.2 梯度爆炸问题"></a>1.3.2 梯度爆炸问题</h5><ul>
<li><p>值超出值域（infinity）</p>
<ul>
<li>对于16位浮点数尤为严重（数值区间 [6e-5 , 6e4]），GPU用16位浮点数更快</li>
</ul>
</li>
<li><p>对学习率敏感</p>
<ul>
<li><p>如果学习率太大→大参数值→更大的梯度，如此循环几次，容易导致梯度爆炸</p>
</li>
<li><p>如果学习率太小→训练无进展</p>
</li>
<li><p>我们可能需要在训练过程中不断调整学习率</p>
</li>
</ul>
</li>
</ul>
<h4 id="1-4-梯度消失"><a href="#1-4-梯度消失" class="headerlink" title="1.4 梯度消失"></a>1.4 梯度消失</h4><h5 id="1-4-1-使用Sigmoid作为激活函数"><a href="#1-4-1-使用Sigmoid作为激活函数" class="headerlink" title="1.4.1 使用Sigmoid作为激活函数"></a>1.4.1 使用Sigmoid作为激活函数</h5><img src="/2024/04/23/11-01-14/14-05.png" class="">
<ul>
<li>蓝色曲线为函数值</li>
<li>黄色曲线为梯度，注意到当输入x值取±6时，此时梯度已经变得很小，由图也可以看出，当输入值稍大或稍小都很容易引起小梯度。</li>
</ul>
<img src="/2024/04/23/11-01-14/14-06.png" class="">
<p>所以最终连乘式中$\prod diag\left ( \sigma ^{‘}\left ( W^{i}h^{i-1} \right ) \right )$项乘出来会很小，导致整个梯度很小，产生梯度消失问题。</p>
<h5 id="1-4-2-梯度消失的问题"><a href="#1-4-2-梯度消失的问题" class="headerlink" title="1.4.2 梯度消失的问题"></a>1.4.2 梯度消失的问题</h5><ul>
<li><p>梯度值变为0</p>
<ul>
<li>对16位浮点数尤为严重</li>
</ul>
</li>
<li><p>训练没有进展</p>
<ul>
<li>不管如何选择学习率，由于梯度已经为0了，学习率x梯度=0</li>
</ul>
</li>
<li>对于底部层尤为严重<ul>
<li>仅仅顶部层训练得较好。第<em>t</em>层导数包含d-t个矩阵乘积，越往底层走，t越小，乘得越多，梯度消失越严重，所以底部层效果更差。</li>
<li>无法让神经网络更深。只能把顶部层训练得比较好，底部层跑不动，这和给一个浅的神经网络没有什么区别。</li>
</ul>
</li>
</ul>
<h3 id="2-模型初始化和激活函数"><a href="#2-模型初始化和激活函数" class="headerlink" title="2. 模型初始化和激活函数"></a>2. 模型初始化和激活函数</h3><h4 id="2-1-让训练更加稳定"><a href="#2-1-让训练更加稳定" class="headerlink" title="2.1 让训练更加稳定"></a>2.1 让训练更加稳定</h4><p>我们的一个核心目标是如何让训练更稳定，梯度值不要太大也不要太小</p>
<ul>
<li>目标：让梯度值在合理的范围内<ul>
<li>例如 [1e-6, 1e3]</li>
</ul>
</li>
<li><p>常用方法：</p>
<ul>
<li>将乘法变加法：<ul>
<li>ResNet（跳跃连接，如果很多层，加入加法进去）</li>
<li>LSTM（引入记忆细胞，更新门，遗忘门，通过门权重求和，控制下一步是否更新）</li>
</ul>
</li>
<li><p>归一化：</p>
<ul>
<li><p>梯度归一化（归一化均值，方差）</p>
</li>
<li><p>梯度裁剪(clipping)：比如大于/小于一个固定的阈值，就让梯度等于这个阈值，将梯度限制在一个范围中。（可以缓解梯度爆炸）</p>
</li>
</ul>
</li>
<li>合理的权重初始和激活函数：本节课讲述重点</li>
</ul>
</li>
</ul>
<p><strong>下面我们重点探讨最后一种方法：合理的权重初始和激活函数</strong></p>
<h4 id="2-2-基本假设：让每层的均值-方差是一个常数"><a href="#2-2-基本假设：让每层的均值-方差是一个常数" class="headerlink" title="2.2 基本假设：让每层的均值/方差是一个常数"></a>2.2 基本假设：让每层的均值/方差是一个常数</h4><ul>
<li><p><strong>将每层的输出和梯度都看做随机变量</strong></p>
<p>比如第i层有100维，就将输出和梯度分别看成100个随机变量</p>
</li>
<li><p><strong>让它们的均值和方差都保持一致</strong></p>
<p>我们的目标，这样不管神经网络多深，最后一层总与第一层差不多，从而不会梯度爆炸和消失</p>
</li>
</ul>
<p>根据我们的假设，可以列出如下方程式：</p>
<img src="/2024/04/23/11-01-14/14-07.png" class="">
<h4 id="2-3-权重初始化"><a href="#2-3-权重初始化" class="headerlink" title="2.3 权重初始化"></a>2.3 权重初始化</h4><ul>
<li>在合理值区间里随机初始参数</li>
<li>训练<strong>开始</strong>的时候更容易有数值不稳定<ul>
<li>远离最优解的地方损失函数表面可能很复杂</li>
<li>最优解附近表面会比较平</li>
</ul>
</li>
<li>使用N(0, 0.01)分布来初始可能对小网络没问题，但不能保证深度神经网络</li>
</ul>
<h4 id="2-4-例子：MLP"><a href="#2-4-例子：MLP" class="headerlink" title="2.4 例子：MLP"></a>2.4 例子：MLP</h4><p>下面我们以MLP为例，考虑需要什么条件，才能满足<a href="#22-基本假设：让每层的均值/方差是一个常数">2.2节</a>的假设。</p>
<h5 id="2-4-1-模型假设"><a href="#2-4-1-模型假设" class="headerlink" title="2.4.1 模型假设"></a>2.4.1 模型假设</h5><ul>
<li>每一层<strong>权重</strong>中的变量均为<strong>独立同分布</strong>，并设出均值、方差。</li>
<li>每一层<strong>输入</strong>的变量<strong>独立于</strong>该层<strong>权重</strong>变量。同时<strong>输入变量</strong>之间<strong>独立同分布</strong>。</li>
<li>假设没有激活函数(先简化分析，之后会考虑有激活函数的情况)，可以求得该层输出的期望为0。</li>
</ul>
<img src="/2024/04/23/11-01-14/14-08.png" class="">
<p>此处用到了一个重要性质：</p>
<img src="/2024/04/23/11-01-14/14-09.png" class="">
<p>更多均值、方差运算可以参考<a href="https://blog.csdn.net/MissXy_/article/details/80705828">期望、方差、协方差及相关系数的基本运算</a></p>
<h5 id="2-4-2-正向方差"><a href="#2-4-2-正向方差" class="headerlink" title="2.4.2 正向方差"></a>2.4.2 正向方差</h5><img src="/2024/04/23/11-01-14/14-10.png" class="">
<ul>
<li><p>第二行的计算中仍然用到了<a href="241模型假设">2.4.1节</a>的期望的重要性质：如果两个变量独立，它们乘积的均值=均值的乘积，再结合w的期望为0(注意w和h独立，w之间独立同分布)，即有第二行末项期望为0。</p>
</li>
<li><p>最后一行由于wi,j独立同分布，方差相同，加上做了hj独立同分布的假设，所以可以写成 <strong>[t-1层输出维度] x [t层权重方差] x [t-1层输出方差]</strong> 的形式</p>
</li>
<li><p>此时，我们回过头来看我们的终极目标<a href="#22-基本假设：让每层的均值/方差是一个常数">2.2节</a>的假设，每层输出期望为0我们已经可以满足(2.4.1节已经推导出)，而方差相同这一目标，通过上图的推导，我们发现需要&lt;$n_{t-1}\gamma _{t}=1$。</p>
</li>
</ul>
<h5 id="2-4-3-反向均值和方差"><a href="#2-4-3-反向均值和方差" class="headerlink" title="2.4.3 反向均值和方差"></a>2.4.3 反向均值和方差</h5><img src="/2024/04/23/11-01-14/14-11.png" class="">
<p>反向的情况和正向的类似，不过此时我们需要满足的式子变为$n_{t}\gamma _{t}=1$。</p>
<h5 id="2-4-4-Xavier初始"><a href="#2-4-4-Xavier初始" class="headerlink" title="2.4.4 Xavier初始"></a>2.4.4 Xavier初始</h5><ul>
<li><p>上述推导带来的问题：难以同时满足$n_{t-1}\gamma _{t}=1$和$n_{t}\gamma _{t}=1$。（需要每层输出的维度都相同）</p>
</li>
<li><p>采用Xavier折中解决，不能同时满足上面两式，转而满足 [<strong>上面两式做加法后除以2</strong>] 得到的式子，用两种分布进行初始化（每层方差、均值满足推导式）。</p>
<img src="/2024/04/23/11-01-14/14-12.png" class="">
</li>
<li><p>如果能确定每层输入、输出维度大小，则能确定该层权重的方差大小。</p>
</li>
<li>权重初始化方式：正态分布、均匀分布，均值/方差满足Xavier的假设。</li>
</ul>
<h5 id="2-4-5-假设线性的激活函数"><a href="#2-4-5-假设线性的激活函数" class="headerlink" title="2.4.5 假设线性的激活函数"></a>2.4.5 假设线性的激活函数</h5><p>真实情况下，我们并不会用线性的激活函数（这样相当于没有进行激活），这里为了简化问题，假设激活函数是线性的。</p>
<ul>
<li><strong>正向</strong></li>
</ul>
<img src="/2024/04/23/11-01-14/14-13.png" class="">
<p>上述推导表明，为了使得前向传播的均值为0，方差固定的话，激活函数必须f(x)=x，这种恒等映射。</p>
<ul>
<li><strong>反向</strong></li>
</ul>
<img src="/2024/04/23/11-01-14/14-14.png" class="">
<p>PPT上的推导似乎有点问题（上图中第二行方程），笔者重新进行了下述推导，读者也可自行推导验证：</p>
<img src="/2024/04/23/11-01-14/14-15.png" class="">
<p><strong>通过正向和反向的推导，我们可以得出的【结论】是：当激活函数为f(x)=x，这种恒等映射更有利于维持神经网络的稳定性。</strong></p>
<h5 id="2-4-6-检查常用激活函数"><a href="#2-4-6-检查常用激活函数" class="headerlink" title="2.4.6 检查常用激活函数"></a>2.4.6 检查常用激活函数</h5><img src="/2024/04/23/11-01-14/14-16.png" class="">
<p>对于常用激活函数：tanh，relu满足在零点附近有f(x)=x，而sigmoid函数在零点附近不满足要求，可以对sigmoid函数进行调整（根据Taylor展开式，调整其过原点）</p>
<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><ul>
<li>当数值过大或者过小时，会导致数值问题。</li>
<li><p>常发生在深度模型中，因为其会对n个数累乘。</p>
</li>
<li><p>合理的权重初始值(如Xavier)和激活函数的选取(如relu, tanh, 调整后的sigmoid)可以提升数值稳定性。</p>
</li>
</ul>
<h3 id="4-Q-amp-A"><a href="#4-Q-amp-A" class="headerlink" title="4.Q&amp;A"></a>4.Q&amp;A</h3><p><strong>问题：nan, inf是怎么产生的以及怎么解决的？</strong></p>
<blockquote>
<p>NaN和Inf怎么产生的：参考<a href="https://blog.csdn.net/qq_16334327/article/details/86526854">出现nan、inf原因</a></p>
<p>如何解决：参考<a href="https://blog.csdn.net/u011119817/article/details/103908065">深度学习中nan和inf的解决</a>以及<a href="https://zhuanlan.zhihu.com/p/89588946#:~:text=一般来说，出现NaN有以下几种情况： 1.,如果在迭代的100轮以内，出现NaN，一般情况下的原因是因为你的学习率过高，需要降低学习率。 可以不断降低学习率直至不出现NaN为止，一般来说低于现有学习率1-10倍即可。">训练网络loss出现Nan解决办法 </a></p>
</blockquote>
<p><strong>问题：训练过程中，如果网络层的输出的中间层特征元素的值突然变成nan了，是发生梯度爆炸了吗？</strong></p>
<blockquote>
<p>参考<a href="https://zhuanlan.zhihu.com/p/89588946#:~:text=一般来说，出现NaN有以下几种情况： 1.,如果在迭代的100轮以内，出现NaN，一般情况下的原因是因为你的学习率过高，需要降低学习率。 可以不断降低学习率直至不出现NaN为止，一般来说低于现有学习率1-10倍即可。">训练网络loss出现Nan解决办法 </a></p>
</blockquote>
<p><strong>问题：老师，让每层方差是一个常数的方法，您指的是batch normalization吗？想问一下bn层为什么要有伽马和贝塔？去掉可以吗</strong></p>
<blockquote>
<p>让每层方差是一个常数，和batch norm没有太多关系，(本节课介绍的方法是合理地初始化权重和设置激活函数)。batch norm可以让你的输出变成一个均值为0，方差差不多是一个固定值的东西，但它不一定能保证你的梯度。</p>
</blockquote>
<p>(此处节选几个重要的Q&amp;A，建议观看完整Q&amp;A，获得更深的理解)</p>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>13-丢弃法</title>
    <url>/2024/04/23/11-01-13/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.04.24：初稿</li>
</ul>
<h2 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h2><ul>
<li><a href="/2024/04/24/12-18-34/" title="动手学深度学习笔记汇总">动手学深度学习笔记汇总</a>
</li>
</ul>
<h2 id="13-丢弃法"><a href="#13-丢弃法" class="headerlink" title="13-丢弃法"></a>13-丢弃法</h2><h3 id="1-丢弃法动机、实现及原则"><a href="#1-丢弃法动机、实现及原则" class="headerlink" title="1.丢弃法动机、实现及原则"></a>1.丢弃法动机、实现及原则</h3><h4 id="1-1动机"><a href="#1-1动机" class="headerlink" title="1.1动机"></a>1.1动机</h4><ul>
<li>一个好的模型需要对输入数据的扰动鲁棒（健壮性）</li>
</ul>
<h4 id=""><a href="#" class="headerlink" title=" "></a> </h4><img src="/2024/04/23/11-01-13/13-02.jpg" class="">       
<img src="/2024/04/23/11-01-13/13-03.jpg" class="">
<h4 id="1-2如何实现模型的这一能力"><a href="#1-2如何实现模型的这一能力" class="headerlink" title="1.2如何实现模型的这一能力"></a>1.2如何实现模型的这一能力</h4><ul>
<li>使用有噪音的数据。</li>
<li>丢弃法：在层之间加入噪音。</li>
</ul>
<h4 id="1-3加入噪音的原则"><a href="#1-3加入噪音的原则" class="headerlink" title="1.3加入噪音的原则"></a>1.3加入噪音的原则</h4><img src="/2024/04/23/11-01-13/13-01.png" class="">
<ul>
<li>例如模型的功能是识别猫猫，加入噪音可以是输入模糊的猫猫图片，但尽量不要是狗狗的图片。</li>
</ul>
<h3 id="2-丢弃法内容"><a href="#2-丢弃法内容" class="headerlink" title="2.丢弃法内容"></a>2.丢弃法内容</h3><ul>
<li>丢弃法对每个元素作如下扰动</li>
</ul>
<img src="/2024/04/23/11-01-13/13-04.png" class="">
<ul>
<li>能够满足加入噪音的期望相同原则</li>
<li>一定概率变为0，一定概率变得很大</li>
</ul>
<img src="/2024/04/23/11-01-13/13-05.png" class="">
<ul>
<li>期望没有发生变化，分母的意义</li>
</ul>
<h3 id="3-丢弃法使用"><a href="#3-丢弃法使用" class="headerlink" title="3.丢弃法使用"></a>3.丢弃法使用</h3><h4 id="3-1丢弃法的使用位置"><a href="#3-1丢弃法的使用位置" class="headerlink" title="3.1丢弃法的使用位置"></a>3.1丢弃法的使用位置</h4><ul>
<li>通常将丢弃法作用在隐藏全连接层的输出上</li>
</ul>
<img src="/2024/04/23/11-01-13/13-06.png" class="">
<ul>
<li>随机选中某些神经元将其输出置位0，因此模型不会过分依赖某些神经元</li>
</ul>
<img src="/2024/04/23/11-01-13/13-07.png" class="">
<h4 id="3-2训练中的丢弃法"><a href="#3-2训练中的丢弃法" class="headerlink" title="3.2训练中的丢弃法"></a>3.2训练中的丢弃法</h4><ul>
<li>正则项（丢弃法）仅在训练中使用：影响模型参数的更新，预测的时候便不再使用</li>
</ul>
<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h3><ul>
<li>丢弃法将一些输出项随机置0来控制模型复杂度</li>
<li>常作用在多层感知机的隐藏层输出上</li>
<li>丢弃概率是控制模型复杂度的超参数（常取0.9，0.5，0.1）</li>
</ul>
<h3 id="5-代码部分"><a href="#5-代码部分" class="headerlink" title="5.代码部分"></a>5.代码部分</h3><h4 id="5-1Dropout部分"><a href="#5-1Dropout部分" class="headerlink" title="5.1Dropout部分"></a>5.1Dropout部分</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dropout_layer</span> (X,dropout)：   <span class="comment">#X为dropout层的输入，dropout为设置的丢弃概率</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="number">0</span>&lt;=dropout&lt;=<span class="number">1</span>        <span class="comment">#丢弃概率介于0，1之间</span></span><br><span class="line">    <span class="keyword">if</span> dropout == <span class="number">1</span>:</span><br><span class="line">       <span class="keyword">return</span> torch.zeros_like(x) <span class="comment">#若丢弃概率为1，则X的全部项均被置0</span></span><br><span class="line">    <span class="keyword">if</span> dropout == <span class="number">0</span>:</span><br><span class="line">       <span class="keyword">return</span> X                   <span class="comment">#若丢弃概率为0，不对X作丢弃操作，直接返回X</span></span><br><span class="line">    mask=(torch.Tensor(X.shape).uniform_(<span class="number">0</span>,<span class="number">1</span>)&gt;dropout).<span class="built_in">float</span>() <span class="comment">#用uniform函数生成0-1间的随机实数，利用”&gt;&quot;，将大于dropout的记为1，小于dropout的记为0，实现丢弃操作</span></span><br><span class="line">    <span class="keyword">return</span> mask*X/(<span class="number">1</span>-dropout) <span class="comment">#将mask与X相乘实现丢弃操作，并除以(1-dropout)，这里不使用选中X中元素置0的原因是相乘操作相比选中操作更快</span></span><br></pre></td></tr></table></figure>
<h4 id="5-2在神经网络中使用丢弃法"><a href="#5-2在神经网络中使用丢弃法" class="headerlink" title="5.2在神经网络中使用丢弃法"></a>5.2在神经网络中使用丢弃法</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num_inputs, num_outputs, num_hiddens1, num_hiddens2 = <span class="number">784</span>, <span class="number">10</span>, <span class="number">256</span>, <span class="number">256</span></span><br><span class="line">dropout1, dropout2 = <span class="number">0.2</span>, <span class="number">0.5</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Net</span>(nn.Module)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_init_</span>(<span class="params">self,num_inputs,num_outputs,num_outputs,num_hiddens1,num_hiddens2,is_training=<span class="literal">True</span></span>):</span><br><span class="line">       <span class="built_in">super</span>(Net,self)._init_()</span><br><span class="line">       self.num_inputs=num_inputs</span><br><span class="line">       self.training=is_training</span><br><span class="line">       self.lin1=nn.Linear(num_inputs,num_hiddens1)</span><br><span class="line">       self.lin2=nn.Linear(num_hiddens1,num_hiddens2)</span><br><span class="line">       self.lin2=nn.Linear(num_hiddens2,num_outputs)</span><br><span class="line">       self.relu=nn.ReLU()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,X</span>):</span><br><span class="line">       H1=self.relu(self.lin1(X.reshape((-<span class="number">1</span>,self.num_inputs))))</span><br><span class="line">       <span class="keyword">if</span> self.training == <span class="literal">True</span>:  <span class="comment">#丢弃法仅在训练中使用</span></span><br><span class="line">           H1=dropout_layer(H1,dropout1)</span><br><span class="line">       H2=self.relu(self.lin2(H1))</span><br><span class="line">       <span class="keyword">if</span> self.training == <span class="literal">True</span>: <span class="comment">#丢弃法仅在训练中使用</span></span><br><span class="line">           H2=dropout_layer(H2,dropout2)</span><br><span class="line">       out=self.lin3(H2)  <span class="comment">#output层不再使用丢弃法</span></span><br><span class="line">       <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>15-实战Kaggle比赛：预测房价</title>
    <url>/2024/04/23/11-01-15/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.04.24：初稿</li>
</ul>
<h2 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h2><ul>
<li><a href="/2024/04/24/12-18-34/" title="动手学深度学习笔记汇总">动手学深度学习笔记汇总</a>
</li>
</ul>
<h3 id="课程练习，kaggle比赛"><a href="#课程练习，kaggle比赛" class="headerlink" title="课程练习，kaggle比赛"></a>课程练习，kaggle比赛</h3><ul>
<li><a href="https://www.kaggle.com/c/house-prices-advanced-regression-techniques">kaggle</a></li>
<li>有一份解决方案公布在论坛里</li>
</ul>
<h3 id="实战Kaggle比赛：预测房价"><a href="#实战Kaggle比赛：预测房价" class="headerlink" title="实战Kaggle比赛：预测房价"></a>实战Kaggle比赛：预测房价</h3><ul>
<li><p>实际上这个时间竞赛已经结束了。</p>
</li>
<li><p>这节目的是提供大家一个实际操作的机会，使用的大多是前面学到的知识。课程提供了代码样本，酒体内容详见含注释的代码中。</p>
</li>
<li>简单介绍一下数据集的内容，数据集是加州2020年几乎全部的房子交易记录，这里选择前半年的数据作为训练集，后半年作为验证集，包括许多的信息，如：ID，洗手间个数，卧室个数，政府预测价格等等共41个特征，连结如下：<a href="https://www.kaggle.com/c/california-house-prices/data?select=train.csv">https://www.kaggle.com/c/california-house-prices/data?select=train.csv</a> 需要大家自行下载数据集（没有kaglle账户的要注册才可以下载）</li>
<li>在真实数据集上，已经提供的程序得到的效果会很差，需要我们使用各种方法来优化，例如dropout，weught decay等，期待大家取得好成绩！</li>
</ul>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>16-Pytorch神经网络基础</title>
    <url>/2024/04/23/11-01-16/</url>
    <content><![CDATA[<h2 id="Pytorch神经网络基础"><a href="#Pytorch神经网络基础" class="headerlink" title="Pytorch神经网络基础"></a>Pytorch神经网络基础</h2><h3 id="层和块"><a href="#层和块" class="headerlink" title="层和块"></a>层和块</h3><p>在之前的内容中，我们认识了一些神经网络，比如：线性回归，Softmax回归，多层感知机；他们有的是整个模型，有的是一层神经网络，有的甚至只是一个单元，他们的功能以及复杂程度也各不相同，但他们都有着如下三个特征：</p>
<ul>
<li>接受一些输入</li>
<li>产生对应的输出</li>
<li>由一组可调整参数描述</li>
</ul>
<p>对于一些复杂的网络，研究讨论比层大但比整个模型小的部分很有意义，因为复杂的网络中经常有重复出现的部分，每个部分也常常有自己的功能。考虑到上面的三个特征，这就使得我们思考是否可以对这些部分进行一个抽象，这就得到了块的概念：块指单个层，多个层组成的部分，或者整个模型本身。使用块对整个模型进行描述就简便许多，这一过程是递归的，块的内部还可以划分为多个块，直至满足需要为止。</p>
<p>PyTorch帮我们实现了块的大部分所需功能，包括自动求导，我们只需从nn.Module继承并改写其中的一部分就能得到我们需要的块以及模型，具体做法和细节见代码中的注释</p>
<h3 id="参数管理"><a href="#参数管理" class="headerlink" title="参数管理"></a>参数管理</h3><p>在选择了架构并设置了超参数后，我们就进入了训练阶段。此时，我们的目标是找到使损失函数最小化的模型参数值。经过训练后，我们将需要使用这些参数来做出未来的预测。此外，有时我们希望提取参数，以便在其他环境中复用它们，将模型保存下来，以便它可以在其他软件中执行，或者为了获得科学的理解而进行检查。</p>
<p>此部分主要为代码实现，笔记见代码中的注释</p>
<h3 id="延后初始化"><a href="#延后初始化" class="headerlink" title="延后初始化"></a>延后初始化</h3><p>有时在建立网络时，我们不会指定网络的输入输出维度，也就不能确定网络的参数形状，深度学习框架支持延后初始化，即当第一次将数据传入模型时自动的得到所有的维度，然后初始化所有的参数。</p>
<p>PyTorch也支持这一点，比如nn.LazyLinear，但本门课程中并未介绍。</p>
<h3 id="自定义层"><a href="#自定义层" class="headerlink" title="自定义层"></a>自定义层</h3><p>深度学习成功背后的一个因素是神经网络的灵活性：我们可以用创造性的方式组合不同的层，从而设计出适用于各种任务的架构。例如，研究人员发明了专门用于处理图像、文本、序列数据和执行动态规划的层。同样的，对于层而言，深度学习框架并不能满足我们所有的需求，然而，层本身也具有极大的灵活性，我们可以自定义想要的层。</p>
<p>此部分主要为代码实现，笔记见代码中的注释</p>
<h3 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h3><p>到目前为止，我们讨论了如何处理数据，以及如何构建、训练和测试深度学习模型。然而，有时我们希望保存训练的模型，以备将来在各种环境中使用（比如在部署中进行预测）。此外，当运行一个耗时较长的训练过程时，最佳的做法是定期保存中间结果，以确保在服务器电源被不小心断掉时，我们不会损失几天的计算结果。</p>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>17-使用和购买GPU</title>
    <url>/2024/04/23/11-01-17/</url>
    <content><![CDATA[<h2 id="使用和购买GPU"><a href="#使用和购买GPU" class="headerlink" title="使用和购买GPU"></a>使用和购买GPU</h2><h3 id="使用GPU"><a href="#使用GPU" class="headerlink" title="使用GPU"></a>使用GPU</h3><p>（简而言之，自2000年以来，GPU性能每10年增长1000倍，本节主要介绍如何利用这种计算性能进行研究，首先是使用单个GPU，然后是如何使用多个GPU和多个服务器）</p>
<ul>
<li><p>准备：</p>
<ul>
<li><p>（首先确保至少安装了一个NVDIA GPU，然后下载<a href="https://developer.nvidia.com/cuda-downloads">NVIDIA驱动和CUDA</a>并按照提示设置适当的路径）</p>
</li>
<li><p>查看显卡信息：        </p>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">!nvidia-smi</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Fri Jan <span class="number">14</span> 03:<span class="number">23</span>:<span class="number">18</span> <span class="number">2022</span></span><br><span class="line">+-----------------------------------------------------------------------------+</span><br><span class="line">| NVIDIA-SMI <span class="number">418.67</span>       Driver Version: <span class="number">418.67</span>       CUDA Version: <span class="number">10.1</span>     |</span><br><span class="line">|-------------------------------+----------------------+----------------------+</span><br><span class="line">| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |</span><br><span class="line">| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |</span><br><span class="line">|===============================+======================+======================|</span><br><span class="line">|   <span class="number">0</span>  Tesla V100-SXM2...  Off  | <span class="number">00000000</span>:<span class="number">00</span>:1B<span class="number">.0</span> Off |                    <span class="number">0</span> |</span><br><span class="line">| N/A   43C    P0    74W / 300W |   1608MiB / 16130MiB |      <span class="number">0</span>%      Default |</span><br><span class="line">+-------------------------------+----------------------+----------------------+</span><br><span class="line">|   <span class="number">1</span>  Tesla V100-SXM2...  Off  | <span class="number">00000000</span>:<span class="number">00</span>:1C<span class="number">.0</span> Off |                    <span class="number">0</span> |</span><br><span class="line">| N/A   42C    P0    62W / 300W |   1706MiB / 16130MiB |      <span class="number">9</span>%      Default |</span><br><span class="line">+-------------------------------+----------------------+----------------------+</span><br><span class="line">|   <span class="number">2</span>  Tesla V100-SXM2...  Off  | <span class="number">00000000</span>:<span class="number">00</span>:1D<span class="number">.0</span> Off |                    <span class="number">0</span> |</span><br><span class="line">| N/A   64C    P0    68W / 300W |     11MiB / 16130MiB |      <span class="number">0</span>%      Default |</span><br><span class="line">+-------------------------------+----------------------+----------------------+</span><br><span class="line">|   <span class="number">3</span>  Tesla V100-SXM2...  Off  | <span class="number">00000000</span>:<span class="number">00</span>:1E<span class="number">.0</span> Off |                    <span class="number">0</span> |</span><br><span class="line">| N/A   57C    P0    45W / 300W |     11MiB / 16130MiB |      <span class="number">0</span>%      Default |</span><br><span class="line">+-------------------------------+----------------------+----------------------+</span><br><span class="line"></span><br><span class="line">+-----------------------------------------------------------------------------+</span><br><span class="line">| Processes:                                                       GPU Memory |</span><br><span class="line">|  GPU       PID   <span class="type">Type</span>   Process name                             Usage      |</span><br><span class="line">|=============================================================================|</span><br><span class="line">|    <span class="number">0</span>      <span class="number">5034</span>      C   ...conda3/envs/d2l-en-release-<span class="number">0</span>/<span class="built_in">bin</span>/python  1597MiB |</span><br><span class="line">|    <span class="number">1</span>      <span class="number">5034</span>      C   ...conda3/envs/d2l-en-release-<span class="number">0</span>/<span class="built_in">bin</span>/python  1695MiB |</span><br></pre></td></tr></table></figure>
<p>（可以看到这里显示有4块Tesla V100的GPU，Memory-Usage显示的是“当前使用空间 / 总空间”，GPU-Util显示的是模型训练时GPU的使用率，如果为50%以下说明模型可能不太好）</p>
<ul>
<li><p>准备（续）：</p>
<ul>
<li>在PyTorch中，每个数组都有一个设备（device）， 我们通常将其称为上下文（context）。 默认情况下，所有变量和相关的计算都分配给CPU。 有时上下文可能是GPU。 当我们跨多个服务器部署作业时，事情会变得更加棘手。 通过智能地将数组分配给上下文， 我们可以最大限度地减少在设备之间传输数据的时间。 例如，当在带有GPU的服务器上训练神经网络时， 我们通常希望模型的参数在GPU上。</li>
<li>要运行此部分中的程序，至少需要两个GPU。 注意，对于大多数桌面计算机来说，这可能是奢侈的，但在云中很容易获得。 例如，你可以使用AWS EC2的多GPU实例。 本书的其他章节大都不需要多个GPU， 而本节只是为了展示数据如何在不同的设备之间传递。</li>
</ul>
</li>
<li><p>计算设备：</p>
<ul>
<li><p>我们可以指定用于存储和计算的设备，如CPU和GPU。 默认情况下，张量是在内存中创建的，然后使用CPU计算它。所有的深度学习框架都是默认在CPU上做运算，如果要使用GPU则需要指定计算机更换运算位置 。</p>
</li>
<li><p>在PyTorch中，CPU和GPU可以用<code>torch.device(&#39;cpu&#39;)</code> 和<code>torch.device(&#39;cuda&#39;)</code>表示。</p>
</li>
<li><p><code>cpu</code>设备意味着所有物理CPU和内存， 这意味着PyTorch的计算将尝试使用所有CPU核心。 然而，<code>gpu</code>设备只代表一个卡和相应的显存。 </p>
</li>
<li><p>如果有多个GPU，我们使用<code>torch.device(f&#39;cuda:&#123;i&#125;&#39;)</code> 来表示第<em>i</em>块GPU（<em>i</em>从0开始）。 另外，<code>cuda:0</code>和<code>cuda</code>是等价的。</p>
</li>
<li><p>```python<br>import torch<br>from torch import nn</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```python</span><br><span class="line">  &quot;&quot;&quot;指定cpu, gpu设备&quot;&quot;&quot;</span><br><span class="line">  torch.device(&#x27;cpu&#x27;), torch.device(&#x27;cuda&#x27;), torch.device(&#x27;cuda:1&#x27;)</span><br><span class="line">  # cpu, gpu0, gpu1</span><br><span class="line">  </span><br><span class="line">  &quot;&quot;&quot;</span><br><span class="line">  输出:</span><br><span class="line">  (device(type=&#x27;cpu&#x27;), device(type=&#x27;cuda&#x27;), device(type=&#x27;cuda&#x27;, index=1))</span><br><span class="line">  &quot;&quot;&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>```python<br>“””查询可用gpu数量”””<br>torch.cuda.device_count()</p>
<p>“””<br>输出:<br>2<br>“””</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```python</span><br><span class="line">  &quot;&quot;&quot;定义了两个方便的函数， 这两个函数允许我们在不存在所需所有GPU的情况下运行代码&quot;&quot;&quot;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  &quot;&quot;&quot;如果存在，则返回gpu(i)，否则返回cpu()&quot;&quot;&quot;</span><br><span class="line">  def try_gpu(i=0):</span><br><span class="line">  # 不输入参数则默认i = 0 </span><br><span class="line">      if torch.cuda.device_count() &gt;= i + 1:</span><br><span class="line">          return torch.device(f&#x27;cuda:&#123;i&#125;&#x27;)</span><br><span class="line">       # 如果当前可用gpu的总数大于等于i+1，则返回第i个gpu（从0计数）		</span><br><span class="line">      return torch.device(&#x27;cpu&#x27;)</span><br><span class="line">  	# 否则证明当前没有更多可用gpu，则返回cpu</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  &quot;&quot;&quot;返回所有可用的GPU，如果没有GPU，则返回[cpu(),]&quot;&quot;&quot;</span><br><span class="line">  def try_all_gpus():</span><br><span class="line">      devices = [torch.device(f&#x27;cuda:&#123;i&#125;&#x27;)</span><br><span class="line">               for i in range(torch.cuda.device_count())]</span><br><span class="line">      # 所有可用gpu设备序号组成的列表devices</span><br><span class="line">      </span><br><span class="line">      return devices if devices else [torch.device(&#x27;cpu&#x27;)]</span><br><span class="line">  	# 如果列表devices不为空则证明此时有可用的gpu，则返回可用gpu序号列表；否则证明没有可用gpu，则返回cpu</span><br><span class="line">  </span><br><span class="line">  try_gpu(), try_gpu(10), try_all_gpus()</span><br><span class="line">  # 测试函数功能</span><br><span class="line">  # try_gpu():检测是否有第i=0号gpu</span><br><span class="line">  # try_gpu(10):检测是否有第i=10号gpu</span><br><span class="line">  # try_all_gpus():返回所有可用gpu序号列表，如果没有gpu则返回cpu</span><br><span class="line">  </span><br><span class="line">  &quot;&quot;&quot;</span><br><span class="line">  输出：</span><br><span class="line">  (device(type=&#x27;cuda&#x27;, index=0),</span><br><span class="line">   device(type=&#x27;cpu&#x27;),</span><br><span class="line">   [device(type=&#x27;cuda&#x27;, index=0), device(type=&#x27;cuda&#x27;, index=1)])</span><br><span class="line">  &quot;&quot;&quot;</span><br><span class="line">  </span><br><span class="line">  # device(type=&#x27;cuda&#x27;, index=0): 有第0号gpu</span><br><span class="line">  # device(type=&#x27;cpu&#x27;): 没有第10号gpu</span><br><span class="line">  # [device(type=&#x27;cuda&#x27;, index=0), device(type=&#x27;cuda&#x27;, index=1)]: 共有序号为0、1的两个gpu</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>张量与GPU</p>
<ul>
<li><p>```python<br>“””我们可以查询张量所在的设备。 默认情况下，张量是在CPU上创建的。”””<br>x = torch.tensor([1, 2, 3])<br>x.device</p>
<p>“””<br>device(type=’cpu’)<br>“””</p>
<h1 id="默认情况下，张量是在CPU上创建的"><a href="#默认情况下，张量是在CPU上创建的" class="headerlink" title="默认情况下，张量是在CPU上创建的"></a>默认情况下，张量是在CPU上创建的</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 注意：无论何时我们要对多个项进行操作， 它们都必须在同一个设备上。 例如，如果我们对两个张量求和， 我们需要确保两个张量都位于同一个设备上， 否则框架将不知道在哪里存储结果，甚至不知道在哪里执行计算。</span><br><span class="line"></span><br><span class="line">- 存储在GPU上：</span><br><span class="line"></span><br><span class="line">  ```python</span><br><span class="line">  &quot;&quot;&quot;我们在第一个gpu上创建张量变量X&quot;&quot;&quot; </span><br><span class="line">  X = torch.ones(2, 3, device=try_gpu())</span><br><span class="line">  &quot;&quot;&quot;</span><br><span class="line">  tensor([[1., 1., 1.],</span><br><span class="line">          [1., 1., 1.]], device=&#x27;cuda:0&#x27;)</span><br><span class="line">  &quot;&quot;&quot;</span><br><span class="line">  </span><br><span class="line">  &quot;&quot;&quot;假设你至少有两个GPU，下面的代码将在第二个GPU上创建一个随机张量&quot;&quot;&quot;</span><br><span class="line">  Y = torch.rand(2, 3, device=try_gpu(1))</span><br><span class="line">  &quot;&quot;&quot;</span><br><span class="line">  tensor([[0.3432, 0.4088, 0.7725],</span><br><span class="line">          [0.0571, 0.3341, 0.2544]], device=&#x27;cuda:1&#x27;)</span><br><span class="line">  &quot;&quot;&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>复制：如果我们要计算<code>X + Y</code>，我们需要决定在哪里执行这个操作。 例如，如下图所示， 我们可以将<code>X</code>传输到第二个GPU并在那里执行操作。 <em>不要</em>简单地<code>X</code>加上<code>Y</code>，因为这会导致异常， 运行时引擎不知道该怎么做：它在同一设备上找不到数据会导致失败。 由于<code>Y</code>位于第二个GPU上，所以我们需要将<code>X</code>移到那里， 然后才能执行相加运算。</p>
<img src="/2024/04/23/11-01-17/17-01.png" class="">
</li>
</ul>
</li>
</ul>
<ul>
<li><p>```python<br>“””将gpu(0)中的X复制到gpu(1)中的Z”””<br>Z = X.cuda(1)<br>print(X)<br>print(Z)</p>
<p>“””<br>tensor([[1., 1., 1.],</p>
<pre><code>    [1., 1., 1.]], device=&#39;cuda:0&#39;)
</code></pre><p>tensor([[1., 1., 1.],</p>
<pre><code>    [1., 1., 1.]], device=&#39;cuda:1&#39;)
</code></pre><p>“””</p>
</li>
</ul>
<pre><code>&quot;&quot;&quot;现在数据在同一个GPU上（Z和Y都在），我们可以将它们相加。&quot;&quot;&quot;
Y + Z

&quot;&quot;&quot;
tensor([[1.3432, 1.4088, 1.7725],
        [1.0571, 1.3341, 1.2544]], device=&#39;cuda:1&#39;)
&quot;&quot;&quot;


&quot;&quot;&quot;如果变量Z已经存在于第i个GPU上，再调用Z.cuda(i)只会返回Z并不会复制并分配新内存&quot;&quot;&quot;
Z.cuda(1) is Z

&quot;&quot;&quot;
True
&quot;&quot;&quot;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - 旁注：人们使用GPU来进行机器学习，因为单个GPU相对运行速度快。 但是在设备（CPU、GPU和其他机器）之间传输数据比计算慢得多。 这也使得并行化变得更加困难，因为我们必须等待数据被发送（或者接收）， 然后才能继续进行更多的操作。 这就是为什么拷贝操作要格外小心。根据经验，多个小操作比一个大操作糟糕得多。 此外，一次执行几个操作比代码中散布的许多单个操作要好得多（除非你确信自己在做什么）。 如果一个设备必须等待另一个设备才能执行其他操作， 那么这样的操作可能会阻塞。 这有点像排队订购咖啡，而不像通过电话预先订购： 当你到店的时候，咖啡已经准备好了。当我们打印张量或将张量转换为NumPy格式时， 如果数据不在内存中，框架会首先将其复制到内存中， 这会导致额外的传输开销。 更糟糕的是，它现在受制于全局解释器锁，使得一切都得等待Python完成。				</span><br><span class="line"></span><br><span class="line">- 神经网络与GPU</span><br><span class="line"></span><br><span class="line">  - 类似地，神经网络模型可以指定设备。 下面的代码将模型参数放在GPU上。</span><br><span class="line"></span><br><span class="line">    ```python</span><br><span class="line">    net = nn.Sequential(nn.Linear(3, 1))</span><br><span class="line">    net = net.to(device=try_gpu())</span><br></pre></td></tr></table></figure>
</code></pre><ul>
<li><p>当输入为GPU上的张量时，模型将在同一GPU上计算结果。总之，只要所有的数据和参数都在同一个设备上， 我们就可以有效地学习模型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">net(X)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([[0.5037],</span></span><br><span class="line"><span class="string">        [0.5037]], device=&#x27;cuda:0&#x27;, grad_fn=&lt;AddmmBackward&gt;)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">net[<span class="number">0</span>].weight.data.device</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">device(type=&#x27;cuda&#x27;, index=0)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="购买GPU"><a href="#购买GPU" class="headerlink" title="购买GPU"></a>购买GPU</h3><p>目前，AMD和NVIDIA是专用GPU的两大主要制造商。NVIDIA是第一个进入深度学习领域的公司，通过CUDA为深度学习框架提供更好的支持。因此，大多数买家选择NVIDIA GPU。</p>
<p>NVIDIA提供两种类型的GPU，针对个人用户（例如，通过GTX和RTX系列）和企业用户（通过其Tesla系列）。这两种类型的GPU提供了相当的计算能力。但是，企业用户GPU通常使用强制（被动）冷却、更多内存和ECC（纠错）内存。这些GPU更适用于数据中心，通常成本是消费者GPU的十倍。</p>
<p>如果你是一个拥有100个服务器的大公司，你应该考虑英伟达Tesla系列，或者在云中使用GPU服务器。对于实验室或10+服务器的中小型公司，英伟达RTX系列可能是最具成本效益的。你可以购买超微或华硕机箱的预配置服务器，这些服务器可以有效地容纳4-8个GPU。</p>
<p>GPU供应商通常每一到两年发布一代，例如2017年发布的GTX 1000（Pascal）系列和2019年发布的RTX 2000（Turing）系列。每个系列都提供几种不同的型号，提供不同的性能级别。GPU性能主要是以下三个参数的组合：</p>
<ol>
<li><strong>计算能力</strong>。通常我们追求32位浮点计算能力。16位浮点训练（FP16）也进入主流。如果你只对预测感兴趣，还可以使用8位整数。最新一代图灵GPU提供4-bit加速。不幸的是，目前训练低精度网络的算法还没有普及。</li>
<li><strong>内存大小</strong>。随着你的模型变大或训练期间使用的批量变大，你将需要更多的GPU内存。检查HBM2（高带宽内存）与GDDR6（图形DDR）内存。HBM2速度更快，但成本更高。</li>
<li><strong>内存带宽</strong>。只有当你有足够的内存带宽时，你才能最大限度地利用你的计算能力。如果使用GDDR6，请追求宽内存总线。</li>
</ol>
<p>对于大多数用户来说，只需看看计算能力就足够了。请注意，许多GPU提供不同类型的加速。例如，NVIDIA的Tensor Cores将操作符子集的速度提高了5×</p>
<p>。确保你的库支持这一点。GPU内存应不小于4GB（8GB更好）。尽量避免将GPU也用于显示GUI（改用内置显卡）。如果无法避免，请添加额外的2GB RAM以确保安全。</p>
<p>下图比较了各种GTX 900、GTX 1000和RTX 2000系列的（GFlops）和价格（Price）。价格是维基百科上的建议价格。</p>
<img src="/2024/04/23/11-01-17/17-02.png" class="">
<p>我们可以看到很多事情：</p>
<ol>
<li>在每个系列中，价格和性能大致成比例。Titan因拥有大GPU内存而有相当的溢价。然而，通过比较980 Ti和1080 Ti可以看出，较新型号具有更好的成本效益。RTX 2000系列的价格似乎没有多大提高。然而，它们提供了更优秀的低精度性能（FP16、INT8和INT4）。</li>
<li>GTX 1000系列的性价比大约是900系列的两倍。</li>
<li>对于RTX 2000系列，浮点计算能力是价格的“仿射”函数。</li>
</ol>
<img src="/2024/04/23/11-01-17/17-03.png" class="">
<p>上图显示了能耗与计算量基本成线性关系。其次，后一代更有效率。这似乎与对应于RTX 2000系列的图表相矛盾。然而，这是TensorCore不成比例的大能耗的结果。</p>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>18-预测房价竞赛总结</title>
    <url>/2024/04/23/11-01-18/</url>
    <content><![CDATA[<h2 id="18-预测房价竞赛总结"><a href="#18-预测房价竞赛总结" class="headerlink" title="18-预测房价竞赛总结"></a>18-预测房价竞赛总结</h2><h3 id="1-方法总结"><a href="#1-方法总结" class="headerlink" title="1.方法总结"></a>1.方法总结</h3><blockquote>
<p>下面提供了排行榜前几使用的方法介绍链接</p>
</blockquote>
<ul>
<li><p>第二和第七：autogluon</p>
<p><a href="https://www.bilibili.com/video/BV1rh411m7Hb/">https://www.bilibili.com/video/BV1rh411m7Hb/</a></p>
</li>
<li><p>第三：h2o</p>
<p><a href="https://www.kaggle.com/wuwawa/automl-using-h2o">https://www.kaggle.com/wuwawa/automl-using-h2o</a></p>
</li>
<li><p>第四：随机森林</p>
<p><a href="https://www.kaggle.com/jackzh/the-4th-place-approach-random-forest">https://www.kaggle.com/jackzh/the-4th-place-approach-random-forest</a></p>
</li>
</ul>
<h3 id="2-分析"><a href="#2-分析" class="headerlink" title="2.分析"></a>2.分析</h3><ul>
<li><p>已知的排名靠前的4个成绩均使用了集成学习</p>
</li>
<li><p>目前不知道是否有使用书中的mlp取得好成绩</p>
<blockquote>
<p>通过调参数，是能够取得很好的结果的</p>
</blockquote>
<p> 对于mlp来说，特征预处理和超参数的调节是取得好成绩的基础</p>
</li>
<li><p>数据的难点</p>
<ul>
<li><p>数值较大</p>
<blockquote>
<p>梯度相对较大，容易发生梯度爆炸</p>
</blockquote>
<p>一个解决方案是可以对数据取对数，再进行标准化</p>
</li>
<li><p>有文本特征（地址，介绍）</p>
<blockquote>
<p>这些文字可能含有较多的噪声，对模型产生影响</p>
</blockquote>
<p>解决办法日后会讲解，比如第二名用的transformer</p>
</li>
<li><p>训练数据是前6个月，公榜是后3个月，私榜是再往后3个月</p>
<blockquote>
<p>利用历史的数据进行训练，在实践中自然会有不同的影响（可能过拟合）</p>
<p>因此公榜与私榜的排名有一定差异</p>
</blockquote>
<pre><code>       这个问题称为Covariate Shift，没有特别好的解决方案  ，可以让模型尽可能稳定，不去仔细调参
</code></pre></li>
</ul>
</li>
</ul>
<h3 id="3-关于automl"><a href="#3-关于automl" class="headerlink" title="3.关于automl"></a>3.关于automl</h3><h4 id="3-1-课程内容"><a href="#3-1-课程内容" class="headerlink" title="3.1 课程内容"></a>3.1 课程内容</h4><blockquote>
<p>这一部分李沐老师要表达的主要是我们应该深入去了解本后的原理，不要因为有”自动化”深度学习而产生一种依赖心理或者变得没有深究深度学习的动力，学习deep learning仍然是有意义的</p>
</blockquote>
<ul>
<li><p>数据科学家80%时间在处理数据，20%调模型</p>
<blockquote>
<p>处理数据是automl不能做的，automl的作用主要在调模型这块，数据科学家仍然能大展身手</p>
</blockquote>
</li>
<li><p>Automl现在能处理一些基础的情况</p>
<blockquote>
<p>目前节省10%时间，未来节省20%时间</p>
</blockquote>
</li>
<li><p>为什么还要学习深度学习</p>
<p>正如买菜只需要用到四则运算甚至不用，我们仍然需要学习三角函数去进行更深入的科学研究等其他事情。当人人都会用Automl的时候，我们仍然需要懂得一些底层的原理，毕竟Automl也是有局限性的，需要我们不断改进，或者想出其他算法。另一方面，我们也要肯定Automl带来的便利。</p>
</li>
</ul>
<h4 id="3-2-补充内容"><a href="#3-2-补充内容" class="headerlink" title="3.2 补充内容"></a>3.2 补充内容</h4><h5 id="AutoGluon"><a href="#AutoGluon" class="headerlink" title="AutoGluon"></a>AutoGluon</h5><blockquote>
<p>与大部分automl框架是基于超参数搜索技术的不同，Autogluon会利用多个机器学习包来训练模型</p>
</blockquote>
<ul>
<li><p>房价预测竞赛中模型的改动</p>
<blockquote>
<p>1.对于数据中数值比较大且数据变化大的数值取log,CPU上训练2个小时，最终排第七</p>
<p>2.房子描述里包含大量文本，使用mutimodal选项来用transformer提取特征，并做多模型融合,用GPU才跑得动，排名第二</p>
</blockquote>
</li>
<li><p>AutoGluon背后的技术</p>
<blockquote>
<p>1.stacking</p>
<p>2.k-则交叉bagging</p>
<p>3.多层stacking</p>
</blockquote>
</li>
<li><p>总结</p>
<blockquote>
<p>1.autogluon在合理的计算开销下得到还不错的模型</p>
<p>2.虽然autogluon可以做自动特征抽取，但是当加入一些人工数据处理也是不错的方法</p>
<p>3.对于比较大的数据集计算开销仍然是瓶颈，需要使用GPU甚至多台机器做分布式训练，这仍是AutoML未来的研究方向</p>
<p>4.具体讲解可参考：<a href="https://www.bilibili.com/video/BV1F84y1F7Ps/?spm_id_from=333.788.recommend_more_video.1">https://www.bilibili.com/video/BV1F84y1F7Ps/?spm_id_from=333.788.recommend_more_video.1</a></p>
</blockquote>
</li>
</ul>
<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h3><p>这节课本身就是一次对预测房价竞赛的总结，主要介绍了排名的分布情况以及一些队伍使用的方法。</p>
<h3 id="5-预测房价竞赛总结-Q-amp-A"><a href="#5-预测房价竞赛总结-Q-amp-A" class="headerlink" title="5.预测房价竞赛总结 Q&amp;A"></a>5.预测房价竞赛总结 Q&amp;A</h3><p><strong>Q1: 统计学专业本科生未来从事人工智能如何规划</strong></p>
<blockquote>
<p>注重动手能力的培养</p>
</blockquote>
<p><strong>Q2: 避免overfit是调参好还是不调参好？老师有何经验分享？</strong></p>
<blockquote>
<p>调参是需要的，首先最好有一个比较好的验证集；当你找到一个在验证集效果比较好的超参数值的时候，最好在这一值上调或下调一点看看是否敏感，如果比较敏感说明这点可能只是在这点凑巧效果好罢了，泛化性就不好；当然在实践中调参并没有像在竞赛中那么重要</p>
</blockquote>
<p><strong>Q3: 老师说的80%时间处理数据是指的找数据、清理数据这些？数据搭建pipeline不就好了， ？为什么改进模型等等不占主要时间？</strong></p>
<blockquote>
<p>处理数据并不是搭建pipeline就好了，你需要决定从哪里获取数据、怎样获取数据、如何处理噪音（清理数据）……这些都是很费时间的</p>
</blockquote>
<p><strong>Q4: AutoML与ML有严格的特征区别吗</strong></p>
<blockquote>
<p>AutoML可以看作是ML中的一类算法</p>
</blockquote>
<p><strong>Q5: 用mlp做竞赛时发现层数深的时候预测出来的房价全是一样的，层数浅一点还不会出现这个问题，为什么？</strong></p>
<blockquote>
<p>应该是梯度爆炸，或者梯度消失，也就是数值稳定性出现问题</p>
</blockquote>
<p><strong>Q6：MLP有值得精细调参的价值吗？</strong></p>
<blockquote>
<p>有。</p>
</blockquote>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>19-卷积层</title>
    <url>/2024/04/23/11-01-19/</url>
    <content><![CDATA[<h2 id="19-卷积层"><a href="#19-卷积层" class="headerlink" title="19-卷积层"></a>19-卷积层</h2><h4 id="本讲文字介绍部分请参考沐神在线书籍-：https-zh-v2-d2l-ai-chapter-convolutional-neural-networks-why-conv-html"><a href="#本讲文字介绍部分请参考沐神在线书籍-：https-zh-v2-d2l-ai-chapter-convolutional-neural-networks-why-conv-html" class="headerlink" title="本讲文字介绍部分请参考沐神在线书籍~：https://zh-v2.d2l.ai/chapter_convolutional-neural-networks/why-conv.html"></a>本讲文字介绍部分请参考沐神在线书籍~：<a href="https://zh-v2.d2l.ai/chapter_convolutional-neural-networks/why-conv.html">https://zh-v2.d2l.ai/chapter_convolutional-neural-networks/why-conv.html</a></h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">corr2d</span>(<span class="params">X,K</span>):    <span class="comment">#X为输入，K为核矩阵</span></span><br><span class="line">    h,w=K.shape    <span class="comment">#h得到K的行数，w得到K的列数</span></span><br><span class="line">    Y=torch.zeros((X.shape[<span class="number">0</span>]-h+<span class="number">1</span>,X.shape[<span class="number">1</span>]-w+<span class="number">1</span>))  <span class="comment">#用0初始化输出矩阵Y</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(Y.shape[<span class="number">0</span>]):   <span class="comment">#卷积运算</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(Y.shape[<span class="number">1</span>]):</span><br><span class="line">          Y[i,j]=(X[i:i+h,j:j+w]*K).<span class="built_in">sum</span>()</span><br><span class="line">    <span class="keyword">return</span> Y</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#样例点测试</span></span><br><span class="line">X=torch.tensor([[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]])</span><br><span class="line">K=torch.tensor([[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">3</span>]])</span><br><span class="line">corr2d(X,K)</span><br></pre></td></tr></table></figure>
<pre><code>&gt;&gt;&gt; tensor([[19., 25.],
            [37., 43.]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#实现二维卷积层</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Conv2d</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_init_</span>(<span class="params">self,kernel_size</span>):</span><br><span class="line">        <span class="built_in">super</span>()._init_()</span><br><span class="line">        self.weight=nn.Parameter(torch.rand(kerner_size))</span><br><span class="line">        self.bias=nn.Parameter(torch.zeros(<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,x</span>):</span><br><span class="line">        <span class="keyword">return</span> corr2d(x,self.weight)+self.bias </span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X=torch.ones((<span class="number">6</span>,<span class="number">8</span>))</span><br><span class="line">X[:,<span class="number">2</span>:<span class="number">6</span>]=<span class="number">0</span></span><br><span class="line">X</span><br></pre></td></tr></table></figure>
<pre><code>&gt;&gt;&gt; tensor([[1., 1., 0., 0., 0., 0., 1., 1.],
        [1., 1., 0., 0., 0., 0., 1., 1.],
        [1., 1., 0., 0., 0., 0., 1., 1.],
        [1., 1., 0., 0., 0., 0., 1., 1.],
        [1., 1., 0., 0., 0., 0., 1., 1.],
        [1., 1., 0., 0., 0., 0., 1., 1.]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">K=torch.tensor([[-<span class="number">1</span>,<span class="number">1</span>]])  <span class="comment">#这个K只能检测垂直边缘</span></span><br><span class="line">Y=corr2d(X,K)</span><br><span class="line">Y</span><br></pre></td></tr></table></figure>
<pre><code>&gt;&gt;&gt; tensor([[ 0., -1.,  0.,  0.,  0.,  1.,  0.],
            [ 0., -1.,  0.,  0.,  0.,  1.,  0.],
            [ 0., -1.,  0.,  0.,  0.,  1.,  0.],
            [ 0., -1.,  0.,  0.,  0.,  1.,  0.],
            [ 0., -1.,  0.,  0.,  0.,  1.,  0.],
            [ 0., -1.,  0.,  0.,  0.,  1.,  0.]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">corr2d(X.t(),K)</span><br></pre></td></tr></table></figure>
<pre><code>&gt;&gt;&gt; tensor([[0., 0., 0., 0., 0.],
            [0., 0., 0., 0., 0.],
            [0., 0., 0., 0., 0.],
            [0., 0., 0., 0., 0.],
            [0., 0., 0., 0., 0.],
            [0., 0., 0., 0., 0.],
            [0., 0., 0., 0., 0.],
            [0., 0., 0., 0., 0.]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conv2d = nn.Conv2d(<span class="number">1</span>, <span class="number">1</span>, kernel_size=(<span class="number">1</span>, <span class="number">2</span>), bias=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">X = X.reshape((<span class="number">1</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">8</span>))</span><br><span class="line">Y = Y.reshape((<span class="number">1</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">7</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    Y_hat = conv2d(X)</span><br><span class="line">    l = (Y_hat - Y)**<span class="number">2</span></span><br><span class="line">    conv2d.zero_grad()</span><br><span class="line">    l.<span class="built_in">sum</span>().backward()</span><br><span class="line">    conv2d.weight.data[:] -= <span class="number">3e-2</span> * conv2d.weight.grad</span><br><span class="line">    <span class="keyword">if</span> (i + <span class="number">1</span>) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;batch <span class="subst">&#123;i+<span class="number">1</span>&#125;</span>, loss <span class="subst">&#123;l.<span class="built_in">sum</span>():<span class="number">.3</span>f&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>&gt;&gt;&gt; batch 2, loss 3.852
    batch 4, loss 1.126
    batch 6, loss 0.386
    batch 8, loss 0.145
    batch 10, loss 0.057
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conv2d.weight.data.reshape((<span class="number">1</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<pre><code>&gt;&gt;&gt; tensor([[-1.0173,  0.9685]])
</code></pre>]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>11-模型选择+过拟合和欠拟合</title>
    <url>/2024/04/23/11-01-11/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.04.24：初稿</li>
</ul>
<h2 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h2><ul>
<li><a href="/2024/04/24/12-18-34/" title="动手学深度学习笔记汇总">动手学深度学习笔记汇总</a>
</li>
</ul>
<h2 id="11-模型选择-过拟合和欠拟合"><a href="#11-模型选择-过拟合和欠拟合" class="headerlink" title="11-模型选择+过拟合和欠拟合"></a>11-模型选择+过拟合和欠拟合</h2><h3 id="1-模型选择"><a href="#1-模型选择" class="headerlink" title="1. 模型选择"></a>1. 模型选择</h3><p>本小节主要介绍了评估模型的一些指标和方法</p>
<h4 id="1-1-实例分析：预测谁会偿还贷款"><a href="#1-1-实例分析：预测谁会偿还贷款" class="headerlink" title="1.1 实例分析：预测谁会偿还贷款"></a>1.1 实例分析：预测谁会偿还贷款</h4><ul>
<li>银行雇你来调查谁会偿还贷款，你得到了100个申请人的信息，其中五个人在3年内违约了。然后你惊讶的发现，<strong>所有的五个人在面试时都穿了蓝色衬衫</strong>。显然，你的模型也发现了这个强信号，这会有什么问题？</li>
</ul>
<p><strong>答案是，你的模型很有可能会认为所有来面试的人都会穿蓝色衬衫，而这当然是不对的。</strong></p>
<h4 id="1-2-训练误差和泛化误差"><a href="#1-2-训练误差和泛化误差" class="headerlink" title="1.2 训练误差和泛化误差"></a>1.2 训练误差和泛化误差</h4><ul>
<li>训练误差：模型在训练数据上的误差</li>
<li>泛化误差：模型在新数据上的误差</li>
<li><p>例子：根据模考成绩来预测未来考试分数</p>
<ul>
<li>在过去的考试中表现很好（<strong>训练误差</strong>）不代表未来会好（<strong>泛化误差</strong>）</li>
<li>学生A通过背书在模考中拿到很好成绩</li>
<li>学生B知道答案后面的原因</li>
</ul>
</li>
<li><p><strong>其中，泛化误差是我们所最关心的</strong></p>
</li>
</ul>
<h4 id="1-3-验证数据集和测试数据集"><a href="#1-3-验证数据集和测试数据集" class="headerlink" title="1.3 验证数据集和测试数据集"></a>1.3 验证数据集和测试数据集</h4><ul>
<li>验证数据集：一个用来评估模型好坏的数据集<ul>
<li>例如拿出50%的训练数据</li>
<li>不要跟训练数据混在一起（常犯错误）</li>
</ul>
</li>
<li><p>测试数据集：只用一次的数据集。例如：</p>
<ul>
<li>未来的考试</li>
<li>我出价的房子的实际成交价</li>
<li>用在kaggle私有排行榜中的数据集</li>
</ul>
</li>
<li><p><strong>二者最大的区别就是，验证数据集可以那来用很多次，相当于平时的模拟考，而测试数据集则只能用一次来评估模型的性能，相当于最终的考试。</strong></p>
</li>
</ul>
<h4 id="1-4-K-则交叉验证"><a href="#1-4-K-则交叉验证" class="headerlink" title="1.4 K-则交叉验证"></a>1.4 K-则交叉验证</h4><ul>
<li>在没有足够多数据时使用（这是常态）</li>
<li>算法：<ul>
<li>将训练数据分割k块</li>
<li>For i = 1，……，k<ul>
<li>使用第i块作为验证数据集，其余的作为训练数据集</li>
</ul>
</li>
<li>报告k个验证集误差的平均</li>
</ul>
</li>
<li>常用：k = 5或10<blockquote>
<p>随机打散，分割K块，k次计算，第i次，用第i块作为验证集，剩下的作为训练数据集。这样会获得k次误差，算误差平均值。</p>
</blockquote>
</li>
<li>K-则交叉验证的目的是在没有足够多数据使用时评估模型和超参数的性能，也就是说，<strong>K次训练和验证使用的是相同的超参数和模型</strong></li>
</ul>
<h4 id="1-5-总结"><a href="#1-5-总结" class="headerlink" title="1.5 总结"></a>1.5 总结</h4><ul>
<li>训练数据集：训练模型参数</li>
<li>验证数据集：选择模型超参数,保留最好的参数</li>
<li>非大数据集上通常使用k-则交叉验证</li>
</ul>
<h3 id="2-过拟合和欠拟合"><a href="#2-过拟合和欠拟合" class="headerlink" title="2. 过拟合和欠拟合"></a>2. 过拟合和欠拟合</h3><h4 id="2-1-什么是过拟合和欠拟合？"><a href="#2-1-什么是过拟合和欠拟合？" class="headerlink" title="2.1 什么是过拟合和欠拟合？"></a>2.1 什么是过拟合和欠拟合？</h4><div class="table-container">
<table>
<thead>
<tr>
<th>模型容量\数据</th>
<th>简单</th>
<th style="text-align:center">复杂</th>
</tr>
</thead>
<tbody>
<tr>
<td>低</td>
<td>正常</td>
<td style="text-align:center">欠拟合</td>
</tr>
<tr>
<td>高</td>
<td>过拟合</td>
<td style="text-align:center">正常</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>tips：模型容量即模型的复杂度，也代表了模型拟合各种函数的能力</li>
</ul>
<h4 id="2-2-模型容量"><a href="#2-2-模型容量" class="headerlink" title="2.2 模型容量"></a>2.2 模型容量</h4><ul>
<li>拟合各种函数的能力</li>
<li>低容量的模型难以拟合训练数据</li>
<li>高容量的模型可以记住所有的训练数据</li>
</ul>
<img src="/2024/04/23/11-01-11/11-01.png" class="">
<ul>
<li>显然，模型容量太低或太高都不好。太低（对应第一种）过于简单，模型分类效果差，太高（对应第二种）则过于复杂，把噪声全部都拟合住了，这是我们所不希望的。</li>
</ul>
<h4 id="2-3-模型容量的影响"><a href="#2-3-模型容量的影响" class="headerlink" title="2.3 模型容量的影响"></a>2.3 模型容量的影响</h4><img src="/2024/04/23/11-01-11/11-02.png" class="">
<ul>
<li>我们的核心任务就是把泛化误差往下降</li>
</ul>
<h4 id="2-4-估计模型容量"><a href="#2-4-估计模型容量" class="headerlink" title="2.4 估计模型容量"></a>2.4 估计模型容量</h4><ul>
<li>难以在不同的种类算法之间比较<ul>
<li>例如树模型和神经网络</li>
</ul>
</li>
<li>给定一个模型种类，将有两个主要因素<ul>
<li>参数的个数</li>
<li>参数的选择范围</li>
</ul>
</li>
</ul>
<img src="/2024/04/23/11-01-11/11-03.png" class="">
<h4 id="2-5-VC维"><a href="#2-5-VC维" class="headerlink" title="2.5 VC维"></a>2.5 VC维</h4><p>VC维是统计学习理论的一个核心思想，这里大致了解就行，因为很难计算之后学习的模型（如CNN,RNN)的VC维，故并不经常用</p>
<ul>
<li>定义：对于一个分类模型，VC维等于一个最大的数据集的大小，不管如何给定标号，都存在一个模型对它进行完美分类。即存在H个样本，模型能把H个样本的2^H种标号方式打散的H的最大值。</li>
<li>例子：线性分类器的VC维<ul>
<li>2维输入的感知机，VC维=3（对于三个点的任意标号都能分类，而任意四个点的样本都存在不能被打散的标号形式个，如之前讲过的XOR）</li>
</ul>
</li>
</ul>
<p>3个点：</p>
<img src="/2024/04/23/11-01-11/11-04.png" class="">
<p>4个点：</p>
<img src="/2024/04/23/11-01-11/11-05.png" class="">
<ul>
<li>支持N维输入的感知机的VC维是N+1</li>
</ul>
<h4 id="2-6-VC维的用处"><a href="#2-6-VC维的用处" class="headerlink" title="2.6 VC维的用处"></a>2.6 VC维的用处</h4><ul>
<li>提供为什么一个模型好的理论依据<ul>
<li>它可以衡量训练误差和泛化误差之间的间隔</li>
</ul>
</li>
<li>但深度学习中很少使用<ul>
<li>衡量不是很准确</li>
<li>计算深度学习模型的VC维很困难</li>
</ul>
</li>
</ul>
<h4 id="2-7-数据复杂度"><a href="#2-7-数据复杂度" class="headerlink" title="2.7 数据复杂度"></a>2.7 数据复杂度</h4><ul>
<li>多个重要因素<ul>
<li>样本的元素个数</li>
<li>每个样本的元素个数</li>
<li>时间、空间结构</li>
<li>多样性</li>
</ul>
</li>
</ul>
<h4 id="2-8-总结"><a href="#2-8-总结" class="headerlink" title="2.8 总结"></a>2.8 总结</h4><ul>
<li>模型容量需要匹配数据复杂度，否则可能导致欠拟合和过拟合</li>
<li>统计机器学习提供数学工具来衡量模型复杂度</li>
<li>实际中一般考观察训练误差和验证误差</li>
</ul>
<h3 id="3-多项式回归"><a href="#3-多项式回归" class="headerlink" title="3. 多项式回归"></a>3. 多项式回归</h3><ul>
<li>本小节使用多项式回归为例子，在pytorch上展示过拟合和欠拟合的实际表现</li>
</ul>
<h4 id="3-1-导入库"><a href="#3-1-导入库" class="headerlink" title="3.1 导入库"></a>3.1 导入库</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br></pre></td></tr></table></figure>
<h4 id="3-2-生成数据集"><a href="#3-2-生成数据集" class="headerlink" title="3.2 生成数据集"></a>3.2 生成数据集</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">max_degree = <span class="number">20</span>  <span class="comment"># 多项式的最大阶数</span></span><br><span class="line">n_train, n_test = <span class="number">100</span>, <span class="number">100</span>  <span class="comment"># 训练和测试数据集大小</span></span><br><span class="line">true_w = np.zeros(max_degree)  <span class="comment"># 分配大量的空间</span></span><br><span class="line">true_w[<span class="number">0</span>:<span class="number">4</span>] = np.array([<span class="number">5</span>, <span class="number">1.2</span>, -<span class="number">3.4</span>, <span class="number">5.6</span>])<span class="comment">#前五个参数是有用的已知的参数，其他都是0，是不希望被学习的参数</span></span><br><span class="line"></span><br><span class="line">features = np.random.normal(size=(n_train + n_test, <span class="number">1</span>))<span class="comment">#创建特征值</span></span><br><span class="line">np.random.shuffle(features)<span class="comment">#打乱顺序</span></span><br><span class="line">poly_features = np.power(features, np.arange(max_degree).reshape(<span class="number">1</span>, -<span class="number">1</span>))<span class="comment">#通过广播机制得到每个特征值的所有多项式值</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(max_degree):</span><br><span class="line">    poly_features[:, i] /= math.gamma(i + <span class="number">1</span>)  <span class="comment"># gamma(n)=(n-1)!，除以gamma防止梯度过大</span></span><br><span class="line"><span class="comment"># labels的维度:(n_train+n_test,)</span></span><br><span class="line">labels = np.dot(poly_features, true_w)<span class="comment">#将对应多项式值与其系数相乘</span></span><br><span class="line">labels += np.random.normal(scale=<span class="number">0.1</span>, size=labels.shape)<span class="comment">#加上噪声项</span></span><br></pre></td></tr></table></figure>
<h4 id="3-3-NumPyndarray转换为tensor"><a href="#3-3-NumPyndarray转换为tensor" class="headerlink" title="3.3 NumPyndarray转换为tensor"></a>3.3 NumPyndarray转换为tensor</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">true_w, features, poly_features, labels = [torch.tensor(x, dtype=</span><br><span class="line">    torch.float32) <span class="keyword">for</span> x <span class="keyword">in</span> [true_w, features, poly_features, labels]]</span><br></pre></td></tr></table></figure>
<h4 id="3-4-对模型进行训练和测试"><a href="#3-4-对模型进行训练和测试" class="headerlink" title="3.4 对模型进行训练和测试"></a>3.4 对模型进行训练和测试</h4><p>首先让我们[实现一个函数来评估模型在给定数据集上的损失]。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">evaluate_loss</span>(<span class="params">net, data_iter, loss</span>):  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;评估给定数据集上模型的损失&quot;&quot;&quot;</span></span><br><span class="line">    metric = d2l.Accumulator(<span class="number">2</span>)  <span class="comment"># 损失的总和,样本数量</span></span><br><span class="line">    <span class="keyword">for</span> X, y <span class="keyword">in</span> data_iter:</span><br><span class="line">        out = net(X)<span class="comment">#预测值</span></span><br><span class="line">        y = y.reshape(out.shape)<span class="comment">#将y维度变为与out一样</span></span><br><span class="line">        l = loss(out, y)<span class="comment">#计算损失</span></span><br><span class="line">        metric.add(l.<span class="built_in">sum</span>(), l.numel())<span class="comment">#加入到迭代器中，进入下一个batch</span></span><br><span class="line">    <span class="keyword">return</span> metric[<span class="number">0</span>] / metric[<span class="number">1</span>]<span class="comment">#返回平均损失</span></span><br></pre></td></tr></table></figure>
<p>现在[定义训练函数]</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">train_features, test_features, train_labels, test_labels,</span></span><br><span class="line"><span class="params">          num_epochs=<span class="number">400</span></span>):</span><br><span class="line">    loss = nn.MSELoss()<span class="comment">#定义损失</span></span><br><span class="line">    input_shape = train_features.shape[-<span class="number">1</span>]</span><br><span class="line">    <span class="comment"># 不设置偏置，因为我们已经在多项式特征中实现了它（即x^0）</span></span><br><span class="line">    net = nn.Sequential(nn.Linear(input_shape, <span class="number">1</span>, bias=<span class="literal">False</span>))<span class="comment">#创建模型</span></span><br><span class="line">    batch_size = <span class="built_in">min</span>(<span class="number">10</span>, train_labels.shape[<span class="number">0</span>])</span><br><span class="line">    train_iter = d2l.load_array((train_features, train_labels.reshape(-<span class="number">1</span>,<span class="number">1</span>)),</span><br><span class="line">                                batch_size)<span class="comment">#训练集</span></span><br><span class="line">    test_iter = d2l.load_array((test_features, test_labels.reshape(-<span class="number">1</span>,<span class="number">1</span>)),</span><br><span class="line">                               batch_size, is_train=<span class="literal">False</span>)<span class="comment">#测试集</span></span><br><span class="line">    trainer = torch.optim.SGD(net.parameters(), lr=<span class="number">0.001</span>)<span class="comment">#设置优化器，这里使用SGD</span></span><br><span class="line">    animator = d2l.Animator(xlabel=<span class="string">&#x27;epoch&#x27;</span>, ylabel=<span class="string">&#x27;loss&#x27;</span>, yscale=<span class="string">&#x27;log&#x27;</span>,</span><br><span class="line">                            xlim=[<span class="number">1</span>, num_epochs], ylim=[<span class="number">1e-3</span>, <span class="number">1e2</span>],</span><br><span class="line">                            legend=[<span class="string">&#x27;train&#x27;</span>, <span class="string">&#x27;test&#x27;</span>])<span class="comment">#动画</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">        d2l.train_epoch_ch3(net, train_iter, loss, trainer)<span class="comment">#训练</span></span><br><span class="line">        <span class="keyword">if</span> epoch == <span class="number">0</span> <span class="keyword">or</span> (epoch + <span class="number">1</span>) % <span class="number">20</span> == <span class="number">0</span>:</span><br><span class="line">            animator.add(epoch + <span class="number">1</span>, (evaluate_loss(net, train_iter, loss),</span><br><span class="line">                                     evaluate_loss(net, test_iter, loss)))<span class="comment">#将当前的训练集和测试集的损失存入animator中，用于绘图</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;weight:&#x27;</span>, net[<span class="number">0</span>].weight.data.numpy())<span class="comment">#打印训练后的参数</span></span><br></pre></td></tr></table></figure>
<h4 id="3-5-三阶多项式函数拟合-正态"><a href="#3-5-三阶多项式函数拟合-正态" class="headerlink" title="3.5 [三阶多项式函数拟合(正态)]"></a>3.5 [<strong>三阶多项式函数拟合(正态)</strong>]</h4><p>我们将首先使用三阶多项式函数，它与数据生成函数的阶数相同。 结果表明，该模型能有效降低训练损失和测试损失。 学习到的模型参数也接近真实值𝑤=[5,1.2,−3.4,5.6]。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从多项式特征中选择前4个维度，即1,x,x^2/2!,x^3/3!</span></span><br><span class="line">train(poly_features[:n_train, :<span class="number">4</span>], poly_features[n_train:, :<span class="number">4</span>],</span><br><span class="line">      labels[:n_train], labels[n_train:])</span><br></pre></td></tr></table></figure>
<img src="/2024/04/23/11-01-11/11-06.png" class="">
<h4 id="3-6-线性函数拟合-欠拟合"><a href="#3-6-线性函数拟合-欠拟合" class="headerlink" title="3.6 [线性函数拟合(欠拟合)]"></a>3.6 [<strong>线性函数拟合(欠拟合)</strong>]</h4><p>让我们再看看线性函数拟合，减少该模型的训练损失相对困难。 在最后一个迭代周期完成后，训练损失仍然很高。 当用来拟合非线性模式（如这里的三阶多项式函数）时，线性模型容易欠拟合。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从多项式特征中选择前2个维度，即1和x</span></span><br><span class="line">train(poly_features[:n_train, :<span class="number">2</span>], poly_features[n_train:, :<span class="number">2</span>],</span><br><span class="line">      labels[:n_train], labels[n_train:])</span><br></pre></td></tr></table></figure>
<img src="/2024/04/23/11-01-11/11-07.png" class="">
<h4 id="3-7-高阶多项式函数拟合-过拟合"><a href="#3-7-高阶多项式函数拟合-过拟合" class="headerlink" title="3.7 [高阶多项式函数拟合(过拟合)]"></a>3.7 [<strong>高阶多项式函数拟合(过拟合)</strong>]</h4><p>现在，让我们尝试使用一个阶数过高的多项式来训练模型。 在这种情况下，没有足够的数据用于学到高阶系数应该具有接近于零的值。 因此，这个过于复杂的模型会轻易受到训练数据中噪声的影响。 虽然训练损失可以有效地降低，但测试损失仍然很高。 结果表明，复杂模型对数据造成了过拟合。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从多项式特征中选取所有维度</span></span><br><span class="line">train(poly_features[:n_train, :], poly_features[n_train:, :],</span><br><span class="line">      labels[:n_train], labels[n_train:], num_epochs=<span class="number">1500</span>)</span><br></pre></td></tr></table></figure>
<img src="/2024/04/23/11-01-11/11-08.png" class="">
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>21-多个输入和输出通道</title>
    <url>/2024/04/23/11-01-21/</url>
    <content><![CDATA[<h1 id="21-多个输入和输出通道"><a href="#21-多个输入和输出通道" class="headerlink" title="21-多个输入和输出通道"></a>21-多个输入和输出通道</h1><h3 id="1-多个输入通道："><a href="#1-多个输入通道：" class="headerlink" title="1.多个输入通道："></a>1.多个输入通道：</h3><ul>
<li><p>彩色图像可能有RGB三个通道</p>
</li>
<li><p>转换为灰度会丢失信息</p>
</li>
</ul>
<img src="/2024/04/23/11-01-21/21-01.png" class="">
<ul>
<li>每个通道都有一个卷积和，结果是所有通道卷积结果的和</li>
</ul>
<img src="/2024/04/23/11-01-21/21-02.png" class="">
<ul>
<li>输入<strong>X</strong>:<img src="https://latex.codecogs.com/svg.image?c_{i}\times&space;n_{h}\times&space;n_{w}" title="c_{i}\times n_{h}\times n_{w}" /></li>
<li>核<strong>W</strong>：<img src="https://latex.codecogs.com/svg.image?c_{i}\times&space;k_{h}\times&space;k_{w}" title="c_{i}\times k_{h}\times k_{w}" /></li>
<li>输出<strong>Y</strong>:<img src="https://latex.codecogs.com/svg.image?m_{h}\times&space;m_{w}" title="m_{h}\times m_{w}" /></li>
</ul>
<p><img src="https://latex.codecogs.com/svg.image?Y=\sum&space;_{i=0}^{c_{i}}X_{i,:,:}\bigstar&space;W_{i,:,:}" title="Y=\sum _{i=0}^{c_{i}}X_{i,:,:}\bigstar W_{i,:,:}" /></p>
<p>多个输入通道：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">corr2d_multi_in</span>(<span class="params">X, K</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(d2l.corr2d(x, k) <span class="keyword">for</span> x, k <span class="keyword">in</span> <span class="built_in">zip</span>(X, K))</span><br></pre></td></tr></table></figure>
<h3 id="2-多个输出通道"><a href="#2-多个输出通道" class="headerlink" title="2.多个输出通道"></a>2.多个输出通道</h3><ul>
<li>无论有多少输入通道，到目前位置我们植绒到单输出通道</li>
<li>我们可以有多个三维卷积核，每个核生成一个输出通道</li>
<li>输入<strong>X</strong>:<img src="https://latex.codecogs.com/svg.image?c_{i}\times&space;k_{h}\times&space;k_{w}" title="c_{i}\times k_{h}\times k_{w}" /></li>
<li>核<strong>W</strong>：<img src="https://latex.codecogs.com/svg.image?c_{o}\times&space;c_{i}\times&space;k_{h}\times&space;k_{w}" title="c_{o}\times c_{i}\times k_{h}\times k_{w}" /></li>
<li>输出<strong>Y</strong>：<img src="https://latex.codecogs.com/svg.image?c_{o}\times&space;m_{h}\times&space;m_{w}" title="c_{o}\times m_{h}\times m_{w}" /></li>
</ul>
<p><img src="https://latex.codecogs.com/svg.image?Y_{i,:,:}=X\bigstar&space;W_{i,:,:}\qquad&space;for&space;\quad&space;i=1,...,c_{o}" title="Y_{i,:,:}=X\bigstar W_{i,:,:}\qquad for \quad i=1,...,c_{o}" /></p>
<p>多个输出通道：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">corr2d_multi_in_out</span>(<span class="params">X, K</span>):</span><br><span class="line">    <span class="keyword">return</span> torch.stack([corr2d_multi_in(X, k) <span class="keyword">for</span> k <span class="keyword">in</span> K], <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h3 id="3-多个输入和输出通道"><a href="#3-多个输入和输出通道" class="headerlink" title="3.多个输入和输出通道"></a>3.多个输入和输出通道</h3><ul>
<li>每个通道可以识别特定的模式</li>
</ul>
<img src="/2024/04/23/11-01-21/21-03.png" class="">
<ul>
<li>输入通道核识别并组合输入中的模式</li>
</ul>
<h3 id="4-1X1卷积层"><a href="#4-1X1卷积层" class="headerlink" title="4.1X1卷积层"></a>4.1X1卷积层</h3><img src="/2024/04/23/11-01-21/21-04.png" class="">
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">corr2d_multi_in_out_1x1</span>(<span class="params">X, K</span>):</span><br><span class="line">    c_i, h, w = X.shape</span><br><span class="line">    c_o = K.shape[<span class="number">0</span>]</span><br><span class="line">    X = X.reshape((c_i, h * w))</span><br><span class="line">    K = K.reshape((c_o, c_i))</span><br><span class="line">    Y = torch.matmul(K, X)</span><br><span class="line">    <span class="keyword">return</span> Y.reshape((c_o, h, w))</span><br></pre></td></tr></table></figure>
<h3 id="5-二维卷积层"><a href="#5-二维卷积层" class="headerlink" title="5.二维卷积层"></a>5.二维卷积层</h3><img src="/2024/04/23/11-01-21/21-05.png" class="">
<h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h3><ul>
<li>输出通道数是卷积层的超参数</li>
<li>每个输入通道有独立的二维卷积和，所有通道结果相加得到一个输出通道结果</li>
<li>每个输出通道有独立的三维卷积核</li>
</ul>
<h3 id="7-Q-amp-A"><a href="#7-Q-amp-A" class="headerlink" title="7.Q&amp;A"></a>7.Q&amp;A</h3><h5 id="Q1-网络越深，Padding-0-越多，这里是否会影响性能？"><a href="#Q1-网络越深，Padding-0-越多，这里是否会影响性能？" class="headerlink" title="Q1:网络越深，Padding 0 越多，这里是否会影响性能？"></a>Q1:网络越深，Padding 0 越多，这里是否会影响性能？</h5><blockquote>
<p>这里性能分为计算性能和网络性能，Padding 0 不会影响网络精度，但会使计算复杂</p>
</blockquote>
<h5 id="Q2-计算卷积时，bias的有无对结果影响大吗？bias的作用怎么解释？"><a href="#Q2-计算卷积时，bias的有无对结果影响大吗？bias的作用怎么解释？" class="headerlink" title="Q2:计算卷积时，bias的有无对结果影响大吗？bias的作用怎么解释？"></a>Q2:计算卷积时，bias的有无对结果影响大吗？bias的作用怎么解释？</h5><blockquote>
<p>因为正则化的操作，bias对结果影响不大，但加入bias对计算性能基本无影响，故默认加入bias</p>
</blockquote>
<h5 id="Q3-如果是一个rgb图像，加上深度图，相当于是四个通道吗？"><a href="#Q3-如果是一个rgb图像，加上深度图，相当于是四个通道吗？" class="headerlink" title="Q3:如果是一个rgb图像，加上深度图，相当于是四个通道吗？"></a>Q3:如果是一个rgb图像，加上深度图，相当于是四个通道吗？</h5><blockquote>
<p>不是，输入输出通道单列，这里使用3d的卷积，输入变为4维，核是5维</p>
</blockquote>
<h5 id="Q4-怎么理解1x1卷积核不识别空间模式？"><a href="#Q4-怎么理解1x1卷积核不识别空间模式？" class="headerlink" title="Q4:怎么理解1x1卷积核不识别空间模式？"></a>Q4:怎么理解1x1卷积核不识别空间模式？</h5><blockquote>
<p>因为输出的一个像素只对应输入的一个像素，所以没有获取到空间信息</p>
</blockquote>
<h5 id="Q5-是不是可以3x3x3和1x1xN的卷积层叠加，来进行空间信息的检测和信息融合，以及输出通道的调整？"><a href="#Q5-是不是可以3x3x3和1x1xN的卷积层叠加，来进行空间信息的检测和信息融合，以及输出通道的调整？" class="headerlink" title="Q5:是不是可以3x3x3和1x1xN的卷积层叠加，来进行空间信息的检测和信息融合，以及输出通道的调整？"></a>Q5:是不是可以3x3x3和1x1xN的卷积层叠加，来进行空间信息的检测和信息融合，以及输出通道的调整？</h5><blockquote>
<p>是的，mobile net就是这种思想                                                                                                                                                                                                                                                                                 </p>
</blockquote>
<h5 id="Q6：3d卷积是处理视频问题的吧？也可以处理rgb加深度信息吗？"><a href="#Q6：3d卷积是处理视频问题的吧？也可以处理rgb加深度信息吗？" class="headerlink" title="Q6：3d卷积是处理视频问题的吧？也可以处理rgb加深度信息吗？"></a>Q6：3d卷积是处理视频问题的吧？也可以处理rgb加深度信息吗？</h5><blockquote>
<p>都可以，rgb加深度信息甚至可以用2d卷积处理。</p>
</blockquote>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>22-池化层</title>
    <url>/2024/04/23/11-01-22/</url>
    <content><![CDATA[<h1 id="池化层"><a href="#池化层" class="headerlink" title="池化层"></a>池化层</h1><p>本节将介绍<em>池化</em>（pooling）层，它具有目的：类似于数据增强，降低卷积层对位置的敏感性；一定程度减少计算。</p>
<h2 id="最大池化层和平均池化层"><a href="#最大池化层和平均池化层" class="headerlink" title="最大池化层和平均池化层"></a>最大池化层和平均池化层</h2><p>与卷积层类似，池化层运算符由一个固定形状的窗口组成，该窗口根据其步幅大小在输入的所有区域上滑动，为固定形状窗口遍历的每个位置计算一个输出。<br>然而，不同于卷积层中的输入与卷积核之间的互相关计算，<strong>池化层不包含参数</strong>。<br>相反，池运算符是确定性的，我们通常计算池化窗口中所有元素的最大值或平均值。这些操作分别称为<em>最大池化层</em>（maximum pooling）和<em>平均池化层</em>（average pooling）。</p>
<p>在这两种情况下，与互相关运算符一样，池化窗口从输入张量的左上角开始，从左往右、从上往下的在输入张量内滑动。在池化窗口到达的每个位置，它计算该窗口中输入子张量的最大值或平均值。计算最大值或平均值是取决于使用了最大池化层还是平均池化层。</p>
<p><img src="http://d2l.ai/_images/pooling.svg" alt="池化窗口形状为 $2\times 2$ 的最大池化层。着色部分是第一个输出元素，以及用于计算这个输出的输入元素: $\max(0, 1, 3, 4)=4$."><br>上图中的输出张量的高度为$2$，宽度为$2$。这四个元素为每个池化窗口中的最大值：</p>
<script type="math/tex; mode=display">
\max(0, 1, 3, 4)=4,\\
\max(1, 2, 4, 5)=5,\\
\max(3, 4, 6, 7)=7,\\
\max(4, 5, 7, 8)=8.\\</script><p>池化窗口形状为$p \times q$的池化层称为$p \times q$池化层，池化操作称为$p \times q$池化。</p>
<p>回到本节开头提到的对象边缘检测示例，现在我们将使用卷积层的输出作为$2\times 2$最大池化的输入。<br>设置卷积层输入为<code>X</code>，池化层输出为<code>Y</code>。<br>无论<code>X[i, j]</code>和<code>X[i, j + 1]</code>的值是否不同，或<code>X[i, j + 1]</code>和<code>X[i, j + 2]</code>的值是否不同，池化层始终输出<code>Y[i, j] = 1</code>。<br>也就是说，使用$2\times 2$最大池化层，即使在高度或宽度上移动一个元素，卷积层仍然可以识别到模式。</p>
<p>在下面的代码中的<code>pool2d</code>函数，我们(<strong>实现池化层的前向传播</strong>)。然而，这里我们没有卷积核，输出为输入中每个区域的最大值或平均值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pool2d</span>(<span class="params">X, pool_size, mode=<span class="string">&#x27;max&#x27;</span></span>):</span><br><span class="line">    p_h, p_w = pool_size</span><br><span class="line">    Y = torch.zeros((X.shape[<span class="number">0</span>] - p_h + <span class="number">1</span>, X.shape[<span class="number">1</span>] - p_w + <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(Y.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(Y.shape[<span class="number">1</span>]):  <span class="comment"># 枚举输出的每个位置，[i,j]对应输入的位置[i至i+p_h,j至j+p_w]</span></span><br><span class="line">            <span class="keyword">if</span> mode == <span class="string">&#x27;max&#x27;</span>:  <span class="comment"># 最大池化</span></span><br><span class="line">                Y[i, j] = X[i: i + p_h, j: j + p_w].<span class="built_in">max</span>()  <span class="comment"># max函数返回最大值</span></span><br><span class="line">            <span class="keyword">elif</span> mode == <span class="string">&#x27;avg&#x27;</span>:  <span class="comment"># 平均池化</span></span><br><span class="line">                Y[i, j] = X[i: i + p_h, j: j + p_w].mean()  <span class="comment"># mean函数返回平均值</span></span><br><span class="line">    <span class="keyword">return</span> Y</span><br></pre></td></tr></table></figure>
<p>我们可以构建上图中的输入张量<code>X</code>，[<strong>验证二维最大池化层的输出</strong>]。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = torch.tensor([[<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>], [<span class="number">3.0</span>, <span class="number">4.0</span>, <span class="number">5.0</span>], [<span class="number">6.0</span>, <span class="number">7.0</span>, <span class="number">8.0</span>]])</span><br><span class="line">pool2d(X, (<span class="number">2</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[4., 5.],
        [7., 8.]])
</code></pre><p>此外，我们还可以(<strong>验证平均池化层</strong>)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pool2d(X, (<span class="number">2</span>, <span class="number">2</span>), <span class="string">&#x27;avg&#x27;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[2., 3.],
        [5., 6.]])
</code></pre><h2 id="填充和步幅"><a href="#填充和步幅" class="headerlink" title="填充和步幅"></a>填充和步幅</h2><p>与卷积层一样，池化层也可以改变输出形状。和以前一样，我们可以通过填充和步幅以获得所需的输出形状。<br>下面，我们用深度学习框架中内置的二维最大池化层，来演示池化层中填充和步幅的使用。<br>我们首先构造了一个输入张量<code>X</code>，它有四个维度，其中样本数和通道数都是1。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = torch.arange(<span class="number">16</span>, dtype=torch.float32).reshape(</span><br><span class="line">    (<span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>))  <span class="comment"># 维度[batch_size，通道数，H，W]</span></span><br><span class="line">X</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[[[ 0.,  1.,  2.,  3.],
          [ 4.,  5.,  6.,  7.],
          [ 8.,  9., 10., 11.],
          [12., 13., 14., 15.]]]])
</code></pre><p>默认情况下，(<strong>深度学习框架中的步幅与池化窗口的大小相同</strong>)。<br>因此，如果我们使用形状为<code>(3, 3)</code>的池化窗口，那么默认情况下，我们得到的步幅形状为<code>(3, 3)</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pool2d = nn.MaxPool2d(<span class="number">3</span>)</span><br><span class="line">pool2d(X)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[[[10.]]]])
</code></pre><p>[<strong>填充和步幅可以手动设定</strong>]。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pool2d = nn.MaxPool2d(<span class="number">3</span>, padding=<span class="number">1</span>, stride=<span class="number">2</span>)</span><br><span class="line">pool2d(X)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[[[ 5.,  7.],
          [13., 15.]]]])
</code></pre><p>当然，我们可以(<strong>设定一个任意大小的矩形池化窗口，并分别设定填充和步幅的高度和宽度</strong>)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pool2d = nn.MaxPool2d((<span class="number">2</span>, <span class="number">3</span>), stride=(<span class="number">2</span>, <span class="number">3</span>), padding=(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">pool2d(X)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[[[ 5.,  7.],
          [13., 15.]]]])
</code></pre><h2 id="多个通道"><a href="#多个通道" class="headerlink" title="多个通道"></a>多个通道</h2><p>在处理多通道输入数据时，[<strong>池化层在每个输入通道上单独运算</strong>]，而不是像卷积层一样在通道上对输入进行汇总。<br>这意味着池化层的输出通道数与输入通道数相同。<br>下面，我们将在通道维度上连结张量<code>X</code>和<code>X + 1</code>，以构建具有2个通道的输入。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = torch.cat((X, X + <span class="number">1</span>), <span class="number">1</span>)  <span class="comment"># 在第一个维度也就是通道维度拼接</span></span><br><span class="line">X</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[[[ 0.,  1.,  2.,  3.],
          [ 4.,  5.,  6.,  7.],
          [ 8.,  9., 10., 11.],
          [12., 13., 14., 15.]],

         [[ 1.,  2.,  3.,  4.],
          [ 5.,  6.,  7.,  8.],
          [ 9., 10., 11., 12.],
          [13., 14., 15., 16.]]]])
</code></pre><p>如下所示，池化后输出通道的数量仍然是2。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pool2d = nn.MaxPool2d(<span class="number">3</span>, padding=<span class="number">1</span>, stride=<span class="number">2</span>)</span><br><span class="line">pool2d(X)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[[[ 5.,  7.],
          [13., 15.]],

         [[ 6.,  8.],
          [14., 16.]]]])
</code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>对于给定输入元素，最大池化层会输出该窗口内的最大值，平均池化层会输出该窗口内的平均值。</li>
<li>池化层的主要优点之一是减轻卷积层对位置的过度敏感。</li>
<li>我们可以指定池化层的填充和步幅。</li>
<li>使用最大池化层以及大于1的步幅，可减少空间维度（如高度和宽度）。</li>
<li>池化层的输出通道数与输入通道数相同。</li>
</ul>
<h2 id="问题和练习"><a href="#问题和练习" class="headerlink" title="问题和练习"></a>问题和练习</h2><ol>
<li>你能将平均池化层作为卷积层的特殊情况实现吗？</li>
</ol>
<blockquote>
<p>设卷积层大小是$m\times n$，卷积层里面每个元素参数是$\dfrac{1} {m\times n}$，这样就是一个平均池化层作为卷积层的实现</p>
</blockquote>
<ol>
<li>假设池化层的输入大小为$c\times h\times w$，则汇聚窗口的形状为$p_h\times p_w$，填充为$(p_h, p_w)$，步幅为$(s_h, s_w)$。这个池化层的计算成本是多少？</li>
</ol>
<blockquote>
<p>$ c\times \left \lfloor \dfrac {h-p_h+s_h}{s_h}\right \rfloor \times \left \lfloor \dfrac {w-p_w+s_w}{s_w}\right \rfloor $</p>
</blockquote>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>23-经典卷积神经网络LeNet</title>
    <url>/2024/04/23/11-01-23/</url>
    <content><![CDATA[<h3 id="1-LeNet卷积神经网络"><a href="#1-LeNet卷积神经网络" class="headerlink" title="1.LeNet卷积神经网络"></a>1.LeNet卷积神经网络</h3><h4 id="1-1-手写数字识别"><a href="#1-1-手写数字识别" class="headerlink" title="1.1 手写数字识别"></a>1.1 手写数字识别</h4><ul>
<li>LeNet网络最早是为了应用于手写数字的识别应用。</li>
<li>应用背景：<ul>
<li>邮政局希望可以自动读出信件上的邮政编码</li>
<li>人们希望可以用支票自动取钱</li>
</ul>
</li>
<li>该模型在80年代末的银行被真正的部署</li>
</ul>
<img src="/2024/04/23/11-01-23/23-01.png" class="">
<h4 id="1-2-MNIST"><a href="#1-2-MNIST" class="headerlink" title="1.2 MNIST"></a>1.2 MNIST</h4><ul>
<li>LeNet所使用的数据集</li>
<li>50，000个训练数据</li>
<li>10，000个测试数据</li>
<li>图像大小为28*28</li>
<li>10类</li>
</ul>
<img src="/2024/04/23/11-01-23/23-02.png" class="">
<h4 id="1-3-LeNet的具体模型"><a href="#1-3-LeNet的具体模型" class="headerlink" title="1.3 LeNet的具体模型"></a>1.3 LeNet的具体模型</h4><img src="/2024/04/23/11-01-23/23-03.png" class="">
<h4 id="1-4-总结"><a href="#1-4-总结" class="headerlink" title="1.4 总结"></a>1.4 总结</h4><ul>
<li>LeNet是早期成功的神经网络</li>
<li>先使用卷积层来学习图片空间信息</li>
<li>然后使用全连接层来转换到类别空间</li>
</ul>
<h3 id="2-代码部分"><a href="#2-代码部分" class="headerlink" title="2.代码部分"></a>2.代码部分</h3><h4 id="2-1-定义网络结构和准备工作"><a href="#2-1-定义网络结构和准备工作" class="headerlink" title="2.1 定义网络结构和准备工作"></a>2.1 定义网络结构和准备工作</h4><ul>
<li>导入所需的库</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#导入所需的库</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br></pre></td></tr></table></figure>
<ul>
<li>定义网络结构（具体可参考上文“具体模型”的图）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定义网络结构</span></span><br><span class="line">net = nn.Sequential(</span><br><span class="line">    nn.Conv2d(<span class="number">1</span>, <span class="number">6</span>, kernel_size=<span class="number">5</span>, padding=<span class="number">2</span>), nn.Sigmoid(),</span><br><span class="line">    nn.AvgPool2d(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>),</span><br><span class="line">    nn.Conv2d(<span class="number">6</span>, <span class="number">16</span>, kernel_size=<span class="number">5</span>), nn.Sigmoid(),</span><br><span class="line">    nn.AvgPool2d(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>),</span><br><span class="line">    nn.Flatten(),</span><br><span class="line">    nn.Linear(<span class="number">16</span> * <span class="number">5</span> * <span class="number">5</span>, <span class="number">120</span>), nn.Sigmoid(),</span><br><span class="line">    nn.Linear(<span class="number">120</span>, <span class="number">84</span>), nn.Sigmoid(),</span><br><span class="line">    nn.Linear(<span class="number">84</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure>
<ul>
<li>查看每一层数据的变化情况</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#把每一层数据的shape给打印出来</span></span><br><span class="line">X = torch.rand(size=(<span class="number">1</span>, <span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>), dtype=torch.float32)<span class="comment">#创建符合要求的张量</span></span><br><span class="line"><span class="keyword">for</span> layer <span class="keyword">in</span> net:</span><br><span class="line">    X = layer(X)<span class="comment">#通过每一层</span></span><br><span class="line">    <span class="built_in">print</span>(layer.__class__.__name__,<span class="string">&#x27;output shape: \t&#x27;</span>,X.shape)<span class="comment">#打印</span></span><br></pre></td></tr></table></figure>
<h4 id="2-2-模型训练"><a href="#2-2-模型训练" class="headerlink" title="2.2 模型训练"></a>2.2 模型训练</h4><ul>
<li>下载数据集</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">batch_size = <span class="number">256</span><span class="comment">#批量大小</span></span><br><span class="line">train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size=batch_size)<span class="comment">#下载或加载数据集，得到训练和测试集的迭代对象</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用GPU计算模型在数据集上的精度</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">evaluate_accuracy_gpu</span>(<span class="params">net, data_iter, device=<span class="literal">None</span></span>): <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用GPU计算模型在数据集上的精度&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(net, nn.Module):</span><br><span class="line">        net.<span class="built_in">eval</span>()  <span class="comment"># 设置为评估模式</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> device:</span><br><span class="line">            device = <span class="built_in">next</span>(<span class="built_in">iter</span>(net.parameters())).device</span><br><span class="line">    <span class="comment"># 正确预测的数量，总预测的数量</span></span><br><span class="line">    metric = d2l.Accumulator(<span class="number">2</span>)<span class="comment">#创建一个累加器，包含2个要累加的元素</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> X, y <span class="keyword">in</span> data_iter:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(X, <span class="built_in">list</span>):</span><br><span class="line">                <span class="comment"># BERT微调所需的（之后将介绍）</span></span><br><span class="line">                X = [x.to(device) <span class="keyword">for</span> x <span class="keyword">in</span> X]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                X = X.to(device)</span><br><span class="line">            y = y.to(device)</span><br><span class="line">            metric.add(d2l.accuracy(net(X), y), y.numel())<span class="comment">#把每一组数据预测结果正确的个数和长度累加</span></span><br><span class="line">    <span class="keyword">return</span> metric[<span class="number">0</span>] / metric[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>训练函数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train_ch6</span>(<span class="params">net, train_iter, test_iter, num_epochs, lr, device</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;用GPU训练模型(在第六章定义)&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">init_weights</span>(<span class="params">m</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(m) == nn.Linear <span class="keyword">or</span> <span class="built_in">type</span>(m) == nn.Conv2d:</span><br><span class="line">            nn.init.xavier_uniform_(m.weight)<span class="comment">#对linear类型的层用xavier初始化</span></span><br><span class="line">    net.apply(init_weights)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;training on&#x27;</span>, device)</span><br><span class="line">    net.to(device)</span><br><span class="line">    optimizer = torch.optim.SGD(net.parameters(), lr=lr)</span><br><span class="line">    loss = nn.CrossEntropyLoss()</span><br><span class="line">    animator = d2l.Animator(xlabel=<span class="string">&#x27;epoch&#x27;</span>, xlim=[<span class="number">1</span>, num_epochs],</span><br><span class="line">                            legend=[<span class="string">&#x27;train loss&#x27;</span>, <span class="string">&#x27;train acc&#x27;</span>, <span class="string">&#x27;test acc&#x27;</span>])<span class="comment">#动画需要</span></span><br><span class="line">    timer, num_batches = d2l.Timer(), <span class="built_in">len</span>(train_iter)</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">        <span class="comment"># 训练损失之和，训练准确率之和，范例数</span></span><br><span class="line">        metric = d2l.Accumulator(<span class="number">3</span>)</span><br><span class="line">        net.train()</span><br><span class="line">        <span class="keyword">for</span> i, (X, y) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_iter):</span><br><span class="line">            timer.start()</span><br><span class="line">            optimizer.zero_grad()<span class="comment">#梯度清零</span></span><br><span class="line">            X, y = X.to(device), y.to(device)</span><br><span class="line">            y_hat = net(X)<span class="comment">#正向传播</span></span><br><span class="line">            l = loss(y_hat, y)<span class="comment">#计算损失</span></span><br><span class="line">            l.backward()<span class="comment">#反向传播</span></span><br><span class="line">            optimizer.step()<span class="comment">#梯度下降</span></span><br><span class="line">            <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">                metric.add(l * X.shape[<span class="number">0</span>], d2l.accuracy(y_hat, y), X.shape[<span class="number">0</span>])<span class="comment">#训练损失之和，训练准确率之和，范例数</span></span><br><span class="line">            timer.stop()</span><br><span class="line">            train_l = metric[<span class="number">0</span>] / metric[<span class="number">2</span>]</span><br><span class="line">            train_acc = metric[<span class="number">1</span>] / metric[<span class="number">2</span>]</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span>) % (num_batches // <span class="number">5</span>) == <span class="number">0</span> <span class="keyword">or</span> i == num_batches - <span class="number">1</span>:</span><br><span class="line">                animator.add(epoch + (i + <span class="number">1</span>) / num_batches,</span><br><span class="line">                             (train_l, train_acc, <span class="literal">None</span>))</span><br><span class="line">        test_acc = evaluate_accuracy_gpu(net, test_iter)<span class="comment">#评估测试集的精度</span></span><br><span class="line">        animator.add(epoch + <span class="number">1</span>, (<span class="literal">None</span>, <span class="literal">None</span>, test_acc))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;loss <span class="subst">&#123;train_l:<span class="number">.3</span>f&#125;</span>, train acc <span class="subst">&#123;train_acc:<span class="number">.3</span>f&#125;</span>, &#x27;</span></span><br><span class="line">          <span class="string">f&#x27;test acc <span class="subst">&#123;test_acc:<span class="number">.3</span>f&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;metric[<span class="number">2</span>] * num_epochs / timer.<span class="built_in">sum</span>():<span class="number">.1</span>f&#125;</span> examples/sec &#x27;</span></span><br><span class="line">          <span class="string">f&#x27;on <span class="subst">&#123;<span class="built_in">str</span>(device)&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>运行</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lr, num_epochs = <span class="number">0.9</span>, <span class="number">10</span></span><br><span class="line">train_ch6(net, train_iter, test_iter, num_epochs, lr, d2l.try_gpu())</span><br></pre></td></tr></table></figure>
<img src="/2024/04/23/11-01-23/23-04.png" class="">
<h4 id="2-3-总结"><a href="#2-3-总结" class="headerlink" title="2.3 总结"></a>2.3 总结</h4><ul>
<li>卷积神经网络（CNN）是一类使用卷积层的网络。</li>
<li>在卷积神经网络中，我们组合使用卷积层、非线性激活函数和汇聚层。</li>
<li>为了构造高性能的卷积神经网络，我们通常对卷积层进行排列，逐渐降低其表示的空间分辨率，同时增加通道数。</li>
<li>在传统的卷积神经网络中，卷积块编码得到的表征在输出之前需由一个或多个全连接层进行处理。</li>
<li>LeNet是最早发布的卷积神经网络之一（80年代）</li>
</ul>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>24-AlexNet</title>
    <url>/2024/04/23/11-01-24/</url>
    <content><![CDATA[<h2 id="AlexNet"><a href="#AlexNet" class="headerlink" title="AlexNet"></a>AlexNet</h2><h3 id="1-历史"><a href="#1-历史" class="headerlink" title="1.历史"></a>1.历史</h3><h4 id="1-1-2000-流行的机器学习方法——SVM，核方法"><a href="#1-1-2000-流行的机器学习方法——SVM，核方法" class="headerlink" title="1.1 2000 流行的机器学习方法——SVM，核方法"></a>1.1 2000 流行的机器学习方法——SVM，核方法</h4><ul>
<li>核方法替代了之前的神经网络网络方法，SVM对于调参不敏感，现在也有一些应用</li>
<li>本质上是特征提取，具体的方法是选择核函数来计算，把特征映射到高纬空间，使得他们线性可分</li>
<li>经过核函数计算之后，原问题可以转化为凸优化问题，这是2006年左右的研究热点</li>
<li><p>核方法有很多漂亮的定理，有很好的数学解释性</p>
</li>
<li><p>2010年左右，深度学习才兴起</p>
</li>
</ul>
<h4 id="1-2-2000计算机视觉主要方法——几何学"><a href="#1-2-2000计算机视觉主要方法——几何学" class="headerlink" title="1.2 2000计算机视觉主要方法——几何学"></a>1.2 2000计算机视觉主要方法——几何学</h4><ul>
<li>首先还是对图片进行特征抽取</li>
<li>希望把计算机视觉问题描述成几何问题，建立（非）凸优化模型，可以得到很多漂亮的定理。</li>
<li>可以假设这是一个几何问题，假设这个假设被满足了，可以推出很好的效果</li>
</ul>
<h4 id="1-3-2010计算机视觉的热点问题——特征工程"><a href="#1-3-2010计算机视觉的热点问题——特征工程" class="headerlink" title="1.3 2010计算机视觉的热点问题——特征工程"></a>1.3 2010计算机视觉的热点问题——特征工程</h4><ul>
<li>特征工程就是怎么抽取一张图片的特征，因为直接输入一张图片效果非常的差</li>
<li>特征描述子：SIFT,SURF</li>
</ul>
<h4 id="1-4-硬件的发展奠定了深度学习的兴起"><a href="#1-4-硬件的发展奠定了深度学习的兴起" class="headerlink" title="1.4 硬件的发展奠定了深度学习的兴起"></a>1.4 硬件的发展奠定了深度学习的兴起</h4><ul>
<li>数据的增长，硬件的计算能力奠定了人们对于方法的选择</li>
</ul>
<img src="/2024/04/23/11-01-24/24-01.png" class="">
<h4 id="1-5-ImageNet（2010）"><a href="#1-5-ImageNet（2010）" class="headerlink" title="1.5 ImageNet（2010）"></a>1.5 ImageNet（2010）</h4><img src="/2024/04/23/11-01-24/24-02.png" class="">
<ul>
<li><p>AlexNet赢得了2012年ImageNet竞赛冠军</p>
</li>
<li><p>本质上是一个加强版的LeNet，更深更大</p>
</li>
<li><p>AlexNet主要改进措施：</p>
<ul>
<li>dropout（正则）</li>
<li>ReLu（梯度更大）</li>
<li>MaxPooling（取最大值，梯度相对增大）</li>
</ul>
</li>
<li><p>影响：计算机视觉方法论的改变，从人工提取特征过渡到CNN学习特征</p>
</li>
</ul>
<img src="/2024/04/23/11-01-24/24-03.png" class="">
<h3 id="2-AlexNet架构"><a href="#2-AlexNet架构" class="headerlink" title="2.AlexNet架构"></a>2.AlexNet架构</h3><img src="/2024/04/23/11-01-24/24-04.png" class="">
<img src="/2024/04/23/11-01-24/24-05.png" class="">
<img src="/2024/04/23/11-01-24/24-06.png" class="">
<ul>
<li>网络代码</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">net = nn.Sequential(</span><br><span class="line">这里，我们使用一个<span class="number">11</span>*<span class="number">11</span>的更大窗口来捕捉对象。</span><br><span class="line">    <span class="comment"># 同时，步幅为4，以减少输出的高度和宽度。</span></span><br><span class="line">    <span class="comment"># 另外，输出通道的数目远大于LeNet</span></span><br><span class="line">    nn.Conv2d(<span class="number">1</span>, <span class="number">96</span>, kernel_size=<span class="number">11</span>, stride=<span class="number">4</span>, padding=<span class="number">1</span>), nn.ReLU(),</span><br><span class="line">    nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>),</span><br><span class="line">    <span class="comment"># 减小卷积窗口，使用填充为2来使得输入与输出的高和宽一致，且增大输出通道数</span></span><br><span class="line">    nn.Conv2d(<span class="number">96</span>, <span class="number">256</span>, kernel_size=<span class="number">5</span>, padding=<span class="number">2</span>), nn.ReLU(),</span><br><span class="line">    nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>),</span><br><span class="line">    <span class="comment"># 使用三个连续的卷积层和较小的卷积窗口。</span></span><br><span class="line">    <span class="comment"># 除了最后的卷积层，输出通道的数量进一步增加。</span></span><br><span class="line">    <span class="comment"># 在前两个卷积层之后，汇聚层不用于减少输入的高度和宽度</span></span><br><span class="line">    nn.Conv2d(<span class="number">256</span>, <span class="number">384</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>), nn.ReLU(),</span><br><span class="line">    nn.Conv2d(<span class="number">384</span>, <span class="number">384</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>), nn.ReLU(),</span><br><span class="line">    nn.Conv2d(<span class="number">384</span>, <span class="number">256</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>), nn.ReLU(),</span><br><span class="line">    nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>),</span><br><span class="line">    nn.Flatten(),</span><br><span class="line">    <span class="comment"># 这里，全连接层的输出数量是LeNet中的好几倍。使用dropout层来减轻过拟合</span></span><br><span class="line">    nn.Linear(<span class="number">6400</span>, <span class="number">4096</span>), nn.ReLU(),</span><br><span class="line">    nn.Dropout(p=<span class="number">0.5</span>),</span><br><span class="line">    nn.Linear(<span class="number">4096</span>, <span class="number">4096</span>), nn.ReLU(),</span><br><span class="line">    nn.Dropout(p=<span class="number">0.5</span>),</span><br><span class="line">    <span class="comment"># 最后是输出层。由于这里使用Fashion-MNIST，所以用类别数为10，而非论文中的1000</span></span><br><span class="line">    nn.Linear(<span class="number">4096</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure>
<ul>
<li>更多细节<ul>
<li>激活函数从sigmoid变成Relu，减缓梯度消失</li>
<li>隐藏全连接层后加入了丢弃层（2个4096之后加入了dropout）</li>
<li>数据增强，将一张图片进行变化，选取多个位置、光照之类的。</li>
</ul>
</li>
</ul>
<img src="/2024/04/23/11-01-24/24-07.png" class="">
<ul>
<li>复杂度对比<ul>
<li>参数个数增加，每次更新数据增加</li>
</ul>
</li>
</ul>
<img src="/2024/04/23/11-01-24/24-08.png" class="">
<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h3><ul>
<li>AlexNet 是更大更深的LeNet，10x参数个数，260x计算复杂度</li>
<li>新加入了dropout，relu，maxpooling，数据增强</li>
<li>标志着新一轮神经网络热潮开始了</li>
</ul>
<h3 id="4-QA"><a href="#4-QA" class="headerlink" title="4.QA"></a>4.QA</h3><ul>
<li>问题大部分都在问如何炼丹，炼丹的理论，为啥炼丹的步骤要这样不哪有？<ul>
<li>老师说这个确实不好理解，只能从自己的角度去尝试解释</li>
</ul>
</li>
<li>数据增强了，但是效果还不如之前的，为啥？<ul>
<li>太正常了，属于超参数没调好</li>
</ul>
</li>
<li>为啥LeNet不属于深度卷积神经网络？<ul>
<li>为了包装现在的产品，更好卖（确实是这么回答的），这个我们研究者需要学习，好好宣传自己的产品</li>
</ul>
</li>
<li>网络要求输入的size是固定的，实际使用的时候图片不一定是要求的size，怎么处理？<ul>
<li>如果是大的图片，在保持长宽比的情况下，把短边压成输入的size，然后在新的图片中随机抠出来几张图片（要求和网络输入一致）进行预测。效果上不会有太大的影响</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>12 权重衰退 Weight Decay</title>
    <url>/2024/04/23/11-01-12/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.04.24：初稿</li>
</ul>
<h2 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h2><ul>
<li><a href="/2024/04/24/12-18-34/" title="动手学深度学习笔记汇总">动手学深度学习笔记汇总</a>
</li>
</ul>
<h2 id="12-权重衰退-Weight-Decay"><a href="#12-权重衰退-Weight-Decay" class="headerlink" title="12 权重衰退 Weight Decay"></a>12 权重衰退 Weight Decay</h2><p>权重衰退是最常见的一种处理过拟合的方法，是最广泛使用的正则化技术之一。</p>
<h4 id="复习：控制模型容量"><a href="#复习：控制模型容量" class="headerlink" title="复习：控制模型容量"></a>复习：控制模型容量</h4><blockquote>
<ol>
<li>使用更少参数</li>
<li>控制每个参数（取值/可选择的值）范围较小</li>
</ol>
</blockquote>
<p>其中权重衰退属于第二种方法。</p>
<h3 id="1-硬性限制-直观理解"><a href="#1-硬性限制-直观理解" class="headerlink" title="1. 硬性限制/直观理解"></a>1. 硬性限制/直观理解</h3><p>我们的优化目标仍然是$min\space\ell(\boldsymbol{w},b)$，只是额外对$\boldsymbol{w}$添加一个限制条件$||\boldsymbol{w}||^2\leqslant\theta$，即权重的各项平方和小于一个特定的常数$\theta$。那么设定一个较小的$\theta$就会使得$\boldsymbol{w}$中每个元素的值都不会太大。</p>
<p>通常不会限制偏移b，理论上讲b表示整个数据在零点上的偏移，因此是不应该限制的，但实践中限制与否对结果都没什么影响。</p>
<p><strong>吴恩达课程中对这一现象的解释是w是高维向量，已经包含了绝大多数参数足以表达高方差问题，b作为单个数字对结果的影响就会很小.</strong></p>
<p>小的$\theta$意味着更强的正则项，对于相同的$\theta$，$\boldsymbol{w}$中元素越多则单个元素的值会越小。</p>
<h3 id="2-柔性限制-实际应用"><a href="#2-柔性限制-实际应用" class="headerlink" title="2. 柔性限制/实际应用"></a>2. 柔性限制/实际应用</h3><p>上文说的硬性限制在实际使用时比较麻烦，实际上常用的函数是</p>
<p>$$<br>\begin{split}<br>min\space\ell(\boldsymbol{w},b)+\frac{\lambda}{2}||\boldsymbol{w}||^2<br>\end{split}<br>$$</p>
<p>可以通过拉格朗日乘子证明对于每个$\theta$都可以找到$\lambda$使得硬性限制的目标函数等价于上式。</p>
<p>其中$\frac{\lambda}{2}||\boldsymbol{w}||^2$这一项被称为罚(penalty)，$\lambda$是超参数，控制了正则项的重要程度。</p>
<p>当 $\lambda=0$ 时无作用，$\lambda\rightarrow\infty$ 时最优解 $\boldsymbol{w}^*\rightarrow0$，也就是说 $\lambda$ 越大模型复杂度就被控制的越低。</p>
<p>下面是老师给出的演示图</p>
<img src="/2024/04/23/11-01-12/12-01.JPG" class="">
<p>以$\boldsymbol{w}$中只有两个参数为例，其中绿色的部分是原本损失函数函数值的“等高线”，黄色部分可以看作是正则项对应函数值的“等高线” ，使用权重衰减后需要优化的损失函数相当于图中两组等高线叠加。原本最优解位于绿色中心，现在这一位置在对于正则项有很高的损失，而正则项最小值位于原点，因此现在的最终优化解会更靠近原点，而当所有参数都更靠近原点时模型的规模也就更小。</p>
<h3 id="3-参数更新"><a href="#3-参数更新" class="headerlink" title="3. 参数更新"></a>3. 参数更新</h3><h4 id="3-1-计算梯度"><a href="#3-1-计算梯度" class="headerlink" title="3.1 计算梯度"></a>3.1 计算梯度</h4><p>$$<br>\begin{split}<br>\frac{\partial{} }{\partial{\boldsymbol{w} } }(\ell(\boldsymbol{w},b)+\frac{\lambda}{2}||\boldsymbol{w}||^2)=\frac{\partial{\ell(\boldsymbol{w},b)} }{ {\partial{\boldsymbol{w} } } }+\lambda\boldsymbol{w}<br>\end{split}<br>$$</p>
<h4 id="3-2-更新参数"><a href="#3-2-更新参数" class="headerlink" title="3.2 更新参数"></a>3.2 更新参数</h4><p>将上式结果带入更新参数公式整理可得</p>
<p>$$<br>\begin{split}<br>\boldsymbol{w}_{t+1}=(1-\eta\lambda)\boldsymbol{w}_{t}-\eta\frac{\partial{\ell(\boldsymbol{w}_t,b_t)} }{ {\partial{\boldsymbol{w}_{t} } } }<br>\end{split}<br>$$</p>
<p>注意到这个公式中后一项与原来更新参数的公式没有区别，仅仅是在前一项$\boldsymbol{w}_{t}$ 上加了一个系数$(1-\eta\lambda)$。通常$\eta\lambda&lt;1$ ，也就是说由于引入了$\lambda$，每次更新参数前先给待更新参数乘上一个小于1的权重再更新，权重衰退由此得名。</p>
<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><ul>
<li>权重衰退通过L2正则项使得模型参数不会过大，从而控制模型复杂度</li>
<li>正则项权重（$\lambda$）是控制模型复杂度的超参数                                                                                                                                       </li>
</ul>
<h3 id="5-Q-amp-A"><a href="#5-Q-amp-A" class="headerlink" title="5. Q&amp;A"></a>5. Q&amp;A</h3><ul>
<li><p>Q：Pytorch是否支持复数神经网络？</p>
</li>
<li><p>A：应该不支持，但复数可以看作是二维的数，可以尝试将对应结构变成二维来实现需要的效果。</p>
</li>
<li><p>Q：为什么参数不过大复杂度就低呢？</p>
</li>
<li><p>A：确切的说是限制模型优化时只能在很小范围内取参数会使模型复杂度降低，见下图</p>
</li>
</ul>
<img src="/2024/04/23/11-01-12/12-02.JPG" class="">
<p>参数选择范围大时可拟合出很复杂的曲线，限制后只能学到更平滑的曲线/选择更简单的模型，那么模型复杂度就变低了。</p>
<ul>
<li><p>Q：如果使用L1范数如何更新权重？</p>
</li>
<li><p>A：编写代码时只需把罚项改成如</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">l1_penalty</span>(<span class="params">w</span>):</span><br><span class="line">  <span class="keyword">return</span> torch.<span class="built_in">sum</span>(torch.<span class="built_in">abs</span>(w))</span><br></pre></td></tr></table></figure>
<p>老师解答就到这里，但实操不应该只改罚项函数，还需重新定义带正则项的损失函数并求导化简。</p>
<div align="center">

$\frac{\partial{} }{\partial{\mathbf{w} } }(\ell(\mathbf{w},b)+\lambda||\mathbf{w}||_1)=\frac{\partial{\ell(\mathbf{w},b)} }{ {\partial{\mathbf{w} } } }+I'\lambda$

</div>

<p>其中$I’=(a_1,…,a_n)$,当$\mathbf{w}$中第i个元素为正时$a_i=1$，反之$a_i=-1$.（=0时随意）</p>
<p>代入公式化简得</p>
<div align="center">

$\mathbf{w}_{t+1}=\mathbf{w}_{t}-\eta\frac{\partial{\ell(\mathbf{w}_t,b_t)} }{ {\partial{\mathbf{w}_{t} } } }-I'\eta\lambda$

</div>

<p>从这个式子可以看出使用L1正则化时只能对所有同号的参数施加一个相同大小的正则项（增减一个定值），而反观L2正则化对参数的影响是与参数本身的值有关的（乘上一个系数）似乎是更好的选择。不过L1正则化在特征提取上会有用处。</p>
<ul>
<li><p>Q：实践中权重衰减的值设置为多少好？跑代码时感觉效果不明显。</p>
</li>
<li><p>A：一般取1e-2,1e-3,1e-4，权重衰退的效果确实有限，之后还会讲解更多方法。如果模型真的很复杂那么权重衰退一般不会带来特别好的效果。</p>
</li>
<li><p>Q：关于L2范数的记法</p>
</li>
<li><p>A：完整的写法是$||\boldsymbol{w}||^2_2$，上标的2表示平方，下标的2表示是L2范数，下标有时省略。</p>
</li>
<li><p>Q：为什么要把$\boldsymbol{w}$往小拉？如果最优解的$\boldsymbol{w}$本来就较大权重衰减是否会起反作用？/正则项使得$\boldsymbol{w}$变得更平均没有突出的值为什么可以拟合的更好呢？</p>
</li>
<li><p>A：实际训练的数据都是有噪音的，而这些噪音可能会被拟合进去使得我们实际求解时得不到数学上的最优解，正则化起到将结果拉向最优解的作用。当然如果$\lambda$选取过大可能会拉小的过多，如果没有过拟合那权重衰减就不起作用。</p>
<p><strong>笔者注：这部分老师花了较长时间解释，建议大家自己去看视频。我的个人理解是重点不在于w大小/是否平均，而是由于数据有噪声，而噪声引起过拟合使得求出的w比数学上的最优解更大/更不平均，这时就需要正则化起到一个将结果拉向更小/平均/接近最优解的作用。</strong></p>
</li>
<li><p>Q：噪音大会使得$\boldsymbol{w}$较大是经验所得还是可以证明？</p>
</li>
<li>A：可以证明，但本课程中不讲，可以自己尝试。</li>
<li>Q：怎样调整$\lambda$？</li>
<li>A：不能确定什么时候是最优，但可以用前面讲的验证集/k折交叉验证，先取$\lambda=0$看训练结果，再改变$\lambda$看是否有改善。</li>
</ul>
<p><strong>代码和部分课后题参考答案见本讲的ipynb文件。</strong></p>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>25 使用块的网络 VGG</title>
    <url>/2024/04/23/11-01-25/</url>
    <content><![CDATA[<h2 id="25-使用块的网络-VGG"><a href="#25-使用块的网络-VGG" class="headerlink" title="25 使用块的网络 VGG"></a>25 使用块的网络 VGG</h2><p>Alexnet最大的问题在于长得不规则，结构不甚清晰，也不便于调整。想要把网络做的更深更大需要更好的设计思想和标准框架。</p>
<h3 id="1-VGG块"><a href="#1-VGG块" class="headerlink" title="1. VGG块"></a>1. VGG块</h3><p>直到现在更深更大的模型也是我们努力的方向，在当时AlexNet比LeNet更深更大得到了更好的精度，大家也希望把网络做的更深更大。选择之一是使用更多的全连接层，但全连接层的成本很高；第二个选择是使用更多的卷积层，但缺乏好的指导思想来说明在哪加，加多少。最终VGG采取了将卷积层组合成块，再把卷积块组合到一起的思路。</p>
<p>VGG块可以看作是AlexNet思路的拓展，AlexNet中将三个相同的卷积层放在一起再加上一个池化层，而VGG将其拓展成可以使用任意个3x3，不改变输入大小的的卷积层，最后加上一个2x2的最大池化层。</p>
<img src="/2024/04/23/11-01-25/25-01.PNG" class="">
<p>为什么选择3x3卷积呢？在计算量相同的情况下选用更大的卷积核涉及对网络会越浅，VGG作者经过实验发现用3x3卷积的效果要比5x5好，也就是说神经网络库深且窄的效果会更好。</p>
<h3 id="2-VGG架构"><a href="#2-VGG架构" class="headerlink" title="2. VGG架构"></a>2. VGG架构</h3><p>多个VGG块后接全连接层，不同次数的重复块得到不同的架构，如VGG-16, VGG-19等，后面的数字取决于网络层数。</p>
<p>可以讲VGG看作是将AlexNet中连续卷积的部分取出加以推广和复制，并删去了AlexNet中不那么规整的前几层。</p>
<img src="/2024/04/23/11-01-25/25-02.PNG" class="">
<p>VGG较AlexNet相比性能有很大的提升，而代价是处理样本速度的降低和内存占用的增加。</p>
<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><ul>
<li><p>VGG使用可重复使用的卷积块来构建深度卷积网络</p>
</li>
<li><p>不同卷积块个数和超参数可以得到不同复杂度的变种</p>
</li>
</ul>
<p>这些思想影响了后面神经网络的设计，在之后的模型中被广泛使用。</p>
<h3 id="4-QA"><a href="#4-QA" class="headerlink" title="4. QA"></a>4. QA</h3><p>Q1: 视觉领域人工特征的研究还有无进展？</p>
<blockquote>
<p>现在在计算机视觉做人工特征是一种“政治不正确”的事，可能会因被认为没有novelty而发不出paper ;-)</p>
<p>老师认为人工特征提取确实应该被取代掉，随着技术进步可以把这部分工作交给机器，人去做更高级的事。</p>
</blockquote>
<p>Q2: 需要学习特征值/特征向量/奇异值分解的知识吗？</p>
<blockquote>
<p>这门课中不一定会讲，但很多深度学习模型用到矩阵分解的思想，但是用的不多，想学可以学。</p>
</blockquote>
<p>Q3: Colab限时12小时与验证码的解决方法</p>
<blockquote>
<p>充钱</p>
</blockquote>
<p>Q4: 训练loss一直下降，测试loss一只不降的原因</p>
<blockquote>
<p>代码写错了/过拟合(训练集和测试集很不一样)</p>
</blockquote>
<p>Q5: 为什么VGG（1，1，224，224）输入高宽减半后通道数是64？</p>
<blockquote>
<p>第一个卷积层的输出通道选的是64。(通道数变化是自定的，和高宽变化没有关系)</p>
</blockquote>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>26-网络中的网络（NiN）</title>
    <url>/2024/04/23/11-01-26/</url>
    <content><![CDATA[<h2 id="26-网络中的网络（NiN）"><a href="#26-网络中的网络（NiN）" class="headerlink" title="26-网络中的网络（NiN）"></a>26-网络中的网络（NiN）</h2><h3 id="1-动机"><a href="#1-动机" class="headerlink" title="1. 动机"></a>1. 动机</h3><p><strong>全连接层的问题</strong></p>
<ul>
<li><strong>卷积层</strong>需要的<strong>参数较少</strong></li>
<li>而卷积层后的第一个<strong>全连接层</strong>的<strong>参数较多</strong></li>
</ul>
<img src="/2024/04/23/11-01-26/26-01.png" class="">
<p>以VGG为例(图示)，全连接层需要先Flatten，输入维度为512x7x7，输出维度为4096，则需要参数个数为512x7x7x4096=102M。</p>
<h3 id="2-NiN块"><a href="#2-NiN块" class="headerlink" title="2. NiN块"></a>2. NiN块</h3><ul>
<li>核心思想：一个卷积层后面跟两个1x1的卷积层，后两层起到全连接层的作用。</li>
</ul>
<img src="/2024/04/23/11-01-26/26-02.png" class="">
<h3 id="3-NiN架构"><a href="#3-NiN架构" class="headerlink" title="3. NiN架构"></a>3. NiN架构</h3><ul>
<li>无全连接层</li>
<li>交替使用NiN块和步幅为2的最大池化层<ul>
<li>逐步减小高宽和增大通道数</li>
</ul>
</li>
<li>最后使用全局平均池化得到输出<ul>
<li>其输入通道是类别数</li>
</ul>
</li>
</ul>
<h3 id="4-NiN-Networks"><a href="#4-NiN-Networks" class="headerlink" title="4. NiN Networks"></a>4. NiN Networks</h3><img src="/2024/04/23/11-01-26/26-03.png" class="">
<p>NiN架构如上图右边所示，若干个NiN块(图示中为4个块)+池化层；前3个块后接最大池化层，最后一块连接一个全局平均池化层。</p>
<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><ul>
<li>NiN块结构：使用卷积层加两个1x1卷积层<ul>
<li>后者对每个像素增加了非线性性</li>
</ul>
</li>
<li>NiN使用全局平均池化层来替代VGG和AlexNet中的全连接层<ul>
<li>不容易过拟合，更少的参数个数</li>
</ul>
</li>
</ul>
<h3 id="6-代码"><a href="#6-代码" class="headerlink" title="6.代码"></a>6.代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果在Colab上跑, 或没有安装过d2l包, 需要最开始pip install d2l</span></span><br><span class="line">!pip install git+https://github.com/d2l-ai/d2l-zh@release  <span class="comment"># installing d2l</span></span><br></pre></td></tr></table></figure>
<p><strong>NiN块</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义NiN块</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nin_block</span>(<span class="params">in_channels, out_channels, kernel_size, strides, padding</span>):</span><br><span class="line">    <span class="keyword">return</span> nn.Sequential(</span><br><span class="line">        nn.Conv2d(in_channels, out_channels, kernel_size, strides, padding),</span><br><span class="line">        nn.ReLU(), nn.Conv2d(out_channels, out_channels, kernel_size=<span class="number">1</span>),</span><br><span class="line">        nn.ReLU(), nn.Conv2d(out_channels, out_channels, kernel_size=<span class="number">1</span>),</span><br><span class="line">        nn.ReLU())</span><br></pre></td></tr></table></figure>
<p><strong>NiN模型</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">net = nn.Sequential(</span><br><span class="line">    nin_block(<span class="number">1</span>, <span class="number">96</span>, kernel_size=<span class="number">11</span>, strides=<span class="number">4</span>, padding=<span class="number">0</span>),</span><br><span class="line">    nn.MaxPool2d(<span class="number">3</span>, stride=<span class="number">2</span>),</span><br><span class="line">    nin_block(<span class="number">96</span>, <span class="number">256</span>, kernel_size=<span class="number">5</span>, strides=<span class="number">1</span>, padding=<span class="number">2</span>),</span><br><span class="line">    nn.MaxPool2d(<span class="number">3</span>, stride=<span class="number">2</span>),</span><br><span class="line">    nin_block(<span class="number">256</span>, <span class="number">384</span>, kernel_size=<span class="number">3</span>, strides=<span class="number">1</span>, padding=<span class="number">1</span>),</span><br><span class="line">    nn.MaxPool2d(<span class="number">3</span>, stride=<span class="number">2</span>), nn.Dropout(<span class="number">0.5</span>),</span><br><span class="line">    <span class="comment"># 标签类别数是10</span></span><br><span class="line">    nin_block(<span class="number">384</span>, <span class="number">10</span>, kernel_size=<span class="number">3</span>, strides=<span class="number">1</span>, padding=<span class="number">1</span>),</span><br><span class="line">    nn.AdaptiveAvgPool2d((<span class="number">1</span>, <span class="number">1</span>)),          <span class="comment">#全局平均池化，高宽都变成1</span></span><br><span class="line">    nn.Flatten())             <span class="comment">#消掉最后两个维度, 变成(batch_size, 10)</span></span><br></pre></td></tr></table></figure>
<p><strong>demo测试，查看每个块的输出情况</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = torch.rand(size=(<span class="number">1</span>, <span class="number">1</span>, <span class="number">224</span>, <span class="number">224</span>))</span><br><span class="line"><span class="keyword">for</span> layer <span class="keyword">in</span> net:</span><br><span class="line">    X = layer(X)</span><br><span class="line">    <span class="built_in">print</span>(layer.__class__.__name__, <span class="string">&#x27;output shape:\t&#x27;</span>, X.shape)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;</span><br><span class="line">Sequential output shape:	 torch.Size([<span class="number">1</span>, <span class="number">96</span>, <span class="number">54</span>, <span class="number">54</span>])</span><br><span class="line">MaxPool2d output shape:		 torch.Size([<span class="number">1</span>, <span class="number">96</span>, <span class="number">26</span>, <span class="number">26</span>])</span><br><span class="line">Sequential output shape:	 torch.Size([<span class="number">1</span>, <span class="number">256</span>, <span class="number">26</span>, <span class="number">26</span>])</span><br><span class="line">MaxPool2d output shape:		 torch.Size([<span class="number">1</span>, <span class="number">256</span>, <span class="number">12</span>, <span class="number">12</span>])</span><br><span class="line">Sequential output shape:	 torch.Size([<span class="number">1</span>, <span class="number">384</span>, <span class="number">12</span>, <span class="number">12</span>])</span><br><span class="line">MaxPool2d output shape:		 torch.Size([<span class="number">1</span>, <span class="number">384</span>, <span class="number">5</span>, <span class="number">5</span>])</span><br><span class="line">Dropout output shape:		 torch.Size([<span class="number">1</span>, <span class="number">384</span>, <span class="number">5</span>, <span class="number">5</span>])</span><br><span class="line">Sequential output shape:	 torch.Size([<span class="number">1</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">5</span>])</span><br><span class="line">AdaptiveAvgPool2d output shape:	 torch.Size([<span class="number">1</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line">Flatten output shape:		 torch.Size([<span class="number">1</span>, <span class="number">10</span>])</span><br></pre></td></tr></table></figure>
<p><strong>训练模型</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lr, num_epochs, batch_size = <span class="number">0.1</span>, <span class="number">10</span>, <span class="number">128</span></span><br><span class="line">train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size, resize=<span class="number">224</span>)</span><br><span class="line">d2l.train_ch6(net, train_iter, test_iter, num_epochs, lr, d2l.try_gpu())</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>&lt;Figure size 252x180 <span class="keyword">with</span> <span class="number">1</span> Axes&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>20-填充和步幅</title>
    <url>/2024/04/23/11-01-20/</url>
    <content><![CDATA[<h2 id="20-填充和步幅"><a href="#20-填充和步幅" class="headerlink" title="20-填充和步幅"></a>20-填充和步幅</h2><h3 id="1-填充"><a href="#1-填充" class="headerlink" title="1. 填充"></a>1. 填充</h3><p><strong>填充</strong>(Padding)指的是在输入周围添加额外的行/列</p>
<img src="/2024/04/23/11-01-20/20-01.png" class="">
<p><strong>维度变化</strong>：</p>
<img src="/2024/04/23/11-01-20/20-02.png" class="">
<p><strong>两种不同的卷积方式</strong>：<br>①Valid 卷积：不进行填充，卷积运算过后得到的矩阵形状为(n-f+1)×(n-f+1)。 </p>
<p>②Same 卷积：先对矩阵进行填充，然后再进行卷积运算，使得运算前后矩阵大小不变。</p>
<img src="/2024/04/23/11-01-20/20-03.png" class="">
<h3 id="2-步幅"><a href="#2-步幅" class="headerlink" title="2. 步幅"></a>2. 步幅</h3><p><strong>想法来源：</strong>如果按照原来的操作(卷积步长为1)，那么给定输入大小为224x224，在使用5x5卷积核的情况下，需要<strong>55层</strong>才能将输出降低到4x4，也就是说，需要大量的计算才能得到维度较小的输出。</p>
<p><strong>步幅</strong>是指行/列的滑动步长</p>
<img src="/2024/04/23/11-01-20/20-04.png" class="">
<p><strong>维度变化</strong>:</p>
<img src="/2024/04/23/11-01-20/20-05.png" class="">
<p>注意：第三点可以当做结论来记(Same卷积或Valid卷积(且s≥k时))。一般来说，如果n是偶数，s取2，池化层做Valid卷积(不填充)且k=2，此时输出维度直接可以写成n/2 x n/2。如果怕搞混，直接记第一个公式每次现推也可。</p>
<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><ul>
<li><p>填充和步幅是卷积层的<strong>超参数</strong></p>
</li>
<li><p><strong>填充</strong>(padding)在输入周围添加额外的行/列，来控制输出形状的减少量</p>
</li>
<li><strong>步幅</strong>(stride)是每次滑动核窗口时的行/列的步长，可以成倍地减少输出形状</li>
</ul>
<h3 id="4-代码"><a href="#4-代码" class="headerlink" title="4. 代码"></a>4. 代码</h3><h4 id="4-1-填充和步幅"><a href="#4-1-填充和步幅" class="headerlink" title="4.1 填充和步幅"></a>4.1 填充和步幅</h4><p><strong>导入包，定义comp_conv2d函数  (进行卷积操作, 输出后两维，便于观察高宽的维度变化)</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">comp_conv2d</span>(<span class="params">conv2d, X</span>):</span><br><span class="line">    X = X.reshape((<span class="number">1</span>, <span class="number">1</span>) + X.shape) <span class="comment">#X的维度之前加入批量大小数(batch_size)和输入通道数(channel_in)</span></span><br><span class="line">    Y = conv2d(X)                    </span><br><span class="line">    <span class="keyword">return</span> Y.reshape(Y.shape[<span class="number">2</span>:])  <span class="comment">#去掉前面的两维后(原来四维) 进行输出</span></span><br></pre></td></tr></table></figure>
<h4 id="4-2-padding"><a href="#4-2-padding" class="headerlink" title="4.2 padding"></a>4.2 padding</h4><p><strong>在所有侧边填充1个像素(padding=1, 即(1,1))</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conv2d = nn.Conv2d(<span class="number">1</span>, <span class="number">1</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>) <span class="comment">#输入输出通道数为1, 卷积核大小3x3, 填充为1(上下左右各填充一行)</span></span><br><span class="line">X = torch.rand(size=(<span class="number">8</span>, <span class="number">8</span>))         </span><br><span class="line">comp_conv2d(conv2d, X).shape</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.Size([<span class="number">8</span>, <span class="number">8</span>])</span><br></pre></td></tr></table></figure>
<p><strong>填充不同的高度和宽度(padding=(2,1))</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conv2d = nn.Conv2d(<span class="number">1</span>, <span class="number">1</span>, kernel_size=(<span class="number">5</span>, <span class="number">3</span>), padding=(<span class="number">2</span>, <span class="number">1</span>))</span><br><span class="line">comp_conv2d(conv2d, X).shape</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.Size([<span class="number">8</span>, <span class="number">8</span>])</span><br></pre></td></tr></table></figure>
<h4 id="4-3-stride"><a href="#4-3-stride" class="headerlink" title="4.3 stride"></a>4.3 stride</h4><p><strong>将高度和宽度的步幅设置为2</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conv2d = nn.Conv2d(<span class="number">1</span>, <span class="number">1</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>, stride=<span class="number">2</span>)</span><br><span class="line">comp_conv2d(conv2d, X).shape</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.Size([<span class="number">4</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure>
<p><strong>一个稍微复杂的例子</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conv2d = nn.Conv2d(<span class="number">1</span>, <span class="number">1</span>, kernel_size=(<span class="number">3</span>, <span class="number">5</span>), padding=(<span class="number">0</span>, <span class="number">1</span>), stride=(<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">comp_conv2d(conv2d, X).shape</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.Size([<span class="number">2</span>, <span class="number">2</span>])</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>30 第二部分完结竞赛：图片分类</title>
    <url>/2024/04/23/11-01-30/</url>
    <content><![CDATA[<h2 id="30-第二部分完结竞赛：图片分类"><a href="#30-第二部分完结竞赛：图片分类" class="headerlink" title="30 第二部分完结竞赛：图片分类"></a>30 第二部分完结竞赛：图片分类</h2><p>竞赛地址：<a href="https://www.kaggle.com/c/classify-leaves">https://www.kaggle.com/c/classify-leaves</a></p>
<p>任务：给出叶子图片预测树种，共20000张图，176类，每类至少50张图。训练样本18353张，测试样本8800张。</p>
<p>这次公榜私榜是随机分的，正常来说两榜的名次差别不会太大。</p>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>31-CPU和GPU</title>
    <url>/2024/04/23/11-01-31/</url>
    <content><![CDATA[<h1 id="CPU和GPU"><a href="#CPU和GPU" class="headerlink" title="CPU和GPU"></a>CPU和GPU</h1><h3 id="1-CPU："><a href="#1-CPU：" class="headerlink" title="1.CPU："></a>1.CPU：</h3><h4 id="1-1-提升CPU利用率一："><a href="#1-1-提升CPU利用率一：" class="headerlink" title="1.1 提升CPU利用率一："></a>1.1 提升CPU利用率一：</h4><ul>
<li>在计算a+b之前，需要准备数据</li>
<li><p>主内存-&gt;L3-&gt;L2-&gt;L1-&gt;寄存器</p>
<ul>
<li>L1访问延时：0.5ms</li>
<li>L2访问延时：7ns（14XL1）</li>
<li>主内存访问延时：100ns(200XL1)</li>
</ul>
</li>
<li><p>提升空间和时间的内存本地性</p>
<ul>
<li>时间：重用数据使它们在缓存里</li>
<li>空间：按序读写数据是的可以预读取</li>
</ul>
</li>
</ul>
<h4 id="1-2-样例分析："><a href="#1-2-样例分析：" class="headerlink" title="1.2 样例分析："></a>1.2 样例分析：</h4><ul>
<li>如果一个矩阵是按行存储，访问一行比访问一列要快<ul>
<li>CPU一次读取64字节（缓存线）</li>
<li>CPU会“聪明的”提前读取下一个（缓存线）</li>
</ul>
</li>
</ul>
<img src="/2024/04/23/11-01-31/31-01.png" class="">
<h4 id="1-3-提升CPU利用率二："><a href="#1-3-提升CPU利用率二：" class="headerlink" title="1.3 提升CPU利用率二："></a>1.3 提升CPU利用率二：</h4><ul>
<li><p>高端CPU有几十个核</p>
<ul>
<li>EC2 P3.16xlarge:2 Intel Xeon CPUs,32物理核</li>
</ul>
</li>
<li><p>并行来利用所用核</p>
<ul>
<li>超线程不一定提升性能，因为他们共享寄存器</li>
</ul>
</li>
</ul>
<h4 id="1-4-样例分析："><a href="#1-4-样例分析：" class="headerlink" title="1.4 样例分析："></a>1.4 样例分析：</h4><ul>
<li>左边比右边慢（python）</li>
</ul>
<img src="/2024/04/23/11-01-31/31-02.png" class="">
<ul>
<li>左边调用n次函数，每次调用有开销</li>
<li>右边很容易被并行（例如下面的C++实现）</li>
</ul>
<img src="/2024/04/23/11-01-31/31-03.png" class="">
<h3 id="2-CPU-vs-GPU"><a href="#2-CPU-vs-GPU" class="headerlink" title="2.CPU vs GPU:"></a>2.CPU vs GPU:</h3><img src="/2024/04/23/11-01-31/31-04.png" class="">
<h4 id="2-1-提升GPU利用率"><a href="#2-1-提升GPU利用率" class="headerlink" title="2.1 提升GPU利用率"></a>2.1 提升GPU利用率</h4><ul>
<li><p>并行</p>
<ul>
<li>使用数千个线程</li>
</ul>
</li>
<li><p>内存本地性</p>
<ul>
<li>缓存更小，架构更简单</li>
</ul>
</li>
<li><p>少用控制语句</p>
<ul>
<li>支持有限</li>
<li>同步开销大</li>
</ul>
</li>
</ul>
<h4 id="2-2-CPU-GPU-带宽"><a href="#2-2-CPU-GPU-带宽" class="headerlink" title="2.2 CPU/GPU 带宽"></a>2.2 CPU/GPU 带宽</h4><img src="/2024/04/23/11-01-31/31-05.png" class="">
<h4 id="2-3-更多的CPUs和GPUs"><a href="#2-3-更多的CPUs和GPUs" class="headerlink" title="2.3 更多的CPUs和GPUs"></a>2.3 更多的CPUs和GPUs</h4><ul>
<li>CPU:AMD,ARM</li>
<li>GPU:AMD,Intel,ARM,Qualcomm…</li>
</ul>
<h4 id="2-4-CPU-GPU高性能计算编程"><a href="#2-4-CPU-GPU高性能计算编程" class="headerlink" title="2.4 CPU/GPU高性能计算编程"></a>2.4 CPU/GPU高性能计算编程</h4><ul>
<li>CPU：C++或者任何高性能语言<ul>
<li>编译器成熟</li>
</ul>
</li>
<li>GPU<ul>
<li>Nvida上用CUDA<ul>
<li>编译器和驱动成熟</li>
</ul>
</li>
<li>其他用OpenCL<ul>
<li>质量取决于硬件厂商</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h3><ul>
<li>CPU:可以处理通用计算。性能优化考虑数据读写效率和多线程</li>
<li>GPU：使用更多的小核和更好的内存带宽，适合能大规模并行的计算任务</li>
</ul>
<h3 id="4-Q-amp-A"><a href="#4-Q-amp-A" class="headerlink" title="4.Q&amp;A"></a>4.Q&amp;A</h3><h5 id="Q1-如果要提高泛化性，就要增加数据？调参的意思是不是最大？"><a href="#Q1-如果要提高泛化性，就要增加数据？调参的意思是不是最大？" class="headerlink" title="Q1:  如果要提高泛化性，就要增加数据？调参的意思是不是最大？"></a>Q1:  如果要提高泛化性，就要增加数据？调参的意思是不是最大？</h5><blockquote>
<p>提高泛化性的有效手段是增加数据，但是数据的质量很重要，少量高质量数据和大量低质量数据可能有1:10或者1:100的换算关系。实际应用场景对调参要求不高，因为有不断增加的数据。</p>
</blockquote>
<h5 id="Q2-alexnet模型比resnet要大，为什么计算上resnet比alexnet运算量大？"><a href="#Q2-alexnet模型比resnet要大，为什么计算上resnet比alexnet运算量大？" class="headerlink" title="Q2:alexnet模型比resnet要大，为什么计算上resnet比alexnet运算量大？"></a>Q2:alexnet模型比resnet要大，为什么计算上resnet比alexnet运算量大？</h5><blockquote>
<p>alexnet后面用到的几个连续的全连接层使模型变大，但是resnet使用的卷积层在少量参数下更消耗计算资源。模型大小和计算复杂度不能直接换算。</p>
</blockquote>
<h5 id="Q3-训练时为什么使用w-lr-w-grad-而不写做w-w-lr-w-grad"><a href="#Q3-训练时为什么使用w-lr-w-grad-而不写做w-w-lr-w-grad" class="headerlink" title="Q3:训练时为什么使用w-=lr*w.grad,而不写做w=w-lr*w.grad?"></a>Q3:训练时为什么使用w-=lr*w.grad,而不写做w=w-lr*w.grad?</h5><blockquote>
<p>因为第二种写法定义了一个新的tensor，梯度参数会成为false</p>
</blockquote>
<h5 id="Q4-llc是显存还是缓存，是l1-l2-还是l3"><a href="#Q4-llc是显存还是缓存，是l1-l2-还是l3" class="headerlink" title="Q4:llc是显存还是缓存，是l1,l2,还是l3?"></a>Q4:llc是显存还是缓存，是l1,l2,还是l3?</h5><blockquote>
<p>llc是缓存，last level cash,是最后一层缓存，具体是ln取决于一共有几层缓存。</p>
</blockquote>
<h5 id="Q5-做计算时把for-lopps运算尽可能向量化？"><a href="#Q5-做计算时把for-lopps运算尽可能向量化？" class="headerlink" title="Q5:做计算时把for_lopps运算尽可能向量化？"></a>Q5:做计算时把for_lopps运算尽可能向量化？</h5><blockquote>
<p>是的，尽量不要用python写for-loop</p>
</blockquote>
<h5 id="Q6-可视化时，需要把数据在cpu和GPU之间切换，如何避免频繁传输？常见的错误操作有哪些？怎么看到和排查这种错误？"><a href="#Q6-可视化时，需要把数据在cpu和GPU之间切换，如何避免频繁传输？常见的错误操作有哪些？怎么看到和排查这种错误？" class="headerlink" title="Q6:可视化时，需要把数据在cpu和GPU之间切换，如何避免频繁传输？常见的错误操作有哪些？怎么看到和排查这种错误？"></a>Q6:可视化时，需要把数据在cpu和GPU之间切换，如何避免频繁传输？常见的错误操作有哪些？怎么看到和排查这种错误？</h5><blockquote>
<p>可视化操作不需要太担心，只要不是计算中来回传递就好。深度学习框架会有限制，只能在一个设备上做。框架没报错一般不会有太多问题</p>
</blockquote>
<h5 id="Q7-go怎么样？"><a href="#Q7-go怎么样？" class="headerlink" title="Q7:go怎么样？"></a>Q7:go怎么样？</h5><blockquote>
<p>go分布式系统做的很好，和深度学习的分布式不太一样</p>
</blockquote>
<h5 id="Q8-怎样复现论文？"><a href="#Q8-怎样复现论文？" class="headerlink" title="Q8:怎样复现论文？"></a>Q8:怎样复现论文？</h5><blockquote>
<p>80%的论文无法复现，要读懂每一句话，和明白作者实现的细节。</p>
</blockquote>
<h5 id="Q9：分布式和高性能的区别？"><a href="#Q9：分布式和高性能的区别？" class="headerlink" title="Q9：分布式和高性能的区别？"></a>Q9：分布式和高性能的区别？</h5><blockquote>
<p>没有本质区别，分布式更多考虑容错。高性能是分布式的一个应用</p>
</blockquote>
<h5 id="Q10-自动驾驶烧钱，短时间难以落地是不是和nas一样？"><a href="#Q10-自动驾驶烧钱，短时间难以落地是不是和nas一样？" class="headerlink" title="Q10:自动驾驶烧钱，短时间难以落地是不是和nas一样？"></a>Q10:自动驾驶烧钱，短时间难以落地是不是和nas一样？</h5><blockquote>
<p>不是，自动驾驶有很好的商业前景。nas没有太多意义。</p>
</blockquote>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>32-深度学习硬件</title>
    <url>/2024/04/23/11-01-32/</url>
    <content><![CDATA[<h2 id="32-深度学习硬件"><a href="#32-深度学习硬件" class="headerlink" title="32-深度学习硬件"></a>32-深度学习硬件</h2><h3 id="1-DSP-数字信号处理"><a href="#1-DSP-数字信号处理" class="headerlink" title="1.DSP:数字信号处理"></a>1.DSP:数字信号处理</h3><ul>
<li><p>为数字信号处理算法设计：点积、卷积、FFT</p>
</li>
<li><p>低功耗，高性能</p>
<ul>
<li>比移动GPU快5倍，功耗更低</li>
</ul>
</li>
<li>VLIW：very long instruction word<ul>
<li>频率低，核少，但是一条指令可以进行上百次的累加，便于重复</li>
</ul>
</li>
<li>缺点：编程和调试困难，编译器良莠不齐（做的人少，工具不是很好用）</li>
</ul>
<h3 id="2-可编程阵列（FPGA）"><a href="#2-可编程阵列（FPGA）" class="headerlink" title="2.可编程阵列（FPGA）"></a>2.可编程阵列（FPGA）</h3><ul>
<li>有大量的可以用来编程的逻辑单元和可配置链接</li>
<li>可以配置成计算复杂函数<ul>
<li>编程语言：VHDL Verilog</li>
</ul>
</li>
<li>通常比通用硬件更高效，但是体积更大不方便</li>
<li>缺点：工具链质量良莠不齐，一次编译需要数个小时（烧一次板子，物理上的改变）</li>
<li>用途：主要用来模拟，看看效果好不好，如果好可以进一步造芯片</li>
</ul>
<h3 id="3-AI-ASIC"><a href="#3-AI-ASIC" class="headerlink" title="3.AI ASIC"></a>3.AI ASIC</h3><ul>
<li>深度学习热门领域（针对特定领域）<ul>
<li>大公司都在造自己的芯片（Intel Qualcomm Google Amazon Facebook）</li>
</ul>
</li>
<li>Google TPU 是标志性芯片（听说在Google内部已经盛行 取代GPU了）<ul>
<li>能够媲美 Nvidia GPU性能</li>
<li>在Google 大量部署</li>
<li>核心是 systolic array（时间快 容易造）</li>
</ul>
</li>
<li>systolic array<ul>
<li>计算单元（PE）阵列</li>
<li>特别适合做矩阵乘法</li>
<li>设计和制造相对简单（核少）</li>
<li>矩阵乘法例子：见PPT<ul>
<li>对于一般的矩阵乘法：通过切开、填充来匹配SA大小</li>
<li>批量输入来降低延迟（避免空等，先出的硬件空闲）</li>
<li>通常有其他硬件单元来处理别的NN操作子，例如激活层</li>
</ul>
</li>
<li>缺点：只针对深度学习这方面有用，别的方面效果不大</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>灵活性、易用性：Intel(CPU) &gt; GPU &gt; DSP &gt; FPGA &gt; ASIC</li>
<li>性能功耗：Intel(CPU) &lt; GPU &lt; DSP &lt; FPGA &lt; ASIC</li>
</ul>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>27-GooLeNet</title>
    <url>/2024/04/18/15-40-53/</url>
    <content><![CDATA[<h2 id="GooLeNet"><a href="#GooLeNet" class="headerlink" title="GooLeNet"></a>GooLeNet</h2><h4 id="含并行连结的网络"><a href="#含并行连结的网络" class="headerlink" title="含并行连结的网络"></a>含并行连结的网络</h4><ul>
<li>GoogLeNet吸收了NiN中串联网络的思想，并在此基础上做了改进。我们往往不确定到底选取什么样的层效果更好，到底是3X3卷积层还是5X5的卷积层，诸如此类的问题是GooLeNet选择了另一种思路“小学生才做选择，我全都要”，这也使得GooLeNet成为了第一个模型中超过1000个层的模型。</li>
</ul>
<h4 id="Inception块"><a href="#Inception块" class="headerlink" title="Inception块"></a>Inception块</h4><ul>
<li><p>在GoogLeNet中，基本的卷积块被称为<em>Inception块</em>（Inception block）</p>
<p><img src="https://github.com/kinza99/DeepLearning-MuLi-Notes/blob/main/imgs/27/27-1.png" alt="截屏2022-01-23 上午10.11.18"></p>
</li>
<li><p>Inception块由四条并行路径组成。 前三条路径使用窗口大小为1×11×1、3×33×3和5×55×5的卷积层，从不同空间大小中提取信息。 中间的两条路径在输入上执行1×11×1卷积，以减少通道数，从而降低模型的复杂性。 第四条路径使用3×33×3最大汇聚层，然后使用1×11×1卷积层来改变通道数。 这四条路径都使用合适的填充来使输入与输出的高和宽一致，最后我们将每条线路的输出在通道维度上连结，并构成Inception块的输出。在Inception块中，通常调整的超参数是每层输出通道数。</p>
</li>
</ul>
<h4 id="GooLeNet模型"><a href="#GooLeNet模型" class="headerlink" title="GooLeNet模型"></a>GooLeNet模型</h4><ul>
<li>GoogLeNet一共使用9个Inception块和全局平均汇聚层的堆叠来生成其估计值。Inception块之间的最大汇聚层可降低维度。 第一个模块类似于AlexNet和LeNet，Inception块的组合从VGG继承，全局平均汇聚层避免了在最后使用全连接层。<img src="https://github.com/kinza99/DeepLearning-MuLi-Notes/blob/main/imgs/27/27-2.png" alt="截屏2022-01-23 上午10.17.11"></li>
<li>第一个模块是7×7卷积层。</li>
<li>第二个模块使用两个卷积层：第一个卷积层是1×1卷积层；第二个卷积层使用将通道数量增加三倍的3×3卷积层。 这对应于Inception块中的第二条路径。</li>
<li>第三个模块串联两个完整的Inception块。 第一个Inception块的输出通道数为64+128+32+32=25664+128+32+32=256，四个路径之间的输出通道数量比为64:128:32:32=2:4:1:164:128:32:32=2:4:1:1。 第二个和第三个路径首先将输入通道的数量分别减少到96/192=1/296/192=1/2和16/192=1/1216/192=1/12，然后连接第二个卷积层。第二个Inception块的输出通道数增加到128+192+96+64=480128+192+96+64=480，四个路径之间的输出通道数量比为128:192:96:64=4:6:3:2128:192:96:64=4:6:3:2。 第二条和第三条路径首先将输入通道的数量分别减少到128/256=1/2128/256=1/2和32/256=1/832/256=1/8。</li>
<li>第四模块更加复杂， 它串联了5个Inception块，其输出通道数分别是192+208+48+64=512192+208+48+64=512、160+224+64+64=512160+224+64+64=512、128+256+64+64=512128+256+64+64=512、112+288+64+64=528112+288+64+64=528和256+320+128+128=832256+320+128+128=832。 这些路径的通道数分配和第三模块中的类似，首先是含3×3卷积层的第二条路径输出最多通道，其次是仅含1×1卷积层的第一条路径，之后是含5×5卷积层的第三条路径和含3×3最大汇聚层的第四条路径。 其中第二、第三条路径都会先按比例减小通道数。 这些比例在各个Inception块中都略有不同。</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li><p>Inception块相当于一个有4条路径的子网络。它通过不同窗口形状的卷积层和最大汇聚层来并行抽取信息，并使用1×1卷积层减少每像素级别上的通道维数从而降低模型复杂度。</p>
</li>
<li><p>GoogLeNet将多个设计精细的Inception块与其他层（卷积层、全连接层）串联起来。其中Inception块的通道数分配之比是在ImageNet数据集上通过大量的实验得来的。</p>
</li>
<li><p>GoogLeNet和它的后继者们一度是ImageNet上最有效的模型之一：它以较低的计算复杂度提供了类似的测试精度。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>33-单机多卡并行</title>
    <url>/2024/04/23/11-01-34/</url>
    <content><![CDATA[<h2 id="单机多卡并行"><a href="#单机多卡并行" class="headerlink" title="单机多卡并行"></a>单机多卡并行</h2><p>一台机器可以安装多个GPU（一般为1-16个），在训练和预测时可以将一个小批量计算切分到多个GPU上来达到加速目的，常用的切分方案有数据并行，模型并行，通道并行。</p>
<h3 id="数据并行"><a href="#数据并行" class="headerlink" title="数据并行"></a>数据并行</h3><p>将小批量的数据分为n块，每个GPU拿到完整的参数，对这一块的数据进行前向传播与反向传播，计算梯度。</p>
<p>数据并行通常性能比模型并行更好，因为对数据进行划分使得各个GPU的计算内容更加均匀。</p>
<h4 id="数据并行的大致流程"><a href="#数据并行的大致流程" class="headerlink" title="数据并行的大致流程"></a>数据并行的大致流程</h4><img src="/2024/04/23/11-01-34/DataParallel.png" class="">
<p>主要分为五部</p>
<ul>
<li>1：每个GPU读取一个数据块（灰色部分）</li>
<li>2：每个GPU读取当前模型的参数（橙色部分）</li>
<li>3：每个GPU计算自己拿到数据块的梯度（绿色部分）</li>
<li>4：GPU将计算得到的梯度传给内存（CPU）（绿色箭头）</li>
<li>5：利用梯度对模型参数进行更新（橙色箭头）</li>
</ul>
<p>数据并行并行性较好，主要因为当每个GPU拿到的数据量相同时计算量也相似，各个GPU的运算时间相近，幸能较好</p>
<h3 id="模型并行"><a href="#模型并行" class="headerlink" title="模型并行"></a>模型并行</h3><p>将整个模型分为n个部分，每个GPU拿到这个部分的参数和负责上一个部分的GPU的输出作为输入来进行计算，反向传播同理。</p>
<p>模型并行通常用于模型十分巨大，参数众多，即使在每个mini-batch只有一个样本的情况下单个GPU的显存仍然不够的情况，但并行性较差，可能有时会有GPU处于等待状态。</p>
<h3 id="通道并行"><a href="#通道并行" class="headerlink" title="通道并行"></a>通道并行</h3><p>通道并行是数据并行和模型并行同时进行</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>当一个模型能用单卡计算时，通常使用数据并行扩展到多卡</li>
<li>模型并行则用在超大模型上</li>
</ul>
<h3 id="Q-amp-A（部分有价值的）"><a href="#Q-amp-A（部分有价值的）" class="headerlink" title="Q&amp;A（部分有价值的）"></a>Q&amp;A（部分有价值的）</h3><ul>
<li>问1：若有4块GPU，两块显存大两块显存小怎么办？</li>
<li>答1：<br>若GPU运算性能相同，则训练取决于小显存的GPU的显存大小，更大的显存相当于浪费掉<br>若GPU运算性能不同，一般即为显存大的GPU性能更好，可以在分配数据时多分配一点</li>
<li></li>
<li>问2：数据拆分后，需存储的数据量会变大吗？会降低性能吗？</li>
<li>答2：每个GPU都单独存储了一份模型，这部分的数据量变大了，但如果只考虑运算时的中间变量，则中间变量的大小与数据量呈线性关系，每个GPU的数据小了，中间变量也会变小，所有GPU的中间变量加起来大小是不变的。<br>数据拆分后性能会变低，在下节课讲解（数据通讯的开销，每个GPU的batch-size变小可能无法跑满GPU，总batch-size变大则相同计算量下训练次数变少）</li>
</ul>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>34-多GPU训练实现</title>
    <url>/2024/04/23/11-01-34/</url>
    <content><![CDATA[<h2 id="34-多GPU训练实现"><a href="#34-多GPU训练实现" class="headerlink" title="34 多GPU训练实现"></a>34 多GPU训练实现</h2><p>本讲内容为代码实现，这里整理QA，其余内容参考代码部分。</p>
<p>Q1: keras从tf分离，书籍会不会需要重新整理？</p>
<blockquote>
<p>暂时不会有影响</p>
</blockquote>
<p>Q2: 是否可以通过把resnet中的卷积层全替换成mlp来实现一个很深的网络？</p>
<blockquote>
<p>可以，有这样做的paper，但是通过一维卷积（等价于全连接层）做的，如果直接换成全连接层很可能会过拟合。</p>
</blockquote>
<p>Q3: 为什么batch norm是一种正则但只加快训练不提升精度？</p>
<blockquote>
<p>老师也不太清楚并认为这是很好的问题，可以去查阅论文。</p>
</blockquote>
<p>Q4: all_reduce, all_gather主要起什么作用？实际使用时发现pytorch的类似分布式op不能传导梯度，会破坏计算图不能自动求导，如何解决？</p>
<blockquote>
<p>all_reduce是把n个东西加在一起再把所有东西复制回去，all_gather则只是把来自不同地方东西合并但不相加。使用分布式的东西会破坏自动求导，跨GPU的自动求导并不好做，老师不确定pytorch能不能做到这一功能，如果不能就只能手写。</p>
</blockquote>
<p>Q5: 两个GPU训练时最后的梯度是把两个GPU上的梯度相加吗？</p>
<blockquote>
<p>是的。mini-batch的梯度就是每个样本的梯度求和，多GPU时同理，每个GPU向将自己算的那部分样本梯度求和，最后再将两个GPU的计算得的梯度求和。</p>
</blockquote>
<p>Q6: 为什么参数大的模型不一定慢？flop数多的模型性能更好是什么原理？</p>
<blockquote>
<p>性能取决于每算一个乘法需要访问多少个bit，计算量与内存访问的比值越高越好。通常CPU/GPU不会被卡在频率上而是访问数据/内存上，所以参数量小，算力高的模型性能较好（如卷积，矩阵乘法）。</p>
</blockquote>
<p>Q7: 为什么分布到多GPU上测试精度会比单GPU抖动大？</p>
<blockquote>
<p>抖动是因为学习率变大了，使用GPU数对测试精度没有影响，只会影响性能。但为了得到更好的速度需要把batchsize调大，使得收敛情况发生变化，把学习率上调就使得精度更抖。</p>
</blockquote>
<p>Q8: batchsize太大会导致loss nan吗？</p>
<blockquote>
<p>不会，batchsize中的loss是求均值的，理论上batchsize更大数值稳定性会更好，出现数值不稳定问题可能是学习率没有调好。</p>
</blockquote>
<p>Q9: GPU显存如何优化？</p>
<blockquote>
<p>显存手动优化很难，靠的是框架，pytorch的优化做的还不错。除非特别懂框架相关技术不然建议把batchsize调小或是把模型做简单一点。</p>
</blockquote>
<p>Q10: 对于精度来说batchsize=1是一种最好的情况吗？</p>
<blockquote>
<p>可能是。</p>
</blockquote>
<p>Q11: parameter server可以和pytorch结合吗，具体如何实现？</p>
<blockquote>
<p>pytorch没有实现parameter server，但mxnet和tensorflow有。但是有第三方实现如byteps支持pytorch。</p>
</blockquote>
<p>Q12: 用了nn.DataParallel()，是不是数据集也被自动分配到了多个GPU上？</p>
<blockquote>
<p>是的。在算net.forward()的时候会分开。</p>
</blockquote>
<p>Q13: 验证集准确率震荡大那个参数影响最大？</p>
<blockquote>
<p>学习率。</p>
</blockquote>
<p>Q14: 为了让网络前几层能够训练能否采用不同stage采用不同学习率的方法？</p>
<blockquote>
<p>可以，主要的问题是麻烦，不好确定各部分学习率相差多少。</p>
</blockquote>
<p>Q15: 在用torch的数据并行中将inputs和labels放到GPU0是否会导致性能问题，因为这些数据最终回被挪一次到其他GPU上。</p>
<blockquote>
<p>数据相比梯度来说很少，不会对性能有太大影响。但这个操作看上去的确很多余，老师认为不需要做，但不这样做会报错。</p>
</blockquote>
<p>Q16: 为什么batchsize较小精度会不怎么变化？</p>
<blockquote>
<p>学习率太大了，batchsize小学习率就不能太大。</p>
</blockquote>
<p>Q17: 使用两块不同型号GPU影响深度学习性能吗？</p>
<blockquote>
<p>需要算好两块GPU的性能差。如一块GPU的性能是另一块的2倍，那么在分配任务时也应该分得2倍的任务量。保证各GPU在同样时间内算完同一部分。</p>
</blockquote>
<p>Q18: 课内竞赛直接用教材的VGG11但不收敛，同样的dataloader用resnet可以收敛，如何解决这一问题？</p>
<blockquote>
<p>可能是学习率太大，也可考虑加入batch normalization。</p>
</blockquote>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>35-分布式训练</title>
    <url>/2024/04/23/11-01-35/</url>
    <content><![CDATA[<h2 id="35-分布式训练"><a href="#35-分布式训练" class="headerlink" title="35-分布式训练"></a>35-分布式训练</h2><h3 id="1-分布式计算"><a href="#1-分布式计算" class="headerlink" title="1.分布式计算"></a>1.分布式计算</h3><ul>
<li>本质上来说和之前讲的单机多卡并行没有区别。二者之间的区别是分布式计算是通过网络把数据从一台机器搬到另一台机器</li>
</ul>
<img src="/2024/04/23/11-01-35/35-01.png" class="">
<h3 id="2-GPU机器架构"><a href="#2-GPU机器架构" class="headerlink" title="2. GPU机器架构"></a>2. GPU机器架构</h3><ul>
<li>总的来说，gpu到gpu的通讯是很快的，gpu到cpu慢一点。机器到机器更慢。因而总体性能的关键就是尽量在本地做通讯而少在机器之间做通讯</li>
</ul>
<h5 id="2-1-样例：计算一个小批量"><a href="#2-1-样例：计算一个小批量" class="headerlink" title="2.1 样例：计算一个小批量"></a>2.1 样例：计算一个小批量</h5><ul>
<li>每个worker从参数服务器那里获取模型参数：首先把样本复制到机器的内存，然后把样本分到每个gpu上</li>
<li>复制参数到每个gpu上：同样，先把每一次的参数放到内存里，然后再复制到每个gpu上</li>
<li>每个gpu计算梯度</li>
<li>再主内存上把所有gpu上的梯度加起来</li>
<li>梯度从主内存传回服务器</li>
<li>每个服务器对梯度求和，并更新参数</li>
</ul>
<h5 id="2-2-总结"><a href="#2-2-总结" class="headerlink" title="2.2 总结"></a>2.2 总结</h5><ul>
<li>由于gpu到gpu和gpu到内存的通讯速度还不错，因此我们尽量再本地做聚合（如梯度相加），并减少再网络上的多次通讯</li>
</ul>
<h3 id="3-关于性能"><a href="#3-关于性能" class="headerlink" title="3.  关于性能"></a>3.  关于性能</h3><h5 id="3-1-对于同步SGD："><a href="#3-1-对于同步SGD：" class="headerlink" title="3.1 对于同步SGD："></a>3.1 对于<strong>同步SGD</strong>：</h5><ul>
<li>这里每个worker都是同步计算一个批量，称为同步SGD</li>
<li>假设有n个ggpu，每个gpu每次处理b个样本，那么同步SGD等价于再单gpu运行批量大小为nb的SGD</li>
<li>再理想情况下，n个gpu可以得到相对单gpu的n倍加速</li>
</ul>
<h5 id="3-2-性能："><a href="#3-2-性能：" class="headerlink" title="3.2 性能："></a>3.2 <strong>性能</strong>：</h5><ul>
<li>t1 = 在单gpu上计算b个样本梯度时间</li>
<li>假设有m个参数，一个worker每次发送和接受m个参数、梯度<ul>
<li>t2 = 发送和接受所用时间</li>
</ul>
</li>
<li>每个批量的计算时间为max（t1，t2）<ul>
<li>选取足够大的b使t1&gt;t2</li>
<li>增加b或n导致更大的批量 大小，当值需要更多计算来得到给定的模型精度</li>
</ul>
</li>
</ul>
<h5 id="3-3-性能的权衡"><a href="#3-3-性能的权衡" class="headerlink" title="3.3 性能的权衡"></a>3.3 性能的权衡</h5><img src="/2024/04/23/11-01-35/35-02.png" class="">
<h3 id="4-实践时的建议"><a href="#4-实践时的建议" class="headerlink" title="4. 实践时的建议"></a>4. 实践时的建议</h3><ul>
<li>使用一个大数据集</li>
<li>需要好的gpu-gpu和机器-机器带宽</li>
<li>高效的数据读取和预处理</li>
<li>模型需要有好的计算和通讯比<ul>
<li>Inception&gt;ResNet&gt;AlexNet</li>
</ul>
</li>
<li>使用足够大的批量大小来得到更好的系统性能</li>
<li>使用高效的优化算法对应大批量大小</li>
</ul>
<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><ul>
<li>分布式同步数据并行是多gpu数据并行在多机器上的拓展</li>
<li>网络通讯通常是瓶颈</li>
<li>需要注意使用特别大的批量大小时的收敛效率</li>
<li>更复杂的分布式有异步、模型并行（这里没有介绍）</li>
</ul>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>29-残差网络（ResNet）</title>
    <url>/2024/04/23/11-01-29/</url>
    <content><![CDATA[<h3 id="残差网络（ResNet）"><a href="#残差网络（ResNet）" class="headerlink" title="残差网络（ResNet）"></a>残差网络（ResNet）</h3><p>随着我们设计越来越深的网络，深刻理解“新添加的层如何提升神经网络的性能”变得至关重要。更重要的是设计网络的能力，在ResNet这种网络中，添加层会使网络更具表现力</p>
<h4 id="函数类"><a href="#函数类" class="headerlink" title="函数类"></a>函数类</h4><ul>
<li>假设有一类特定的神经网络架构F，它包括学习速率和其他超参数设置。 对于所有<em>f</em>∈F，存在一些参数集（例如权重和偏置），这些参数可以通过在合适的数据集上进行训练而获得。 现在假设<em>f</em>∗是我们真正想要找到的函数，如果是<em>f</em>∗∈F，那我们可以轻而易举的训练得到它，但通常我们不会那么幸运。 相反，我们将尝试找到一个函数<em>f</em>∗，这是我们在F中的最佳选择。</li>
<li>为了得到更近似真正<em>f</em>∗的函数我们需要设计一个更强大的架构F’，但是如果先前的框架F不包含于新框架F‘中就可能导致如下图中左侧的最优函数离实际预测函数误差反而随框架边强而增大，这不是我们期望的结果，所以我们选择使用下图中右侧的嵌套函数类以解决这个问题</li>
<li>引入方法：对于深度神经网络，如果我们能将新添加的层训练成<em>恒等映射</em>（identity function）<em>f</em>(<strong>x</strong>)=<strong>x</strong>，新模型和原模型将同样有效。 同时，由于新模型可能得出更优的解来拟合训练数据集，因此添加层似乎更容易降低训练误差。</li>
</ul>
<img src="/2024/04/23/11-01-29/29-01.png" class="">
<img src="/2024/04/23/11-01-29/29-02.png" class="">
<h4 id="残差块"><a href="#残差块" class="headerlink" title="残差块"></a>残差块</h4><ul>
<li><p>神经网络中的具体实现：假设我们的原始输入为<em>x</em>，而希望学出的理想映射为<em>f</em>(<strong>x</strong>)，左图虚线框中的部分需要直接拟合出该映射<em>f</em>(<strong>x</strong>)，而右图虚线框中的部分则需要拟合出残差映射<em>f</em>(<strong>x</strong>)−<strong>x</strong>。而右图正是ResNet的基础架构–<em>残差块</em>（residual block）</p>
</li>
<li><p>残差块的代码实现：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Residual</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, input_channels, num_channels,</span></span><br><span class="line"><span class="params">                 use_1x1conv=<span class="literal">False</span>, strides=<span class="number">1</span></span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="comment"># 第一个卷积层</span></span><br><span class="line">        self.conv1 = nn.Conv2d(input_channels, num_channels,</span><br><span class="line">                               kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>, stride=strides)</span><br><span class="line">        <span class="comment"># 第二个卷积层</span></span><br><span class="line">        self.conv2 = nn.Conv2d(num_channels, num_channels,</span><br><span class="line">                               kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 如果使用1 x 1卷积以使得输入变换成需要的形状</span></span><br><span class="line">        <span class="keyword">if</span> use_1x1conv:</span><br><span class="line">            self.conv3 = nn.Conv2d(input_channels, num_channels,</span><br><span class="line">                                   kernel_size=<span class="number">1</span>, stride=strides)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.conv3 = <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 对应第一个卷积层的批量规范化层</span></span><br><span class="line">        self.bn1 = nn.BatchNorm2d(num_channels)</span><br><span class="line">        <span class="comment"># 对应第二个卷积层的批量规范化层</span></span><br><span class="line">        self.bn2 = nn.BatchNorm2d(num_channels)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, X</span>):</span><br><span class="line">        <span class="comment"># 第一层：卷积 -&gt; 规范化 -&gt; relu激活</span></span><br><span class="line">        Y = F.relu(self.bn1(self.conv1(X)))</span><br><span class="line">        <span class="comment"># 第二层：卷积 -&gt; 规范化</span></span><br><span class="line">        Y = self.bn2(self.conv2(Y))</span><br><span class="line">        <span class="comment"># 如果要让输入变换成需要的形状</span></span><br><span class="line">        <span class="keyword">if</span> self.conv3:</span><br><span class="line">            <span class="comment"># 对X使用1 x 1卷积，以使输出成为需要的形状</span></span><br><span class="line">            X = self.conv3(X)</span><br><span class="line">        <span class="comment"># 嵌套模型的实现，即对上一次训练后的模型进行嵌套</span></span><br><span class="line">        Y += X</span><br><span class="line">        <span class="comment"># relu激活并输出</span></span><br><span class="line">        <span class="keyword">return</span> F.relu(Y)</span><br></pre></td></tr></table></figure>
<img src="/2024/04/23/11-01-29/29-03.png" class="">
<h4 id="ResNet模型"><a href="#ResNet模型" class="headerlink" title="ResNet模型"></a>ResNet模型</h4><ul>
<li>ResNet的前两层跟之前介绍的GoogLeNet中的一样： 在输出通道数为64、步幅为2的7×7卷积层后，接步幅为2的3×3的最大汇聚层。 不同之处在于ResNet每个卷积层后增加了批量规范化层。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b1 = nn.Sequential(nn.Conv2d(<span class="number">1</span>, <span class="number">64</span>, kernel_size=<span class="number">7</span>, stride=<span class="number">2</span>, padding=<span class="number">3</span>),</span><br><span class="line">                   nn.BatchNorm2d(<span class="number">64</span>), nn.ReLU(),</span><br><span class="line">                   nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>, padding=<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<ul>
<li>GoogLeNet在后面接了4个由Inception块组成的模块。 ResNet则使用4个由残差块组成的模块，每个模块使用若干个同样输出通道数的残差块。 第一个模块的通道数同输入通道数一致。 由于之前已经使用了步幅为2的最大汇聚层，所以无须减小高和宽。 之后的每个模块在第一个残差块里将上一个模块的通道数翻倍，并将高和宽减半。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">resnet_block</span>(<span class="params">input_channels, num_channels, num_residuals,</span></span><br><span class="line"><span class="params">                 first_block=<span class="literal">False</span></span>):</span><br><span class="line">    blk = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_residuals):</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> first_block:</span><br><span class="line">            blk.append(Residual(input_channels, num_channels,</span><br><span class="line">                                use_1x1conv=<span class="literal">True</span>, strides=<span class="number">2</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            blk.append(Residual(num_channels, num_channels))</span><br><span class="line">    <span class="keyword">return</span> blk</span><br></pre></td></tr></table></figure>
<ul>
<li>接着在ResNet加入所有残差块，这里每个模块使用2个残差块。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b2 = nn.Sequential(*resnet_block(<span class="number">64</span>, <span class="number">64</span>, <span class="number">2</span>, first_block=<span class="literal">True</span>))</span><br><span class="line">b3 = nn.Sequential(*resnet_block(<span class="number">64</span>, <span class="number">128</span>, <span class="number">2</span>))</span><br><span class="line">b4 = nn.Sequential(*resnet_block(<span class="number">128</span>, <span class="number">256</span>, <span class="number">2</span>))</span><br><span class="line">b5 = nn.Sequential(*resnet_block(<span class="number">256</span>, <span class="number">512</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<ul>
<li>最后，与GoogLeNet一样，在ResNet中加入全局平均汇聚层，以及全连接层输出。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">net = nn.Sequential(b1, b2, b3, b4, b5,</span><br><span class="line">                    nn.AdaptiveAvgPool2d((<span class="number">1</span>,<span class="number">1</span>)),</span><br><span class="line">                    nn.Flatten(), nn.Linear(<span class="number">512</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure>
<ul>
<li>每个模块有4个卷积层（不包括恒等映射的1×1卷积层）。 加上第一个7×7卷积层和最后一个全连接层，共有18层。 因此，这种模型通常被称为ResNet-18。 通过配置不同的通道数和模块里的残差块数可以得到不同的ResNet模型，例如更深的含152层的ResNet-152。 虽然ResNet的主体架构跟GoogLeNet类似，但ResNet架构更简单，修改也更方便。这些因素都导致了ResNet迅速被广泛使用。</li>
</ul>
<img src="/2024/04/23/11-01-29/29-04.png" class="">
<h4 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h4><ul>
<li>我们在Fashion-MNIST数据集上训练ResNet</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lr, num_epochs, batch_size = <span class="number">0.05</span>, <span class="number">10</span>, <span class="number">256</span></span><br><span class="line">train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size, resize=<span class="number">96</span>)</span><br><span class="line">d2l.train_ch6(net, train_iter, test_iter, num_epochs, lr, d2l.try_gpu())</span><br></pre></td></tr></table></figure>
<img src="/2024/04/23/11-01-29/29-05.png" class="">
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>学习嵌套函数（nested function）是训练神经网络的理想情况。在深层神经网络中，学习另一层作为恒等映射（identity function）较容易（尽管这是一个极端情况）。</li>
<li>残差映射可以更容易地学习同一函数，例如将权重层中的参数近似为零。</li>
<li>利用残差块（residual blocks）可以训练出一个有效的深层神经网络：输入可以通过层间的残余连接更快地向前传播。</li>
<li>残差网络（ResNet）对随后的深层神经网络设计产生了深远影响。</li>
</ul>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>36-数据增广</title>
    <url>/2024/04/23/11-01-36/</url>
    <content><![CDATA[<h2 id="36-数据增广"><a href="#36-数据增广" class="headerlink" title="36 数据增广"></a>36 数据增广</h2><p>数据增广不仅用于处理图片，也可用于文本和语音，这里只涉及到图片。</p>
<h3 id="1-使用增强数据训练"><a href="#1-使用增强数据训练" class="headerlink" title="1. 使用增强数据训练"></a>1. 使用增强数据训练</h3><p>采集数据得到的训练场景与实际部署场景不同是常见的问题，这种变化有时会显著影响模型表现。在训练集中尽可能模拟部署时可能遇到的场景对模型的泛化性十分重要。</p>
<p>数据增强是指在一个已有数据集上操作使其有更多的多样性。对语音来说可以加入不同的背景噪音，对图片而言可以改变其颜色，形状等。</p>
<p>一般来说不会先将数据集做增广后存下来再用于训练；而是直接在线生成，从原始数据中读图片并随机做数据增强，再进入模型训练。通常只在训练时做数据增强而测试时不用。可以将数据增强理解为一个正则项。</p>
<h3 id="2-增强手段"><a href="#2-增强手段" class="headerlink" title="2. 增强手段"></a>2. 增强手段</h3><h4 id="2-1-翻转"><a href="#2-1-翻转" class="headerlink" title="2.1 翻转"></a>2.1 翻转</h4><p>一些例子：左右翻转，上下翻转</p>
<p>要注意不是所有增强策略都总是可行，如建筑图片上下翻转就不太合适，而之前的树叶分类竞赛中的树叶图片就没关系。</p>
<img src="/2024/04/23/11-01-36/36-01.png" class="">
<h4 id="2-2-切割"><a href="#2-2-切割" class="headerlink" title="2.2 切割"></a>2.2 切割</h4><p>从图片中切割一块然后变形到固定形状。一般做法是随机取一个高宽比，随机取图片大小（切下部分占原图的百分数），随机取位置。</p>
<img src="/2024/04/23/11-01-36/36-02.png" class="">
<h4 id="2-3-颜色"><a href="#2-3-颜色" class="headerlink" title="2.3 颜色"></a>2.3 颜色</h4><p>改变色调，饱和度，明亮度。</p>
<img src="/2024/04/23/11-01-36/36-03.png" class="">
<h4 id="2-4-其他"><a href="#2-4-其他" class="headerlink" title="2.4 其他"></a>2.4 其他</h4><p>还可以有很多种不同的方法，如高斯模糊，部分像素变黑，图片变形，锐化等等。理论上讲Photoshop能做到的都可以用作图片数据增强，但效果好坏另当别论。如果测试集中有类似的效果那么相应的数据增广手段会更有效。</p>
<img src="/2024/04/23/11-01-36/36-04.png" class="">
<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><ul>
<li>数据增广通过变形数据来获取多样性从而使得模型泛化性能更好</li>
<li>常见图片增广包括翻转，切割，变色</li>
</ul>
<h3 id="4-QA"><a href="#4-QA" class="headerlink" title="4. QA"></a>4. QA</h3><p>Q1: 理论上是不是原始样本足够多就不需要做增广？</p>
<blockquote>
<p>是的，但实际情况中很难有足够多样性的图片能覆盖测试的所有情况。</p>
<p>数据量大也不一定意味着足够多样，可能简单情况已经很充分，但对于很难的情况覆盖率不够。</p>
</blockquote>
<p>Q2: （代码实现中的）num_worker值是不是根据GPU性能而定？</p>
<blockquote>
<p>是。</p>
<p>这里老师还提到虽然深度学习主要用GPU，但CPU也不能太差，否则可能数据预处理跟不上，CPU的内存带宽和到显卡的带宽不够。具体决定num_worker可以自己定一个值然后跑一个epoch看看耗时。</p>
</blockquote>
<p>Q3: 金融风控领域经常面临极度偏斜数据（欺诈样本极少），是否可对正样本做数据增广？</p>
<blockquote>
<p>可以，类似地震预测等等正样本少的情况都可以尝试对正样本做增广，负样本可以不用。</p>
</blockquote>
<p>Q4: 测试一般做什么样的增广？如何理解对测试集增广能提高精度？</p>
<blockquote>
<p>一般不对测试集做增广。也可以对一张测试图像做增广，将每个增广出的图片都做一次预测最后取平均，会一定程度改善精度。但这样会使得对每张图片预测计算量成倍增长，所以使用较少。</p>
</blockquote>
<p>Q5: 课件里提到的对比实验固定了所有随机种子吗？昨晚增广后训练精度下降是不是意味着还可以继续训练减少gap？</p>
<blockquote>
<p>没有。</p>
<p>是的，课堂演示时往往跑的epoch较少，另外训练到后期gap一般不会减少。</p>
</blockquote>
<p>Q6: 图片增广后需要人工一张张确认效果吗？</p>
<blockquote>
<p>不用全看，大概看看效果即可。</p>
</blockquote>
<p>Q7: 图片增广后训练数据与测试数据分布可能不同，会对模型最终精度有影响吗？</p>
<blockquote>
<p>首先多数图片增广手段不改变数据分布，因为亮度变化等是随机的，数据的均值不变，翻转不影响分布，crop可能会有改变但影响不大。</p>
<p>后面还有问题提到对增广不改变数据分布的理解，可理解成增广不改变均值但稍微增大方差。很多时候讨论训练集和测试集分布是否相同不是看原始的像素分布而是看各label比例或图片色调等是否差不多。</p>
</blockquote>
<p>Q8: 关于图神经网络</p>
<blockquote>
<p>图神经网络很强大但不好训练，目前落地还太早了</p>
</blockquote>
<p>Q9: 关于mosaic和crop</p>
<blockquote>
<p>把多张图片拼起来训练。这里老师理解错了问题，提到了加马赛克和本节代码中一次展示八张图片只是一起显示而不是使用了crop方法。</p>
</blockquote>
<p>Q10: 用对一个事物的视频描述做数据集是不是会比增广更有效？</p>
<blockquote>
<p>可以这么认为，但拍视频是很贵的事情，获取视频往往划不来。</p>
</blockquote>
<p>Q11: 多张图片叠加是否也是有效的增广方式？</p>
<blockquote>
<p>是的，这种方法叫mix-up，非常有用。</p>
<p>后面有问到为什么mix-up有用，老师也不清楚。</p>
<p>lable的叠加是对两张图片label按特定分布随机取权重加权求和</p>
</blockquote>
<p>Q12: 做车辆位置识别如果实际应用场景摄像头高度角度清晰度都和训练集不一样，是不是只能针对场景单独采集数据重新打标训练？</p>
<blockquote>
<p>是，可以考虑将实际部署时识别错误的数据加入训练集使得训练集测试集分布趋同</p>
</blockquote>
<p>Q13: 是否会出现图像增广减小类间差异，混淆不同类别的情况？</p>
<blockquote>
<p>那倒不会。可以考虑不要crop太小的区域。</p>
</blockquote>
<p>Q14: 实际操作用torchvision还是albumentation?</p>
<blockquote>
<p>都差不多</p>
</blockquote>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>37-微调</title>
    <url>/2024/04/23/11-01-37/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul>
<li>很多时候，例如我们想对家具进行分类，但是往往在努力收集数据得到的数据集也比较小假如我们想识别图片中不同类型的椅子，然后向用户推荐购买链接。 一种可能的方法是首先识别100把普通椅子，为每把椅子拍摄1000张不同角度的图像，然后在收集的图像数据集上训练一个分类模型。 尽管这个椅子数据集可能大于Fashion-MNIST数据集，但实例数量仍然不到ImageNet中的十分之一。 适合ImageNet的复杂模型可能会在这个椅子数据集上过拟合。 此外，由于训练样本数量有限，训练模型的准确性可能无法满足实际要求。为了避免这种情况，我们可以有两种方法：<ul>
<li>显然的想法就是收集更多的数据，但是，收集和标记数据可能需要大量的时间和金钱。 例如，为了收集ImageNet数据集，研究人员花费了数百万美元的研究资金。 尽管目前的数据收集成本已大幅降低，但这一成本仍不能忽视。</li>
<li>我们可以考虑迁移学习将从<em>源数据集</em>学到的知识迁移到<em>目标数据集</em>。 例如，尽管ImageNet数据集中的大多数图像与椅子无关，但在此数据集上训练的模型可能会提取更通用的图像特征，这有助于识别边缘、纹理、形状和对象组合。 这些类似的特征也可能有效地识别椅子。</li>
</ul>
</li>
</ul>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ul>
<li>如图所示，微调包括以下四个步骤：<ol>
<li>在源数据集（例如ImageNet数据集）上预训练神经网络模型，即<strong><em>源模型</em></strong>。</li>
<li>创建一个新的神经网络模型，即<strong><em>目标模型</em></strong>。这将复制源模型上的所有模型设计及其参数（输出层除外）。我们假定这些模型参数包含从源数据集中学到的知识，这些知识也将适用于目标数据集。我们还假设源模型的输出层与源数据集的标签密切相关；因此不在目标模型中使用该层。</li>
<li>向目标模型添加输出层，其输出数是目标数据集中的类别数。然后随机初始化该层的模型参数。</li>
<li>在目标数据集（如椅子数据集）上训练目标模型。输出层将从头开始进行训练，而所有其他层的参数将根据源模型的参数进行微调。</li>
</ol>
</li>
</ul>
<img src="/2024/04/23/11-01-37/37-01.png" class="">
<ol>
<li>通常来讲，微调速度更快，并且具有较强的正则性，一般学习率比较小，也不需要很多轮的数据迭代，对于不同的任务往往只需要改变最后输出层，这一层随机初始化即可。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>迁移学习将从源数据集中学到的知识“迁移”到目标数据集，微调是迁移学习的常见技巧。</li>
<li>除输出层外，目标模型从源模型中复制所有模型设计及其参数，并根据目标数据集对这些参数进行微调。但是，目标模型的输出层需要从头开始训练。</li>
<li>通常，微调参数使用较小的学习率，而从头开始训练输出层可以使用更大的学习率。</li>
</ul>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>28-批量归一化</title>
    <url>/2024/04/23/11-01-28/</url>
    <content><![CDATA[<h2 id="批量归一化"><a href="#批量归一化" class="headerlink" title="批量归一化"></a>批量归一化</h2><p>深层神经网络的训练，尤其是使网络在较短时间内收敛是十分困难的，<strong>批量归一化[batch normalization]</strong>是一种流行且有效的技术，能加速深层网络的收敛速度，目前仍被广泛使用。</p>
<h3 id="训练深层网络时的问题"><a href="#训练深层网络时的问题" class="headerlink" title="训练深层网络时的问题"></a>训练深层网络时的问题</h3><img src="/2024/04/23/11-01-28/deep_model.png" class="">
<p>深度神经网络在训练时会遇到一些问题：</p>
<ul>
<li>收敛速度慢：<ul>
<li>由于训练时先正向传播后反向传播，且每层的梯度一般较小，若网络较深，则反向传播时会出现类似于梯度消失的现象，导致距离数据更近的层梯度较小，收敛慢，而距离输出更近的层梯度较大，收敛快。然而底部的层一般都用于提取较基础的特征信息，上方的层收敛后，由于底部提取基础特征的层仍在变化，上方的层一直在不停的重新训练，导致整个网络难以收敛，训练较慢。</li>
</ul>
</li>
<li>内部协变量转移：<ul>
<li>分布偏移：偏移在视频课程中并未出现，但在《动手学深度学习》这本书中有提到过，在<a href="https://zh-v2.d2l.ai/chapter_multilayer-perceptrons/environment.html">4.9. 环境和分布偏移</a>部分。偏移指的是训练数据可能和测试数据的分布不同，比如利用来自真实的猫和狗的照片的训练数据训练模型，然后让模型去预测动画中的猫和狗的图片。<img src="../imgs/28/cat-dog-train.svg" alt="cat-dog-train"><img src="../imgs/28/cat-dog-test.svg" alt="cat-dog-test">这显然会降低正确率也会对模型的进一步优化带来干扰。一般情况下对于分布偏移我们毫无办法，然而，在一些特定场景中，如果假定一些训练数据和测试数据分布的前提条件，就能对分布偏移进行处理，其中之一就是协变量偏移。</li>
<li>协变量偏移：协变量偏移假设输入的分布可能随时间变化，但标签函数（条件分布$P(y|\bold x)$）没有改变。统计学家称这为<em>协变量偏移</em>（covariate shift）并给出了一些解决方案</li>
<li><strong>内部协变量偏移(Internal Covariate Shift)</strong>：每一层的参数在更新过程中，会改变下一层输入的分布，导致网络参数变幻莫测，难以收敛，神经网络层数越多，表现得越明显。</li>
<li><font color="red">注意：</font>
* <font color="red">1：内部协变量偏移这个词与标准的协变量偏移所有区别。</font>
* <font color="red">2：能缓解内部协变量偏移仅仅是批量归一化的作者提出的假想，后续论文证实批量归一化实际对内部协变量偏移的缓解帮助不大</font>
* <font color="red">3：批量归一化一般只影响模型的收敛速度，不影响精度</font></li>
</ul>
</li>
<li>过拟合：<ul>
<li>由于网络深度加深，变得更为复杂，使得网络容易过拟合。</li>
</ul>
</li>
</ul>
<h3 id="批量归一化-1"><a href="#批量归一化-1" class="headerlink" title="批量归一化"></a>批量归一化</h3><p><strong>批量归一化(batch normalization)</strong>在 <a href="https://zh-v2.d2l.ai/chapter_references/zreferences.html#ioffe-szegedy-2015">[Ioffe &amp; Szegedy, 2015]</a>中被提出，用于解决上述训练深度网络时的这些问题，然而这只是人们的感性理解，关于批量归一化具体是怎样帮助训练这个问题目前仍待进一步研究。</p>
<p>批量归一化尝试将每个训练中的mini-batch小批量数据（即会导致参数更新的数据）在每一层的结果进行归一化，使其更稳定，归一化指的是对于当前小批量中的所有样本，求出期望和方差，然后将每个样本减去期望再除以标准差。</p>
<h3 id="形式化表达"><a href="#形式化表达" class="headerlink" title="形式化表达"></a>形式化表达</h3><p>下面的运算均为向量运算，向量中的每个维度代表一个特征，对于每个特征分别进行计算再拼接在一起即为向量运算。</p>
<p>设$ \bold x \in \mathcal{B}$为来自一个小批量$\mathcal{B}$的输入，批量规范化BN根据下式进行转换</p>
<script type="math/tex; mode=display">
\mathrm{BN}(\mathbf{x}) = \boldsymbol{\gamma} \odot \frac{\mathbf{x} - \hat{\boldsymbol{\mu}}_\mathcal{B}}{\hat{\boldsymbol{\sigma}}_\mathcal{B}} + \boldsymbol{\beta}.</script><p>式中$\hat{\boldsymbol{\mu}}_\mathcal{B}$为小批量$\mathcal{B}$样本均值，$\hat{\boldsymbol{\sigma}}_\mathcal{B}$为样本标准差：</p>
<script type="math/tex; mode=display">
\begin{split}\begin{aligned} \hat{\boldsymbol{\mu}}_\mathcal{B} &= \frac{1}{|\mathcal{B}|} \sum_{\mathbf{x} \in \mathcal{B}} \mathbf{x},\\
\hat{\boldsymbol{\sigma}}_\mathcal{B}^2 &= \frac{1}{|\mathcal{B}|} \sum_{\mathbf{x} \in \mathcal{B}} (\mathbf{x} - \hat{\boldsymbol{\mu}}_{\mathcal{B}})^2 + \epsilon\end{aligned}\end{split}</script><p>其中$\epsilon$用于防止分母为0，经过减期望与除以标准差后得到期望为1方差为0的小批量数据。然而，期望和方差为了使小批量有更自由的选择，再将其乘拉伸参数$\boldsymbol {\gamma}$，加偏移参数$\boldsymbol \beta$，这两个参数与$\bold x$同样大小，是模型中的可学习参数，与其他参数一同更新。</p>
<p>由于$\hat{\boldsymbol{\mu}}_\mathcal{B}$和$\hat{\boldsymbol{\sigma}}_\mathcal{B}$为由当前小批量计算的值，实际上是整个分布对应的期望与标准差的估计值，由于小批量的随机选择，$\hat{\boldsymbol{\mu}}_\mathcal{B}$和$\hat{\boldsymbol{\sigma}}_\mathcal{B}$会给模型带来一定的与输入数据有关的噪音，而这些噪音也能对模型进行正则化，防止过拟合。为何这种噪音能加快训练并带来正则化还有待研究，不过已有理论说明了为什么批量规范化最适应$50∼100$范围中的中等批量大小的问题。</p>
<p>训练时不能使用整个数据集，只能一步步的训练和更新；而预测时模型已然固定，可以根据整个数据集精确计算均值和方差。因此，批量归一化对于训练和预测时有两种不同模式。</p>
<h3 id="批量归一化层"><a href="#批量归一化层" class="headerlink" title="批量归一化层"></a>批量归一化层</h3><p>批量归一化不再单独的考虑单个样本，需要对整个mini-batch进行，因此需要考虑多种情况。</p>
<h4 id="全连接层"><a href="#全连接层" class="headerlink" title="全连接层"></a>全连接层</h4><p>通常，我们将批量规范化层置于全连接层中的仿射变换和激活函数之间。如下：</p>
<script type="math/tex; mode=display">
\mathbf{h} = \phi(\mathrm{BN}(\mathbf{W}\mathbf{x} + \mathbf{b}))</script><h4 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h4><p>在卷积层中，我们将通道视作每个位置的特征，将每个样本中的每个位置视作一个样本进行计算。每个通道都有着自己的拉伸参数${\gamma}$和偏移参数$\beta$，所有通道加在一起组成了拉伸参数向量$\boldsymbol {\gamma}$和偏移参数向量$\boldsymbol \beta$，若样本数为m，卷积输出为p*q，计算时对m*p*q个向量进行批量归一化运算（即视作有m*p*q个样本）</p>
<h4 id="预测过程中的批量归一化"><a href="#预测过程中的批量归一化" class="headerlink" title="预测过程中的批量归一化"></a>预测过程中的批量归一化</h4><p>在训练过程中，我们需要不断地更新模型，方差和均值也就在不断地变化，就必须计算当前小批量数据对应的方差和均值，然而预测时我们的模型已经确定下来，可以用在整个训练数据集上得到的均值和方差来对预测时的结果进行归一化。</p>
<h4 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h4><ul>
<li><p>在实际实现时，一般使用指数加权平均来更新小批量的均值和方差，指数加权平均将旧值和当前计算结果不断进行加权平均，最终做到平滑的向更新值靠拢，公式如下：</p>
</li>
<li><script type="math/tex; mode=display">
S_t = 
\begin{cases} 
Y_1, &t = 1 \\\\ 
\beta S_{t-1} + (1-\beta)Y_t, &t > 1 
\end{cases}</script></li>
<li><p>批量归一化的参数可以通过动量梯度下降，RMSProp，Adam等多种优化方法进行训练。</p>
</li>
</ul>
<h3 id="吴恩达老师深度学习课程中的批量归一化"><a href="#吴恩达老师深度学习课程中的批量归一化" class="headerlink" title="吴恩达老师深度学习课程中的批量归一化"></a>吴恩达老师深度学习课程中的批量归一化</h3><p>吴恩达老师深度学习课程中的批量归一化中的部分内容与本课程有所出入，考虑到批量归一化这部分内容还没有精确的理论解释，目前的认识仅限于直觉，故将两课程中的区别即补充罗列在此作为参考：</p>
<ul>
<li>关于dropout：<ul>
<li>本课中提到批量归一化有正则化效果，无需再进行dropout</li>
<li>吴恩达老师课程中提到批量归一化正则化效果较差，不能作为正则化的手段，必要时需要dropout</li>
</ul>
</li>
<li>对于线性层（包括其他带有偏置项的层）后的批量归一化，由于归一化时减去了均值，偏置项被消掉，可以省略归一化层之前的偏置项</li>
<li>标准化的输入能使梯度下降加快，批归一化能使得每层的输入都被归一化，这也是训练更快的原因之一</li>
<li>批量归一化可以使得不同层之间互相的影响减少，从而应对数据偏移，增强鲁棒性。</li>
</ul>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>41-物体检测和数据集</title>
    <url>/2024/04/23/11-01-41/</url>
    <content><![CDATA[<h3 id="41-物体检测和数据集"><a href="#41-物体检测和数据集" class="headerlink" title="41 物体检测和数据集"></a>41 物体检测和数据集</h3><h4 id="物体检测"><a href="#物体检测" class="headerlink" title="物体检测"></a>物体检测</h4><ol>
<li>图片分类和目标检测在任务上的区别：图片分类已知有一个确定目标，任务是识别该目标属于何种分类，而目标检测不仅需要检测出图片中所有感兴趣的目标类别，并确定其位置，所以目标检测要比图片分类更复杂应用场景更广。</li>
<li>图片分类和目标检测在数据集上的区别：由于目标检测中每一张图片可能存在多个目标，每个目标我们不仅需要分类，还需要确定边缘框以给出目标位置信息，因此目标检测数据集的标注成本要显著高于图片分类，也就导致了目标检测数据集较小。</li>
<li>边缘框：用一个尽量小矩形框将目标物体大体框起来，边框的位置信息就可以表示目标位置在图片中的位置信息，常见的边缘框有两种表示方法：</li>
</ol>
<ul>
<li>（左上x，左上y，右下x，右下y）</li>
<li>（左上x，左上y，宽，高）</li>
</ul>
<ol>
<li>目标检测数据集的常见表示：每一行表示一个物体，对于每一个物体而言，用“图片文件名，物体类别，边缘框”表示，由于边缘框用4个数值表示，因此对于每一行的那一个物体而言，需要用6个数值表示。</li>
<li>目标检测领域常用数据集：COCO（80类物体，330K图片，所有图片共标注1.5M物体）</li>
</ol>
<h4 id="边缘框实现"><a href="#边缘框实现" class="headerlink" title="边缘框实现"></a>边缘框实现</h4><ol>
<li>目标的位置</li>
</ol>
<p>在图像分类任务中，我们假设图像中只有一个主要物体对象，我们只关注如何识别其类别。 然而，很多时候图像里有多个我们感兴趣的目标，我们不仅想知道它们的类别，还想得到它们在图像中的具体位置。 在计算机视觉里，我们将这类任务称为<em>目标检测</em>（object detection）或<em>目标识别</em>（object recognition）。目标检测在多个领域中被广泛使用。 例如，在无人驾驶里，我们需要通过识别拍摄到的视频图像里的车辆、行人、道路和障碍物的位置来规划行进线路。 机器人也常通过该任务来检测感兴趣的目标。安防领域则需要检测异常目标，如歹徒或者炸弹。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面加载本节将使用的示例图像。可以看到图像左边是一只狗，右边是一只猫。 它们是这张图像里的两个主要目标。</span></span><br><span class="line"></span><br><span class="line">d2l.set_figsize()</span><br><span class="line">img = d2l.plt.imread(<span class="string">&#x27;../img/catdog.jpg&#x27;</span>)</span><br><span class="line">d2l.plt.imshow(img);</span><br></pre></td></tr></table></figure>
<ol>
<li>边界框</li>
</ol>
<ul>
<li><p>在目标检测中，我们通常使用<em>边界框</em>（bounding box）来描述对象的空间位置。 边界框是矩形的，由矩形左上角的以及右下角的<em>x</em>和<em>y</em>坐标决定。 另一种常用的边界框表示方法是边界框中心的(<em>x</em>,<em>y</em>)轴坐标以及框的宽度和高度。</p>
</li>
<li><p>在这里，我们定义在这两种表示法之间进行转换的函数：<code>box_corner_to_center</code>从两角表示法转换为中心宽度表示法，而<code>box_center_to_corner</code>反之亦然。 输入参数<code>boxes</code>可以是长度为4的张量，也可以是形状为（<em>n</em>，4）的二维张量，其中<em>n</em>是边界框的数量。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">box_corner_to_center</span>(<span class="params">boxes</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;从（左上，右下）转换到（中间，宽度，高度）&quot;&quot;&quot;</span></span><br><span class="line">    x1, y1, x2, y2 = boxes[:, <span class="number">0</span>], boxes[:, <span class="number">1</span>], boxes[:, <span class="number">2</span>], boxes[:, <span class="number">3</span>]</span><br><span class="line">    cx = (x1 + x2) / <span class="number">2</span></span><br><span class="line">    cy = (y1 + y2) / <span class="number">2</span></span><br><span class="line">    w = x2 - x1</span><br><span class="line">    h = y2 - y1</span><br><span class="line">    boxes = torch.stack((cx, cy, w, h), axis=-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> boxes</span><br><span class="line"></span><br><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">box_center_to_corner</span>(<span class="params">boxes</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;从（中间，宽度，高度）转换到（左上，右下）&quot;&quot;&quot;</span></span><br><span class="line">    cx, cy, w, h = boxes[:, <span class="number">0</span>], boxes[:, <span class="number">1</span>], boxes[:, <span class="number">2</span>], boxes[:, <span class="number">3</span>]</span><br><span class="line">    x1 = cx - <span class="number">0.5</span> * w</span><br><span class="line">    y1 = cy - <span class="number">0.5</span> * h</span><br><span class="line">    x2 = cx + <span class="number">0.5</span> * w</span><br><span class="line">    y2 = cy + <span class="number">0.5</span> * h</span><br><span class="line">    boxes = torch.stack((x1, y1, x2, y2), axis=-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> boxes</span><br></pre></td></tr></table></figure>
<ul>
<li>我们将根据坐标信息定义图像中狗和猫的边界框。 图像中坐标的原点是图像的左上角，向右的方向为<em>x</em>轴的正方向，向下的方向为<em>y</em>轴的正方向。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># bbox是边界框的英文缩写</span></span><br><span class="line">dog_bbox, cat_bbox = [<span class="number">60.0</span>, <span class="number">45.0</span>, <span class="number">378.0</span>, <span class="number">516.0</span>], [<span class="number">400.0</span>, <span class="number">112.0</span>, <span class="number">655.0</span>, <span class="number">493.0</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>我们可以将边界框在图中画出，以检查其是否准确。 画之前，我们定义一个辅助函数<code>bbox_to_rect</code>。 它将边界框表示成<code>matplotlib</code>的边界框格式。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bbox_to_rect</span>(<span class="params">bbox, color</span>):</span><br><span class="line">    <span class="comment"># 将边界框(左上x,左上y,右下x,右下y)格式转换成matplotlib格式：</span></span><br><span class="line">    <span class="comment"># ((左上x,左上y),宽,高)</span></span><br><span class="line">    <span class="keyword">return</span> d2l.plt.Rectangle(</span><br><span class="line">        xy=(bbox[<span class="number">0</span>], bbox[<span class="number">1</span>]), width=bbox[<span class="number">2</span>]-bbox[<span class="number">0</span>], height=bbox[<span class="number">3</span>]-bbox[<span class="number">1</span>],</span><br><span class="line">        fill=<span class="literal">False</span>, edgecolor=color, linewidth=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>在图像上添加边界框之后，我们可以看到两个物体的主要轮廓基本上在两个框内。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig = d2l.plt.imshow(img)</span><br><span class="line">fig.axes.add_patch(bbox_to_rect(dog_bbox, <span class="string">&#x27;blue&#x27;</span>))</span><br><span class="line">fig.axes.add_patch(bbox_to_rect(cat_bbox, <span class="string">&#x27;red&#x27;</span>));</span><br></pre></td></tr></table></figure>
<ol>
<li>小结</li>
</ol>
<ul>
<li>目标检测不仅可以识别图像中所有感兴趣的物体，还能识别它们的位置，该位置通常由矩形边界框表示。</li>
<li>我们可以在两种常用的边界框表示（中间，宽度，高度）和（左上，右下）坐标之间进行转换。</li>
</ul>
<h4 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h4><p>目标检测领域没有像MNIST和Fashion-MNIST那样的小数据集。 为了快速测试目标检测模型，我们收集并标记了一个小型数据集。 首先，我们拍摄了一组香蕉的照片，并生成了1000张不同角度和大小的香蕉图像。 然后，我们在一些背景图片的随机位置上放一张香蕉的图像。 最后，我们在图片上为这些香蕉标记了边界框。</p>
<ol>
<li>下载数据集</li>
</ol>
<ul>
<li>包含所有图像和CSV标签文件的香蕉检测数据集可以直接从互联网下载。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> mxnet <span class="keyword">import</span> gluon, image, np, npx</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> mxnet <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line">npx.set_np()</span><br><span class="line"></span><br><span class="line"><span class="comment">#@save</span></span><br><span class="line">d2l.DATA_HUB[<span class="string">&#x27;banana-detection&#x27;</span>] = (</span><br><span class="line">    d2l.DATA_URL + <span class="string">&#x27;banana-detection.zip&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;5de26c8fce5ccdea9f91267273464dc968d20d72&#x27;</span>)</span><br></pre></td></tr></table></figure>
<ol>
<li>读取数据集</li>
</ol>
<ul>
<li>通过<code>read_data_bananas</code>函数，我们读取香蕉检测数据集。 该数据集包括一个的CSV文件，内含目标类别标签和位于左上角和右下角的真实边界框坐标。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_data_bananas</span>(<span class="params">is_train=<span class="literal">True</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;读取香蕉检测数据集中的图像和标签&quot;&quot;&quot;</span></span><br><span class="line">    data_dir = d2l.download_extract(<span class="string">&#x27;banana-detection&#x27;</span>)</span><br><span class="line">    csv_fname = os.path.join(data_dir, <span class="string">&#x27;bananas_train&#x27;</span> <span class="keyword">if</span> is_train</span><br><span class="line">                             <span class="keyword">else</span> <span class="string">&#x27;bananas_val&#x27;</span>, <span class="string">&#x27;label.csv&#x27;</span>)</span><br><span class="line">    csv_data = pd.read_csv(csv_fname)</span><br><span class="line">    csv_data = csv_data.set_index(<span class="string">&#x27;img_name&#x27;</span>)</span><br><span class="line">    images, targets = [], []</span><br><span class="line">    <span class="keyword">for</span> img_name, target <span class="keyword">in</span> csv_data.iterrows():</span><br><span class="line">        images.append(torchvision.io.read_image(</span><br><span class="line">            os.path.join(data_dir, <span class="string">&#x27;bananas_train&#x27;</span> <span class="keyword">if</span> is_train <span class="keyword">else</span></span><br><span class="line">                         <span class="string">&#x27;bananas_val&#x27;</span>, <span class="string">&#x27;images&#x27;</span>, <span class="string">f&#x27;<span class="subst">&#123;img_name&#125;</span>&#x27;</span>)))</span><br><span class="line">        <span class="comment"># 这里的target包含（类别，左上角x，左上角y，右下角x，右下角y），</span></span><br><span class="line">        <span class="comment"># 其中所有图像都具有相同的香蕉类（索引为0）</span></span><br><span class="line">        targets.append(<span class="built_in">list</span>(target))</span><br><span class="line">    <span class="keyword">return</span> images, torch.tensor(targets).unsqueeze(<span class="number">1</span>) / <span class="number">256</span></span><br></pre></td></tr></table></figure>
<ul>
<li>通过使用<code>read_data_bananas</code>函数读取图像和标签，以下<code>BananasDataset</code>类别将允许我们创建一个自定义<code>Dataset</code>实例来加载香蕉检测数据集。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BananasDataset</span>(torch.utils.data.Dataset):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;一个用于加载香蕉检测数据集的自定义数据集&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, is_train</span>):</span><br><span class="line">        self.features, self.labels = read_data_bananas(is_train)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;read &#x27;</span> + <span class="built_in">str</span>(<span class="built_in">len</span>(self.features)) + (<span class="string">f&#x27; training examples&#x27;</span> <span class="keyword">if</span></span><br><span class="line">              is_train <span class="keyword">else</span> <span class="string">f&#x27; validation examples&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, idx</span>):</span><br><span class="line">        <span class="keyword">return</span> (self.features[idx].<span class="built_in">float</span>(), self.labels[idx])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.features)</span><br></pre></td></tr></table></figure>
<ul>
<li>最后，我们定义<code>load_data_bananas</code>函数，来为训练集和测试集返回两个数据加载器实例。对于测试集，无须按随机顺序读取它。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_data_bananas</span>(<span class="params">batch_size</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;加载香蕉检测数据集&quot;&quot;&quot;</span></span><br><span class="line">    train_iter = torch.utils.data.DataLoader(BananasDataset(is_train=<span class="literal">True</span>),</span><br><span class="line">                                             batch_size, shuffle=<span class="literal">True</span>)</span><br><span class="line">    val_iter = torch.utils.data.DataLoader(BananasDataset(is_train=<span class="literal">False</span>),</span><br><span class="line">                                           batch_size)</span><br><span class="line">    <span class="keyword">return</span> train_iter, val_iter</span><br></pre></td></tr></table></figure>
<ul>
<li>让我们读取一个小批量，并打印其中的图像和标签的形状。 图像的小批量的形状为（批量大小、通道数、高度、宽度），看起来很眼熟：它与我们之前图像分类任务中的相同。 标签的小批量的形状为（批量大小，<em>m</em>，5），其中<em>m</em>是数据集的任何图像中边界框可能出现的最大数量。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">batch_size, edge_size = <span class="number">32</span>, <span class="number">256</span></span><br><span class="line">train_iter, _ = load_data_bananas(batch_size)</span><br><span class="line">batch = <span class="built_in">next</span>(<span class="built_in">iter</span>(train_iter))</span><br><span class="line">batch[<span class="number">0</span>].shape, batch[<span class="number">1</span>].shape</span><br></pre></td></tr></table></figure>
<ol>
<li>小结</li>
</ol>
<ul>
<li>我们收集的香蕉检测数据集可用于演示目标检测模型。</li>
<li>用于目标检测的数据加载与图像分类的数据加载类似。但是，在目标检测中，标签还包含真实边界框的信息，它不出现在图像分类中。</li>
</ul>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>43-树叶分类竞赛技术总结</title>
    <url>/2024/04/23/11-01-43/</url>
    <content><![CDATA[<h2 id="43-树叶分类竞赛技术总结"><a href="#43-树叶分类竞赛技术总结" class="headerlink" title="43-树叶分类竞赛技术总结"></a>43-树叶分类竞赛技术总结</h2><h3 id="1-比赛结果"><a href="#1-比赛结果" class="headerlink" title="1. 比赛结果"></a>1. 比赛结果</h3><ul>
<li>176类，18353训练样本</li>
</ul>
<img src="/2024/04/23/11-01-43/43-01.png" class="">
<ul>
<li>165只队伍参加<ul>
<li>41只队伍精度 &gt; 98% (非常好)</li>
<li>83只队伍精度 &gt; 95% (够用)</li>
</ul>
</li>
</ul>
<h3 id="2-结果分析"><a href="#2-结果分析" class="headerlink" title="2. 结果分析"></a>2. 结果分析</h3><ul>
<li><p>16只队伍提供了代码：</p>
<ul>
<li><a href="https://www.kaggle.com/c/classify-leaves/code">Classify Leaves | Kaggle</a></li>
</ul>
</li>
<li><p>额外加上Neko Kiku</p>
<ul>
<li>很多人参考了此代码 <a href="https://www.kaggle.com/nekokiku/simple-resnet-baseline">simple resnet baseline | Kaggle</a></li>
</ul>
</li>
</ul>
<h3 id="3-技术分析"><a href="#3-技术分析" class="headerlink" title="3. 技术分析"></a>3. 技术分析</h3><p>相比于课程介绍的代码，同学们主要做了下面这些加强：</p>
<ul>
<li><p><strong>数据增强</strong>，在测试时多次使用稍弱的增强然后取平均</p>
</li>
<li><p>使用<strong>多个模型</strong>预测，最后结果加权平均</p>
<ul>
<li>有使用10种模型的，也有使用单一模型的</li>
</ul>
</li>
<li><strong>训练算法</strong>和<strong>学习率</strong></li>
<li><strong>清理数据</strong></li>
</ul>
<h3 id="4-模型方面"><a href="#4-模型方面" class="headerlink" title="4. 模型方面"></a>4. 模型方面</h3><ul>
<li><p>模型多为ResNet变种</p>
<ul>
<li>DenseNet，ResNeXt，ResNeSt,  …</li>
<li>EfficientNet</li>
</ul>
</li>
<li><p>优化算法多为Adam或其变种</p>
</li>
<li>学习率一般是Cosine或者训练不动时往下调</li>
</ul>
<h3 id="5-AutoGluon"><a href="#5-AutoGluon" class="headerlink" title="5. AutoGluon"></a>5. AutoGluon</h3><ul>
<li>15行代码， 安装加训练耗时100分钟<ul>
<li><a href="https://www.kaggle.com/zhreshold/autogluon-vision-0-96-with-15-lines">AutoGluon.vision: 0.96+ with 15 lines | Kaggle</a></li>
</ul>
</li>
<li>精度96%<ul>
<li>可以通过定制化提升精度</li>
<li>下一个版本将搜索更多的模型超参数</li>
<li>AG目前主要仍是关注工业界应用上，而非比赛</li>
</ul>
</li>
</ul>
<h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h3><ul>
<li>提升精度思路：根据数据挑选增强，使用新模型、新优化算法，多个模型融合，测试时使用增强</li>
<li>数据相对简单，排名有相对随机性</li>
<li>在工业界应用中：<ul>
<li>少使用模型融合和测试时增强，计算代价过高</li>
<li>通常固定模型超参数，而将精力主要花在提升数据质量</li>
</ul>
</li>
</ul>
<p>比赛/学术界：固定数据，调模型</p>
<p>工业界：固定模型，调数据</p>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>38-第二次竞赛树叶分类结果</title>
    <url>/2024/04/23/11-01-38/</url>
    <content><![CDATA[<h2 id="第二次竞赛树叶分类结果"><a href="#第二次竞赛树叶分类结果" class="headerlink" title="第二次竞赛树叶分类结果"></a>第二次竞赛树叶分类结果</h2><h3 id="任务简介"><a href="#任务简介" class="headerlink" title="任务简介"></a>任务简介</h3><p>对176种叶子进行分类，每类叶子的数据大约有100张图片，数据较干净，没有复杂背景且颜色并不关键，模型只要能识别出形状即可</p>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>165个队伍参加，1800次提交，私榜排名第一的同学正确率有0.99272，李沐老师私下使用AutoML训练大约0.98，由于结果较好，6-20名的队伍如果分享代码也可获得签名书</p>
<h3 id="方法总结"><a href="#方法总结" class="headerlink" title="方法总结"></a>方法总结</h3><p>待参加比赛的同学分享代码后下周课程上讲解，但B站视频并未上传此部分。</p>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>39-实战kaggle竞赛：CIFAR-10</title>
    <url>/2024/04/23/11-01-39/</url>
    <content><![CDATA[<h1 id="CIFAR-10"><a href="#CIFAR-10" class="headerlink" title="CIFAR-10"></a>CIFAR-10</h1><p>首先，导入竞赛所需要的包和模块：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br></pre></td></tr></table></figure>
<h4 id="2-1-下载数据集："><a href="#2-1-下载数据集：" class="headerlink" title="2.1 下载数据集："></a>2.1 下载数据集：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#@save</span></span><br><span class="line">d2l.DATA_HUB[<span class="string">&#x27;cifar10_tiny&#x27;</span>] = (d2l.DATA_URL + <span class="string">&#x27;kaggle_cifar10_tiny.zip&#x27;</span>,</span><br><span class="line">                                <span class="string">&#x27;2068874e4b9a9f0fb07ebe0ad2b29754449ccacd&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果你使用完整的Kaggle竞赛的数据集，设置demo为False</span></span><br><span class="line">demo = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> demo:</span><br><span class="line">    data_dir = d2l.download_extract(<span class="string">&#x27;cifar10_tiny&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    data_dir = <span class="string">&#x27;../data/cifar-10/&#x27;</span></span><br></pre></td></tr></table></figure>
<p>为了便于入门，我们提供包含前1000个训练图像和5个随机测试图像的数据集的小规模样本，如果要获取完整数据集，你需要将一下demo变量设置为False</p>
<h4 id="2-2-整理数据集"><a href="#2-2-整理数据集" class="headerlink" title="2.2 整理数据集"></a>2.2 整理数据集</h4><p>首先我们用以下函数读取CSV文件中的标签，它返回一个字典，该字典将文件名中不带拓展名德部分映射到其标签。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">read_csv_labels</span>(<span class="params">fname</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;读取fname来给标签字典返回一个文件名&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(fname, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="comment"># 跳过文件头行(列名)</span></span><br><span class="line">        lines = f.readlines()[<span class="number">1</span>:]</span><br><span class="line">    tokens = [</span><br><span class="line">        <span class="comment"># 训练样本 : 1000l.rstrip().split(&#x27;,&#x27;) for l in lines]</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dict</span>(((name, label) <span class="keyword">for</span> name, label <span class="keyword">in</span> tokens))</span><br><span class="line"></span><br><span class="line">labels = read_csv_labels(os.path.join(data_dir, <span class="string">&#x27;trainLabels.csv&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;# 训练样本 :&#x27;</span>, <span class="built_in">len</span>(labels))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;# 类别 :&#x27;</span>, <span class="built_in">len</span>(<span class="built_in">set</span>(labels.values())))</span><br><span class="line"><span class="comment"># 训练样本 : 1000</span></span><br><span class="line"><span class="comment"># 类别 : 10</span></span><br></pre></td></tr></table></figure>
<p>接下来，我们定义reorg_train_valid函数来将验证集从原始的训练集中拆分出来。此函数中的参数valid_ratio是验证集中的样本数与原始训练集中的样本数之比。更具体的说，令n等于样本最少的类别中的图像数量，而r是比率。验证集将为每个类别拆分出max([nr],1)张图像。让我们以valid_ratio=0.1为例，由于原始的训练集有50000张图像，因此trian_valid_test/train路径中将有45000张图像用于训练，而剩下5000张图像将作为路径train_valid_test/valid中的验证集。组织数据集后，同类别的图像将被放置在同一文件夹下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">copyfile</span>(<span class="params">filename, target_dir</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;将文件复制到目标目录&quot;&quot;&quot;</span></span><br><span class="line">    os.makedirs(target_dir, exist_ok=<span class="literal">True</span>)</span><br><span class="line">    shutil.copy(filename, target_dir)</span><br><span class="line"></span><br><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reorg_train_valid</span>(<span class="params">data_dir, labels, valid_ratio</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;将验证集从原始的训练集中拆分出来&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 训练数据集中样本最少的类别中的样本数</span></span><br><span class="line">    n = collections.Counter(labels.values()).most_common()[-<span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line">    <span class="comment"># 验证集中每个类别的样本数</span></span><br><span class="line">    n_valid_per_label = <span class="built_in">max</span>(<span class="number">1</span>, math.floor(n * valid_ratio))</span><br><span class="line">    label_count = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> train_file <span class="keyword">in</span> os.listdir(os.path.join(data_dir, <span class="string">&#x27;train&#x27;</span>)):</span><br><span class="line">        label = labels[train_file.split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">0</span>]]</span><br><span class="line">        fname = os.path.join(data_dir, <span class="string">&#x27;train&#x27;</span>, train_file)</span><br><span class="line">        copyfile(fname, os.path.join(data_dir, <span class="string">&#x27;train_valid_test&#x27;</span>,</span><br><span class="line">                                     <span class="string">&#x27;train_valid&#x27;</span>, label))</span><br><span class="line">        <span class="keyword">if</span> label <span class="keyword">not</span> <span class="keyword">in</span> label_count <span class="keyword">or</span> label_count[label] &lt; n_valid_per_label:</span><br><span class="line">            copyfile(fname, os.path.join(data_dir, <span class="string">&#x27;train_valid_test&#x27;</span>,</span><br><span class="line">                                         <span class="string">&#x27;valid&#x27;</span>, label))</span><br><span class="line">            label_count[label] = label_count.get(label, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            copyfile(fname, os.path.join(data_dir, <span class="string">&#x27;train_valid_test&#x27;</span>,</span><br><span class="line">                                         <span class="string">&#x27;train&#x27;</span>, label))</span><br><span class="line">    <span class="keyword">return</span> n_valid_per_label</span><br></pre></td></tr></table></figure>
<p>其中os.listdir显示指定路径下的文件和文件夹列表</p>
<p>下面的reorg_test函数用来预测期间整理测试集，以方便读取。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reorg_test</span>(<span class="params">data_dir</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;在预测期间整理测试集，以方便读取&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> test_file <span class="keyword">in</span> os.listdir(os.path.join(data_dir, <span class="string">&#x27;test&#x27;</span>)):</span><br><span class="line">        copyfile(os.path.join(data_dir, <span class="string">&#x27;test&#x27;</span>, test_file),</span><br><span class="line">                 os.path.join(data_dir, <span class="string">&#x27;train_valid_test&#x27;</span>, <span class="string">&#x27;test&#x27;</span>,</span><br><span class="line">                              <span class="string">&#x27;unknown&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>最后我们使用一个函数来调用前面定义的函数read_csv_labels，reorg_train_valid和reorg_test。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reorg_cifar10_data</span>(<span class="params">data_dir, valid_ratio</span>):</span><br><span class="line">    labels = read_csv_labels(os.path.join(data_dir, <span class="string">&#x27;trainLabels.csv&#x27;</span>))</span><br><span class="line">    reorg_train_valid(data_dir, labels, valid_ratio)</span><br><span class="line">    reorg_test(data_dir)</span><br></pre></td></tr></table></figure>
<p>在这里，我们只将样本数据集的批量大小设置为32.在实际训练和测试中，应该使用Kaggle竞赛的完整数据集，并将batch_size设置为更大的整数，例如128.我们将10%的训练样本作为调整超参数的验证集。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">batch_size = <span class="number">32</span> <span class="keyword">if</span> demo <span class="keyword">else</span> <span class="number">128</span></span><br><span class="line">valid_ratio = <span class="number">0.1</span></span><br><span class="line">reorg_cifar10_data(data_dir, valid_ratio)</span><br></pre></td></tr></table></figure>
<h3 id="3-图像增广"><a href="#3-图像增广" class="headerlink" title="3.图像增广"></a>3.图像增广</h3><p>使用图像增广来解决过拟合问题。在训练中，我们可以随机水平翻转图像。我们可以对彩色图像的三个RGB通道执行标准化。下面为一些可以调整的操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">transform_train = torchvision.transforms.Compose([</span><br><span class="line">    <span class="comment"># 在高度和宽度上将图像放大到40像素的正方形</span></span><br><span class="line">    torchvision.transforms.Resize(<span class="number">40</span>),</span><br><span class="line">    <span class="comment"># 随机裁剪出一个高度和宽度均为40像素的正方形图像，</span></span><br><span class="line">    <span class="comment"># 生成一个面积为原始图像面积0.64到1倍的小正方形，</span></span><br><span class="line">    <span class="comment"># 然后将其缩放为高度和宽度均为32像素的正方形</span></span><br><span class="line">    torchvision.transforms.RandomResizedCrop(<span class="number">32</span>, scale=(<span class="number">0.64</span>, <span class="number">1.0</span>),</span><br><span class="line">                                                   ratio=(<span class="number">1.0</span>, <span class="number">1.0</span>)),</span><br><span class="line">    torchvision.transforms.RandomHorizontalFlip(),</span><br><span class="line">    torchvision.transforms.ToTensor(),</span><br><span class="line">    <span class="comment"># 标准化图像的每个通道</span></span><br><span class="line">    torchvision.transforms.Normalize([<span class="number">0.4914</span>, <span class="number">0.4822</span>, <span class="number">0.4465</span>],</span><br><span class="line">                                     [<span class="number">0.2023</span>, <span class="number">0.1994</span>, <span class="number">0.2010</span>])])</span><br></pre></td></tr></table></figure>
<p>在测试期间，我们只对图像执行标准化，以消除评估结果中的随机性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">transform_test = torchvision.transforms.Compose([</span><br><span class="line">    torchvision.transforms.ToTensor(),</span><br><span class="line">    torchvision.transforms.Normalize([<span class="number">0.4914</span>, <span class="number">0.4822</span>, <span class="number">0.4465</span>],</span><br><span class="line">                                     [<span class="number">0.2023</span>, <span class="number">0.1994</span>, <span class="number">0.2010</span>])])</span><br></pre></td></tr></table></figure>
<h3 id="4-读取数据集"><a href="#4-读取数据集" class="headerlink" title="4.读取数据集"></a>4.读取数据集</h3><p>读取由原始图像组成的数据集，每个样本都包括一张图片和一个标签。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_ds, train_valid_ds = [torchvision.datasets.ImageFolder(</span><br><span class="line">    os.path.join(data_dir, <span class="string">&#x27;train_valid_test&#x27;</span>, folder),</span><br><span class="line">    transform=transform_train) <span class="keyword">for</span> folder <span class="keyword">in</span> [<span class="string">&#x27;train&#x27;</span>, <span class="string">&#x27;train_valid&#x27;</span>]]</span><br><span class="line"></span><br><span class="line">valid_ds, test_ds = [torchvision.datasets.ImageFolder(</span><br><span class="line">    os.path.join(data_dir, <span class="string">&#x27;train_valid_test&#x27;</span>, folder),</span><br><span class="line">    transform=transform_test) <span class="keyword">for</span> folder <span class="keyword">in</span> [<span class="string">&#x27;valid&#x27;</span>, <span class="string">&#x27;test&#x27;</span>]]</span><br></pre></td></tr></table></figure>
<p>当验证集在超参数调整过程中用于模型评估中，不应引入图像增广的随机性。在最终预测之前，我们根据训练集合验证集组合而成的训练模型进行训练，以充分利用所有标记的数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_iter, train_valid_iter = [torch.utils.data.DataLoader(</span><br><span class="line">    dataset, batch_size, shuffle=<span class="literal">True</span>, drop_last=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">for</span> dataset <span class="keyword">in</span> (train_ds, train_valid_ds)]</span><br><span class="line"></span><br><span class="line">valid_iter = torch.utils.data.DataLoader(valid_ds, batch_size, shuffle=<span class="literal">False</span>,</span><br><span class="line">                                         drop_last=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">test_iter = torch.utils.data.DataLoader(test_ds, batch_size, shuffle=<span class="literal">False</span>,</span><br><span class="line">                                        drop_last=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<h3 id="5-定义模型"><a href="#5-定义模型" class="headerlink" title="5.定义模型"></a>5.定义模型</h3><p>直接使用Resnet-18模型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_net</span>():</span><br><span class="line">    num_classes = <span class="number">10</span></span><br><span class="line">    net = d2l.resnet18(num_classes, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> net</span><br><span class="line"></span><br><span class="line">loss = nn.CrossEntropyLoss(reduction=<span class="string">&quot;none&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="6-定义训练函数"><a href="#6-定义训练函数" class="headerlink" title="6.定义训练函数"></a>6.定义训练函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">net, train_iter, valid_iter, num_epochs, lr, wd, devices, lr_period,</span></span><br><span class="line"><span class="params">          lr_decay</span>):</span><br><span class="line">    trainer = torch.optim.SGD(net.parameters(), lr=lr, momentum=<span class="number">0.9</span>,</span><br><span class="line">                              weight_decay=wd)</span><br><span class="line">    scheduler = torch.optim.lr_scheduler.StepLR(trainer, lr_period, lr_decay)</span><br><span class="line">    num_batches, timer = <span class="built_in">len</span>(train_iter), d2l.Timer()</span><br><span class="line">    legend = [<span class="string">&#x27;train loss&#x27;</span>, <span class="string">&#x27;train acc&#x27;</span>]</span><br><span class="line">    <span class="keyword">if</span> valid_iter <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        legend.append(<span class="string">&#x27;valid acc&#x27;</span>)</span><br><span class="line">    animator = d2l.Animator(xlabel=<span class="string">&#x27;epoch&#x27;</span>, xlim=[<span class="number">1</span>, num_epochs],</span><br><span class="line">                            legend=legend)</span><br><span class="line">    net = nn.DataParallel(net, device_ids=devices).to(devices[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">        net.train()</span><br><span class="line">        metric = d2l.Accumulator(<span class="number">3</span>)</span><br><span class="line">        <span class="keyword">for</span> i, (features, labels) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_iter):</span><br><span class="line">            timer.start()</span><br><span class="line">            l, acc = d2l.train_batch_ch13(net, features, labels,</span><br><span class="line">                                          loss, trainer, devices)</span><br><span class="line">            metric.add(l, acc, labels.shape[<span class="number">0</span>])</span><br><span class="line">            timer.stop()</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span>) % (num_batches // <span class="number">5</span>) == <span class="number">0</span> <span class="keyword">or</span> i == num_batches - <span class="number">1</span>:</span><br><span class="line">                animator.add(epoch + (i + <span class="number">1</span>) / num_batches,</span><br><span class="line">                             (metric[<span class="number">0</span>] / metric[<span class="number">2</span>], metric[<span class="number">1</span>] / metric[<span class="number">2</span>],</span><br><span class="line">                              <span class="literal">None</span>))</span><br><span class="line">        <span class="keyword">if</span> valid_iter <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            valid_acc = d2l.evaluate_accuracy_gpu(net, valid_iter)</span><br><span class="line">            animator.add(epoch + <span class="number">1</span>, (<span class="literal">None</span>, <span class="literal">None</span>, valid_acc))</span><br><span class="line">        scheduler.step()</span><br><span class="line">    measures = (<span class="string">f&#x27;train loss <span class="subst">&#123;metric[<span class="number">0</span>] / metric[<span class="number">2</span>]:<span class="number">.3</span>f&#125;</span>, &#x27;</span></span><br><span class="line">                <span class="string">f&#x27;train acc <span class="subst">&#123;metric[<span class="number">1</span>] / metric[<span class="number">2</span>]:<span class="number">.3</span>f&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> valid_iter <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        measures += <span class="string">f&#x27;, valid acc <span class="subst">&#123;valid_acc:<span class="number">.3</span>f&#125;</span>&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(measures + <span class="string">f&#x27;\n<span class="subst">&#123;metric[<span class="number">2</span>] * num_epochs / timer.<span class="built_in">sum</span>():<span class="number">.1</span>f&#125;</span>&#x27;</span></span><br><span class="line">          <span class="string">f&#x27; examples/sec on <span class="subst">&#123;<span class="built_in">str</span>(devices)&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>使用随机梯度下降和学习率规划来训练模型，以更快达到收敛。</p>
<h3 id="7-训练和验证模型"><a href="#7-训练和验证模型" class="headerlink" title="7.训练和验证模型"></a>7.训练和验证模型</h3><p>以下所有超参数都可以调节</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">devices, num_epochs, lr, wd = d2l.try_all_gpus(), <span class="number">20</span>, <span class="number">2e-4</span>, <span class="number">5e-4</span></span><br><span class="line">lr_period, lr_decay, net = <span class="number">4</span>, <span class="number">0.9</span>, get_net()</span><br><span class="line">train(net, train_iter, valid_iter, num_epochs, lr, wd, devices, lr_period,</span><br><span class="line">      lr_decay)</span><br></pre></td></tr></table></figure>
<img src="/2024/04/23/11-01-39/39-01.png" class="">
<h3 id="8-Q-amp-A"><a href="#8-Q-amp-A" class="headerlink" title="8.Q&amp;A"></a>8.Q&amp;A</h3><h5 id="Q1-深度学习的损失函数一般是非凸的吗？"><a href="#Q1-深度学习的损失函数一般是非凸的吗？" class="headerlink" title="Q1:深度学习的损失函数一般是非凸的吗？"></a>Q1:深度学习的损失函数一般是非凸的吗？</h5><blockquote>
<p>损失函数一般是凸的，但是神经网络是非凸的(非单层)。凸函数表示能力有限。</p>
</blockquote>
<h5 id="Q2-训练时的训练集交叉熵loss大于验证集，但是训练集acc也是大于验证集的？"><a href="#Q2-训练时的训练集交叉熵loss大于验证集，但是训练集acc也是大于验证集的？" class="headerlink" title="Q2:训练时的训练集交叉熵loss大于验证集，但是训练集acc也是大于验证集的？"></a>Q2:训练时的训练集交叉熵loss大于验证集，但是训练集acc也是大于验证集的？</h5><blockquote>
<p>应该是因为在训练集上加了数据增广</p>
</blockquote>
<h5 id="Q3-normalize参数怎么来的？"><a href="#Q3-normalize参数怎么来的？" class="headerlink" title="Q3:normalize参数怎么来的？"></a>Q3:normalize参数怎么来的？</h5><blockquote>
<p>由imagenet数据集上RGB的均值和方差</p>
</blockquote>
<h5 id="Q4：weight-decay和lr-decay的作用有什么区别吗？"><a href="#Q4：weight-decay和lr-decay的作用有什么区别吗？" class="headerlink" title="Q4：weight decay和lr decay的作用有什么区别吗？"></a>Q4：weight decay和lr decay的作用有什么区别吗？</h5><blockquote>
<p>weight decay是对权重更新的操作——正则化（统计），lr decay 是作用在学习率上——为了收敛（优化模型）</p>
</blockquote>
<h5 id="Q5-scheduler怎么设置是最好的最优的，怎么选择？"><a href="#Q5-scheduler怎么设置是最好的最优的，怎么选择？" class="headerlink" title="Q5:scheduler怎么设置是最好的最优的，怎么选择？"></a>Q5:scheduler怎么设置是最好的最优的，怎么选择？</h5><blockquote>
<p>现在一般选用cosine函数，参数设置较少   。最好在前期保证比较大的lr，后期lr可以变小一点。具体流行什么说不准</p>
</blockquote>
<h5 id="Q6-lr-decay和weight-decay的效果？"><a href="#Q6-lr-decay和weight-decay的效果？" class="headerlink" title="Q6:lr decay和weight decay的效果？"></a>Q6:lr decay和weight decay的效果？</h5><blockquote>
<p>效果类似，但是本质不同。</p>
</blockquote>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>47-转置卷积</title>
    <url>/2024/04/23/11-01-47/</url>
    <content><![CDATA[<h3 id="47-转置卷积"><a href="#47-转置卷积" class="headerlink" title="47-转置卷积"></a>47-转置卷积</h3><h3 id="1-转置卷积"><a href="#1-转置卷积" class="headerlink" title="1.转置卷积"></a>1.转置卷积</h3><ul>
<li>转置卷积和卷积的区别：<ul>
<li>卷积不会增大输入的高宽，通常要么不变、要么减半</li>
<li>转置卷积则可以用来增大输入高宽</li>
</ul>
</li>
<li>转置卷积的具体实现：</li>
</ul>
<img src="/2024/04/23/11-01-47/47-01.png" class="">
<p>如图所示，input里的每个元素和kernel相乘，最后把对应位置相加，相当于卷积的逆变换</p>
<ul>
<li>为什么称之为“转置：<ul>
<li>对于卷积Y=X*W<ul>
<li>可以对W构造一个V，使得卷积等价于矩阵乘法Y’=VX’</li>
<li>这里Y’,X’是Y,X对应的向量版本</li>
</ul>
</li>
<li>转置卷积等价于Y’=VTX’</li>
<li>如果卷积将输入从（h，w）变成了（h‘，w’）<ul>
<li>同样超参数的转置卷积则从（h‘，w’）变成为（h，w）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-转置卷积是一种卷积"><a href="#2-转置卷积是一种卷积" class="headerlink" title="2.转置卷积是一种卷积"></a>2.转置卷积是一种卷积</h3><ul>
<li><p>重新排列输入和核</p>
<ul>
<li>当填充为0步幅为1时：<ul>
<li>将输入填充k-1（k时核窗口）</li>
<li>将核矩阵上下、左右翻转</li>
<li>然后做正常卷积（填充0、步幅1）</li>
</ul>
</li>
</ul>
<img src="/2024/04/23/11-01-47/47-02.png" class="">
<ul>
<li>当填充为p步幅为1时：<ul>
<li>将输如填充k-p-1（k是核窗口）</li>
<li>将核矩阵上下、左右翻转</li>
<li>然后做正常卷积（填充0、步幅1）</li>
</ul>
</li>
</ul>
<img src="/2024/04/23/11-01-47/47-03.png" class="">
<ul>
<li><p>当填充为p步幅为s时：</p>
<ul>
<li><p>在行和列之间插入s-1行或列</p>
</li>
<li><p>将输如填充k-p-1（k是核窗口）</p>
</li>
<li>将核矩阵上下、左右翻转</li>
<li>然后做正常卷积（填充0、步幅1）</li>
</ul>
</li>
</ul>
<img src="/2024/04/23/11-01-47/47-04.png" class="">
</li>
<li><p>形状换算</p>
<ul>
<li><p>输入高（宽）为n，核k，填充p，步幅s：</p>
<ul>
<li><p>转置卷积：n‘=sn+k-2p-s</p>
</li>
<li><p>卷积：n’=[(n-k-2p+s)/s]向下取整</p>
</li>
</ul>
</li>
<li><p>如果让高宽成倍增加，那么k=2p+s</p>
</li>
</ul>
</li>
<li><p>同反卷积的关系</p>
<ul>
<li>数学上的反卷积是指卷积的逆运算<ul>
<li>若Y=conv（X,K），那么X=deconv（Y,K）</li>
</ul>
</li>
<li>反卷积很少用在深度学习中<ul>
<li>我们说的反卷积神经网络指用了转置卷积的神经网络</li>
</ul>
</li>
</ul>
</li>
<li><p>总结</p>
<ul>
<li>转置卷积是一种变化了输入和核的卷积，来得到上采用的目的</li>
<li>不等同于数学上的反卷积操作</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>46.语义分割</title>
    <url>/2024/04/23/11-01-46/</url>
    <content><![CDATA[<h2 id="46-语义分割"><a href="#46-语义分割" class="headerlink" title="46 语义分割"></a>46 语义分割</h2><h3 id="1-语义分割"><a href="#1-语义分割" class="headerlink" title="1.语义分割"></a>1.语义分割</h3><p>有时只能实现框选的目标检测还是太粗糙了，无法得到更精细的信息。语义分割将图片中的每个像素分类到对应的类别。</p>
<p>分割这一概念在计算机视觉中由来已久。最早的图片分割对给定图片使用聚类等方法把语义上比较像的像素放在一起，但通常不会告诉我们这些像素到底是什么。而语义分割可以告诉我们每个像素对应的label是什么。</p>
<p>这也意味着我们需要对图片的每一个像素都做label，使得语义分割成为了一个比较精细且大的任务。语义分割的数据集成本也较高，往往规模小像素高。常用的数据集之一是Pascal VOC2012。</p>
<img src="/2024/04/23/11-01-46/46-01.jpg" class="">
<h3 id="2-应用"><a href="#2-应用" class="headerlink" title="2.应用"></a>2.应用</h3><p>背景虚化：传统的背景替换往往采用绿幕。在没有绿幕的情况下传统相机可以通过光圈来实现背景虚化，对于手机等设备而言背景虚化通常使用的都是语义分割或结合图像景深信息。</p>
<p>路面分割：如无人驾驶时用于实时识别周围物体，实现找路的功能。</p>
<h3 id="3-实例分割"><a href="#3-实例分割" class="headerlink" title="3.实例分割"></a>3.实例分割</h3><p>语义分割只关心像素属于哪一类，而实例分割则更进一步，如图片里有两只狗，则需要得出哪个像素属于哪一只狗。可以将其理解为目标检测的进化版本。</p>
<img src="/2024/04/23/11-01-46/46-02.png" class="">
<h3 id="4-QA"><a href="#4-QA" class="headerlink" title="4.QA"></a>4.QA</h3><p>Q1: 能否做更细的语义分割如狗的头/身/腿？</p>
<blockquote>
<p>可以，有标注数据即可，不过可能会出现不同标注者对身体部位分界不同之类的问题。针对狗头这一例子可以考虑使用姿态识别得到关节点。</p>
</blockquote>
<p>Q2: 目标检测里做图像增广，目标框做对应变换后不再是矩形怎么办？</p>
<blockquote>
<p>如果很关心角度信息可以给框加入一个表示旋转角度的feature，也可以考虑在旋转后的原框外面画一个大框把它圈起来，这个大框是可以计算出来的。</p>
</blockquote>
<p>Q3: 把人像语义分割做到slides中的效果大概需要多少训练集？</p>
<blockquote>
<p>人像这块技术相对比较成熟，应该能找到很好的预训练模型在其基础上调整即可。人像的形状是比较容易做的，难点主要在于光照不同（可能使背景与人像/衣服模糊）</p>
</blockquote>
<p>Q4: 三维语义分割标注怎么做？</p>
<blockquote>
<p>（这里把三维理解成有景深的图片）一个简单的做法是把图片压缩成2维，也可以使用三维卷积。三维的分割实际上是好做的，因为一个物体的像素景深往往是连续的且与背景差距较大。</p>
</blockquote>
<p>Q5: 自动驾驶用语义分割，实例分割还是目标检测更合适？</p>
<blockquote>
<p>自动驾驶需要用到大量不同的模型，语义分割主要用于路面分割，目标检测用于检测前车/行人及其距离/速度。</p>
</blockquote>
<p>Q6: 语义分割有什么标注工具？</p>
<blockquote>
<p>国内外的数据标注公司会有这方面的平台，可以自己找找，老师认为这个比较简单，工具大同小异。</p>
<p>（弹幕提及较多：labelme）</p>
</blockquote>
<p>Q7: 摄像头怕过曝，逆光相关</p>
<blockquote>
<p>过曝不常见，但欠曝在光线不足时很常见，一种方法是做大量数据增广。逆光更难做一点，不过photoshop可以模拟出逆光效果用于数据增强，也可以在采集数据时采集一些逆光照片，检查低置信度的照片确认是否为逆光，之后加以标注对模型重新训练。这样的方法可能会涉及到数据隐私问题。</p>
</blockquote>
<p>Q8: 自动驾驶用纯视觉方案能不能做到很可靠？</p>
<blockquote>
<p>tesla做的就是纯视觉，国内/Google用激光雷达（贵但精准），此外大家都会用摄像头和雷达。老师的广电是使用纯摄像头方案一方面是因为技术团队在这方面有积累，另一个可能的原因是摄像头便宜，第三个原因是tesla的算力很大能很好处理大量摄像头信息，最后是Tesla有大量的数据积累，大量的数据可以弥补传感器方面的劣势。</p>
<p>理论上纯视觉自动驾驶是可行的，但目前只有Tesla做的还算可靠。</p>
</blockquote>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>48-全连接卷积神经网络（FCN）</title>
    <url>/2024/04/23/11-01-48/</url>
    <content><![CDATA[<h2 id="48-全连接卷积神经网络（FCN）"><a href="#48-全连接卷积神经网络（FCN）" class="headerlink" title="48.全连接卷积神经网络（FCN）"></a>48.全连接卷积神经网络（FCN）</h2><img src="/2024/04/23/11-01-48/48-01.png" class="">
<ul>
<li><p>代码</p>
<ul>
<li>见code</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>44.物体检测算法：R-CNN,SSD,YOLO</title>
    <url>/2024/04/23/11-01-44/</url>
    <content><![CDATA[<h2 id="44-物体检测算法：R-CNN-SSD-YOLO"><a href="#44-物体检测算法：R-CNN-SSD-YOLO" class="headerlink" title="44.物体检测算法：R-CNN,SSD,YOLO"></a>44.物体检测算法：R-CNN,SSD,YOLO</h2><h3 id="1-区域卷积神经网络"><a href="#1-区域卷积神经网络" class="headerlink" title="1.区域卷积神经网络"></a>1.区域卷积神经网络</h3><h4 id="1-1-R-CNN"><a href="#1-1-R-CNN" class="headerlink" title="1.1.R-CNN"></a>1.1.R-CNN</h4><ul>
<li>使用启发式搜索算法来选择锚框</li>
<li>使用预训练模型来对每个锚框抽取特征（每个锚框当作一个图片，用CNN）</li>
<li>训练一个SVM来类别分类（神经网络之前，category prediction）</li>
<li>训练一个线性回归模型来预测边缘框偏移（bounding box prediction）</li>
<li>兴趣区域（Rol）池化层<ul>
<li>给定一个锚框，均匀分割（如果没法均匀分割，取整）成 n x m 块，输出每块的最大值（max pooling）</li>
<li>不管锚框多大，总是输出nm个值</li>
<li>目的：每个锚框都可以变成想要的形状</li>
</ul>
</li>
</ul>
<h4 id="1-2-Fast-RCNN"><a href="#1-2-Fast-RCNN" class="headerlink" title="1.2 Fast RCNN"></a>1.2 Fast RCNN</h4><ul>
<li><p>RCNN需要对每个锚框进行CNN运算，这些特征抽取计算有重复，并且锚框数量大，特征抽取的计算量也大。Fast RCNN改进了这种计算量大的问题</p>
</li>
<li><p>使用CNN对整张图片抽取特征（快的关键）</p>
</li>
<li><p>使用Rol池化层对每个锚框（将在原图片中搜索到的锚框，映射到CNN得到的结果上），生成固定长度的特征</p>
</li>
</ul>
<img src="/2024/04/23/11-01-44/44-01.png" class="">
<h4 id="1-3-Faster-RCNN"><a href="#1-3-Faster-RCNN" class="headerlink" title="1.3 Faster RCNN"></a>1.3 Faster RCNN</h4><ul>
<li>在Fast RCNN基础上变得更快</li>
<li>使用一个 <strong>区域提议网络来替代启发式搜索获得更好的锚框</strong></li>
<li>如下图所示，将CNN结果输入到卷积层，然后用锚框去圈区域，这些锚框很多有好有坏，然后进行预测，binary 预测是预测这个锚框的好坏，即有没有有效的圈住物体，bounding box prediction预测是对锚框进行一些改进，最后用NMS（非极大值抑制）对锚框进行合并。</li>
<li>具体来说，区域提议网络的计算步骤如下：<ol>
<li>使用填充为1的3×3的卷积层变换卷积神经网络的输出，并将输出通道数记为c。这样，卷积神经网络为图像抽取的特征图中的每个单元均得到一个长度为c的新特征。</li>
<li>以特征图的每个像素为中心，生成多个不同大小和宽高比的锚框并标注它们。</li>
<li>使用锚框中心单元长度为c的特征，分别预测该锚框的二元类别（含目标还是背景）和边界框。</li>
<li>使用非极大值抑制，从预测类别为目标的预测边界框中移除相似的结果。最终输出的预测边界框即是兴趣区域汇聚层所需的提议区域。</li>
</ol>
</li>
</ul>
<img src="/2024/04/23/11-01-44/44-02.png" class="">
<h4 id="1-4-Mask-RCNN"><a href="#1-4-Mask-RCNN" class="headerlink" title="1.4 Mask RCNN"></a>1.4 Mask RCNN</h4><ul>
<li>如果有<strong>像素级别的标号</strong>，使用FCN（fully convolutional network）利用这些信息。可以提升CNN的性能</li>
<li><strong>Rol align</strong>。之前的Rol进行池化的时候，如果没法整除，可以直接取整。但是像素级别的标号预测的时候，会造成偏差的累积，导致边界预测不准确。未来避免这种情况，使用Rol align，也就是当没法整除，对每个像素值进行按比例分配。</li>
<li>具体来说，Mask R-CNN将兴趣区域汇聚层替换为了<em>兴趣区域对齐</em>层，使用<em>双线性插值</em>（bilinear interpolation）来保留特征图上的空间信息，从而更适于像素级预测。 兴趣区域对齐层的输出包含了所有与兴趣区域的形状相同的特征图。 它们不仅被用于预测每个兴趣区域的类别和边界框，还通过额外的全卷积网络预测目标的像素级位置。</li>
</ul>
<img src="/2024/04/23/11-01-44/44-03.png" class="">
<h4 id="1-5-总结"><a href="#1-5-总结" class="headerlink" title="1.5 总结"></a>1.5 总结</h4><ul>
<li>R-CNN是最早也是最有名的一类基于锚框和CNN的目标检测算法</li>
<li>Fast/Faster RCNN 持续提升性能</li>
<li>Faster RCNN和Mask RCNN是在要求高精度场景下常用的算法（但是速度是最慢的）</li>
</ul>
<h3 id="2-单发多框检测（SSD-single-shot-detection）"><a href="#2-单发多框检测（SSD-single-shot-detection）" class="headerlink" title="2. 单发多框检测（SSD single shot detection）"></a>2. 单发多框检测（SSD single shot detection）</h3><ul>
<li>生成锚框<ul>
<li>对每个像素，生成多个以它为中心的锚框</li>
<li>给定 n 个大小$s_1,…,s_n$和m个高宽比，生成n+m-1个锚框，其大小和高宽比分别为：$(s_1,r_1),(s_2,r_1)…,(s_n,r_1),(s_1,r_2),…,(s_1,r_m)$</li>
</ul>
</li>
<li>SSD模型<ul>
<li>对多个分辨率下的卷积特征，生成锚框，预测</li>
<li>一个基础网络，抽取特征，然后用多个卷积层来减半高宽</li>
<li>在每段都生成锚框<ul>
<li>底部段拟合小物体</li>
<li>顶部段拟合大物体</li>
</ul>
</li>
<li>对每个锚框预测类别和边缘框</li>
</ul>
</li>
</ul>
<img src="/2024/04/23/11-01-44/44-04.png" class="">
<ul>
<li>总结<ul>
<li>速度快，精度很低。这么多年，作者没有持续的提升，但是启发了后面的一系列工作，实现上相对比较简单。</li>
<li>SSD通过单神经网络来检测模型（single shot）</li>
<li>以像素为中心的产生多个锚框</li>
<li>在多个段的输出上进行多尺度的检测</li>
</ul>
</li>
</ul>
<h3 id="3-YOLO（you-only-look-once）"><a href="#3-YOLO（you-only-look-once）" class="headerlink" title="3. YOLO（you only look once）"></a>3. YOLO（you only look once）</h3><ul>
<li>SSD中锚框大量重复，因此浪费了很多计算资源</li>
<li>YOLO将图片均分为 S X S 个锚框</li>
<li>每个锚框预测 B 个边缘框（防止多个物体出现在一个锚框里面）</li>
<li>后续版本 v2 v3 v4 有持续改进</li>
<li>非锚框算法</li>
</ul>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>49-样式迁移</title>
    <url>/2024/04/23/11-01-49/</url>
    <content><![CDATA[<h2 id="样式迁移"><a href="#样式迁移" class="headerlink" title="样式迁移"></a>样式迁移</h2><p>样式迁移类似于手机相机中的滤镜，指的是给定内容图片和风格图片，合成一张新的图片，使得他的内容与内容图片相似，而风格却是风格图片的样子，如下例：</p>
<img src="/2024/04/23/11-01-49/%E6%A0%B7%E5%BC%8F%E8%BF%81%E7%A7%BB%E7%A4%BA%E4%BE%8B.png" class="">
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>如下图所示，可以用一个预训练好的神经网络来实现样式迁移：</p>
<ul>
<li>1：复制内容图片来初始化一张图片，之后将这张图片中的像素作为参数进行更新，最终得到合成的图片</li>
<li>2：将内容图片，当前的合成图片，样式图片分别输入一个相同的预训练好的神经网络</li>
<li>3：假设该神经网络的不同层分别提取与内容和风格相关的信息，可以据此得到一个损失：<ul>
<li>将合成图片与<strong>内容</strong>相关的层的输出与<strong>内容</strong>图片对应层的输出进行处理，得到<strong>内容损失</strong></li>
<li>将合成图片与<strong>风格</strong>相关的层的输出与<strong>风格</strong>图片对应层的输出进行处理，得到<strong>风格损失</strong></li>
<li>对合成图片本身，统计图片中的高频噪点（即过明或过暗像素点），得到<strong>全变分损失</strong></li>
<li>将三部分损失加起来得到总的样式迁移的<strong>损失函数</strong></li>
</ul>
</li>
<li>4：利用3定义的损失函数，以合成图片的每个像素点为参数进行梯度下降，得到最终合成的图片</li>
</ul>
<img src="/2024/04/23/11-01-49/CNN%E5%AE%9E%E7%8E%B0.png" class="">
<h3 id="内容损失"><a href="#内容损失" class="headerlink" title="内容损失"></a>内容损失</h3><p>神经网络内容相关层的输出的相似度可以直接反应两张图片在内容上的相似度，因此内容损失可以直接将对应层的输出视为内容直接求平方差损失。</p>
<h3 id="风格损失：格拉姆矩阵"><a href="#风格损失：格拉姆矩阵" class="headerlink" title="风格损失：格拉姆矩阵"></a>风格损失：格拉姆矩阵</h3><p>对于内容层，可以直接将对应层的输出求平方差损失，但是对于风格则略有不同</p>
<p>一般认为，风格层对应的输出的多个通道分别对应着不同类型的信息，如果将输出的形状从$[batch_size=1,channels,h,w]$转化为$[channels,h*w]$就能得到通道数个向量，以$x_1,x_2…x_c$表示，代表不同通道所提取出的不同信息，而风格可以视作这些信息之间的关联，即相似度。</p>
<p>定义格拉姆矩阵$\bold X * \bold X^T \in R^{c \cdot c}$，矩阵的第i行第j列即向量$x_i$与$x_j$的内积，这个矩阵就代表了一张图片的风格。</p>
<p>对于生成图片和风格图片的格拉姆矩阵求平方差损失就能得到所需的风格损失</p>
<p>此外，为了让风格损失不受格拉姆矩阵及向量的大小影响，实际将格拉姆矩阵除以这些大小$channnels<em>h</em>w$。</p>
<h3 id="全变分损失"><a href="#全变分损失" class="headerlink" title="全变分损失"></a>全变分损失</h3><p>用于去除高频噪点（过明过暗像素点）</p>
<script type="math/tex; mode=display">
\sum_{i, j} \left|x_{i, j} - x_{i+1, j}\right| + \left|x_{i, j} - x_{i, j+1}\right|</script>]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>50-课程竞赛：牛仔行头检测</title>
    <url>/2024/04/23/11-01-50/</url>
    <content><![CDATA[<h2 id="课程竞赛：牛仔行头检测"><a href="#课程竞赛：牛仔行头检测" class="headerlink" title="课程竞赛：牛仔行头检测"></a>课程竞赛：牛仔行头检测</h2><h3 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h3><p>图像中的目标检测，检测牛仔的装备，主要包括：夹克，墨镜，靴子，牛仔帽，腰带</p>
<p>有6937张训练图片，12660个标注框，数据集使用MS-COCO格式，可以调用pycocotools库，评测使用mAP（评测对每个类预测的框的好坏）</p>
<p>挑战：五个类别出现次数不同，墨镜、夹克次数多，牛仔帽、靴子其次，腰带很少</p>
<img src="/2024/04/23/11-01-50/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1.png" class="">
<h3 id="安排"><a href="#安排" class="headerlink" title="安排"></a>安排</h3><p>Kaggle不支持mAP，提交结果csv文件时网址不同</p>
<p>公私榜分配和之前不同，之前kaggle从所有数据中选出一部分作为私榜，本次限定了时间公榜结束后12小时内拿到私榜数据并提交结果，至多提交三次</p>
<p>提供了一个示例程序</p>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>51-序列模型</title>
    <url>/2024/04/23/11-01-51/</url>
    <content><![CDATA[<h1 id="序列模型"><a href="#序列模型" class="headerlink" title="序列模型"></a>序列模型</h1><h3 id="2-序列数据"><a href="#2-序列数据" class="headerlink" title="2.序列数据"></a>2.序列数据</h3><ul>
<li>实际中很多数据是有时序的</li>
<li>电影的评价随时间变化而变化<ul>
<li>拿了奖后评分上升，直到奖项被遗忘</li>
<li>看了很多好电影后，人们的期望变高</li>
<li>季节性：贺岁片，暑期档</li>
<li>导演、演员的负面报道导致评分变低</li>
</ul>
</li>
</ul>
<h4 id="2-1-更多例子"><a href="#2-1-更多例子" class="headerlink" title="2.1 更多例子"></a>2.1 更多例子</h4><ul>
<li><p>音乐、文本、语言和视频都是连续的</p>
<ul>
<li>标题“狗咬人”远没有“人咬狗”那么令人惊讶</li>
</ul>
</li>
<li><p>大地震发生后，很有可能会有几次较小的余震</p>
</li>
<li>人的互动是连续的，从网上吵架可以看出</li>
<li>预测明天的股价要比填补昨天遗失的股价更困难</li>
</ul>
<h3 id="3-统计工具"><a href="#3-统计工具" class="headerlink" title="3.统计工具"></a>3.统计工具</h3><ul>
<li><p>在时间t观察到<img src="https://latex.codecogs.com/svg.image?X_{t}" title="X_{t}" />，那么得到T个不独立的随机变量<img src="https://latex.codecogs.com/svg.image?(X_{1},...X_{t})\sim&space;p(X)" title="(X_{1},...X_{t})\sim p(X)" /></p>
</li>
<li><p>使用条件概率展开</p>
<p><img src="https://latex.codecogs.com/svg.image?p(a,b)=p(a)p(b|a)=p(b)p(a|b)" title="p(a,b)=p(a)p(b|a)=p(b)p(a|b)" /></p>
</li>
</ul>
<img src="/2024/04/23/11-01-51/51-01.png" class="">
<h3 id="4-序列模型"><a href="#4-序列模型" class="headerlink" title="4.序列模型"></a>4.序列模型</h3><img src="/2024/04/23/11-01-51/51-02.png" class="">
<ul>
<li>对条件概率建模</li>
</ul>
<img src="/2024/04/23/11-01-51/51-03.png" class="">
<h4 id="4-1-方案A-马尔科夫假设"><a href="#4-1-方案A-马尔科夫假设" class="headerlink" title="4.1 方案A:马尔科夫假设"></a>4.1 方案A:马尔科夫假设</h4><img src="/2024/04/23/11-01-51/51-04.png" class="">
<ul>
<li>假设当前数据只跟τ个过去数据点相关</li>
</ul>
<img src="/2024/04/23/11-01-51/51-05.png" class="">
<h4 id="4-2-方案B-潜变量模型"><a href="#4-2-方案B-潜变量模型" class="headerlink" title="4.2 方案B:潜变量模型"></a>4.2 方案B:潜变量模型</h4><img src="/2024/04/23/11-01-51/51-06.png" class="">
<ul>
<li>引入潜变量<img src="https://latex.codecogs.com/svg.image?h_{t}" title="h_{t}" />来表示过去信息<img src="https://latex.codecogs.com/svg.image?h_{t}=f(x_{1},...x_{t-1})" title="h_{t}=f(x_{1},...x_{t-1})" /><ul>
<li>这样<img src="https://latex.codecogs.com/svg.image?x_{t}=p(x_{t}|h_{t})" title="x_{t}=p(x_{t}|h_{t})" /></li>
</ul>
</li>
</ul>
<img src="/2024/04/23/11-01-51/51-07.png" class="">
<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h3><ul>
<li>时序模型中，当前数据跟之前观察到的数据相关</li>
<li>自回归模型使用自身过去数据来预测未来</li>
<li>马尔科夫模型假设当前只跟最近少数数据相关，从而简化模型</li>
<li>潜变量模型使用潜变量来概括历史信息</li>
</ul>
<h3 id="6-Q-amp-A："><a href="#6-Q-amp-A：" class="headerlink" title="6.Q&amp;A："></a>6.Q&amp;A：</h3><h5 id="Q1-在常规范围内tau是不是越大越好。刚才例子tau-5是不是比4好？"><a href="#Q1-在常规范围内tau是不是越大越好。刚才例子tau-5是不是比4好？" class="headerlink" title="Q1:在常规范围内tau是不是越大越好。刚才例子tau=5是不是比4好？"></a>Q1:在常规范围内tau是不是越大越好。刚才例子tau=5是不是比4好？</h5><blockquote>
<p>当然比4好，也有局限性，tau特别大，训练样本变小，模型变复杂</p>
</blockquote>
<h5 id="Q2：潜变量模型和隐马尔科夫模型有什么区别？"><a href="#Q2：潜变量模型和隐马尔科夫模型有什么区别？" class="headerlink" title="Q2：潜变量模型和隐马尔科夫模型有什么区别？"></a>Q2：潜变量模型和隐马尔科夫模型有什么区别？</h5><blockquote>
<p>没有太多联系，两个不同的观点，但是潜变量模型可以使用隐马尔科夫假设。潜变量-怎么建模，隐马尔科夫-这个数据和之前多少个数据有关。</p>
</blockquote>
<h5 id="Q3：若预测一个月，tau-30-预测7天，tau-7，是否有这样的关系？"><a href="#Q3：若预测一个月，tau-30-预测7天，tau-7，是否有这样的关系？" class="headerlink" title="Q3：若预测一个月，tau=30,预测7天，tau=7，是否有这样的关系？"></a>Q3：若预测一个月，tau=30,预测7天，tau=7，是否有这样的关系？</h5><blockquote>
<p>tau取决于对数据的理解，没有固定的规则</p>
</blockquote>
<h5 id="Q4：在预测未来方面，现在的sota模型能做到多好？"><a href="#Q4：在预测未来方面，现在的sota模型能做到多好？" class="headerlink" title="Q4：在预测未来方面，现在的sota模型能做到多好？"></a>Q4：在预测未来方面，现在的sota模型能做到多好？</h5><blockquote>
<p>具体问题具体分析，在有些领域做得好比如写作，写代码，在一些领域做的不好，比如预测股票。</p>
</blockquote>
<h5 id="Q5-tau能够随着xt的变化而变化吗？这样感觉更符合实际情况"><a href="#Q5-tau能够随着xt的变化而变化吗？这样感觉更符合实际情况" class="headerlink" title="Q5:tau能够随着xt的变化而变化吗？这样感觉更符合实际情况"></a>Q5:tau能够随着xt的变化而变化吗？这样感觉更符合实际情况</h5><blockquote>
<p>当然可以，有计算量的增加，也不一定更好</p>
</blockquote>
<h5 id="Q6-预测电池之类很多参数的未来变化趋势时怎么长步预测？"><a href="#Q6-预测电池之类很多参数的未来变化趋势时怎么长步预测？" class="headerlink" title="Q6:预测电池之类很多参数的未来变化趋势时怎么长步预测？"></a>Q6:预测电池之类很多参数的未来变化趋势时怎么长步预测？</h5><blockquote>
<p>与数据关系比较大，负类样本较少，所以比较难训练</p>
</blockquote>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>54-循环神经网络RNN</title>
    <url>/2024/04/23/11-01-54/</url>
    <content><![CDATA[<h3 id="使用潜变量"><a href="#使用潜变量" class="headerlink" title="使用潜变量"></a>使用潜变量</h3><ul>
<li>RNN使用了隐藏层来记录过去发生的所有事件的信息，从而引入时许的特性，并且避免常规序列模型每次都要重新计算前面所有已发生的事件而带来的巨大计算量。<img src="https://github.com/kinza99/DeepLearning-MuLi-Notes/blob/main/imgs/54/54-01.png" alt="截屏2022-02-12 下午2.17.32"></li>
</ul>
<h3 id="RNN"><a href="#RNN" class="headerlink" title="RNN"></a>RNN</h3><ul>
<li>流程如下，首先有一个输入序列，对于时刻t，我们用t-1时刻的输入x~t-1~和潜变量h~t-1~来计算新的潜变量h~t~。同时，对于t时刻的输出o~t~，则直接使用h~t~来计算得到。注意，计算第一个潜变量只需要输入即可（因为前面并不存在以往的潜变量）。<img src="https://github.com/kinza99/DeepLearning-MuLi-Notes/blob/main/imgs/54/54-02.png" alt="截屏2022-02-12 下午2.34.14"> </li>
<li>值得注意的是，RNN本质也是一种MLP，尤其是将h~t-1~这一项去掉时就完全退化成了MLP。RNN的核心其实也就是h~t-1~这一项，它使得模型可以和前面的信息联系起来，将时序信息储存起来，可以把RNN理解为是包含时序信息的MLP。</li>
</ul>
<h3 id="困惑度"><a href="#困惑度" class="headerlink" title="困惑度"></a>困惑度</h3><ul>
<li>为了衡量一个语言模型的好坏，例如分类模型，可以使用平均交叉熵来衡量，就是将预测概率的负对数值求和之后再去平均，即常用的交叉熵损失。但是由于某些历史原因，NLP往往不是用这种方式，而是在这种方式的基础上最后再取指数，即exp，这样得到的结果如果是1，说明完美；如果是无穷大，说明结果很差。</li>
</ul>
<h3 id="梯度裁剪"><a href="#梯度裁剪" class="headerlink" title="梯度裁剪"></a>梯度裁剪</h3><ul>
<li>在T个时间步中进行反向传播，会由于产生O(T)长度的梯度乘法链，导致导数数值不稳定，这里使用一个限制θ，通常为5到10，来控制梯度乘法链的长度。使用如下的公式<img src="https://github.com/kinza99/DeepLearning-MuLi-Notes/blob/main/imgs/54/54-03.png" alt="截屏2022-02-12 下午3.10.38">在这个公式中，如果梯度长度大于θ，梯度g会变为<script type="math/tex; mode=display">
\frac{\theta}{\Vert g \Vert} g</script>这样再对g求2范式就变成了θ，所以可以把梯度限制在θ以下。</li>
</ul>
<h3 id="更多的应用RNNs"><a href="#更多的应用RNNs" class="headerlink" title="更多的应用RNNs"></a>更多的应用RNNs</h3><ul>
<li>基本的应用如下图<img src="https://github.com/kinza99/DeepLearning-MuLi-Notes/blob/main/imgs/54/54-04.png" alt="截屏2022-02-12 下午3.36.29"></li>
</ul>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>56-门控循环单元(GRU)</title>
    <url>/2024/04/23/11-01-56/</url>
    <content><![CDATA[<h2 id="56-门控循环单元-GRU"><a href="#56-门控循环单元-GRU" class="headerlink" title="56-门控循环单元(GRU)"></a>56-门控循环单元(GRU)</h2><h3 id="1-动机：如何关注一个序列"><a href="#1-动机：如何关注一个序列" class="headerlink" title="1. 动机：如何关注一个序列"></a>1. 动机：如何关注一个序列</h3><ul>
<li>不是每个观察值都是同等重要</li>
</ul>
<img src="/2024/04/23/11-01-56/56-01.png" class="">
<p>比如上图中的序列，若干个猫中出现了一个鼠，那么我们应该重点关注这个鼠，而中间重复出现的猫则减少关注。文本序列同理，通常长文本我们需要关注的是几个关键词，关键句。</p>
<ul>
<li>想只记住相关的观察需要：<ul>
<li>能<strong>关注</strong>的机制（<strong>更新门</strong>）：顾名思义，是否需要根据我的输入，更新隐藏状态</li>
<li>能<strong>遗忘</strong>的机制（<strong>重置门</strong>）：更新候选项时，是否要考虑前一隐藏状态。</li>
</ul>
</li>
</ul>
<h3 id="2-门的概念"><a href="#2-门的概念" class="headerlink" title="2. 门的概念"></a>2. 门的概念</h3><ul>
<li><p>更新门Zt，重置门Rt的公式大体相同，唯一不同的是学习到的参数。</p>
</li>
<li><p>需要注意的是，计算门的方式和原来RNN的实现中计算新的隐状态相似，只是激活函数改成了sigmoid。</p>
</li>
<li>门本来是电路中的一个概念，0,1代表不同的电平，可以用于控制电路的通断。此处sigmoid将门的数值归一化到0到1之间，是一种”软更新”方式。而从后面的公式上可以看出，本讲课程采用的是低电平有效（越靠近0，门的作用越明显）的方式控制。</li>
</ul>
<img src="/2024/04/23/11-01-56/56-02.png" class="">
<h3 id="3-候选隐状态"><a href="#3-候选隐状态" class="headerlink" title="3. 候选隐状态"></a>3. 候选隐状态</h3><img src="/2024/04/23/11-01-56/56-03.png" class="">
<ul>
<li><p>候选隐状态，如果抛开公式中的$R_{t}$遗忘门来说，这个和之前RNN中计算当前步的隐状态没有差别。</p>
</li>
<li><p>但是这里引入了遗忘门，如果$R_{t}$无限接近于0，那么此时候选隐状态将不再考虑前一隐状态的影响，也就是和MLP没有区别，起到“遗忘”的作用；</p>
</li>
<li>反之，如果$R_{t}$无限接近于1，那么与RNN计算隐状态的过程没有差别，不进行遗忘。</li>
<li>公式中的⊙表示逐元素乘积。</li>
</ul>
<blockquote>
<p>为什么叫候选隐状态？</p>
<p>在RNN中，这个所谓的候选隐状态就是当前步的隐状态（$R_{t}$无限接近1时）。但是由于引入了更新门，我们需要考虑是直接沿用上一步的隐藏状态，还是像RNN一样使用当前步计算的隐状态。所以这个结合了当前输入计算的隐状态，不能立马变成当前的$H_{t}$，而是需要用更新门和前一隐状态$H_{t-1}$做一个加权，所以它是一个候选项。</p>
</blockquote>
<h3 id="4-隐状态"><a href="#4-隐状态" class="headerlink" title="4. 隐状态"></a>4. 隐状态</h3><img src="/2024/04/23/11-01-56/56-04.png" class="">
<p>用更新门对<strong>候选隐状态</strong>和<strong>前一隐状态</strong>做加权，得到当前步<strong>隐状态</strong>的值。</p>
<p>如果$Z_{t}$无限接近于0，更新起作用，候选隐状态“转正”，变为当前隐状态。</p>
<p>如果$Z_{t}$无限接近于1，更新不起作用，当前隐状态还是沿用前一隐状态。</p>
<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><img src="/2024/04/23/11-01-56/56-05.png" class="">
<p>上图四行公式概括了GRU模型。在RNN的基础上，最重要的是引入了<strong>更新门和重置门</strong>，来决定前一隐状态对当前隐状态的影响。以最开始的猫鼠序列的例子来说，如果我的模型一直看到猫，模型可以学习到隐状态不怎么去更新，于是隐状态一直保留了猫的信息，而看到老鼠，隐状态才进行更新。</p>
<ul>
<li>对于一个更具体的例子而言(语言模型)：</li>
</ul>
<p>“The cat, which already ate ……, __(is/ was) full.”，假设我的句子很长，预测完前面的词后需要预测下一个词is还是was，如果引入这种更新/重置的机制，那我们的模型可以在was这个词之前尽可能去保持隐状态的信息，从而即使阅读了一个很长的定语从句，但我们还是保留了cat这个词的单数信息，从而模型预测下一个词为’was’。</p>
<ul>
<li>一个与RNN的联动在于：</li>
</ul>
<p>如果更新门完全发挥作用（无限接近于0），重置门不起作用（无限接近于1），此时GRU模型退化为RNN模型。</p>
<h3 id="6-QA"><a href="#6-QA" class="headerlink" title="6. QA"></a>6. QA</h3><p>问题：GRU为什么需要两个门？</p>
<blockquote>
<p>重置门和更新门各司其职。重置门单方面控制自某个节点开始，之前的记忆（隐状态）不在乎了，直接清空影响，同时也需要更新门帮助它实现记忆的更新。更新门更多是用于处理梯度消失问题，可以选择一定程度地保留记忆，防止梯度消失。</p>
<p>重置门影响的是当前步新的候选隐状态的计算，更新门影响的是当前步隐状态的更新程度。</p>
</blockquote>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>57-长短期记忆网络(LSTM)</title>
    <url>/2024/04/23/11-01-57/</url>
    <content><![CDATA[<h1 id="长短期记忆网络"><a href="#长短期记忆网络" class="headerlink" title="长短期记忆网络"></a>长短期记忆网络</h1><h3 id="2-长短期记忆网络："><a href="#2-长短期记忆网络：" class="headerlink" title="2.长短期记忆网络："></a>2.长短期记忆网络：</h3><ul>
<li>忘记门：将值朝0减少</li>
<li>输入门：决定是不是忽略掉输入数据</li>
<li>输出门：决定是不是使用隐状态</li>
</ul>
<p>可以说，长短期记忆网络的设计灵感来自于计算机的逻辑门。 长短期记忆网络引入了<em>记忆元</em>（memory cell），或简称为<em>单元</em>（cell）。 有些文献认为记忆元是隐状态的一种特殊类型， 它们与隐状态具有相同的形状，其设计目的是用于记录附加的信息。 为了控制记忆元，我们需要许多门。 其中一个门用来从单元中输出条目，我们将其称为<em>输出门</em>（output gate）。 另外一个门用来决定何时将数据读入单元，我们将其称为<em>输入门</em>（input gate）。 我们还需要一种机制来重置单元的内容，由<em>遗忘门</em>（forget gate）来管理， 这种设计的动机与门控循环单元相同， 能够通过专用机制决定什么时候记忆或忽略隐状态中的输入。 让我们看看这在实践中是如何运作的。</p>
<h4 id="2-1-门："><a href="#2-1-门：" class="headerlink" title="2.1 门："></a>2.1 门：</h4><p>输入门：<img src="https://latex.codecogs.com/svg.image?I_{t}=\sigma&space;(X_{t}W_{xi}&plus;H_{t-1}W_{hi}&plus;b_{i})" title="I_{t}=\sigma (X_{t}W_{xi}+H_{t-1}W_{hi}+b_{i})" /></p>
<p>忘记门：<img src="https://latex.codecogs.com/svg.image?F_{t}=\sigma&space;(X_{t}W_{xf}&plus;H_{t-1}W_{hf}&plus;b_{f})" title="F_{t}=\sigma (X_{t}W_{xf}+H_{t-1}W_{hf}+b_{f})" /></p>
<p>输出门：<img src="https://latex.codecogs.com/svg.image?O_{t}=\sigma&space;(X_{t}W_{xo}&plus;H_{t-1}W_{ho}&plus;b_{o})" title="O_{t}=\sigma (X_{t}W_{xo}+H_{t-1}W_{ho}+b_{o})" /></p>
<p>这三个门的算式和普通RNN计算Ht算式相同。</p>
<img src="/2024/04/23/11-01-57/57-1.png" class="">
<h4 id="2-2候选记忆单元"><a href="#2-2候选记忆单元" class="headerlink" title="2.2候选记忆单元"></a>2.2候选记忆单元</h4><p><img src="https://latex.codecogs.com/svg.image?\widetilde{C_{t}}=tanh(X_{t}W_{xc}&plus;H_{t-1}W_{hc}&plus;b_{c})" title="\widetilde{C_{t}}=tanh(X_{t}W_{xc}+H_{t-1}W_{hc}+b_{c})" /></p>
<p>相当于在ht-1到ht的预测中又加了一层隐藏单元</p>
<img src="/2024/04/23/11-01-57/57-2.png" class="">
<h4 id="2-2记忆单元"><a href="#2-2记忆单元" class="headerlink" title="2.2记忆单元"></a>2.2记忆单元</h4><p><img src="https://latex.codecogs.com/svg.image?C_{t}=F_{t}\odot&space;C_{t-1}&plus;I_{t}\odot&space;\widetilde{C_{t}}" title="C_{t}=F_{t}\odot C_{t-1}+I_{t}\odot \widetilde{C_{t}}" /></p>
<p>如果遗忘门始终为(1)且输入门始终为(0)， 则过去的记忆元 将随时间被保存并传递到当前时间步。 引入这种设计是为了缓解梯度消失问题， 并更好地捕获序列中的长距离依赖关系。</p>
<img src="/2024/04/23/11-01-57/57-3.png" class="">
<h4 id="2-3隐状态"><a href="#2-3隐状态" class="headerlink" title="2.3隐状态"></a>2.3隐状态</h4><p><img src="https://latex.codecogs.com/svg.image?H_{t}=O_{t}\odot&space;tanh(C_{t})" title="H_{t}=O_{t}\odot tanh(C_{t})" /></p>
<p>最后，我们需要定义如何计算隐状态， 这就是输出门发挥作用的地方。 在长短期记忆网络中，它仅仅是记忆元的的门控版本。 这就确保了Ht的值始终在区间((-1, 1))内.</p>
<p>只要输出门接近1，我们就能够有效地将所有记忆信息传递给预测部分， 而对于输出门接近(0)，我们只保留记忆元内的所有信息，而不需要更新隐状态。</p>
<img src="/2024/04/23/11-01-57/57-4.png" class="">
<h4 id="2-4总结"><a href="#2-4总结" class="headerlink" title="2.4总结"></a>2.4总结</h4><p>LSTM的计算流程：</p>
<p><img src="https://latex.codecogs.com/svg.image?I_{t}=\sigma&space;(X_{t}W_{xi}&plus;H_{t-1}W_{hi}&plus;b_{i})" title="I_{t}=\sigma (X_{t}W_{xi}+H_{t-1}W_{hi}+b_{i})" /></p>
<p><img src="https://latex.codecogs.com/svg.image?F_{t}=\sigma&space;(X_{t}W_{xf}&plus;H_{t-1}W_{hf}&plus;b_{f})" title="F_{t}=\sigma (X_{t}W_{xf}+H_{t-1}W_{hf}+b_{f})" /></p>
<p><img src="https://latex.codecogs.com/svg.image?O_{t}=\sigma&space;(X_{t}W_{xo}&plus;H_{t-1}W_{ho}&plus;b_{o})" title="O_{t}=\sigma (X_{t}W_{xo}+H_{t-1}W_{ho}+b_{o})" /></p>
<p><img src="https://latex.codecogs.com/svg.image?\widetilde{C_{t}}=tanh(X_{t}W_{xc}&plus;H_{t-1}W_{hc}&plus;b_{c})" title="\widetilde{C_{t}}=tanh(X_{t}W_{xc}+H_{t-1}W_{hc}+b_{c})" /></p>
<p><img src="https://latex.codecogs.com/svg.image?C_{t}=F_{t}\odot&space;C_{t-1}&plus;I_{t}\odot&space;\widetilde{C_{t}}" title="C_{t}=F_{t}\odot C_{t-1}+I_{t}\odot \widetilde{C_{t}}" /></p>
<p><img src="https://latex.codecogs.com/svg.image?H_{t}=O_{t}\odot&space;tanh(C_{t})" title="H_{t}=O_{t}\odot tanh(C_{t})" /></p>
<h3 id="3-从零实现"><a href="#3-从零实现" class="headerlink" title="3.从零实现"></a>3.从零实现</h3><p>加载时光机器数据集</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line">batch_size, num_steps = <span class="number">32</span>, <span class="number">35</span></span><br><span class="line">train_iter, vocab = d2l.load_data_time_machine(batch_size, num_steps)</span><br></pre></td></tr></table></figure>
<h4 id="3-1初始化模型参数"><a href="#3-1初始化模型参数" class="headerlink" title="3.1初始化模型参数"></a>3.1初始化模型参数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_lstm_params</span>(<span class="params">vocab_size, num_hiddens, device</span>):</span><br><span class="line">    num_inputs = num_outputs = vocab_size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">normal</span>(<span class="params">shape</span>):</span><br><span class="line">        <span class="keyword">return</span> torch.randn(size=shape, device=device)*<span class="number">0.01</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">three</span>():</span><br><span class="line">        <span class="keyword">return</span> (normal((num_inputs, num_hiddens)),</span><br><span class="line">                normal((num_hiddens, num_hiddens)),</span><br><span class="line">                torch.zeros(num_hiddens, device=device))</span><br><span class="line"></span><br><span class="line">    W_xi, W_hi, b_i = three()  <span class="comment"># 输入门参数</span></span><br><span class="line">    W_xf, W_hf, b_f = three()  <span class="comment"># 遗忘门参数</span></span><br><span class="line">    W_xo, W_ho, b_o = three()  <span class="comment"># 输出门参数</span></span><br><span class="line">    W_xc, W_hc, b_c = three()  <span class="comment"># 候选记忆元参数</span></span><br><span class="line">    <span class="comment"># 输出层参数</span></span><br><span class="line">    W_hq = normal((num_hiddens, num_outputs))</span><br><span class="line">    b_q = torch.zeros(num_outputs, device=device)</span><br><span class="line">    <span class="comment"># 附加梯度</span></span><br><span class="line">    params = [W_xi, W_hi, b_i, W_xf, W_hf, b_f, W_xo, W_ho, b_o, W_xc, W_hc,</span><br><span class="line">              b_c, W_hq, b_q]</span><br><span class="line">    <span class="keyword">for</span> param <span class="keyword">in</span> params:</span><br><span class="line">        param.requires_grad_(<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> params</span><br></pre></td></tr></table></figure>
<h4 id="3-2定义模型"><a href="#3-2定义模型" class="headerlink" title="3.2定义模型"></a>3.2定义模型</h4><p>在初始化函数中， 长短期记忆网络的隐状态需要返回一个<em>额外</em>的记忆元， 单元的值为0，形状为（批量大小，隐藏单元数）。 因此，我们得到以下的状态初始化。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">init_lstm_state</span>(<span class="params">batch_size, num_hiddens, device</span>):</span><br><span class="line">    <span class="keyword">return</span> (torch.zeros((batch_size, num_hiddens), device=device),</span><br><span class="line">            torch.zeros((batch_size, num_hiddens), device=device))</span><br></pre></td></tr></table></figure>
<p>实际模型的定义与我们前面讨论的一样： 提供三个门和一个额外的记忆元。 请注意，只有隐状态才会传递到输出层， 而记忆元(\mathbf{C}_t)不直接参与输出计算。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lstm</span>(<span class="params">inputs, state, params</span>):</span><br><span class="line">    [W_xi, W_hi, b_i, W_xf, W_hf, b_f, W_xo, W_ho, b_o, W_xc, W_hc, b_c,</span><br><span class="line">     W_hq, b_q] = params</span><br><span class="line">    (H, C) = state</span><br><span class="line">    outputs = []</span><br><span class="line">    <span class="keyword">for</span> X <span class="keyword">in</span> inputs:</span><br><span class="line">        I = torch.sigmoid((X @ W_xi) + (H @ W_hi) + b_i)</span><br><span class="line">        F = torch.sigmoid((X @ W_xf) + (H @ W_hf) + b_f)</span><br><span class="line">        O = torch.sigmoid((X @ W_xo) + (H @ W_ho) + b_o)</span><br><span class="line">        C_tilda = torch.tanh((X @ W_xc) + (H @ W_hc) + b_c)</span><br><span class="line">        C = F * C + I * C_tilda</span><br><span class="line">        H = O * torch.tanh(C)</span><br><span class="line">        Y = (H @ W_hq) + b_q</span><br><span class="line">        outputs.append(Y)</span><br><span class="line">    <span class="keyword">return</span> torch.cat(outputs, dim=<span class="number">0</span>), (H, C)</span><br></pre></td></tr></table></figure>
<h4 id="3-3训练和预测"><a href="#3-3训练和预测" class="headerlink" title="3.3训练和预测"></a>3.3训练和预测</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">vocab_size, num_hiddens, device = <span class="built_in">len</span>(vocab), <span class="number">256</span>, d2l.try_gpu()</span><br><span class="line">num_epochs, lr = <span class="number">500</span>, <span class="number">1</span></span><br><span class="line">model = d2l.RNNModelScratch(<span class="built_in">len</span>(vocab), num_hiddens, device, get_lstm_params,</span><br><span class="line">                            init_lstm_state, lstm)</span><br><span class="line">d2l.train_ch8(model, train_iter, vocab, lr, num_epochs, device)</span><br></pre></td></tr></table></figure>
<img src="/2024/04/23/11-01-57/57-5.png" class="">
<h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><h5 id="Q1：请问LSTM如果不要C-把公式里的换成，好像可以实现隐藏状态往下传递？"><a href="#Q1：请问LSTM如果不要C-把公式里的换成，好像可以实现隐藏状态往下传递？" class="headerlink" title="Q1：请问LSTM如果不要C,把公式里的换成，好像可以实现隐藏状态往下传递？"></a>Q1：请问LSTM如果不要C,把公式里的<img src="https://latex.codecogs.com/svg.image?&space;C_{t-1}" title=" C_{t-1}" />换成<img src="https://latex.codecogs.com/svg.image?&space;H_{t-1}" title=" H_{t-1}" />，好像可以实现隐藏状态往下传递？</h5><blockquote>
<p><img src="https://latex.codecogs.com/svg.image?&space;C_{t-1}" title=" C_{t-1}" />的可以约束<img src="https://latex.codecogs.com/svg.image?&space;H_{t-1}" title=" H_{t-1}" />的大小在0-1之间，避免梯度爆炸，而且使算式更加自然，c换成h复杂度降低。</p>
</blockquote>
<h5 id="Q2：I-F-O-C-tilda的初始化为零？"><a href="#Q2：I-F-O-C-tilda的初始化为零？" class="headerlink" title="Q2：I,F,O,C_tilda的初始化为零？"></a>Q2：I,F,O,C_tilda的初始化为零？</h5><blockquote>
<p>这些是计算的中间变量，不需要初始化</p>
</blockquote>
<h5 id="Q3：如何计算模型占用显存，batch占用的显存？"><a href="#Q3：如何计算模型占用显存，batch占用的显存？" class="headerlink" title="Q3：如何计算模型占用显存，batch占用的显存？"></a>Q3：如何计算模型占用显存，batch占用的显存？</h5><blockquote>
<p>取决于框架和库，没法具体算</p>
</blockquote>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>61-编码器-解码器架构</title>
    <url>/2024/04/23/11-06-01/</url>
    <content><![CDATA[<h2 id="编码器-解码器架构"><a href="#编码器-解码器架构" class="headerlink" title="编码器-解码器架构"></a>编码器-解码器架构</h2><h3 id="CNN中的解释"><a href="#CNN中的解释" class="headerlink" title="CNN中的解释"></a>CNN中的解释</h3><p>考虑一个CNN模型：</p>
<img src="/2024/04/23/11-06-01/CNN.png" class="">
<p>整个CNN实际上可以看作一个编码器，解码器两部分。</p>
<ul>
<li>底层的神经网络，也就是编码器将输入编码成能被模型识别的中间表达形式，也就是特征</li>
<li>解码器将中间结果解码为输出</li>
</ul>
<h3 id="RNN中的解释"><a href="#RNN中的解释" class="headerlink" title="RNN中的解释"></a>RNN中的解释</h3><p>对于RNN而言，同样有着类似的划分</p>
<img src="/2024/04/23/11-06-01/RNN.png" class="">
<ul>
<li>编码器将输入文本表示为向量</li>
<li>解码器将向量表示为输出</li>
</ul>
<h3 id="抽象的编码器-解码器架构"><a href="#抽象的编码器-解码器架构" class="headerlink" title="抽象的编码器-解码器架构"></a>抽象的编码器-解码器架构</h3><p>指一个模型被分为两块：</p>
<ul>
<li>一块是编码器，也叫encoder，用于将输入处理为一个中间状态</li>
<li>一块是解码器，也叫decoder，用于将中间状态表示为输出</li>
<li>解码器也可以有额外的输入提供信息</li>
</ul>
<img src="/2024/04/23/11-06-01/encoder-decoder.png" class="">
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>62-序列到序列学习</title>
    <url>/2024/04/23/11-06-02/</url>
    <content><![CDATA[<h2 id="62-序列到序列学习"><a href="#62-序列到序列学习" class="headerlink" title="62-序列到序列学习"></a>62-序列到序列学习</h2><h3 id="1-应用举例：机器翻译"><a href="#1-应用举例：机器翻译" class="headerlink" title="1. 应用举例：机器翻译"></a>1. 应用举例：机器翻译</h3><ul>
<li>给定一个源语言的句子，自动翻译成目标语言</li>
<li>这两个句子可以有不同的长度</li>
</ul>
<h3 id="2-模型架构：Seq2seq"><a href="#2-模型架构：Seq2seq" class="headerlink" title="2. 模型架构：Seq2seq"></a>2. 模型架构：Seq2seq</h3><img src="/2024/04/23/11-06-02/62-01.png" class="">
<ul>
<li><p>序列到序列模型由<strong>编码器-解码器</strong>构成。</p>
</li>
<li><p><strong>编码器</strong>RNN可以是<strong>双向</strong>，由于输入的句子是完整地，可以正着看，也可以反着看；而<strong>解码器</strong>只能是<strong>单向</strong>，由于预测时，只能正着去预测。</p>
</li>
<li>编码器，解码器采用<strong>不同的RNN</strong>，此RNN也可以是GRU，LSTM等。</li>
</ul>
<h3 id="3-编码器-解码器细节"><a href="#3-编码器-解码器细节" class="headerlink" title="3. 编码器-解码器细节"></a>3. 编码器-解码器细节</h3><img src="/2024/04/23/11-06-02/62-02.png" class="">
<ul>
<li><p>编码器的RNN<strong>没有</strong>连接<strong>输出层</strong></p>
</li>
<li><p><strong>编码器</strong>的<strong>最后时间步的隐状态</strong>用作<strong>解码器</strong>的<strong>初始隐状态</strong>（图中箭头的传递）</p>
</li>
</ul>
<h3 id="4-训练和推理"><a href="#4-训练和推理" class="headerlink" title="4. 训练和推理"></a>4. 训练和推理</h3><img src="/2024/04/23/11-06-02/62-03.png" class="">
<ul>
<li>第3节中提到编码器没有输出层，只有解码器有，于是损失函数的计算只关注解码器的输出层。</li>
<li>训练和预测（推理）有区别的，训练时解码器使用目标句子（真值）作为输入，以指导模型训练；而推理时无法提前得知真值，需要一步一步进行预测。</li>
</ul>
<h3 id="5-衡量生成序列的好坏：BLEU"><a href="#5-衡量生成序列的好坏：BLEU" class="headerlink" title="5. 衡量生成序列的好坏：BLEU"></a>5. 衡量生成序列的好坏：BLEU</h3><h4 id="5-1-BLUE值定义："><a href="#5-1-BLUE值定义：" class="headerlink" title="5.1 BLUE值定义："></a>5.1 BLUE值定义：</h4><img src="/2024/04/23/11-06-02/62-04.png" class="">
<p>宗成庆老师《统计自然语言处理》（第二版）一书中关于BLEU的定义：</p>
<img src="/2024/04/23/11-06-02/62-05.png" class="">
<p>同时，吴恩达深度学习课程中也是使用这一方式定义。但观察两种方式，BP惩罚因子的计算是一致的，pn也是使用了几何平均的方式，只是对于wn这一加权值的选择有所不同。</p>
<h4 id="5-2-定义式解析"><a href="#5-2-定义式解析" class="headerlink" title="5.2 定义式解析"></a>5.2 定义式解析</h4><img src="/2024/04/23/11-06-02/62-06.png" class="">
<p>BLEU值衡量的是精确率，而且对不同n-gram进行集成打分。</p>
<ul>
<li><p>BP惩罚因子：为了惩罚过短的句子，由于过短的句子基数小，精确率容易提升，所以加上一个BP乘子，当预测句子长度&lt;参考句子长度，则BP&lt;1。</p>
</li>
<li><p>wn的选择：李沐老师课程中是采用了$\frac{1}{2^n}$​作为加权因子，n越大，加权因子越小，但由于pn&lt;1，赋予的权重越大，即长匹配具有更高的权重。而宗老师的书中所述：在BLEU的基线系统中取N＝4，wn＝1/N，也可以参考。</p>
</li>
</ul>
<h3 id="6-QA"><a href="#6-QA" class="headerlink" title="6. QA"></a>6. QA</h3><p>问题：LSTM、GRU、Seq2Seq的区别是什么？</p>
<blockquote>
<p>Seq2Seq是一种由编码器和解码器组成的框架，而LSTM、GRU是组成编码器和解码器的一种单元。</p>
</blockquote>
<p>问题：encoder的输出和decoder的输入，拼接和按位相加起来有什么区别么？</p>
<blockquote>
<p>不能够按位加，由于encoder的输出最后维度是hidden_size，而decoder的输入最后维度是embedding_size，可能不一样，所以用拼接。</p>
</blockquote>
<p>问题：embedding层是做word2vec吗？</p>
<blockquote>
<p>这里不是，这里是从头开始训练。现在用的比较多得都是预训练，BERT等。</p>
</blockquote>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>53-语言模型</title>
    <url>/2024/04/23/11-01-53/</url>
    <content><![CDATA[<h3 id="53-语言模型"><a href="#53-语言模型" class="headerlink" title="53 语言模型"></a>53 语言模型</h3><ul>
<li><p>语言模型的目标：</p>
<p>假设长度为<em>T</em>的文本序列中的词元依次为<em>x</em>~1~,<em>x</em>~2~,…,<em>x~T~</em>。 于是，<em>x~t~</em>（1≤<em>t</em>≤<em>T</em>） 可以被认为是文本序列在时间步<em>t</em>处的观测或标签。 在给定这样的文本序列时目标是估计序列的联合概率<em>P</em>(<em>x</em>~1~,<em>x~2~</em>,…,<em>x~T~</em>)</p>
</li>
</ul>
<h4 id="学习语言模型"><a href="#学习语言模型" class="headerlink" title="学习语言模型"></a>学习语言模型</h4><ul>
<li><p>基本想法：</p>
<p><em>P</em>(<em>x</em>~1~,<em>x~2~</em>,…,<em>x~T~</em>) = <em>P</em>(<em>x~t~</em>∣<em>x</em>~1~,…,<em>x~t−1~</em>). (1 &lt;= t &lt;= T) 共T个结果相乘</p>
<p>例如，包含了四个单词的一个文本序列的概率是：</p>
<p><em>P</em>(deep,learning,is,fun)=<em>P</em>(deep)<em>P</em>(learning∣deep)<em>P</em>(is∣deep,learning)<em>P</em>(fun∣deep,learning,is) </p>
<p>为了训练语言模型，我们需要计算单词的概率， 以及给定前面几个单词后出现某个单词的条件概率。 这些概率本质上就是语言模型的参数。训练数据集中词的概率可以根据给定词的相对词频来计算。 例如，可以将估计值<em>P</em>^(deep) 计算为任何以单词“deep”开头的句子的概率。 一种（稍稍不太精确的）方法是统计单词“deep”在数据集中的出现次数， 然后将其除以整个语料库中的单词总数。 这种方法效果不错，特别是对于频繁出现的单词。</p>
</li>
<li><p>基本想法的问题：</p>
<p>由于连续单词对“deep learning”的出现频率要低得多， 所以估计这类单词正确的概率要困难得多。 特别是对于一些不常见的单词组合，要想找到足够的出现次数来获得准确的估计可能都不容易。 而对于三个或者更多的单词组合，情况会变得更糟。 许多合理的三个单词组合可能是存在的，但是在数据集中却找不到。 除非我们提供某种解决方案，来将这些单词组合指定为非零计数， 否则将无法在语言模型中使用它们。 如果数据集很小，或者单词非常罕见，那么这类单词出现一次的机会可能都找不到。</p>
</li>
</ul>
<h4 id="马尔可夫模型与n元语法"><a href="#马尔可夫模型与n元语法" class="headerlink" title="马尔可夫模型与n元语法"></a>马尔可夫模型与n元语法</h4><ul>
<li>如果<em>P</em>(x~t+1~∣<em>x~t~</em>,…,<em>x</em>~1~)=<em>P</em>(x~t+1~∣<em>x~t~</em>)， 则序列上的分布满足一阶马尔可夫性质。 阶数越高，对应的依赖关系就越长。 这种性质推导出了许多可以应用于序列建模的近似公式：<ul>
<li>P(x~1~,x~2~,x~3~,x~4~) = P(x~1~)P(x~2~)P(x~3~)P(x~4~)</li>
<li>P(x~1~,x~2~,x~3~,x~4~) = P(x~1~)P(x~2~ |x~1~)P(x~3~|x~2~)P(x~4~|x~3~)</li>
<li>P(x~1~,x~2~,x~3~,x~4~) = P(x~1~)P(x~2~ |x~1~)P(x~3~|x~1~,x~2~)P(x~4~|x~2~,x~3~)</li>
</ul>
</li>
</ul>
<h4 id="自然语言统计"><a href="#自然语言统计" class="headerlink" title="自然语言统计"></a>自然语言统计</h4><ul>
<li>在真实数据上如果进行自然语言统计：</li>
</ul>
<p>根据前几节介绍的时光机器数据集构建词表，并打印前10个最常用的单词</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line">tokens = d2l.tokenize(d2l.read_time_machine())</span><br><span class="line"><span class="comment"># 因为每个文本行不一定是一个句子或一个段落，因此我们把所有文本行拼接到一起</span></span><br><span class="line">corpus = [token <span class="keyword">for</span> line <span class="keyword">in</span> tokens <span class="keyword">for</span> token <span class="keyword">in</span> line]</span><br><span class="line">vocab = d2l.Vocab(corpus)</span><br><span class="line">vocab.token_freqs[:<span class="number">10</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[(<span class="string">&#x27;the&#x27;</span>, <span class="number">2261</span>),</span><br><span class="line"> (<span class="string">&#x27;i&#x27;</span>, <span class="number">1267</span>),</span><br><span class="line"> (<span class="string">&#x27;and&#x27;</span>, <span class="number">1245</span>),</span><br><span class="line"> (<span class="string">&#x27;of&#x27;</span>, <span class="number">1155</span>),</span><br><span class="line"> (<span class="string">&#x27;a&#x27;</span>, <span class="number">816</span>),</span><br><span class="line"> (<span class="string">&#x27;to&#x27;</span>, <span class="number">695</span>),</span><br><span class="line"> (<span class="string">&#x27;was&#x27;</span>, <span class="number">552</span>),</span><br><span class="line"> (<span class="string">&#x27;in&#x27;</span>, <span class="number">541</span>),</span><br><span class="line"> (<span class="string">&#x27;that&#x27;</span>, <span class="number">443</span>),</span><br><span class="line"> (<span class="string">&#x27;my&#x27;</span>, <span class="number">440</span>)]</span><br></pre></td></tr></table></figure>
<ul>
<li>正如我们所看到的，最流行的词看起来很无聊， 这些词通常被称为<em>停用词</em>（stop words），因此可以被过滤掉。 尽管如此，它们本身仍然是有意义的，我们仍然会在模型中使用它们。 此外，还有个明显的问题是词频衰减的速度相当地快。 例如，最常用单词的词频对比，第10个还不到第1个的1/5。 为了更好地理解，我们可以画出的词频图：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">freqs = [freq <span class="keyword">for</span> token, freq <span class="keyword">in</span> vocab.token_freqs]</span><br><span class="line">d2l.plot(freqs, xlabel=<span class="string">&#x27;token: x&#x27;</span>, ylabel=<span class="string">&#x27;frequency: n(x)&#x27;</span>,</span><br><span class="line">         xscale=<span class="string">&#x27;log&#x27;</span>, yscale=<span class="string">&#x27;log&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>我们可以发现：词频以一种明确的方式迅速衰减。 将前几个单词作为例外消除后，剩余的所有单词大致遵循双对数坐标图上的一条直线。</p>
<ul>
<li>我们来看看二元语法的频率是否与一元语法的频率表现出相同的行为方式。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bigram_tokens = [pair <span class="keyword">for</span> pair <span class="keyword">in</span> <span class="built_in">zip</span>(corpus[:-<span class="number">1</span>], corpus[<span class="number">1</span>:])]</span><br><span class="line">bigram_vocab = d2l.Vocab(bigram_tokens)</span><br><span class="line">bigram_vocab.token_freqs[:<span class="number">10</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[((<span class="string">&#x27;of&#x27;</span>, <span class="string">&#x27;the&#x27;</span>), <span class="number">309</span>),</span><br><span class="line"> ((<span class="string">&#x27;in&#x27;</span>, <span class="string">&#x27;the&#x27;</span>), <span class="number">169</span>),</span><br><span class="line"> ((<span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;had&#x27;</span>), <span class="number">130</span>),</span><br><span class="line"> ((<span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;was&#x27;</span>), <span class="number">112</span>),</span><br><span class="line"> ((<span class="string">&#x27;and&#x27;</span>, <span class="string">&#x27;the&#x27;</span>), <span class="number">109</span>),</span><br><span class="line"> ((<span class="string">&#x27;the&#x27;</span>, <span class="string">&#x27;time&#x27;</span>), <span class="number">102</span>),</span><br><span class="line"> ((<span class="string">&#x27;it&#x27;</span>, <span class="string">&#x27;was&#x27;</span>), <span class="number">99</span>),</span><br><span class="line"> ((<span class="string">&#x27;to&#x27;</span>, <span class="string">&#x27;the&#x27;</span>), <span class="number">85</span>),</span><br><span class="line"> ((<span class="string">&#x27;as&#x27;</span>, <span class="string">&#x27;i&#x27;</span>), <span class="number">78</span>),</span><br><span class="line"> ((<span class="string">&#x27;of&#x27;</span>, <span class="string">&#x27;a&#x27;</span>), <span class="number">73</span>)]</span><br></pre></td></tr></table></figure>
<p>这里值得注意：在十个最频繁的词对中，有九个是由两个停用词组成的， 只有一个与“the time”有关。 我们再进一步看看三元语法的频率是否表现出相同的行为方式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">trigram_tokens = [triple <span class="keyword">for</span> triple <span class="keyword">in</span> <span class="built_in">zip</span>(</span><br><span class="line">    corpus[:-<span class="number">2</span>], corpus[<span class="number">1</span>:-<span class="number">1</span>], corpus[<span class="number">2</span>:])]</span><br><span class="line">trigram_vocab = d2l.Vocab(trigram_tokens)</span><br><span class="line">trigram_vocab.token_freqs[:<span class="number">10</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[((<span class="string">&#x27;the&#x27;</span>, <span class="string">&#x27;time&#x27;</span>, <span class="string">&#x27;traveller&#x27;</span>), <span class="number">59</span>),</span><br><span class="line"> ((<span class="string">&#x27;the&#x27;</span>, <span class="string">&#x27;time&#x27;</span>, <span class="string">&#x27;machine&#x27;</span>), <span class="number">30</span>),</span><br><span class="line"> ((<span class="string">&#x27;the&#x27;</span>, <span class="string">&#x27;medical&#x27;</span>, <span class="string">&#x27;man&#x27;</span>), <span class="number">24</span>),</span><br><span class="line"> ((<span class="string">&#x27;it&#x27;</span>, <span class="string">&#x27;seemed&#x27;</span>, <span class="string">&#x27;to&#x27;</span>), <span class="number">16</span>),</span><br><span class="line"> ((<span class="string">&#x27;it&#x27;</span>, <span class="string">&#x27;was&#x27;</span>, <span class="string">&#x27;a&#x27;</span>), <span class="number">15</span>),</span><br><span class="line"> ((<span class="string">&#x27;here&#x27;</span>, <span class="string">&#x27;and&#x27;</span>, <span class="string">&#x27;there&#x27;</span>), <span class="number">15</span>),</span><br><span class="line"> ((<span class="string">&#x27;seemed&#x27;</span>, <span class="string">&#x27;to&#x27;</span>, <span class="string">&#x27;me&#x27;</span>), <span class="number">14</span>),</span><br><span class="line"> ((<span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;did&#x27;</span>, <span class="string">&#x27;not&#x27;</span>), <span class="number">14</span>),</span><br><span class="line"> ((<span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;saw&#x27;</span>, <span class="string">&#x27;the&#x27;</span>), <span class="number">13</span>),</span><br><span class="line"> ((<span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;began&#x27;</span>, <span class="string">&#x27;to&#x27;</span>), <span class="number">13</span>)]</span><br></pre></td></tr></table></figure>
<ul>
<li>最后，我们直观地对比三种模型中的词元频率：一元语法、二元语法和三元语法。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bigram_freqs = [freq <span class="keyword">for</span> token, freq <span class="keyword">in</span> bigram_vocab.token_freqs]</span><br><span class="line">trigram_freqs = [freq <span class="keyword">for</span> token, freq <span class="keyword">in</span> trigram_vocab.token_freqs]</span><br><span class="line">d2l.plot([freqs, bigram_freqs, trigram_freqs], xlabel=<span class="string">&#x27;token: x&#x27;</span>,</span><br><span class="line">         ylabel=<span class="string">&#x27;frequency: n(x)&#x27;</span>, xscale=<span class="string">&#x27;log&#x27;</span>, yscale=<span class="string">&#x27;log&#x27;</span>,</span><br><span class="line">         legend=[<span class="string">&#x27;unigram&#x27;</span>, <span class="string">&#x27;bigram&#x27;</span>, <span class="string">&#x27;trigram&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p><img src="https://zh-v2.d2l.ai/_images/output_language-models-and-dataset_789d14_54_0.svg" alt="../_images/output_language-models-and-dataset_789d14_54_0.svg"></p>
<h4 id="读取长序列数据"><a href="#读取长序列数据" class="headerlink" title="读取长序列数据"></a>读取长序列数据</h4><ul>
<li><p>由于序列数据本质上是连续的，因此我们在处理数据时需要解决这个问题。在前几节中我们以一种相当特别的方式做到了这一点： 当序列变得太长而不能被模型一次性全部处理时， 我们可能希望拆分这样的序列方便模型读取。</p>
</li>
<li><p>在介绍该模型之前，我们看一下总体策略。 假设我们将使用神经网络来训练语言模型， 模型中的网络一次处理具有预定义长度 （例如<em>n</em>个时间步）的一个小批量序列。 现在的问题是如何随机生成一个小批量数据的特征和标签以供读取。首先，由于文本序列可以是任意长的， 例如整本《时光机器》（<em>The Time Machine</em>）， 于是任意长的序列可以被我们划分为具有相同时间步数的子序列。 当训练我们的神经网络时，这样的小批量子序列将被输入到模型中。 假设网络一次只处理具有<em>n</em>个时间步的子序列。下画出了从原始文本序列获得子序列的所有不同的方式， 其中<em>n</em>=5，并且每个时间步的词元对应于一个字符。 请注意，因为我们可以选择任意偏移量来指示初始位置，所以我们有相当大的自由度。</p>
<p><img src="https://zh-v2.d2l.ai/_images/timemachine-5gram.svg" alt="../_images/timemachine-5gram.svg"></p>
</li>
</ul>
<p>因此，我们应该从中选择哪一个呢？ 事实上，他们都一样的好。 然而，如果我们只选择一个偏移量， 那么用于训练网络的、所有可能的子序列的覆盖范围将是有限的。 因此，我们可以从随机偏移量开始划分序列， 以同时获得<em>覆盖性</em>（coverage）和<em>随机性</em>（randomness）。 下面，我们将描述如何实现<em>随机采样</em>（random sampling）和 <em>顺序分区</em>（sequential partitioning）策略。</p>
<h4 id="随机采样"><a href="#随机采样" class="headerlink" title="随机采样"></a>随机采样</h4><ul>
<li>在随机采样中，每个样本都是在原始的长序列上任意捕获的子序列。 在迭代过程中，来自两个相邻的、随机的、小批量中的子序列不一定在原始序列上相邻。 对于语言建模，目标是基于到目前为止我们看到的词元来预测下一个词元， 因此标签是移位了一个词元的原始序列。下面的代码每次可以从数据中随机生成一个小批量。 在这里，参数<code>batch_size</code>指定了每个小批量中子序列样本的数目， 参数<code>num_steps</code>是每个子序列中预定义的时间步数。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">seq_data_iter_random</span>(<span class="params">corpus, batch_size, num_steps</span>):  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用随机抽样生成一个小批量子序列&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 从随机偏移量开始对序列进行分区，随机范围包括num_steps-1</span></span><br><span class="line">    corpus = corpus[random.randint(<span class="number">0</span>, num_steps - <span class="number">1</span>):]</span><br><span class="line">    <span class="comment"># 减去1，是因为我们需要考虑标签</span></span><br><span class="line">    num_subseqs = (<span class="built_in">len</span>(corpus) - <span class="number">1</span>) // num_steps</span><br><span class="line">    <span class="comment"># 长度为num_steps的子序列的起始索引</span></span><br><span class="line">    initial_indices = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">0</span>, num_subseqs * num_steps, num_steps))</span><br><span class="line">    <span class="comment"># 在随机抽样的迭代过程中，</span></span><br><span class="line">    <span class="comment"># 来自两个相邻的、随机的、小批量中的子序列不一定在原始序列上相邻</span></span><br><span class="line">    random.shuffle(initial_indices)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">data</span>(<span class="params">pos</span>):</span><br><span class="line">        <span class="comment"># 返回从pos位置开始的长度为num_steps的序列</span></span><br><span class="line">        <span class="keyword">return</span> corpus[pos: pos + num_steps]</span><br><span class="line"></span><br><span class="line">    num_batches = num_subseqs // batch_size</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, batch_size * num_batches, batch_size):</span><br><span class="line">        <span class="comment"># 在这里，initial_indices包含子序列的随机起始索引</span></span><br><span class="line">        initial_indices_per_batch = initial_indices[i: i + batch_size]</span><br><span class="line">        X = [data(j) <span class="keyword">for</span> j <span class="keyword">in</span> initial_indices_per_batch]</span><br><span class="line">        Y = [data(j + <span class="number">1</span>) <span class="keyword">for</span> j <span class="keyword">in</span> initial_indices_per_batch]</span><br><span class="line">        <span class="keyword">yield</span> torch.tensor(X), torch.tensor(Y)</span><br></pre></td></tr></table></figure>
<ul>
<li>下面我们生成一个从0到34的序列。 假设批量大小为2，时间步数为5，这意味着可以生成 ⌊(35−1)/5⌋=6个“特征－标签”子序列对。 如果设置小批量大小为2，我们只能得到3个小批量。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_seq = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">35</span>))</span><br><span class="line"><span class="keyword">for</span> X, Y <span class="keyword">in</span> seq_data_iter_random(my_seq, batch_size=<span class="number">2</span>, num_steps=<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;X: &#x27;</span>, X, <span class="string">&#x27;\nY:&#x27;</span>, Y)</span><br></pre></td></tr></table></figure>
<h4 id="顺序分区"><a href="#顺序分区" class="headerlink" title="顺序分区"></a>顺序分区</h4><ul>
<li>在迭代过程中，除了对原始序列可以随机抽样外， 我们还可以保证两个相邻的小批量中的子序列在原始序列上也是相邻的。 这种策略在基于小批量的迭代过程中保留了拆分的子序列的顺序，因此称为顺序分区。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">seq_data_iter_sequential</span>(<span class="params">corpus, batch_size, num_steps</span>):  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用顺序分区生成一个小批量子序列&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 从随机偏移量开始划分序列</span></span><br><span class="line">    offset = random.randint(<span class="number">0</span>, num_steps)</span><br><span class="line">    num_tokens = ((<span class="built_in">len</span>(corpus) - offset - <span class="number">1</span>) // batch_size) * batch_size</span><br><span class="line">    Xs = torch.tensor(corpus[offset: offset + num_tokens])</span><br><span class="line">    Ys = torch.tensor(corpus[offset + <span class="number">1</span>: offset + <span class="number">1</span> + num_tokens])</span><br><span class="line">    Xs, Ys = Xs.reshape(batch_size, -<span class="number">1</span>), Ys.reshape(batch_size, -<span class="number">1</span>)</span><br><span class="line">    num_batches = Xs.shape[<span class="number">1</span>] // num_steps</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, num_steps * num_batches, num_steps):</span><br><span class="line">        X = Xs[:, i: i + num_steps]</span><br><span class="line">        Y = Ys[:, i: i + num_steps]</span><br><span class="line">        <span class="keyword">yield</span> X, Y</span><br></pre></td></tr></table></figure>
<ul>
<li>基于相同的设置，通过顺序分区读取每个小批量的子序列的特征<code>X</code>和标签<code>Y</code>。 通过将它们打印出来可以发现： 迭代期间来自两个相邻的小批量中的子序列在原始序列中确实是相邻的。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> X, Y <span class="keyword">in</span> seq_data_iter_sequential(my_seq, batch_size=<span class="number">2</span>, num_steps=<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;X: &#x27;</span>, X, <span class="string">&#x27;\nY:&#x27;</span>, Y)</span><br></pre></td></tr></table></figure>
<ul>
<li>现在，我们将上面的两个采样函数包装到一个类中， 以便稍后可以将其用作数据迭代器。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SeqDataLoader</span>:  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;加载序列数据的迭代器&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, batch_size, num_steps, use_random_iter, max_tokens</span>):</span><br><span class="line">        <span class="keyword">if</span> use_random_iter:</span><br><span class="line">            self.data_iter_fn = d2l.seq_data_iter_random</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.data_iter_fn = d2l.seq_data_iter_sequential</span><br><span class="line">        self.corpus, self.vocab = d2l.load_corpus_time_machine(max_tokens)</span><br><span class="line">        self.batch_size, self.num_steps = batch_size, num_steps</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.data_iter_fn(self.corpus, self.batch_size, self.num_steps)</span><br></pre></td></tr></table></figure>
<ul>
<li>最后，我们定义了一个函数<code>load_data_time_machine</code>， 它同时返回数据迭代器和词表， 因此可以与其他带有<code>load_data</code>前缀的函数类似地使用。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_data_time_machine</span>(<span class="params">batch_size, num_steps,  <span class="comment">#@save</span></span></span><br><span class="line"><span class="params">                           use_random_iter=<span class="literal">False</span>, max_tokens=<span class="number">10000</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;返回时光机器数据集的迭代器和词表&quot;&quot;&quot;</span></span><br><span class="line">    data_iter = SeqDataLoader(</span><br><span class="line">        batch_size, num_steps, use_random_iter, max_tokens)</span><br><span class="line">    <span class="keyword">return</span> data_iter, data_iter.vocab</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>63-束搜索</title>
    <url>/2024/04/23/11-06-03/</url>
    <content><![CDATA[<h2 id="束搜索"><a href="#束搜索" class="headerlink" title="束搜索"></a>束搜索</h2><p>在序列生成问题中，常用的方法是一个个词元地进行生成，但是先前步生成的词元会影响之后词元的概率分布，为此，我们需要使用搜索算法来得到一个较好的序列</p>
<h3 id="贪心搜索"><a href="#贪心搜索" class="headerlink" title="贪心搜索"></a>贪心搜索</h3><p>贪心搜索即每个时间步都选择具有最高条件概率的词元。</p>
<script type="math/tex; mode=display">
y_{t'} = \operatorname*{argmax}_{y \in \mathcal{Y}} P(y \mid y_1, \ldots, y_{t'-1}, \mathbf{c})</script><p>我们的目标是找到一个最有序列，他的联合概率，也就是每步之间的条件概率的乘积，最大。</p>
<script type="math/tex; mode=display">
\prod_{t'=1}^{T'} P(y_{t'} \mid y_1, \ldots, y_{t'-1}, \mathbf{c})</script><p>然而，贪心搜索很可能搜索到的不是最优解，例如：<img src="/2024/04/23/11-06-03/Greedy_or_not.png" class=""></p>
<p>左侧的搜索方式为贪心搜索，每次找到当前条件概率最大的选项进行预测，但是这样可能会导致之后的条件概率较小，从而导致最终的联合概率较小，生成的序列不优。</p>
<p>而右侧的选择方式虽然在第二步选择了较小的选项，但之后在第三步时有了条件概率为0.6选项，最终结果反而更好。</p>
<h3 id="穷举搜索"><a href="#穷举搜索" class="headerlink" title="穷举搜索"></a>穷举搜索</h3><p>穷举搜索枚举所有可能的输出序列及其概率，然后选择概率最大的作为最终的输出，枚举搜索可以保证得到最优解，但是计算复杂度很高，难以实现</p>
<h3 id="束搜索（beam-search）"><a href="#束搜索（beam-search）" class="headerlink" title="束搜索（beam search）"></a>束搜索（beam search）</h3><p>束搜索综合了贪心搜索和穷举搜索，在能接受的计算成本下得到比贪心搜索更好的结果。</p>
<p>束搜索有一个超参数，名为<strong>束宽（beam size）</strong>$k$，束搜索的具体流程如下：</p>
<ul>
<li>1：在第一时间步选择条件概率最高的k个选项</li>
<li><p>2：对随后的每个时间步，基于上一时间步的k个候选输出序列预测这一时间步的所有可能选项的条件概率，从中取k个最大的</p>
</li>
<li><p>3：最后基于每步得到的序列，删去截止符和其后元素，获得最终候选序列集合，取出加权条件概率最大的</p>
</li>
</ul>
<p>加权条件概率公式如下：</p>
<script type="math/tex; mode=display">
\frac{1}{L^\alpha} \log P(y_1, \ldots, y_{L}\mid \mathbf{c}) = \frac{1}{L^\alpha} \sum_{t'=1}^L \log P(y_{t'} \mid y_1, \ldots, y_{t'-1}, \mathbf{c}),</script><p>式中$\frac{1}{L^\alpha}$用于调整长序列的评估值使得长短序列间的比较公平</p>
<p>束宽k的选择：</p>
<ul>
<li>k=1时实际为贪心搜索</li>
<li>k越小搜索速度越快，但结果越差，k越大则搜索速度越慢，但结果越好</li>
</ul>
<p>束搜索只在测试时使用</p>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>58-深层循环神经网络</title>
    <url>/2024/04/23/11-01-58/</url>
    <content><![CDATA[<h2 id="58-深层循环神经网络"><a href="#58-深层循环神经网络" class="headerlink" title="58 深层循环神经网络"></a>58 深层循环神经网络</h2><p>x</p>
<h3 id="1-深层循环神经网络"><a href="#1-深层循环神经网络" class="headerlink" title="1.深层循环神经网络"></a>1.深层循环神经网络</h3><p>之前讲的RNN都只有一个隐藏层（序列变长不算是深度），而一个隐藏层的RNN一旦做的很宽就容易出现过拟合。因此我们考虑将网络做的更深而非更宽，每层都只做一点非线性，靠层数叠加得到更加非线性的模型。</p>
<p>浅RNN：输入-隐层-输出</p>
<p>深RNN：输入-隐层-隐层-…-输出</p>
<img src="/2024/04/23/11-01-58/58-01.png" class="">
<p>（课程视频中的图片有错误，最后输出层后一时间步是不受前一步影响的，即没有箭头）</p>
<h3 id="2-公式"><a href="#2-公式" class="headerlink" title="2.公式"></a>2.公式</h3><div align="center">

![](http://latex.codecogs.com/svg.latex?\mathbf{H}_t^1=f_1(\mathbf{H_{t-1}^1},\mathbf{X_t}))

</div>

<p><em>第一层的第t步状态是关于第一层第t-1步状态和第t步输入的函数</em></p>
<div align="center">

<p><img src="http://latex.codecogs.com/svg.latex?\mathbf{H}_t^j=f_j(\mathbf{H_{t-1}^j},\mathbf{H_{t}^{j-1}" alt="">})</p>
<p>&lt;/div&gt;<br><em>第j层的第t步状态是关于当前层上一步步状态和上一层当前步的函数</em></p>
<div align="center">

<p><img src="http://latex.codecogs.com/svg.latex?\mathbf{O}_t=g(\mathbf{H}_t^L" alt="">)</p>
<p>&lt;/div&gt;<br><em>由最后一个隐藏层得到输出</em></p>
<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h3><ul>
<li>深度循环神经网络使用多个隐藏层来获得更多的非线性性</li>
</ul>
<p>将RNN/GRU/LSTM做深都是一个道理，三者只是使用的函数f不同。</p>
<h3 id="4-QA"><a href="#4-QA" class="headerlink" title="4.QA"></a>4.QA</h3><p>Q1: NLP那个方向好找工作？文本翻译是不是现在只在学术研究中才需要自己实现？（2021-7-27）</p>
<blockquote>
<p>文本翻译已经是一个很成熟的领域，NLP挺好找工作，人产生的文本远多于图片。</p>
</blockquote>
<p>Q2: 关于BPTT</p>
<blockquote>
<p>课上不讲，书上有讲原理</p>
</blockquote>
<p>Q3: 深层RNN是不是每层都需要一个初始hidenstate?</p>
<blockquote>
<p>是的</p>
</blockquote>
<p>Q4: 可不可以手动实现hidden_size不一样的多层RNN？</p>
<blockquote>
<p>应该没问题，但通常大家不会去调hidden_size，因为网络不会做的很深，最后还有全连接层。</p>
</blockquote>
<p>Q5: 关于课上提到的classifier</p>
<blockquote>
<p>分类的任务在最后的全连接层完成</p>
</blockquote>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>65-注意力分数</title>
    <url>/2024/04/23/11-06-05/</url>
    <content><![CDATA[<h3 id="65-注意力分数"><a href="#65-注意力分数" class="headerlink" title="65 注意力分数"></a>65 注意力分数</h3><ul>
<li>在上一节中，我们使用高斯核来对查询和键之间的关系建模。我们可以将上一节中的高斯核函数部分视为注意力评分函数，简称评分函数，然后把这个函数的输出结果输入到softmax函数中进行运算。 通过上述步骤，我们将得到与键对应的值的概率分布（即注意力权重）。 最后，注意力汇聚的输出就是基于这些注意力权重的值的加权和。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br></pre></td></tr></table></figure>
<h4 id="掩蔽softmax操作"><a href="#掩蔽softmax操作" class="headerlink" title="掩蔽softmax操作"></a>掩蔽softmax操作</h4><ul>
<li>正如上面提到的，softmax操作用于输出一个概率分布作为注意力权重。 在某些情况下，并非所有的值都应该被纳入到注意力汇聚中。 例如，为了在 <a href="https://zh-v2.d2l.ai/chapter_recurrent-modern/machine-translation-and-dataset.html#sec-machine-translation">9.5节</a>中高效处理小批量数据集， 某些文本序列被填充了没有意义的特殊词元。 为了仅将有意义的词元作为值来获取注意力汇聚， 我们可以指定一个有效序列长度（即词元的个数）， 以便在计算softmax时过滤掉超出指定范围的位置。 通过这种方式，我们可以在下面的<code>masked_softmax</code>函数中 实现这样的<em>掩蔽softmax操作</em>（masked softmax operation）， 其中任何超出有效长度的位置都被掩蔽并置为0。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">masked_softmax</span>(<span class="params">X, valid_lens</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;通过在最后一个轴上掩蔽元素来执行softmax操作&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># X:3D张量，valid_lens:1D或2D张量</span></span><br><span class="line">    <span class="keyword">if</span> valid_lens <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> nn.functional.softmax(X, dim=-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        shape = X.shape</span><br><span class="line">        <span class="keyword">if</span> valid_lens.dim() == <span class="number">1</span>:</span><br><span class="line">            valid_lens = torch.repeat_interleave(valid_lens, shape[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            valid_lens = valid_lens.reshape(-<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 最后一轴上被掩蔽的元素使用一个非常大的负值替换，从而其softmax输出为0</span></span><br><span class="line">        X = d2l.sequence_mask(X.reshape(-<span class="number">1</span>, shape[-<span class="number">1</span>]), valid_lens,</span><br><span class="line">                              value=-<span class="number">1e6</span>)</span><br><span class="line">        <span class="keyword">return</span> nn.functional.softmax(X.reshape(shape), dim=-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h4 id="加性注意力"><a href="#加性注意力" class="headerlink" title="加性注意力"></a>加性注意力</h4><ul>
<li>一般来说，当查询和键是不同长度的矢量时， 我们可以使用加性注意力作为评分函数。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AdditiveAttention</span>(nn.Module):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;加性注意力&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, key_size, query_size, num_hiddens, dropout, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>(AdditiveAttention, self).__init__(**kwargs)</span><br><span class="line">        self.W_k = nn.Linear(key_size, num_hiddens, bias=<span class="literal">False</span>)</span><br><span class="line">        self.W_q = nn.Linear(query_size, num_hiddens, bias=<span class="literal">False</span>)</span><br><span class="line">        self.w_v = nn.Linear(num_hiddens, <span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">        self.dropout = nn.Dropout(dropout)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, queries, keys, values, valid_lens</span>):</span><br><span class="line">        queries, keys = self.W_q(queries), self.W_k(keys)</span><br><span class="line">        <span class="comment"># 在维度扩展后，</span></span><br><span class="line">        <span class="comment"># queries的形状：(batch_size，查询的个数，1，num_hidden)</span></span><br><span class="line">        <span class="comment"># key的形状：(batch_size，1，“键－值”对的个数，num_hiddens)</span></span><br><span class="line">        <span class="comment"># 使用广播方式进行求和</span></span><br><span class="line">        features = queries.unsqueeze(<span class="number">2</span>) + keys.unsqueeze(<span class="number">1</span>)</span><br><span class="line">        features = torch.tanh(features)</span><br><span class="line">        <span class="comment"># self.w_v仅有一个输出，因此从形状中移除最后那个维度。</span></span><br><span class="line">        <span class="comment"># scores的形状：(batch_size，查询的个数，“键-值”对的个数)</span></span><br><span class="line">        scores = self.w_v(features).squeeze(-<span class="number">1</span>)</span><br><span class="line">        self.attention_weights = masked_softmax(scores, valid_lens)</span><br><span class="line">        <span class="comment"># values的形状：(batch_size，“键－值”对的个数，值的维度)</span></span><br><span class="line">        <span class="keyword">return</span> torch.bmm(self.dropout(self.attention_weights), values)</span><br></pre></td></tr></table></figure>
<h4 id="缩放点积注意力"><a href="#缩放点积注意力" class="headerlink" title="缩放点积注意力"></a>缩放点积注意力</h4><ul>
<li>使用点积可以得到计算效率更高的评分函数， 但是点积操作要求查询和键具有相同的长度<em>d</em>。 假设查询和键的所有元素都是独立的随机变量， 并且都满足零均值和单位方差， 那么两个向量的点积的均值为0，方差为<em>d</em>。 为确保无论向量长度如何， 点积的方差在不考虑向量长度的情况下仍然是1， 我们将点积除以√d,在下面的缩放点积注意力的实现中，我们使用了暂退法进行模型正则化。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DotProductAttention</span>(nn.Module):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;缩放点积注意力&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, dropout, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>(DotProductAttention, self).__init__(**kwargs)</span><br><span class="line">        self.dropout = nn.Dropout(dropout)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># queries的形状：(batch_size，查询的个数，d)</span></span><br><span class="line">    <span class="comment"># keys的形状：(batch_size，“键－值”对的个数，d)</span></span><br><span class="line">    <span class="comment"># values的形状：(batch_size，“键－值”对的个数，值的维度)</span></span><br><span class="line">    <span class="comment"># valid_lens的形状:(batch_size，)或者(batch_size，查询的个数)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, queries, keys, values, valid_lens=<span class="literal">None</span></span>):</span><br><span class="line">        d = queries.shape[-<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># 设置transpose_b=True为了交换keys的最后两个维度</span></span><br><span class="line">        scores = torch.bmm(queries, keys.transpose(<span class="number">1</span>,<span class="number">2</span>)) / math.sqrt(d)</span><br><span class="line">        self.attention_weights = masked_softmax(scores, valid_lens)</span><br><span class="line">        <span class="keyword">return</span> torch.bmm(self.dropout(self.attention_weights), values)</span><br></pre></td></tr></table></figure>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>将注意力汇聚的输出计算可以作为值的加权平均，选择不同的注意力评分函数会带来不同的注意力汇聚操作。</li>
<li>当查询和键是不同长度的矢量时，可以使用可加性注意力评分函数。当它们的长度相同时，使用缩放的“点－积”注意力评分函数的计算效率更高。</li>
</ul>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>69-BERT预训练</title>
    <url>/2024/04/23/11-06-09/</url>
    <content><![CDATA[<h2 id="BERT预训练"><a href="#BERT预训练" class="headerlink" title="BERT预训练"></a>BERT预训练</h2><h3 id="2-BERT"><a href="#2-BERT" class="headerlink" title="2.BERT:"></a>2.BERT:</h3><h4 id="2-1-NLP里的迁移学习"><a href="#2-1-NLP里的迁移学习" class="headerlink" title="2.1 NLP里的迁移学习"></a>2.1 NLP里的迁移学习</h4><ul>
<li><p>使用预训练好的模型来抽取词，句子的特征</p>
<ul>
<li>例如word2vec或语言模型</li>
</ul>
</li>
<li><p>不更新预训练好的模型</p>
</li>
<li>需要构建新的网络来抓取任务需要的信息<ul>
<li>Word2vec忽略了时序信息</li>
<li>语言模型只看了一个方向</li>
</ul>
</li>
</ul>
<h4 id="2-2-BERT的动机"><a href="#2-2-BERT的动机" class="headerlink" title="2.2 BERT的动机"></a>2.2 BERT的动机</h4><ul>
<li>基于微调的NLP模型</li>
<li>预训练的模型抽取了足够多的信息</li>
<li>新的任务只需要增加一个简单地输出层</li>
</ul>
<img src="/2024/04/23/11-06-09/69-1.png" class="">
<h4 id="2-3-BERT架构"><a href="#2-3-BERT架构" class="headerlink" title="2.3 BERT架构"></a>2.3 BERT架构</h4><ul>
<li>只有编码器的Transformer</li>
<li><p>两个版本：</p>
<ul>
<li>Base:#blocks=12,hidden size=768,#heads=12,#parameters=110M</li>
<li>Large:#blocks=24,hidden size=1024,#heads=16,#paramerter=340M</li>
</ul>
</li>
<li><p>在大规模数据上训练&gt;3B词</p>
</li>
</ul>
<h4 id="2-4-对输入的修改"><a href="#2-4-对输入的修改" class="headerlink" title="2.4 对输入的修改"></a>2.4 对输入的修改</h4><ul>
<li>每个样本是一个句子对</li>
<li>加入额外的片段嵌入</li>
<li>位置编码可学习</li>
</ul>
<img src="/2024/04/23/11-06-09/69-2.png" class="">
<h4 id="2-5-预训练任务"><a href="#2-5-预训练任务" class="headerlink" title="2.5 预训练任务"></a>2.5 预训练任务</h4><h5 id="2-5-1-带掩码的语言模型"><a href="#2-5-1-带掩码的语言模型" class="headerlink" title="2.5.1 带掩码的语言模型"></a>2.5.1 带掩码的语言模型</h5><ul>
<li>Transformer的编码器是双向的，标准语言模型要求单向</li>
<li>带掩码的语言模型每次随机（15%概率）将一些词元换成<mask>
</li>
</ul>
<h5 id="2-5-2-下一个句子预测"><a href="#2-5-2-下一个句子预测" class="headerlink" title="2.5.2 下一个句子预测"></a>2.5.2 下一个句子预测</h5><ul>
<li>预测一个句子对中两个句子是不是相邻</li>
<li><p>训练样本中：</p>
<ul>
<li>50%概率选择相邻句子对：<cls>this movie is great <sep> i like it <sep></li>
<li>50%概率选择随机句子对：<cls>this movie is great<sep> hello world<sep></li>
</ul>
</li>
<li><p>将<cls>对应的输出放到一个全连接层来预测</p>
</li>
</ul>
<h4 id="2-6-总结"><a href="#2-6-总结" class="headerlink" title="2.6 总结"></a>2.6 总结</h4><ul>
<li>BERT针对微调设计</li>
<li>基于Transformer的编码器做了如下修改<ul>
<li>模型更大，训练数据更多</li>
<li>输入句子对，片段嵌入，可学习的位置编码</li>
<li>训练时使用两个任务：<ul>
<li>带掩码的语言模型</li>
<li>下一个句子预测</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3.代码实现"></a>3.代码实现</h3><h4 id="3-1-获取输入："><a href="#3-1-获取输入：" class="headerlink" title="3.1 获取输入："></a>3.1 获取输入：</h4><p>在自然语言处理中，有些任务（如情感分析）以单个文本作为输入，而有些任务（如自然语言推断）以一对文本序列作为输入。BERT输入序列明确地表示单个文本和文本对。当输入为单个文本时，BERT输入序列是特殊类别词元“<cls>”、文本序列的标记、以及特殊分隔词元“<sep>”的连结。当输入为文本对时，BERT输入序列是“<cls>”、第一个文本序列的标记、“<sep>”、第二个文本序列标记、以及“<sep>”的连结。我们将始终如一地将术语“BERT输入序列”与其他类型的“序列”区分开来。例如，一个<em>BERT输入序列</em>可以包括一个<em>文本序列</em>或两个<em>文本序列</em>。</p>
<p>为了区分文本对，根据输入序列学到的片段嵌入eA和eB分别被添加到第一序列和第二序列的词元嵌入中。对于单文本输入，仅使用eA。</p>
<p>下面的<code>get_tokens_and_segments</code>将一个句子或两个句子作为输入，然后返回BERT输入序列的标记及其相应的片段索引。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_tokens_and_segments</span>(<span class="params">tokens_a, tokens_b=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;获取输入序列的词元及其片段索引&quot;&quot;&quot;</span></span><br><span class="line">    tokens = [<span class="string">&#x27;&lt;cls&gt;&#x27;</span>] + tokens_a + [<span class="string">&#x27;&lt;sep&gt;&#x27;</span>]</span><br><span class="line">    <span class="comment"># 0和1分别标记片段A和B</span></span><br><span class="line">    segments = [<span class="number">0</span>] * (<span class="built_in">len</span>(tokens_a) + <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> tokens_b <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        tokens += tokens_b + [<span class="string">&#x27;&lt;sep&gt;&#x27;</span>]</span><br><span class="line">        segments += [<span class="number">1</span>] * (<span class="built_in">len</span>(tokens_b) + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> tokens, segments</span><br></pre></td></tr></table></figure>
<p>BERT选择Transformer编码器作为其双向架构。在Transformer编码器中常见是，位置嵌入被加入到输入序列的每个位置。然而，与原始的Transformer编码器不同，BERT使用<em>可学习的</em>位置嵌入。总之， 下图表明BERT输入序列的嵌入是词元嵌入、片段嵌入和位置嵌入的和。</p>
<img src="/2024/04/23/11-06-09/69-3.png" class="">
<h4 id="3-2-BERT实现"><a href="#3-2-BERT实现" class="headerlink" title="3.2 BERT实现"></a>3.2 BERT实现</h4><p>下面的<code>BERTEncoder</code>类类似于 <a href="https://zh-v2.d2l.ai/chapter_attention-mechanisms/transformer.html#sec-transformer">10.7节</a>中实现的<code>TransformerEncoder</code>类。与<code>TransformerEncoder</code>不同，<code>BERTEncoder</code>使用片段嵌入和可学习的位置嵌入。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BERTEncoder</span>(nn.Module):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;BERT编码器&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, vocab_size, num_hiddens, norm_shape, ffn_num_input,</span></span><br><span class="line"><span class="params">                 ffn_num_hiddens, num_heads, num_layers, dropout,</span></span><br><span class="line"><span class="params">                 max_len=<span class="number">1000</span>, key_size=<span class="number">768</span>, query_size=<span class="number">768</span>, value_size=<span class="number">768</span>,</span></span><br><span class="line"><span class="params">                 **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>(BERTEncoder, self).__init__(**kwargs)</span><br><span class="line">        self.token_embedding = nn.Embedding(vocab_size, num_hiddens)</span><br><span class="line">        self.segment_embedding = nn.Embedding(<span class="number">2</span>, num_hiddens)</span><br><span class="line">        self.blks = nn.Sequential()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_layers):</span><br><span class="line">            self.blks.add_module(<span class="string">f&quot;<span class="subst">&#123;i&#125;</span>&quot;</span>, d2l.EncoderBlock(</span><br><span class="line">                key_size, query_size, value_size, num_hiddens, norm_shape,</span><br><span class="line">                ffn_num_input, ffn_num_hiddens, num_heads, dropout, <span class="literal">True</span>))</span><br><span class="line">        <span class="comment"># 在BERT中，位置嵌入是可学习的，因此我们创建一个足够长的位置嵌入参数</span></span><br><span class="line">        self.pos_embedding = nn.Parameter(torch.randn(<span class="number">1</span>, max_len,</span><br><span class="line">                                                      num_hiddens))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, tokens, segments, valid_lens</span>):</span><br><span class="line">        <span class="comment"># 在以下代码段中，X的形状保持不变：（批量大小，最大序列长度，num_hiddens）</span></span><br><span class="line">        X = self.token_embedding(tokens) + self.segment_embedding(segments)</span><br><span class="line">        X = X + self.pos_embedding.data[:, :X.shape[<span class="number">1</span>], :]</span><br><span class="line">        <span class="keyword">for</span> blk <span class="keyword">in</span> self.blks:</span><br><span class="line">            X = blk(X, valid_lens)</span><br><span class="line">        <span class="keyword">return</span> X</span><br></pre></td></tr></table></figure>
<p>假设词表大小为10000，为了演示<code>BERTEncoder</code>的前向推断，让我们创建一个实例并初始化它的参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">vocab_size, num_hiddens, ffn_num_hiddens, num_heads = <span class="number">10000</span>, <span class="number">768</span>, <span class="number">1024</span>, <span class="number">4</span></span><br><span class="line">norm_shape, ffn_num_input, num_layers, dropout = [<span class="number">768</span>], <span class="number">768</span>, <span class="number">2</span>, <span class="number">0.2</span></span><br><span class="line">encoder = BERTEncoder(vocab_size, num_hiddens, norm_shape, ffn_num_input,</span><br><span class="line">                      ffn_num_hiddens, num_heads, num_layers, dropout)</span><br></pre></td></tr></table></figure>
<p>我们将<code>tokens</code>定义为长度为8的2个输入序列，其中每个词元是词表的索引。使用输入<code>tokens</code>的<code>BERTEncoder</code>的前向推断返回编码结果，其中每个词元由向量表示，其长度由超参数<code>num_hiddens</code>定义。此超参数通常称为Transformer编码器的<em>隐藏大小</em>（隐藏单元数）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tokens = torch.randint(<span class="number">0</span>, vocab_size, (<span class="number">2</span>, <span class="number">8</span>))</span><br><span class="line">segments = torch.tensor([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]])</span><br><span class="line">encoded_X = encoder(tokens, segments, <span class="literal">None</span>)</span><br><span class="line">encoded_X.shape</span><br></pre></td></tr></table></figure>
<h4 id="3-3-预训练任务"><a href="#3-3-预训练任务" class="headerlink" title="3.3 预训练任务"></a>3.3 预训练任务</h4><h5 id="3-3-1-遮掩语言模型"><a href="#3-3-1-遮掩语言模型" class="headerlink" title="3.3.1 遮掩语言模型"></a>3.3.1 遮掩语言模型</h5><p>我们实现了下面的<code>MaskLM</code>类来预测BERT预训练的掩蔽语言模型任务中的掩蔽标记。预测使用单隐藏层的多层感知机（<code>self.mlp</code>）。在前向推断中，它需要两个输入：<code>BERTEncoder</code>的编码结果和用于预测的词元位置。输出是这些位置的预测结果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MaskLM</span>(nn.Module):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;BERT的掩蔽语言模型任务&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, vocab_size, num_hiddens, num_inputs=<span class="number">768</span>, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>(MaskLM, self).__init__(**kwargs)</span><br><span class="line">        self.mlp = nn.Sequential(nn.Linear(num_inputs, num_hiddens),</span><br><span class="line">                                 nn.ReLU(),</span><br><span class="line">                                 nn.LayerNorm(num_hiddens),</span><br><span class="line">                                 nn.Linear(num_hiddens, vocab_size))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, X, pred_positions</span>):</span><br><span class="line">        num_pred_positions = pred_positions.shape[<span class="number">1</span>]</span><br><span class="line">        pred_positions = pred_positions.reshape(-<span class="number">1</span>)</span><br><span class="line">        batch_size = X.shape[<span class="number">0</span>]</span><br><span class="line">        batch_idx = torch.arange(<span class="number">0</span>, batch_size)</span><br><span class="line">        <span class="comment"># 假设batch_size=2，num_pred_positions=3</span></span><br><span class="line">        <span class="comment"># 那么batch_idx是np.array（[0,0,0,1,1]）</span></span><br><span class="line">        batch_idx = torch.repeat_interleave(batch_idx, num_pred_positions)</span><br><span class="line">        masked_X = X[batch_idx, pred_positions]</span><br><span class="line">        masked_X = masked_X.reshape((batch_size, num_pred_positions, -<span class="number">1</span>))</span><br><span class="line">        mlm_Y_hat = self.mlp(masked_X)</span><br><span class="line">        <span class="keyword">return</span> mlm_Y_hat</span><br></pre></td></tr></table></figure>
<p>为了演示<code>MaskLM</code>的前向推断，我们创建了其实例<code>mlm</code>并对其进行了初始化。回想一下，来自<code>BERTEncoder</code>的正向推断<code>encoded_X</code>表示2个BERT输入序列。我们将<code>mlm_positions</code>定义为在<code>encoded_X</code>的任一输入序列中预测的3个指示。<code>mlm</code>的前向推断返回<code>encoded_X</code>的所有掩蔽位置<code>mlm_positions</code>处的预测结果<code>mlm_Y_hat</code>。对于每个预测，结果的大小等于词表的大小。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mlm = MaskLM(vocab_size, num_hiddens)</span><br><span class="line">mlm_positions = torch.tensor([[<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>], [<span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>]])</span><br><span class="line">mlm_Y_hat = mlm(encoded_X, mlm_positions)</span><br><span class="line">mlm_Y_hat.shape</span><br></pre></td></tr></table></figure>
<p>通过掩码下的预测词元<code>mlm_Y</code>的真实标签<code>mlm_Y_hat</code>，我们可以计算在BERT预训练中的遮蔽语言模型任务的交叉熵损失。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mlm_Y = torch.tensor([[<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]])</span><br><span class="line">loss = nn.CrossEntropyLoss(reduction=<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">mlm_l = loss(mlm_Y_hat.reshape((-<span class="number">1</span>, vocab_size)), mlm_Y.reshape(-<span class="number">1</span>))</span><br><span class="line">mlm_l.shape</span><br></pre></td></tr></table></figure>
<h5 id="3-3-2-下一句预测"><a href="#3-3-2-下一句预测" class="headerlink" title="3.3.2 下一句预测"></a>3.3.2 下一句预测</h5><p>下面的<code>NextSentencePred</code>类使用单隐藏层的多层感知机来预测第二个句子是否是BERT输入序列中第一个句子的下一个句子。由于Transformer编码器中的自注意力，特殊词元“<cls>”的BERT表示已经对输入的两个句子进行了编码。因此，多层感知机分类器的输出层（<code>self.output</code>）以<code>X</code>作为输入，其中<code>X</code>是多层感知机隐藏层的输出，而MLP隐藏层的输入是编码后的“<cls>”词元。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NextSentencePred</span>(nn.Module):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;BERT的下一句预测任务&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, num_inputs, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>(NextSentencePred, self).__init__(**kwargs)</span><br><span class="line">        self.output = nn.Linear(num_inputs, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, X</span>):</span><br><span class="line">        <span class="comment"># X的形状：(batchsize,num_hiddens)</span></span><br><span class="line">        <span class="keyword">return</span> self.output(X)</span><br></pre></td></tr></table></figure>
<p>我们可以看到，<code>NextSentencePred</code>实例的前向推断返回每个BERT输入序列的二分类预测。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">encoded_X = torch.flatten(encoded_X, start_dim=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># NSP的输入形状:(batchsize，num_hiddens)</span></span><br><span class="line">nsp = NextSentencePred(encoded_X.shape[-<span class="number">1</span>])</span><br><span class="line">nsp_Y_hat = nsp(encoded_X)</span><br><span class="line">nsp_Y_hat.shape</span><br></pre></td></tr></table></figure>
<h4 id="3-4-整合代码"><a href="#3-4-整合代码" class="headerlink" title="3.4 整合代码"></a>3.4 整合代码</h4><p>在预训练BERT时，最终的损失函数是掩蔽语言模型损失函数和下一句预测损失函数的线性组合。现在我们可以通过实例化三个类<code>BERTEncoder</code>、<code>MaskLM</code>和<code>NextSentencePred</code>来定义<code>BERTModel</code>类。前向推断返回编码后的BERT表示<code>encoded_X</code>、掩蔽语言模型预测<code>mlm_Y_hat</code>和下一句预测<code>nsp_Y_hat</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BERTModel</span>(nn.Module):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;BERT模型&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, vocab_size, num_hiddens, norm_shape, ffn_num_input,</span></span><br><span class="line"><span class="params">                 ffn_num_hiddens, num_heads, num_layers, dropout,</span></span><br><span class="line"><span class="params">                 max_len=<span class="number">1000</span>, key_size=<span class="number">768</span>, query_size=<span class="number">768</span>, value_size=<span class="number">768</span>,</span></span><br><span class="line"><span class="params">                 hid_in_features=<span class="number">768</span>, mlm_in_features=<span class="number">768</span>,</span></span><br><span class="line"><span class="params">                 nsp_in_features=<span class="number">768</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(BERTModel, self).__init__()</span><br><span class="line">        self.encoder = BERTEncoder(vocab_size, num_hiddens, norm_shape,</span><br><span class="line">                    ffn_num_input, ffn_num_hiddens, num_heads, num_layers,</span><br><span class="line">                    dropout, max_len=max_len, key_size=key_size,</span><br><span class="line">                    query_size=query_size, value_size=value_size)</span><br><span class="line">        self.hidden = nn.Sequential(nn.Linear(hid_in_features, num_hiddens),</span><br><span class="line">                                    nn.Tanh())</span><br><span class="line">        self.mlm = MaskLM(vocab_size, num_hiddens, mlm_in_features)</span><br><span class="line">        self.nsp = NextSentencePred(nsp_in_features)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, tokens, segments, valid_lens=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">                pred_positions=<span class="literal">None</span></span>):</span><br><span class="line">        encoded_X = self.encoder(tokens, segments, valid_lens)</span><br><span class="line">        <span class="keyword">if</span> pred_positions <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            mlm_Y_hat = self.mlm(encoded_X, pred_positions)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            mlm_Y_hat = <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 用于下一句预测的多层感知机分类器的隐藏层，0是“&lt;cls&gt;”标记的索引</span></span><br><span class="line">        nsp_Y_hat = self.nsp(self.hidden(encoded_X[:, <span class="number">0</span>, :]))</span><br><span class="line">        <span class="keyword">return</span> encoded_X, mlm_Y_hat, nsp_Y_hat</span><br></pre></td></tr></table></figure>
<h4 id="3-5-小结"><a href="#3-5-小结" class="headerlink" title="3.5 小结"></a>3.5 小结</h4><ul>
<li>word2vec和GloVe等词嵌入模型与上下文无关。它们将相同的预训练向量赋给同一个词，而不考虑词的上下文（如果有的话）。它们很难处理好自然语言中的一词多义或复杂语义。</li>
<li>对于上下文敏感的词表示，如ELMo和GPT，词的表示依赖于它们的上下文。</li>
<li>ELMo对上下文进行双向编码，但使用特定于任务的架构（然而，为每个自然语言处理任务设计一个特定的体系架构实际上并不容易）；而GPT是任务无关的，但是从左到右编码上下文。</li>
<li>BERT结合了这两个方面的优点：它对上下文进行双向编码，并且需要对大量自然语言处理任务进行最小的架构更改。</li>
<li>BERT输入序列的嵌入是词元嵌入、片段嵌入和位置嵌入的和。</li>
<li>预训练包括两个任务：掩蔽语言模型和下一句预测。前者能够编码双向上下文来表示单词，而后者则显式地建模文本对之间的逻辑关系。</li>
</ul>
<h3 id="Q-amp-A："><a href="#Q-amp-A：" class="headerlink" title="Q&amp;A："></a>Q&amp;A：</h3><h5 id="Q1-BERT是不是很少用在CV上？"><a href="#Q1-BERT是不是很少用在CV上？" class="headerlink" title="Q1:BERT是不是很少用在CV上？"></a>Q1:BERT是不是很少用在CV上？</h5><blockquote>
<p>transformer架构这几年在大量的用于CV上</p>
</blockquote>
<h5 id="Q2-展示一下10W-batch-训练结果？"><a href="#Q2-展示一下10W-batch-训练结果？" class="headerlink" title="Q2:展示一下10W batch 训练结果？"></a>Q2:展示一下10W batch 训练结果？</h5><blockquote>
<p>微调时会用到</p>
</blockquote>
<h5 id="Q3：使用BERT-large时显存不足，有什么方法吗？"><a href="#Q3：使用BERT-large时显存不足，有什么方法吗？" class="headerlink" title="Q3：使用BERT large时显存不足，有什么方法吗？"></a>Q3：使用BERT large时显存不足，有什么方法吗？</h5><blockquote>
<p>单机多卡，模型并行，或改用小模型</p>
</blockquote>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>68-transformer架构</title>
    <url>/2024/04/23/11-06-08/</url>
    <content><![CDATA[<h3 id="1-transformer架构"><a href="#1-transformer架构" class="headerlink" title="1.transformer架构"></a>1.transformer架构</h3><ul>
<li>基于encoder-decoder架构来处理序列对</li>
<li>跟使用注意力的seq2seq不同，transformer是纯基于注意力</li>
</ul>
<p>&lt;</p>
<h3 id="2-多头注意力"><a href="#2-多头注意力" class="headerlink" title="2.多头注意力"></a>2.多头注意力</h3><ul>
<li><p>对同一key，value，query，希望抽取不同的信息</p>
<ul>
<li>例如短距离关系和长距离关系</li>
</ul>
</li>
<li><p>多头注意力使用h个独立的注意力池化</p>
<ul>
<li><p>合并各个头（head）输出得到最终输出</p>
</li>
<li><img src="/2024/04/23/11-06-08/68-02.png" class="">
</li>
</ul>
</li>
<li><p>数学表达式</p>
<img src="/2024/04/23/11-06-08/68-02.png" class="">
</li>
</ul>
<h3 id="3-有掩码的多头注意力"><a href="#3-有掩码的多头注意力" class="headerlink" title="3.有掩码的多头注意力"></a>3.有掩码的多头注意力</h3><ul>
<li>解码器对序列中一个元素输出的时候，不应该考虑该元素之后的元素</li>
<li>可以用掩码来实现<ul>
<li>也就是计算$x_i$输出的时候，假装当前序列长度为i</li>
</ul>
</li>
</ul>
<h3 id="4-基于位置的前馈网络"><a href="#4-基于位置的前馈网络" class="headerlink" title="4.基于位置的前馈网络"></a>4.基于位置的前馈网络</h3><ul>
<li>将输入形状变化（b,n,d）变换成（bn，d）；输出形状由（bn，d）变成（b，n，d）</li>
<li>作用两个全连接层</li>
<li>等价于两层核窗口为1的一维卷积层（全连接）</li>
</ul>
<h3 id="5-层归一化"><a href="#5-层归一化" class="headerlink" title="5.层归一化"></a>5.层归一化</h3><ul>
<li>批量归一化对每个特征/通道里元素进行归一化<ul>
<li>不适合序列长度会变的nlp应用</li>
</ul>
</li>
<li>层归一化对每个样本里面的元素进行归一化（ layer norm ）</li>
</ul>
<h3 id="6-信息传递"><a href="#6-信息传递" class="headerlink" title="6.信息传递"></a>6.信息传递</h3><ul>
<li>将编码器输出作为解码中第i个transformer块中多头注意力的key和value<ul>
<li>query来自目标序列</li>
</ul>
</li>
<li>意味着编码器和解码器中块的个数，输出维度都是一样的</li>
</ul>
<h3 id="7-预测"><a href="#7-预测" class="headerlink" title="7.预测"></a>7.预测</h3><ul>
<li>预测第t+1个输出时</li>
<li>解码器中输入前t个预测值（顺序）<ul>
<li>在自注意力中，前t个预测值作为key和value，第t个预测值还作为query</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>transformer是一个纯使用注意力的encoder-decoder</li>
<li>编码器和解码器都有n个transformer块</li>
<li>每个块里面使用多头注意力，基于位置的前馈网络，层归一化</li>
</ul>
<h3 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h3><ul>
<li>多头注意力，concat和相加取平均怎么选择？<ul>
<li>老师认为concat保留的信息更全面，更好</li>
</ul>
</li>
<li>为什么在获取词向量之后，需要对词向量进行缩放（乘以embedding size的开方之后再加上PE）<ul>
<li>embedding之后，向量长度变长，元素值变小，乘以之后可以保证在-1，1之间，和position大小差不多</li>
</ul>
</li>
<li>num of head是什么？<ul>
<li>类似卷积的多通道，多个attention关注的是不同的特征</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>72-优化算法</title>
    <url>/2024/04/23/11-06-12/</url>
    <content><![CDATA[<h2 id="72-优化算法"><a href="#72-优化算法" class="headerlink" title="72.优化算法"></a>72.优化算法</h2><h3 id="1-优化问题"><a href="#1-优化问题" class="headerlink" title="1.优化问题"></a>1.优化问题</h3><img src="/2024/04/23/11-06-12/72-01.png" class="">
<h3 id="2-局部最小-vs-全局最小"><a href="#2-局部最小-vs-全局最小" class="headerlink" title="2.局部最小 vs 全局最小"></a>2.局部最小 vs 全局最小</h3><img src="/2024/04/23/11-06-12/72-02.png" class="">
<h3 id="3-凸集和凸函数"><a href="#3-凸集和凸函数" class="headerlink" title="3.凸集和凸函数"></a>3.凸集和凸函数</h3><ul>
<li>凸集：形象化来说，就是这个集合上任意两个点连一条线，这个线在集合里面</li>
<li>凸函数：形象上来说函数上任取两个点连线，函数都在该线下面</li>
<li>凸优化问题：局部最小一定是全局最小。严格凸优化问题有唯一的全局最小。<ul>
<li>凸：线性回归，softmax回归</li>
<li>非凸：其他（MLP,CNN,RNN,attention）</li>
</ul>
</li>
</ul>
<h3 id="4-梯度下降"><a href="#4-梯度下降" class="headerlink" title="4.梯度下降"></a>4.梯度下降</h3><ul>
<li>梯度下降——最简单的迭代求解算法</li>
<li>随机梯度下降<ul>
<li>求导数需要求所有样本导数，样本多的情况下代价太大</li>
<li>理论依据：所用样本，和随机选取一个样本得到的数学期望是一样的。</li>
</ul>
</li>
<li>小批量随机梯度下降（实际应用的）<ul>
<li>计算原因：计算单样本的梯度难以完全利用硬件资源</li>
<li>采集一个随机子集</li>
<li>理论依据：无偏近，但降低了方差</li>
</ul>
</li>
</ul>
<h3 id="5-冲量法"><a href="#5-冲量法" class="headerlink" title="5.冲量法"></a>5.冲量法</h3><ul>
<li>使用平滑过的梯度对权重更新，不容易震荡</li>
<li>momentum</li>
</ul>
<img src="/2024/04/23/11-06-12/72-03.png" class="">
<h3 id="6-Adam"><a href="#6-Adam" class="headerlink" title="6.Adam"></a>6.Adam</h3><ul>
<li>非常平滑，对于学习率不敏感</li>
<li>对于t比较小的时候，由于$v_0=0$,所以会导致一开始值比较小，做了一个修正。</li>
</ul>
<img src="/2024/04/23/11-06-12/72-04.png" class="">
<ul>
<li>为什么除以$\sqrt{\widehat{s}_t}+\epsilon$？<ul>
<li>在nlp里面常用，起到正则化的作用，控制每个维度的值在合适的大小。</li>
</ul>
</li>
</ul>
<img src="/2024/04/23/11-06-12/72-05.png" class="">
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>深度学习模型大部分是非凸的</li>
<li>小批量随机梯度下降是最常见的优化算法</li>
<li>冲量是对梯度做平滑</li>
<li>Adam是对梯度做平滑，且对梯度各个维度值做重新调整，对于学习率不敏感</li>
</ul>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>动手学深度学习笔记汇总</title>
    <url>/2024/04/24/12-18-34/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.04.24：初稿</li>
</ul>
<h1 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h1><ul>
<li><a href="/2024/04/24/12-18-34/" title="动手学深度学习笔记汇总">动手学深度学习笔记汇总</a></li>
<li><a href="/2024/04/23/11-01-00/" title="00-深度学习预告">00-预告</a></li>
<li><a href="/2024/04/23/11-01-01/" title="01-深度学习课程安排">01-课程安排</a></li>
<li><a href="/2024/04/23/11-01-02/" title="02-深度学习介绍">02-深度学习介绍</a></li>
<li><a href="/2024/04/23/11-01-03/" title="03-深度学习安装">03-安装</a></li>
<li><a href="/2024/04/23/11-01-04/" title="04-数据读取和操作">04-数据读取和操作</a></li>
<li><a href="/2024/04/23/11-01-05/" title="05-线性代数">05-线性代数</a></li>
<li><a href="/2024/04/23/11-01-06/" title="06-矩阵计算">06-矩阵计算</a></li>
<li><a href="/2024/04/23/11-01-07/" title="07-链式法则与自动求导">07-链式法则与自动求导</a></li>
<li><a href="/2024/04/23/11-01-08/" title="08-线性回归+基础优化算法">08-线性回归+基础优化算法</a></li>
<li><a href="/2024/04/23/11-01-09/" title="09-softmax回归">09-softmax回归</a></li>
<li><a href="/2024/04/23/11-01-10/" title="10-多层感知机">10-多层感知机</a></li>
<li><a href="/2024/04/23/11-01-11/" title="11-模型选择+过拟合和欠拟合">11-模型选择+过拟合和欠拟合</a></li>
<li><a href="/2024/04/23/11-01-12/" title="12 权重衰退 Weight Decay">12-权重衰退</a></li>
<li><a href="/2024/04/23/11-01-13/" title="13-丢弃法">13-丢弃法</a></li>
<li><a href="/2024/04/23/11-01-14/" title="14-数值稳定性+模型初始化和激活函数">14-数值稳定性</a></li>
<li><a href="/2024/04/23/11-01-15/" title="15-实战Kaggle比赛：预测房价">15-实战Kaggle比赛：预测房价</a>
</li>
</ul>
<blockquote>
<p>暂停，开始读论文</p>
</blockquote>
<h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><p><strong>d2l官网</strong>：<a href="https://zh-v2.d2l.ai/index.html">动手学深度学习</a><br><strong>笔记来源</strong>：<a href="https://github.com/MLNLP-World/DeepLearning-MuLi-Notes/tree/main">DeepLearning-MuLi-Notes</a><br><strong>小土堆笔记</strong>：<a href="https://github.com/AccumulateMore/CV/tree/main">含课程代码注释</a></p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li><code>!pip install git+https://github.com/d2l-ai/d2l-zh@release  # installing d2l</code>下载较慢，使用<code>!pip install d2l==1.0.3</code>。</li>
</ul>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>vim实用技巧</title>
    <url>/2024/04/19/11-47-11/</url>
    <content><![CDATA[<h1 id="按键说明"><a href="#按键说明" class="headerlink" title="按键说明"></a>按键说明</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="动词"><a href="#动词" class="headerlink" title="动词"></a>动词</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">d 删除 delete</span><br><span class="line">r 替换 replace</span><br><span class="line">c 修改 change</span><br><span class="line">y 复制 yank</span><br><span class="line">v 选取 visual select</span><br></pre></td></tr></table></figure>
<h3 id="名词-text-object"><a href="#名词-text-object" class="headerlink" title="名词 text object"></a>名词 text object</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">w 单词word</span><br><span class="line">s 句子 sentence</span><br><span class="line">p 段落paragraph</span><br><span class="line">t HTML标签tag</span><br><span class="line">u 撤销(undo)</span><br><span class="line">. 重复最后一个命令</span><br><span class="line">引号或者各种括号所包含的文本称作一个文本块。</span><br></pre></td></tr></table></figure>
<h3 id="介词"><a href="#介词" class="headerlink" title="介词"></a>介词</h3><p>介词界定了待编辑文本的范围或者位置。例如：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">i “在…之内”inside</span><br><span class="line">a “环绕…”around</span><br><span class="line">t “到…位置前”to</span><br><span class="line">f “到…位置上”forward</span><br></pre></td></tr></table></figure></p>
<h3 id="组词为句"><a href="#组词为句" class="headerlink" title="组词为句"></a>组词为句</h3><p>动词+介词+名词<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">删除一个段落 delete inside paragraph: dip</span><br><span class="line">选取一个句子 visual select inside sentence: vis</span><br><span class="line">修改一个单词 change inside word: ciw</span><br><span class="line">修改一个单词 change around word: caw</span><br><span class="line">删除文本直到字符“x”（不包括字符“x”）delete to x: dtx</span><br><span class="line">删除文本直到字符“x”（包括字符“x”）delete forward x:dfx</span><br></pre></td></tr></table></figure></p>
<h3 id="数词"><a href="#数词" class="headerlink" title="数词"></a>数词</h3><p>动词+介词/数词+名词<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">修改三个单词 change three words: c3w</span><br><span class="line">删除两个单词 delete two words: d2w</span><br></pre></td></tr></table></figure></p>
<p>数词也可以修饰动词，表示将操作执行 n 次<br>数词+动词+名词<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">两次删除单词（等价于删除两个单词） twice delete word: <span class="number">2</span>dw</span><br><span class="line">三次删除字符（等价于删除三个字符）three times delete character: <span class="number">3</span>x</span><br></pre></td></tr></table></figure></p>
<h2 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h2><h3 id="行"><a href="#行" class="headerlink" title="行"></a>行</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> 跳转到当前行首</span><br><span class="line">^ 跳转到当前行的第一个非空字符(空格/TAB)</span><br><span class="line">$ 跳转到当前行的末尾</span><br><span class="line">gg 跳转到文件第一行(<span class="keyword">goto</span>)</span><br><span class="line">G 跳转到文件最后一行</span><br><span class="line"><span class="number">47</span>G 跳转到文件第<span class="number">47</span>行</span><br><span class="line">:<span class="number">47</span> 跳转到文件第<span class="number">47</span>行(同<span class="string">&quot;47G&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">f[<span class="type">char</span>] 跳转到第一个[<span class="type">char</span>]字符(find)</span><br><span class="line"><span class="number">3f</span>[<span class="type">char</span>] 跳转到第三个[<span class="type">char</span>]字符</span><br><span class="line">F[<span class="type">char</span>] 向左跳转到第一个[<span class="type">char</span>]字符</span><br><span class="line">t[<span class="type">char</span>] 跳转到第一个[<span class="type">char</span>]字符的前一个字符(till before - right)</span><br><span class="line">T[<span class="type">char</span>] 向左跳转到第一个[<span class="type">char</span>]字符的后一个字符(till after - left)</span><br><span class="line">; 重复最后一次的 f/F/t/T 移动命令</span><br><span class="line"> </span><br><span class="line">这里加 shift 大写，意为反向：向左</span><br></pre></td></tr></table></figure>
<h3 id="单词和文本块"><a href="#单词和文本块" class="headerlink" title="单词和文本块"></a>单词和文本块</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">w 跳转到下一个单词的开头(word)</span><br><span class="line"><span class="number">3</span>w 跳转到第三个单词的开头</span><br><span class="line">e 跳转到下一个单词的结尾(end of word)</span><br><span class="line">b 跳转到上一个单词的开头(backward beginning)</span><br><span class="line">( 跳转到上一个句子的开头</span><br><span class="line">) 跳转到下一个句子的开头</span><br><span class="line">&#123; 跳转到上一个段落的开头</span><br><span class="line">&#125; 跳转到下一个段落的开头</span><br></pre></td></tr></table></figure>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">% 在当前大括号/中括号/小括号的开始位置<span class="string">&quot;&#123;/[/(&quot;</span>和结束位置<span class="string">&quot;&#125;/]/)&quot;</span>之间跳转</span><br><span class="line">[[ 跳转到上一个函数的开头(如果光标在函数体内则跳转到当前函数的开头)</span><br><span class="line">]] 跳转到下一个函数的开头</span><br><span class="line">[&#123; 跳转到当前程序块的开头(当前程序块为当前程序的上一层，不是固定的)</span><br><span class="line">]&#125; 跳转到当前程序块的结尾</span><br></pre></td></tr></table></figure>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/[word] 搜索[word]字符串</span><br><span class="line">?[word] 向上搜索[word]字符串</span><br><span class="line">n 跳转到下一个匹配的字符串(保持最后一个搜索命令的方向)(next match)</span><br><span class="line">N 跳转到上一个匹配的字符串(保持最后一个搜索命令的方向)</span><br><span class="line">* 搜索当前光标下的单词</span><br><span class="line"># 向上搜索当前光标下的单词</span><br></pre></td></tr></table></figure>
<h2 id="插入模式"><a href="#插入模式" class="headerlink" title="插入模式"></a>插入模式</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">s 删除光标位置下的字符并进入插入模式</span><br><span class="line">S 删除当前行内容并进入插入模式</span><br></pre></td></tr></table></figure>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x 删除光标位置下的字符</span><br><span class="line">dw 删除光标之后的单词剩余部分(delete word)</span><br><span class="line">diw 删除一个单词</span><br><span class="line">dd 删除当前行</span><br><span class="line">D 删除从光标位置到当前行的末尾(同<span class="string">&quot;d$&quot;</span>)</span><br><span class="line">df[<span class="type">char</span>] 删除从光标位置到[<span class="type">char</span>]字符(delete find [<span class="type">char</span>])</span><br><span class="line">d) 删除从光标位置到下一个句子的开始</span><br><span class="line">d&#125; 删除从光标位置到该段落的末尾</span><br><span class="line">di&#123; 删除花括号之间的内容(delete inner &#123;&#125;)(同<span class="string">&quot;diB&quot;</span>)</span><br><span class="line">di( 删除小括号之间的内容(delete inner ())(同<span class="string">&quot;dib&quot;</span>)</span><br><span class="line">dit 删除闭合标签之间的内容(html/xml等标签，delete inner tag)</span><br><span class="line">dat 删除左右尖括号及之间的内容(delete a tag)</span><br><span class="line">da&lt; 删除左右尖括号及之间的内容(delete a &lt;&gt;)</span><br><span class="line">di<span class="string">&quot; 删除引号之间的内容(delete inner &quot;</span><span class="string">&quot;)</span></span><br><span class="line"><span class="string">da&quot;</span> 删除左右引号及之间的内容(delete a <span class="string">&quot;&quot;</span>)</span><br><span class="line">:<span class="number">5</span>,<span class="number">10</span>d 删除<span class="number">5</span><span class="number">-10</span>行</span><br><span class="line"><span class="number">3</span>dd 删除从当前行开始的<span class="number">3</span>行</span><br><span class="line">&lt;C-w&gt; 删除光标前的一个单词(插入模式)</span><br><span class="line">&lt;C-u&gt; 从光标位置删除到行首(插入模式)</span><br><span class="line"> </span><br><span class="line">这里加 shift 大写，意为行尾</span><br><span class="line">注：<span class="string">&quot;d&quot;</span>/<span class="string">&quot;c&quot;</span>开头的命令会将删除的文本放到寄存器(通过<span class="string">&quot;:reg&quot;</span>查看)，可以理解为剪切。</span><br><span class="line">关于<span class="string">&quot;a&quot;</span>n和<span class="string">&quot;i&quot;</span>nner可以参考<span class="string">&quot;:help object-select&quot;</span>文本对象选择部分</span><br><span class="line">另：一般向右的操作包含光标下的字符，向左的操作不包含光标下的字符</span><br></pre></td></tr></table></figure>
<h2 id="更改文本"><a href="#更改文本" class="headerlink" title="更改文本"></a>更改文本</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">J 将下一行合并的当前行的末尾(Join line)</span><br><span class="line"><span class="number">3</span>,<span class="number">9</span>j 合并<span class="number">3</span><span class="number">-9</span>行</span><br><span class="line">~ 切换光标下字符的大小写</span><br><span class="line">u 更改选定的文本为小写(可视模式)</span><br><span class="line">U 更改选定的文本为大写(可视模式)</span><br><span class="line">&lt;C-a&gt; 把当前光标下或之后的数值加<span class="number">1</span></span><br><span class="line">&lt;C-x&gt; 把当前光标下或之后的数值减<span class="number">1</span></span><br><span class="line">r[<span class="type">char</span>] 替换光标下的字符为[<span class="type">char</span>]. (replace)</span><br><span class="line">R 进入替换模式</span><br><span class="line">cw 删除光标之后的单词剩余部分并进入插入模式(change word)</span><br><span class="line">cc 删除当前行内容并进入插入模式(同<span class="string">&quot;S&quot;</span>)</span><br><span class="line">C 删除从光标位置到当前行的末尾并进入插入模式(同<span class="string">&quot;c$&quot;</span>)</span><br><span class="line">cf[<span class="type">char</span>] 删除从光标位置到[<span class="type">char</span>]字符并进入插入模式</span><br><span class="line"> </span><br><span class="line">这里<span class="string">&quot;c&quot;</span>开头加 shift 大写，意为行尾</span><br><span class="line"><span class="string">&quot;c&quot;</span>开头<span class="string">&quot;change&quot;</span>更改(删除并插入)，<span class="string">&quot;d&quot;</span>开头<span class="string">&quot;delete&quot;</span>删除，和<span class="string">&quot;y&quot;</span>开头<span class="string">&quot;yank/copy&quot;</span>，格式相同，可相互参考使用</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;&gt; 缩进当前行</span><br><span class="line">&lt;&lt; 向左缩进当前行</span><br><span class="line">&lt;C-d&gt; 缩进当前行(插入模式)</span><br><span class="line">&lt;C-t&gt; 向左缩进当前行(插入模式)</span><br><span class="line">:<span class="number">3</span>,<span class="number">9</span>&gt;&gt;&gt;&gt;&gt; 将<span class="number">3</span><span class="number">-9</span>行缩进<span class="number">5</span>个TAB</span><br><span class="line">&gt; 缩进选定的行(可视模式)</span><br><span class="line">&lt; 向左缩进选定的行(可视模式)</span><br><span class="line">&gt;i&#123; 缩进花括号之间的内容(indent inner &#123;&#125;)(同<span class="string">&quot;&gt;iB&quot;</span>)</span><br><span class="line">&gt;a&#123; 缩进花括号及之间的内容(indent a &#123;&#125;)(同<span class="string">&quot;&gt;aB&quot;</span>)</span><br><span class="line">=&#125; 缩进当前段落</span><br><span class="line">gg=G 全文缩进/格式化</span><br></pre></td></tr></table></figure>
<h2 id="复制粘贴"><a href="#复制粘贴" class="headerlink" title="复制粘贴"></a>复制粘贴</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v 进入可视模式，以字符为单位选择</span><br><span class="line">V 进入可视模式，以行为单位选择</span><br><span class="line">&lt;C-v&gt; 进入列块可视模式(如果映射<span class="string">&quot;&lt;C-v&gt;&quot;</span>为<span class="string">&quot;粘贴&quot;</span>时请注意)</span><br><span class="line">gv 重新选择最后选定的区域</span><br><span class="line">y 抽出选择的文本到寄存器(可视模式)(yank/copy)</span><br><span class="line"><span class="string">&quot;+y 抽出选择的文本到系统剪切板(可视模式)(好像不太好使)</span></span><br><span class="line"><span class="string">:co 10 复制当前行到第11行(copy)</span></span><br><span class="line"><span class="string">:co . 复制当前行到下一行(同&quot;</span>yyp<span class="string">&quot;)</span></span><br><span class="line"><span class="string">:5,10co 20 复制5-10行到第21行</span></span><br><span class="line"><span class="string">yy 复制当前行</span></span><br><span class="line"><span class="string">y$ 复制到行尾</span></span><br><span class="line"><span class="string">yw 复制光标之后的单词剩余部分(yank word)</span></span><br><span class="line"><span class="string">yb 复制光标之前的单词剩余部分</span></span><br><span class="line"><span class="string">yiw 复制一个单词</span></span><br><span class="line"><span class="string">yip 复制当前段落(yank inner paragraph)</span></span><br><span class="line"><span class="string">yas 复制一个句子(yank a sentence)</span></span><br><span class="line"><span class="string">yi&lt; 复制尖括号之间的内容(Yank inner &lt;&gt;)</span></span><br><span class="line"><span class="string">11y 复制11行</span></span><br><span class="line"><span class="string">p 粘贴(paste)</span></span><br><span class="line"><span class="string">P 粘贴到光标前</span></span><br><span class="line"><span class="string">&lt;C-r&gt;&quot;</span> 粘贴(插入模式)</span><br><span class="line"><span class="string">&quot;ayy 复制当前行到寄存器&quot;</span>a<span class="string">&quot;(可使用范围&quot;</span>a-z<span class="string">&quot;)</span></span><br><span class="line"><span class="string">&quot;</span>ap 粘贴从寄存器<span class="string">&quot;a&quot;</span></span><br><span class="line"> </span><br><span class="line">这里的<span class="string">&quot;寄存器&quot;</span>即VIM剪切板</span><br></pre></td></tr></table></figure>
<h2 id="滚动屏幕"><a href="#滚动屏幕" class="headerlink" title="滚动屏幕"></a>滚动屏幕</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">H 跳转到屏幕的顶部(home)</span><br><span class="line">M 跳转到屏幕的中间(middle)</span><br><span class="line">L 跳转到屏幕的底部(low)</span><br><span class="line">zt 将当前行滚动至屏幕顶部(top)</span><br><span class="line">zz 将当前行滚动至屏幕中间(同<span class="string">&quot;z.&quot;</span>)</span><br><span class="line">zb 将当前行滚动至屏幕中间(bottom)(同<span class="string">&quot;z-&quot;</span>)</span><br><span class="line">&lt;C-f&gt; 滚动至下一页(forwards)</span><br><span class="line">&lt;C-b&gt; 滚动至上一页(backwards)</span><br><span class="line">&lt;C-d&gt; 向下滚动半屏(downwards)</span><br><span class="line">&lt;C-u&gt; 向下滚动半屏(upwards)</span><br></pre></td></tr></table></figure>
<h2 id="键映射"><a href="#键映射" class="headerlink" title="键映射"></a>键映射</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">:<span class="built_in">map</span> 查看已映射的键列表</span><br><span class="line">:imap 查看插入模式下已映射的键列表</span><br><span class="line">:nmap 查看普通模式下已映射的键列表</span><br><span class="line">:imap jj &lt;Esc&gt; 插入模式下键入<span class="string">&quot;jj&quot;</span>映射到<span class="string">&quot;&lt;ESC&gt;&quot;</span>(返回普通模式)</span><br><span class="line">:nmap &lt;C-h&gt; &lt;C-w&gt;h 普通模式下映射<span class="string">&quot;&lt;C-h&gt;&quot;</span>到<span class="string">&quot;&lt;C-w&gt;h&quot;</span>(光标移动到左边一个窗口)</span><br></pre></td></tr></table></figure>
<h1 id="键位图"><a href="#键位图" class="headerlink" title="键位图"></a>键位图</h1><ul>
<li>绿色键：motion，移动光标，或定义操作的范围</li>
<li>黄色键：command，直接执行的命令，红色命令进入编辑模式</li>
<li>橙色键：operator，后面跟随表示操作范围的指令</li>
<li>灰色键：extra，特殊功能，需要额外的输入</li>
</ul>
<img src="/2024/04/19/11-47-11/592892-20180328123208117-408079142.gif" class="">
<img src="/2024/04/19/11-47-11/57cbaf4d4db0e734254abe2717da0360.jpeg" class="">
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具, vim</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown语法</title>
    <url>/2024/04/19/22-19-04/</url>
    <content><![CDATA[<h1 id="hexo引擎更换"><a href="#hexo引擎更换" class="headerlink" title="hexo引擎更换"></a>hexo引擎更换</h1><h2 id="latex特殊转义"><a href="#latex特殊转义" class="headerlink" title="latex特殊转义"></a>latex特殊转义</h2><p>选用hexo-renderer-kramed渲染器</p>
<blockquote>
<p>作为行内代码：$ a+b $<br>行内公式：<code>\$\$ a+b \$\$</code></p>
</blockquote>
<h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><ul>
<li>换行：\begin{align*}  //  \end{align*}  转为 \begin{split}</li>
<li>换行中间不能有空行</li>
<li>多行公式对齐，使用<code>&amp;</code>，所有的符号都会在每一行对齐</li>
</ul>
<h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法*"></a>乘法*</h3><ul>
<li>乘法需要加\*转义</li>
</ul>
<h3 id="求导偏导"><a href="#求导偏导" class="headerlink" title="求导偏导"></a>求导偏导</h3><ul>
<li>求导 <code>d</code>  直接写</li>
<li>偏导 <code>\partial</code></li>
</ul>
<h3 id="大写bold"><a href="#大写bold" class="headerlink" title="大写bold"></a>大写bold</h3><ul>
<li>改为<code>boldsymbol</code></li>
</ul>
<h2 id="markdown"><a href="#markdown" class="headerlink" title="markdown"></a>markdown</h2><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>与正文空一行，才能正常转义</p>
<h3 id="跳转1"><a href="#跳转1" class="headerlink" title="跳转1"></a>跳转<sup><a href="#fn_1" id="reffn_1">1</a></sup></h3><ul>
<li><blockquote id="fn_1">
<sup>1</sup>. <code>[^1]</code>设置标签， 在需要跳转的地方写入<code>[^1]:</code>生成跳转箭头<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown, hexo, Latex</tag>
      </tags>
  </entry>
  <entry>
    <title>70-BERT微调</title>
    <url>/2024/04/23/11-06-10/</url>
    <content><![CDATA[<h2 id="70-BERT微调"><a href="#70-BERT微调" class="headerlink" title="70 BERT微调"></a>70 BERT微调</h2><h3 id="1-intro"><a href="#1-intro" class="headerlink" title="1.intro"></a>1.intro</h3><p>与图片分类不同，BERT预训练时使用的两个任务没有什么实际应用场景，所以使用BERT时多需要进行微调。</p>
<p>BERT对每一个token都返回一个特定长度的特征向量（课堂演示为128，bert-base是768，bert-large是1024），这些特征向量抽取了上下文信息。不同的任务使用不同的特征。</p>
<h3 id="2-具体应用"><a href="#2-具体应用" class="headerlink" title="2.具体应用"></a>2.具体应用</h3><h4 id="2-1句子分类"><a href="#2-1句子分类" class="headerlink" title="2.1句子分类"></a>2.1句子分类</h4><p>将句首的\<CLS\>token对应的向量输入到全连接层分类。对于一对句子也是同理，句子中间用\<SEP\>分开但仍只用第一个\<CLS\>对应的向量。</p>
<p>关于为什么要使用\<CLS\>是因为预训练中判断句子是否连续任务中使用的是\<CLS\>，因此模型会“知道”\<CLS\>是句子级别分类用的向量，表示的信息应与句子整体有关。当然我们也可以不使用\<CLS\>选定自己想要的token，之后在微调中更新bert的权重即可。</p>
<h4 id="2-2命名实体识别"><a href="#2-2命名实体识别" class="headerlink" title="2.2命名实体识别"></a>2.2命名实体识别</h4><p>命名实体识别即识别一个词元是不是命名实体，例如人名、机构、位置。其方法是将每一个非特殊词元的向量放进全连接层分类（二分类多分类均可）。</p>
<h4 id="2-3问题回答"><a href="#2-3问题回答" class="headerlink" title="2.3问题回答"></a>2.3问题回答</h4><p>给定一个问题和描述文字，找出一个判断作为回答，微调方法为对片段中的每个词元预测它是不是回答的开头或结束。</p>
<p>总体而言，无论是句子级别还是词级别的分类任务，都只需要在bert的基础上加全连接层，bert中的权重是可以直接从预训练模型得到的，真正需要自己从头训练的只有全连接层的权重。</p>
<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h3><ul>
<li>即使下游任务各有不同，使用BERT微调时均只需要增加输出层</li>
<li>但根据任务的不同，输入的表示，和使用的BERT特征也会不一样</li>
</ul>
<p>在BERT的基础上微调使得多数任务都变的简单许多且效果相比从零开始训练要好很多，至此自然语言处理也向计算机视觉一样转向微调路线。</p>
<h3 id="4-QA"><a href="#4-QA" class="headerlink" title="4.QA"></a>4.QA</h3><p>Q1: BERT微调的时候固定预训练模型的参数吗？</p>
<blockquote>
<p>一般不固定，所有权重都进行训练。也可以固定住底部一些层来加速训练，但通常来说不固定效果更好。可以自行尝试固定哪几层在训练速度更快的前提下效果更好</p>
</blockquote>
<p>Q2: 为什么没讲YOLO？</p>
<blockquote>
<p>YOLO的较新版本已经跟之前版本很不一样了，且里面的技术细节很杂多。纯Python实现的yolo效果不见得比其他算法好，之所以表现出众是因为加入了大量的技术细节。只给大家实现一个本身大家可能不会太感兴趣。</p>
</blockquote>
<p>Q3: BERT在实际应用中怎样部署？用C++写代码吗？</p>
<blockquote>
<p>一般不需要用C++，可以将模型编译到C++（框架通常有支持）。但搬到C++也不能解决速度问题，BERT本身比resnet之类慢很多。</p>
</blockquote>
<p>Q4: 如果设备性能不高是不是不建议用BERT？</p>
<blockquote>
<p>可以用简化版本的BERT，如蒸馏版的BERT大约只有原模型十分之一大小。</p>
</blockquote>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
</search>
