<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>动手学深度学习笔记汇总</title>
    <url>/2024/04/24/12-18-34/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.04.24：初稿</li>
</ul>
<h1 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h1><ul>
<li><a href="/2024/04/24/12-18-34/" title="动手学深度学习笔记汇总">动手学深度学习笔记汇总</a></li>
<li><a href="/2024/04/23/11-01-00/" title="00-深度学习预告">00-预告</a></li>
<li><a href="/2024/04/23/11-01-01/" title="01-深度学习课程安排">01-课程安排</a></li>
<li><a href="/2024/04/23/11-01-02/" title="02-深度学习介绍">02-深度学习介绍</a></li>
<li><a href="/2024/04/23/11-01-03/" title="03-深度学习安装">03-安装</a></li>
<li><a href="/2024/04/23/11-01-04/" title="04-数据读取和操作">04-数据读取和操作</a></li>
<li><a href="/2024/04/23/11-01-05/" title="05-线性代数">05-线性代数</a></li>
<li><a href="/2024/04/23/11-01-06/" title="06-矩阵计算">06-矩阵计算</a></li>
<li><a href="/2024/04/23/11-01-07/" title="07-链式法则与自动求导">07-链式法则与自动求导</a></li>
<li><a href="/2024/04/23/11-01-08/" title="08-线性回归+基础优化算法">08-线性回归+基础优化算法</a></li>
<li><a href="/2024/04/23/11-01-09/" title="09-softmax回归">09-softmax回归</a></li>
<li><a href="/2024/04/23/11-01-10/" title="10-多层感知机">10-多层感知机</a></li>
<li><a href="/2024/04/23/11-01-11/" title="11-模型选择+过拟合和欠拟合">11-模型选择+过拟合和欠拟合</a></li>
<li><a href="/2024/04/23/11-01-12/" title="12 权重衰退 Weight Decay">12-权重衰退</a></li>
<li><a href="/2024/04/23/11-01-13/" title="13-丢弃法">13-丢弃法</a></li>
<li><a href="/2024/04/23/11-01-14/" title="14-数值稳定性+模型初始化和激活函数">14-数值稳定性</a></li>
<li><a href="/2024/04/23/11-01-15/" title="15-实战Kaggle比赛：预测房价">15-实战Kaggle比赛：预测房价</a>
</li>
</ul>
<blockquote>
<p>暂停，开始读论文</p>
</blockquote>
<h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><p><strong>d2l官网</strong>：<a href="https://zh-v2.d2l.ai/index.html">动手学深度学习</a><br><strong>笔记来源</strong>：<a href="https://github.com/MLNLP-World/DeepLearning-MuLi-Notes/tree/main">DeepLearning-MuLi-Notes</a><br><strong>小土堆笔记</strong>：<a href="https://github.com/AccumulateMore/CV/tree/main">含课程代码注释</a></p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li><code>!pip install git+https://github.com/d2l-ai/d2l-zh@release  # installing d2l</code>下载较慢，使用<code>!pip install d2l==1.0.3</code>。</li>
</ul>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>好用的的科研神器</title>
    <url>/2024/09/15/11-15-05/</url>
    <content><![CDATA[<h1 id="Trello-时间管理"><a href="#Trello-时间管理" class="headerlink" title="Trello 时间管理"></a>Trello 时间管理</h1><p>你可以针对不同的论文建立不同的看板，然后在该看板下你可以建立多个不同种类的任务列单，比如</p>
<ul>
<li>To-do</li>
<li>Doing</li>
<li>Done<br>三个列单，然后在每个列单下写上对应的该论文的任务，并且给每个任务分配一个due date. 这样就能做到全面、即时地跟踪科研完成情况。</li>
</ul>
<h1 id="Keep-amp-Share-时间管理软件"><a href="#Keep-amp-Share-时间管理软件" class="headerlink" title="Keep&amp;Share 时间管理软件"></a>Keep&amp;Share 时间管理软件</h1><h1 id="Zotero-论文管理工具"><a href="#Zotero-论文管理工具" class="headerlink" title="Zotero 论文管理工具"></a>Zotero 论文管理工具</h1>]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>深度学习, 计算机视觉</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习训练中的相关工具</title>
    <url>/2024/09/13/14-56-06/</url>
    <content><![CDATA[<h1 id="参数管理"><a href="#参数管理" class="headerlink" title="参数管理"></a>参数管理</h1><h2 id="使用argparse和yaml文件"><a href="#使用argparse和yaml文件" class="headerlink" title="使用argparse和yaml文件"></a>使用argparse和yaml文件</h2><p>1.argparse的使用：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import argparse</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">	argparse.ArgumentParser()创建了一个对象</span><br><span class="line">	add_argument()添加参数</span><br><span class="line">	parse_args()将参数封装在opt内，各个参数通过.运算符调用</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">def main(opt):</span><br><span class="line">    print(opt.num_batches)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line"></span><br><span class="line">    parse = argparse.ArgumentParser()</span><br><span class="line">    parse.add_argument(&#x27;--num_batches&#x27;, type=int, default=50, help=&#x27;the num of batch&#x27;)</span><br><span class="line">    parse.add_argument(&#x27;--num_window&#x27;, type=int, default=5, help=&#x27;the num of window&#x27;)</span><br><span class="line">    parse.add_argument(&#x27;--weight&#x27;, type=str, default= &#x27;../pretrain.pth&#x27;, help=&#x27;the path of pretrained model&#x27;)</span><br><span class="line"></span><br><span class="line">    opt = parse.parse_args()</span><br><span class="line">    main(opt)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>2.yaml文件的使用<br>下面是一个yaml文件的例子，参数呈现层级结构<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">device: &#x27;cpu&#x27;</span><br><span class="line"></span><br><span class="line">data:</span><br><span class="line">    train_path: &#x27;data/train&#x27;</span><br><span class="line">    test_path: &#x27;test/train&#x27;</span><br><span class="line">    num: 1000</span><br><span class="line"></span><br></pre></td></tr></table></figure><br><strong>特别需要注意缩进使用空格而不是tab，并且层级之间一定要对齐。</strong></p>
<p>读取yaml文件<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def read_yaml(path):</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">	read()读入yaml文件中的内容</span><br><span class="line">	safe_load()加载yaml格式的内容并转换为字典</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">    file = open(path, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;)</span><br><span class="line">    string = file.read()</span><br><span class="line">    file.close()</span><br><span class="line">    dict = yaml.safe_load(string)</span><br><span class="line"></span><br><span class="line">    return dict</span><br><span class="line"></span><br><span class="line">path = &#x27;config.yaml&#x27;</span><br><span class="line">Dict = read_yaml(path)</span><br><span class="line">device = Dict[&#x27;device&#x27;]</span><br><span class="line">print(device)</span><br><span class="line">train_path = Dict[&#x27;data&#x27;][&#x27;train_path&#x27;]</span><br><span class="line">print(train_path)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>使用方法：<br>在yaml文件中给全部参数设置默认值，使用argparse库设置待调参数的值</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>深度学习, 神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>ST-GCN 时空图卷积神经网路</title>
    <url>/2024/09/13/10-54-10/</url>
    <content><![CDATA[<p>论文名称：Spatial Temporal Graph Convolutional Networks for Skeleton-Based Action Recognition</p>
<h1 id="论文笔记"><a href="#论文笔记" class="headerlink" title="论文笔记"></a>论文笔记</h1><img src="/2024/09/13/10-54-10/31983eeeb54690c58ff568866b3d2f13.png" class>
<p><img src="/2024/09/13/10-54-10/31983eeeb54690c58ff568866b3d2f13.png" alt="logo"><br><img src="/2024/09/13/10-54-10/log.png" alt="logo"></p>
<p><img src="/2024/09/13/10-54-10/QQ_1726468024365.png" alt="QQ_1726468024365"></p>
<p>在这里插入图片描述</p>
<ul>
<li>对视频进行姿态估计，在骨架序列上构造时空图；</li>
<li>在输入数据上应用多层时空图卷积(ST-GCN)，逐步在图上生成更高层次的特征图；</li>
<li>然后由标准 Softmax 分类器将其分类到相应的动作类别。</li>
<li>整个模型采用反向传播的端到端方式训练。</li>
</ul>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>传统的骨骼建模方法依赖于手工制作的部件或遍历规则，表达能力有限和泛化困难，模型很难推广到其他应用。<br>这项工作提出了动态骨架模型。</p>
<h2 id="主要贡献"><a href="#主要贡献" class="headerlink" title="主要贡献"></a>主要贡献</h2><ul>
<li>提出了 ST-GCN，这是一种基于图的动态骨骼建模通用公式，这是第一个将基于图的神经网络应用于该任务。</li>
<li>针对骨架建模的具体要求，提出了 ST-GCN 中卷积核的设计原则。</li>
<li>在基于骨骼的动作识别的两个大规模数据集上，与之前使用手工制作部件或遍历规则的方法相比，所提出的模型获得了更好的性能，在手工设计方面的工作量大大减少。ST-GCN 的代码和模型是公开的。</li>
</ul>
<h3 id="ST-GCN：基于图的动态骨骼建模通用公式"><a href="#ST-GCN：基于图的动态骨骼建模通用公式" class="headerlink" title="ST-GCN：基于图的动态骨骼建模通用公式"></a>ST-GCN：基于图的动态骨骼建模通用公式</h3><img src="/2024/09/13/10-54-10/c837aa026e5755538d5406dd26bdb6d2.png" class>
<p>分别为两种边：时间边，空间边。<br>ST-GCN 的层次特性消除了手工制作的部件分配或遍历规则的需要。</p>
<blockquote>
<p>传统的骨架模型方法中，根据预定义的部件分配和遍历规则对骨架进行建模。<br>具体规则：<br>1.人体骨架的构成方式和连接顺序。<br>2.节点对应的身体部位、编号和名称等信息。<br>3.骨架节点的搜索顺序和遍历方式。</p>
</blockquote>
<p><strong>STGCN可以动态学习现有数据的关系规则</strong></p>
<p>ST-GCN 在进行时空图卷积之前，仍然需要对骨架节点进行部件分配和遍历规则的设计。可以根据不同任务，设定不同规则。</p>
<h3 id="ST-GCN-模型中的组件"><a href="#ST-GCN-模型中的组件" class="headerlink" title="ST-GCN 模型中的组件"></a>ST-GCN 模型中的组件</h3><p>在具有 N 个关节和 T 个框架（帧）的骨架序列上构造了无向时空图 $G=(V,E)$</p>
<ul>
<li>节点集$V=\{v_{ti}\left|t=1, \ldots, T;i=1, \ldots, N\right\}$包括骨架序列中的所有关节,节点 $F(v_{ti}\mathrm{~})$ 上的特征向量由帧 $t$ 上第 $i$ 个关节的坐标向量和估计置信度组成。</li>
<li>边集 E:<br>骨架内连接，记为 $E_S=\{v_{ti} v_{tj} |(i,j)\in H\},$，其中 $H$ 为自然连接的人体关节集合<br>帧间边：$E_F=\{v_{ti}v_{(t+1)i}\}$</li>
</ul>
<h3 id="空间图卷积神经网络"><a href="#空间图卷积神经网络" class="headerlink" title="空间图卷积神经网络"></a>空间图卷积神经网络</h3><h4 id="单帧的图CNN模型"><a href="#单帧的图CNN模型" class="headerlink" title="单帧的图CNN模型"></a>单帧的图CNN模型</h4><p>在时间 $\tau$ 的单个帧上，将有 $N$ 个关节节点 $V_t$​，以及骨架边 $E_S\left(\tau\right)=\{v_{ti} v_{tj} |t=\tau , (i,j)\in H\}$。</p>
<p>给定核尺寸为 $K×K$ 的卷积算子，以及通道数量为 $c$ 的输入特征映射 $f_{in}$​。在空间位置 $x$ 处，单个通道的输出值可以写成：<br>$f_{out}\left(x\right)=\sum_{h=1}^K\sum_{w=1}^Kf_{in}\left(\mathbf{p}(\mathbf{x},h,w)\right)\cdotp\mathbf{w}(h,w)$</p>
<p>抽样函数 $\mathbf{p}$：$Z^2\times Z^2\to Z^2$ 列举了空间位置 $x$ 的邻居的位置。在图像卷积，它也可以表示为 $\mathbf{p}(\mathbf{x},h,w)=\mathbf{x}+\mathbf{p}^{\prime}(h,w)$。权函数 $\mathbf{w}$:$Z^2\to\mathbb{R}^c$ 提供了一个 $c$ 维实空间中的权向量，用于计算与采样的 $c$ 维输入特征向量的内积。注意，权函数与输入位置 $x$ 无关。因此，在输入图像滤波器权重到处都是共享的。</p>
<blockquote>
<p>$\mathbf{p}^{\prime}(h,w)$：映射一个方向访问函数，类似象棋中的[0,-1],[1,0];</p>
<p>抽样函数 $\mathbf{p}$： 就是一个编码的定位函数，映射$x$位置附近的卷积核内对应的位置。</p>
</blockquote>
<p>从二维抽象到三维：<br>通过将上述公式扩展到输入特征映射位于空间图 $V_t$​ 上的情况，来定义图上的卷积操作。即特征映射 $f_{in}^t$​：$V_t​→R^c$ 在图的每个节点上都有一个向量。扩展的下一步是重新定义抽样函数 p 和权重函数 w。</p>
<h4 id="采样函数"><a href="#采样函数" class="headerlink" title="采样函数"></a>采样函数</h4><p>在图像上，采样函数 $\mathbf{p}(h,w)$ 是在相邻像素点关于中心位置 $x$ 上定义的。在图上，我们同样可以在节点 $v_{ti}$​ 的邻居集 $B(v_{ti})=\{v_{tj}|d(v_{tj},v_{ti})\leq D\}$ 上定义采样函数。这里 $d(v_{tj},v_{ti}\mathrm{~})$ 表示从 $v_{tj}$​ 到 $v_{ti}$​ 的任何路径的最小长度。因此，抽样函数 $\mathbf{p}:B(v_{ti})\to V$ 可以写成：<br>$\mathbf{p}(v_{ti},v_{tj})=v_{tj}$</p>
<blockquote>
<p>注意这里的 $v_{tj}$ 是节点 $v_{ti}$ 的邻居集 $B(v_{ti})$ 中的节点，即当 $D=1$ 时，采样函数 $\mathbf{p}$ 取的是邻接点。</p>
</blockquote>
<h4 id="权重函数"><a href="#权重函数" class="headerlink" title="权重函数"></a>权重函数</h4><p>主要是如何定义图的顺序，保证权重可以按顺序对邻接点作用。</p>
<p>将一个关节点 $v_{ti}$ 的邻居集 $B(v_{ti})$ 划分为固定数量的 $K$ 个子集，其中每个子集都有一个数字标签，从 $0$ 到 $K-1$。</p>
<p>映射 $l_{ti}: B(v_{ti} )\to\{0, \ldots, K-1\}$，<br>权重函数 $\mathbf{w}(v_{ti},v_{tj}):B(v_{ti})\to R^c$ 可以通过索引一个 $(c,K)$ 维张量或<br>$\mathbf{w}(v_{ti},v_{tj})=\mathbf{w}^{\prime}(l_{ti}\left(v_{tj}\right))$<br>来实现。</p>
<blockquote>
<p>即相同标签会使用同一个权重，保持权重函数不变，拓展到每个节点</p>
</blockquote>
<h4 id="空间图卷积"><a href="#空间图卷积" class="headerlink" title="空间图卷积"></a>空间图卷积</h4><p>有了改进的抽样函数和权函数，我们现在用图卷积重写公式(1)如下：<br>$f_{out}\left(v_{ti}\right)=\sum_{v_{tj}\in B(v_{ti})}\frac1{Z_{ti}\left(v_{tj}\right)}f_{in}\left(\mathbf{p}(v_{ti},v_{tj})\right)\cdotp\mathbf{w}(v_{ti},v_{tj})$其中归一项 $Z_{ti}\left(v_{tj}\right.)=\left|v_{tk}\left|l_{ti}\left(v_{tk}\right.\right)=l_{ti}\left(v_{tj}\right.\right)|$ 等于相应子集的基数。为了平衡不同子集对输出的贡献。</p>
<p>得到<br>$f_{out}\left(v_{ti}\right)=\sum_{v_{tj}\in B\left(v_{ti}\right)}\frac1{Z_{ti}\left(v_{tj}\right)}f_{in}\left(v_{tj}\right)\cdotp\mathbf{w}(l_{ti}\left(v_{tj}\right))$</p>
<h4 id="时空建模"><a href="#时空建模" class="headerlink" title="时空建模"></a>时空建模</h4><p>需要重新定义相邻位置的关系，增加时间相邻点。</p>
<blockquote>
<p>将2D图像增加时间维度，转换为3D图像，应用到图卷积神经网络。</p>
</blockquote>
<p>$B(v_{ti})=\{v_{qj}\left|d(v_{tj},v_{ti})\leq K,\left|q-t\right|\leq\left\lfloor\Gamma/2\right\rfloor\right\}$<br>该公式定义了每个节点的邻域 $B(v_{ti})$ 包括空间距离不超过 $K $个单位的所有节点和时间距离不超过 $\lfloor\Gamma/2\rfloor$ 个单位的所有节点。其中，参数 $\Gamma$ 控制时间上要包含在邻域图中的范围，因此可以称为时间内核大小。</p>
<p>重新修改映射标签：$l_{ST}\left(v_{qj}\right)=l_{ti}\left(v_{tj}\right)+\left(q-t+\left\lfloor\Gamma/2\right\rfloor\right)\times K$<br>其中 $l_{ti}\left(v_{tj}\right)$ 是在一个单帧 $t$ 上关节 $i$ 的邻接点 $j$ 的标签映射，而 $(q-t+\lfloor\Gamma/2\rfloor)\times K$ 用于在时间维度上对标签进行编码。</p>
<blockquote>
<p>对时间的前后正负，转移到正数轴上，乘$K$，将所有的数据转移到一维数组内的顺序。可以通过每一个下标，定位到第几个节点的第几个时间帧内。</p>
</blockquote>
<h3 id="分区策略"><a href="#分区策略" class="headerlink" title="分区策略"></a>分区策略</h3><p>标签映射：将相邻的接点映射到标签内。<br>标签划分：如何确定接点的属于哪个标签。</p>
<img src="/2024/09/13/10-54-10/2cd7d888fa671be10bd482949b831e2d.png" class>
<p><img src="/2024/09/13/10-54-10/2cd7d888fa671be10bd482949b831e2d.png" alt></p>
<p>上图是构造卷积运算的划分策略。从左到右：</p>
<p>（a）输入骨架示例帧。身体关节用蓝点绘制。D=1 的过滤器的接受域用红色虚线圈绘制。<br>（b）单标签分区策略，即一个邻域内的所有节点都有相同的标签(绿色)。<br>（c）距离分区策略，这两个子集是距离为0的根节点本身(绿色)和距离为1的其他相邻点(蓝色)。<br>（d）空间结构分区策略，节点根据与骨架重心(黑色十字)的距离与根节点(绿色)的距离进行标记，向心节点的距离较短(蓝色)，而离心节点的距离较长(黄色)。</p>
<p>相同标签的子集，使用相同的权重。</p>
<h4 id="Uni-labeling-单标签分区策略"><a href="#Uni-labeling-单标签分区策略" class="headerlink" title="Uni-labeling 单标签分区策略"></a>Uni-labeling 单标签分区策略</h4><p>所有节点一个标签，只有一种权重。</p>
<h4 id="istance-partitioning-距离分区策略"><a href="#istance-partitioning-距离分区策略" class="headerlink" title="istance partitioning 距离分区策略"></a>istance partitioning 距离分区策略</h4><p>$D$ = 1,的情况下，只有两种权重，分为两个子集。</p>
<h4 id="Spatial-configuration-partitioning-空间结构分区策略"><a href="#Spatial-configuration-partitioning-空间结构分区策略" class="headerlink" title="Spatial configuration partitioning 空间结构分区策略"></a>Spatial configuration partitioning 空间结构分区策略</h4><p>将邻居集分为三个子集：1)根节点本身；2)向心群：比根节点更接近骨架重心的相邻节点；3)否则为离心群。</p>
<p>\begin{split}<br>l_{ti}\left(v_{tj}\right)=<br>\begin{cases}<br>0, &amp; r_j=r_i \\<br>1, &amp; r_j &lt; r_i \\<br>2, &amp; r_j &gt; r_i<br>\end{cases}<br>\end{split}</p>
<p>其中 $r_i$​ 是训练集中所有帧中从重心到关节 $i$ 的平均距离。</p>
<blockquote>
<p>会不会出现三种标签，只有两种：如端节点</p>
</blockquote>
<h3 id="可学习边缘重要性加权"><a href="#可学习边缘重要性加权" class="headerlink" title="可学习边缘重要性加权"></a>可学习边缘重要性加权</h3><p>我们在时空图卷积的每一层上都加上一个可学习的掩码 $M$。<br>掩码将根据 $E_s$​ 中每个空间图边的学习重要性权重，将节点的特征贡献扩展到其邻近节点。</p>
<p><strong>作者认为未来改进方向</strong></p>
<ul>
<li>也可以使用一个依赖于数据的注意力图，来提升空间特征的贡献扩展效果。</li>
</ul>
<h2 id="实现-ST-GCN"><a href="#实现-ST-GCN" class="headerlink" title="实现 ST-GCN"></a>实现 ST-GCN</h2><p>我们采用类似于(Kipf和Welling 2017)中的图卷积实现。单帧内关节的体内连接由表示自连接的邻接矩阵 $A$ 和单位矩阵 $I$ 表示。<br>在单帧情况下，采用第一个分区策略的 ST-GCN 可以用以下公式实现<br> $\mathbf{f}_{out}=\mathbf{\Lambda}^{ {-\frac{1}{2}} }(\mathbf{A}+\mathbf{I})\mathbf{\Lambda}^{ {-\frac{1}{2}} }\mathbf{f}_{in}\mathbf{W}$<br>解释：</p>
<ul>
<li>$\mathbf{f}_{out}$: 输入特征矩阵,每行对应一个节点的特征向量,是一个行向量，具有多个特征。</li>
<li>$\mathbf{\Lambda}$: 度矩阵</li>
<li>$\mathbf{\Lambda}^{ {-\frac{1}{2}} }$: 平方根的倒数，用于归一化</li>
<li>$\mathbf{A}$: 邻接矩阵, 行$i$是出发点，列$j$是连接点</li>
<li>$\mathbf{I}$: 单位矩阵，表示自环</li>
</ul>
<h3 id="公式计算过程"><a href="#公式计算过程" class="headerlink" title="公式计算过程"></a>公式计算过程</h3><ul>
<li>自环矩阵：$\tilde{\mathbf{A}}=\mathbf{A}+\mathbf{I}$</li>
<li>对称归一化：$\tilde{\mathbf{A}}_{\mathrm{norm}}=\Lambda^{-\frac12}\tilde{\mathbf{A}}\Lambda^{-\frac12}$<br>保持了数值的稳定性，防止特征信息在传播中过度缩放。<br>过程：<ol>
<li>先右乘$\Lambda^{-\frac12}$：对每个达到节点的邻接节点进行缩放,高度节点，影响被缩小了。</li>
<li>再左乘$\Lambda^{-\frac12}$：对出发节点的邻接节点进行缩放，保持传播平衡，避免单向影响。即添加了信息回传的平衡。</li>
</ol>
</li>
<li>输入特征与邻接矩阵传播: $\tilde{\mathbf{A}}_{\mathrm{norm}}\mathbf{f}_{\mathrm{in}}$每个节点将从它的邻居节点中接收特征并进行聚合。<br>过程：<br>\begin{split}<br>\mathbf{f}_{\mathrm{in}}=\begin{bmatrix}\mathbf{f}_1 \\<br>\mathbf{f}_2 \\<br>\vdots \\<br>\mathbf{f}_N\end{bmatrix}\in\mathbb{R}^{N\times F_{\mathrm{in} } }<br>\end{split}<ul>
<li>特征传播公式：$\mathbf{f}_{\mathrm{prop}}=\mathbf{Af}_{\mathrm{in}}$</li>
<li>对于每个节点$i$，它的新特征$\mathbf{f}_{i,\mathrm{prop}}$，可以表示为：$\mathbf{f}_{i,\mathrm{prop}}=\sum_{j\in\mathcal{N}(i)}A_{ij}\mathbf{f}_j$<br>其中，$\mathcal{N}(i)$: 表示$i$的所有邻接节点</li>
<li>节点$i$的新特征向量是其所有邻居节点特征向量的加权和</li>
</ul>
</li>
<li></li>
</ul>
<ul>
<li>假设$N$个节点，$d_{in}$维的输入特征: $\tilde{\mathbf{A}}_{\mathrm{norm}}f_{\mathrm{in}}$<br>表示将邻居节点的信息通过归一化邻接矩阵传播给每个节点。每个节点的新特征是根据其相邻节点的特征进行加权求和</li>
</ul>
<blockquote>
<p>使用自连接矩阵，是为了用邻接矩阵算度？</p>
</blockquote>
<p> 其中$\Lambda^{ii}=\sum_j(A^{ij}+I^{ij})$，</p>
<h1 id="代码复现"><a href="#代码复现" class="headerlink" title="代码复现"></a>代码复现</h1><h2 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">usage: main.py recognition [-h] [-w WORK_DIR] [-c CONFIG] [--phase PHASE] [--save_result SAVE_RESULT] [--start_epoch START_EPOCH] [--num_epoch NUM_EPOCH]</span><br><span class="line">                           [--use_gpu USE_GPU] [--device DEVICE [DEVICE ...]] [--log_interval LOG_INTERVAL] [--save_interval SAVE_INTERVAL]</span><br><span class="line">                           [--eval_interval EVAL_INTERVAL] [--save_log SAVE_LOG] [--print_log PRINT_LOG] [--pavi_log PAVI_LOG] [--feeder FEEDER]</span><br><span class="line">                           [--num_worker NUM_WORKER] [--train_feeder_args TRAIN_FEEDER_ARGS] [--test_feeder_args TEST_FEEDER_ARGS] [--batch_size BATCH_SIZE]</span><br><span class="line">                           [--test_batch_size TEST_BATCH_SIZE] [--debug] [--model MODEL] [--model_args MODEL_ARGS] [--weights WEIGHTS]</span><br><span class="line">                           [--ignore_weights IGNORE_WEIGHTS [IGNORE_WEIGHTS ...]] [--show_topk SHOW_TOPK [SHOW_TOPK ...]] [--base_lr BASE_LR]</span><br><span class="line">                           [--step STEP [STEP ...]] [--optimizer OPTIMIZER] [--nesterov NESTEROV] [--weight_decay WEIGHT_DECAY]</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --help            show this help message and exit</span><br><span class="line">  -w WORK_DIR, --work_dir WORK_DIR</span><br><span class="line">                        the work folder for storing results</span><br><span class="line">  -c CONFIG, --config CONFIG</span><br><span class="line">                        path to the configuration file</span><br><span class="line">  --phase PHASE         must be train or test</span><br><span class="line">  --save_result SAVE_RESULT</span><br><span class="line">                        if ture, the output of the model will be stored</span><br><span class="line">  --start_epoch START_EPOCH</span><br><span class="line">                        start training from which epoch</span><br><span class="line">  --num_epoch NUM_EPOCH</span><br><span class="line">                        stop training in which epoch</span><br><span class="line">  --use_gpu USE_GPU     use GPUs or not</span><br><span class="line">  --device DEVICE [DEVICE ...]</span><br><span class="line">                        the indexes of GPUs for training or testing</span><br><span class="line">  --log_interval LOG_INTERVAL</span><br><span class="line">                        the interval for printing messages (#iteration)</span><br><span class="line">  --save_interval SAVE_INTERVAL</span><br><span class="line">                        the interval for storing models (#iteration)</span><br><span class="line">  --eval_interval EVAL_INTERVAL</span><br><span class="line">                        the interval for evaluating models (#iteration)</span><br><span class="line">  --save_log SAVE_LOG   save logging or not</span><br><span class="line">  --print_log PRINT_LOG</span><br><span class="line">                        print logging or not</span><br><span class="line">  --pavi_log PAVI_LOG   logging on pavi or not</span><br><span class="line">  --feeder FEEDER       data loader will be used</span><br><span class="line">  --num_worker NUM_WORKER</span><br><span class="line">                        the number of worker per gpu for data loader</span><br><span class="line">  --train_feeder_args TRAIN_FEEDER_ARGS</span><br><span class="line">                        the arguments of data loader for training</span><br><span class="line">  --test_feeder_args TEST_FEEDER_ARGS</span><br><span class="line">                        the arguments of data loader for test</span><br><span class="line">  --batch_size BATCH_SIZE</span><br><span class="line">                        training batch size</span><br><span class="line">  --test_batch_size TEST_BATCH_SIZE</span><br><span class="line">                        test batch size</span><br><span class="line">  --debug               less data, faster loading</span><br><span class="line">  --model MODEL         the model will be used</span><br><span class="line">  --model_args MODEL_ARGS</span><br><span class="line">                        the arguments of model</span><br><span class="line">  --weights WEIGHTS     the weights for network initialization</span><br><span class="line">  --ignore_weights IGNORE_WEIGHTS [IGNORE_WEIGHTS ...]</span><br><span class="line">                        the name of weights which will be ignored in the initialization</span><br><span class="line">  --show_topk SHOW_TOPK [SHOW_TOPK ...]</span><br><span class="line">                        which Top K accuracy will be shown</span><br><span class="line">  --base_lr BASE_LR     initial learning rate</span><br><span class="line">  --step STEP [STEP ...]</span><br><span class="line">                        the epoch where optimizer reduce the learning rate</span><br><span class="line">  --optimizer OPTIMIZER</span><br><span class="line">                        type of optimizer</span><br><span class="line">  --nesterov NESTEROV   use nesterov or not</span><br><span class="line">  --weight_decay WEIGHT_DECAY</span><br><span class="line">                        weight decay for optimizer</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>测试命令：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./bin/python main.py recognition --phase test --work_dir ./work_dir/recognition/kinetics_skeleton --config ./config/kinetics.yaml --weights ./models/model.pth --test_batch_size 64 --device 0 --save_result True</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./bin/python3.8 main.py recognition -c config/st_gcn/kinetics-skeleton/test.yaml</span><br></pre></td></tr></table></figure>
<p> -训练命令<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./bin/python3.8 main.py recognition -c config/st_gcn/kinetics-skeleton/train.yaml</span><br></pre></td></tr></table></figure></p>
<p>测试命令<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./bin/python3.8 main.py recognition -c config/st_gcn/kinetics-skeleton/test.yaml --weights ./models/st_gcn.kinetics.pt</span><br></pre></td></tr></table></figure></p>
<h2 id="调整参数文件"><a href="#调整参数文件" class="headerlink" title="调整参数文件"></a>调整参数文件</h2><h3 id="train-yaml"><a href="#train-yaml" class="headerlink" title="train.yaml"></a>train.yaml</h3><ul>
<li>feeder 通常是指数据加载器（Data Feeder）</li>
</ul>
<ul>
<li>修改config文件夹内的，train.yaml，设置显卡编号为单显卡。</li>
<li>减少batch_size = 128</li>
</ul>
<h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><p><a href="https://arxiv.org/pdf/1801.07455.pdf">论文地址</a><br><a href="https://github.com/yysijie/st-gcn">论文代码</a></p>
<p><a href="https://blog.csdn.net/xiaoyuting999/article/details/130039164?spm=1001.2014.3001.5506">论文解读</a></p>
]]></content>
      <categories>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>深度学习, 计算机视觉</tag>
      </tags>
  </entry>
  <entry>
    <title>GNN 图神经网络</title>
    <url>/2024/09/13/09-59-13/</url>
    <content><![CDATA[<p>博客链接：<a href="https://distill.pub/2021/gnn-intro/">GNN博客</a></p>
<h1 id="图是什么"><a href="#图是什么" class="headerlink" title="图是什么?"></a>图是什么?</h1><p>实体（顶点 node）之间的关系（边 edge）。A graph represents the relations (edges) between a colelction of entities(nodes). </p>
<img src="/2024/09/13/09-59-13/ef7de1a9117a2b8046f5962c517559369153e850.png@620w_!web-note.png" class>
<p>Q2: attributes in V E U 重要吗？</p>
<p>！关心图的整个架构</p>
<p>！更关心 每个顶点、每条边、和 整个图表示的信息</p>
<p>Q3: attribute 如何表示呢？</p>
<img src="/2024/09/13/09-59-13/49dd0d770ef736cee57d5d85b15e28e8dc1785df.png@620w_!web-note.png" class>
<p>Q4：数据如何表示成图？</p>
<p>图片如何表示成图？</p>
<p> 244 <em> 244 </em> 3通道，3维度的tensor</p>
<p>把图片看作一张图，一个像素是一个点；一个像素跟我是连接关系的话，像素之间连一条边。</p>
<img src="/2024/09/13/09-59-13/909d5904a2de4cc989ee7760cafe4143fcfd0f91.png@620w_!web-note.png" class>
<p>把图片上的像素 映射到 图上的每一个点</p>
<p>0-0 2-2</p>
<img src="/2024/09/13/09-59-13/74a28726ded8422863321b9a13f283272cd11c3e.png@620w_!web-note.png" class>
<p>蓝色点 表示 adjacent matrix，白色点表示无连接；通常是很大的sparse matrix</p>
<h2 id="什么可以表示为图"><a href="#什么可以表示为图" class="headerlink" title="什么可以表示为图"></a>什么可以表示为图</h2><p>文本的顺序：图的有向路</p>
<p>Q5：除了图片、文本，还有什么数据可以表示成图？</p>
<p>香料分子图、咖啡因的分子图、社交网络图、引用图(directed)</p>
<h2 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h2><p>图有几类信息需要表示？</p>
<p>nodes V, edges E, global-context U and connectivity</p>
<p>V E U 可以用 vector 表示，问题是 connectivity 如何表示？by adjacent matrix? </p>
<p>Q6：n * n 的 0-1 元素矩阵 表示 connectivity 可以吗？</p>
<p>矩阵很大，i.e., wikipedia数据集，12M nodes，矩阵会有12M行、12M列，无法存储。<br>边通常是稀疏的，存储 sparse matrix ✔；但稀疏矩阵在GPU上的高效运算，难❌<br>邻接矩阵的 行、列顺序交换，不会影响图</p>
<h1 id="图神经网络"><a href="#图神经网络" class="headerlink" title="图神经网络"></a>图神经网络</h1><p>输入一个高效存储、顺序无关的 Nodes, Edges, Adjacency List, Global 信息，如何用 NN 处理呢？—— Graph Neural Networks</p>
<h2 id="图神经网络的定义"><a href="#图神经网络的定义" class="headerlink" title="图神经网络的定义"></a>图神经网络的定义</h2><p>A GNN is  an optimizable transformation on all attributes of the graph (nodes, edges, global-contex ) that preserves graph symmetries (permuation invariance).</p>
<p>图上属性的 可以优化的变化，且保持图的对称信息。</p>
<p>对 attributes 进行变换时，图的结构不变化</p>
<p>Un 全局向量, Vn 顶点向量, En 边向量 分别构造一个MLP, MLP的输入输出的大小一致。</p>
<p>3个MLP f_Un, f_Vn, f_En 组成一个 GNN 的层。</p>
<p>graph-in, graph out</p>
<p>MLP f_Un, f_Vn, f_En  分别对输入的 Un 全局向量, Vn 顶点向量, En 边向量 计算，得到更新 Un+1 全局向量, Vn+1 顶点向量, En+1 边向量 。</p>
<img src="/2024/09/13/09-59-13/58b51ce69eb62a7a67d381ab5d1fe9e3989de776.png@620w_!web-note.png" class>
<h2 id="GNN-predictions-by-pooling-information"><a href="#GNN-predictions-by-pooling-information" class="headerlink" title="GNN predictions by pooling information"></a>GNN predictions by pooling information</h2><p>最后一层的输出，怎么得到预测值？</p>
<p>simplest: nodes prediction 顶点预测</p>
<p>分类预测: i.e., 空手道俱乐部喜欢 A 老师还是 B 老师</p>
<p>和 NN 类似，node embeddings 向量 接入 输出维度为 2 or n 的全连接层 + 一个 softmax，得到分类结果；输出维度为 1，得到回归结果。</p>
<p>最后一层的顶点进入 图中的 C_V_{i,n} classification 全连接网络，得到顶点的分类。</p>
<img src="/2024/09/13/09-59-13/3222c2a50c031b6fe61c40eea4cb6a85a552c347.png@620w_!web-note.png" class>
<p>Note: 所有顶点共享一个全连接层 C_V_{i,n} 的参数。</p>
<p>GNN 之前的层，不论图有多大，一层里面只有 3 个MLP</p>
<ul>
<li>所有顶点共享一个 MLP</li>
<li>所有边共享一个 MLP</li>
<li>所有的全局 U（哈哈哈，全局只有一个）不用共享。</li>
</ul>
<p><strong>complex: node predictions without node embeddings</strong></p>
<p>对某个顶点分类预测，但是没有这个顶点的向量。</p>
<p>pooling 汇聚 （似 CNN 的 pooling）</p>
<p>与缺失点连接的边的向量 4个 + 全局向量 1 个 == 代表这个缺失点的向量，再做一个全连接层的预测输出。</p>
<p>假设：所有顶点、边、全局向量的维度一致；不一致，需要做投影。</p>
<img src="/2024/09/13/09-59-13/71411099ddffd12967a5d1255744c79cf70bbd72.png@620w_!web-note.png" class>
<p>别的缺失点，连接关系不一样，最后的向量也不一样。</p>
<img src="/2024/09/13/09-59-13/83d55b86bb0e6bd45f2992eddd76b16659f7cab1.png@620w_!web-note.png" class>
<p>V_n 是只有边、没有顶点的向量</p>
<p>E_n 是边的向量</p>
<p>Rho_{E_n —&gt; V_n} 通过 pooling 汇聚从 边 +全局 到 顶点的信息， 进入顶点共享的分类层 C_V_n 之前，每个顶点都有自己的向量 embedding</p>
<p>Q: 只有 node embeddings 没有 边的向量，怎么办？</p>
<p>Rho_{V_n —&gt; E_n} 把 node embeddings 汇聚到 vertex 边上。</p>
<p>一条边，连接两个顶点，2个顶点向量相加 （+ 全局向量）== 得到 边的向量，然后进入边共享的一个 MLP 预测分类网络，得到边的预测输出。</p>
<p>Q: 没有全局向量 U, 有 node embeddings, 对整个图做预测？</p>
<img src="/2024/09/13/09-59-13/83d32576fb6bd47389a7892c2a77125e5f00686a.png@620w_!web-note.png" class>
<p>把所有的 node embeddings 加起来，得到一个全局的向量，进入全局的MLP，得到一个全局的预测输出。</p>
<p><strong>总结：不论缺少哪一类 V E U attributes，pooling 汇聚得到缺失值 embeddings，进入MLP，得到预测值。</strong></p>
<h2 id="最简单的-GNN-示意图"><a href="#最简单的-GNN-示意图" class="headerlink" title="最简单的 GNN 示意图"></a>最简单的 GNN 示意图</h2><p>input graph 经过 GNN blocks （每一个 block 里面有 3个 MLP对 V顶点 E边 U全局 attributes 更新）得到 一个同结构的 transformed graph, 但 V E U 属性值已被更新。</p>
<p>(if 某类 embeddings 缺失，通过其它 embeddings pooling 汇聚而来)</p>
<p>最后根据 V E U 某类属性做预测，接一个 MLP classification layer 输出预测信息。</p>
<img src="/2024/09/13/09-59-13/QQ20240913-103019.png" class>
<p>Q: simplest GNN 有什么问题？</p>
<p>GNN blocks 没有使用图结构信息：使用 MLP 更新属性值时，没有看到 V 顶点 E 边 的交互信息，只是 V 进 MLP_V, E 进 MLP_E, U 进 MLP_U，忽略了点边之间的连接信息。</p>
<p>overlook information: 一个顶点与哪些边相连，一个顶点与哪些顶点相连；一条边与哪些顶点相连，一条边与哪些边相连</p>
<p>GNN blocks 没有合理的将整个图的信息更新到属性值里，最后的结果不能 leverage 图的信息。</p>
<p>Q: 如何改进 GNN blocks 以考虑图的结构信息？</p>
<p>信息传递<br>Passing messages between parts of the graph</p>
<p>类似 pooling 汇聚<br>顶点的向量和邻居的向量相加，进行MLP变换。</p>
<p>对图中顶点进行更新，<br><img src="/2024/09/13/09-59-13/QQ20240913-103203.png" class></p>
<p>和卷积的不同，卷积的核权重每一个都不一样，GNN权重都是一样的，直接相加。</p>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>GNN 对超参数比较敏感：</p>
<p>多少层、attribute的embedding的维度、汇聚使用什么操作max average、怎样传递消息</p>
<h2 id="相关技术"><a href="#相关技术" class="headerlink" title="相关技术"></a>相关技术</h2><h3 id="除-GNN-外，还有别的图吗？"><a href="#除-GNN-外，还有别的图吗？" class="headerlink" title="除 GNN 外，还有别的图吗？"></a>除 GNN 外，还有别的图吗？</h3><p>Multigraph</p>
<p>一张图中的多种边：有向边、无向边；分层图，一些顶点是子图的<br><img src="/2024/09/13/09-59-13/QQ20240913-103857.png" class></p>
<p>不同的图结构 影响 message passing 的操作</p>
<h3 id="Sampling-graphs-and-batching-in-GNNs"><a href="#Sampling-graphs-and-batching-in-GNNs" class="headerlink" title="Sampling graphs and batching in GNNs"></a>Sampling graphs and batching in GNNs</h3><p>Why sample graphs？</p>
<p>i.e., 一个有很多层、很大的图</p>
<p>最后一层的顶点，即使只看每一层的一阶邻居，根据消息传递，最后一层的顶点能看到一个很大的图，甚至是全图的信息（如果图的connectivity可以的话）</p>
<p>计算梯度需要 forward 过程中全部的中间变量。因为最后一层的顶点要看整个图的话，对最后一层的顶点计算梯度，需要把整个图的计算中间结果都保存下来，—&gt; 计算难 /(ㄒoㄒ)/~~ </p>
<p>—&gt; sample graph   采样</p>
<blockquote>
<p>类似候选框</p>
</blockquote>
<h3 id="sample-graph-的方法有哪些呢？"><a href="#sample-graph-的方法有哪些呢？" class="headerlink" title="sample graph 的方法有哪些呢？"></a>sample graph 的方法有哪些呢？</h3><ol>
<li>random node sampling</li>
</ol>
<p>采样 4 个黄色nodes，得到 1-degree neighbor 红色点<br>只在 sample 出来的子图上做计算，避免图特别大、内存存不了<br><img src="/2024/09/13/09-59-13/QQ20240913-104144.png" class></p>
<ol>
<li>random walk sampling </li>
</ol>
<p>随机游走<br>从某一个顶点开始，随机找一条边，然后沿着这条边走到下一个节点<br>规定最多随机走多少步，得到一个sample子图<br><img src="/2024/09/13/09-59-13/QQ20240913-104206.png" class></p>
<ol>
<li>1 + 2 </li>
</ol>
<p>随机走三步，走到的节点的邻居也考虑进来<br><img src="/2024/09/13/09-59-13/QQ20240913-104231.png" class></p>
<ol>
<li>BFS</li>
</ol>
<p>取一个点及其一阶、二阶邻居，然后再往前走 k 步，得到子图<br><img src="/2024/09/13/09-59-13/QQ20240913-104255.png" class></p>
<p><strong>4 种 sample graphs 的方法取决于数据集的形式</strong></p>
<h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h2><p>卷积神经网络：假设空间变换不变性<br>循环神经网络：假设时序延续性<br>图神经网络：假设保持图的对称性：不管怎么交换顶点顺序，GNN的作用都不变。</p>
<p>GCN:图卷积神经网络，图神经网络做了汇聚操作。</p>
]]></content>
      <categories>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>深度学习, 计算机视觉</tag>
      </tags>
  </entry>
  <entry>
    <title>知乎科研文章相关笔记内容</title>
    <url>/2024/09/12/07-50-15/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="4b27b049f44f82420410efd1d6eb3ed1a27b16aafcdabd27197be814961f1bef">1cc37a9b4bf89818b07fff6360960bb856aa952e31d1416348243144b6168bb97db31266016472ea51d1450c29453439db12fd10139d9ddb97f0fa6cdb024b3f3ad25622d403a26dd0b1aaaabca523613ec1ab28ea0bc6329a75c5e4df68fa80f7ec8a54197dd06e7b9f4416830c8c9383f21ccab4d39faea68a088c3d120425e329aa791a1af121f531429cc0243a151588fc59984d5546079cd71bbcc0079067ca86de50d3c420b4ac594e2f1e905677a94347eca95380d5a7fafb96e8ae93cd465e4342994823b9c5d5ba026331d7bdc9466c2556230b5849126560fa1df50c2a9a245b16c94daa7b16eb048f0540c0bd16c60cdae7f843a0899af96d4571fc2e645e83f2e7d835c608bfc967d17b44310e40f90398bc6894c48019dd2cb877a057810e2a40a0a9e89f794d5d412ae904994cb6baa4c1ab198325b5766e316cc831a2d9525f036381522f7ff4687d8639ac276a6b6c599fde4157c2d02ac24d9123dc83d41b0259cd30cbb68b309551e8b93757cc86040abb0ceff528d6d7de8d593a4d53a2607e64c4b68836aa15a04f404dcdfbe9308dd56466d47db3e08c0d75ea8fe816133a20a18350ef7d91d2b8a315b51999a524d3972f62e24a90f6c055d9b70b9e19a599d2bda4f2ffd285da2f96a982c58f0e5966c9c91f78357167563e7cbfe60301ac70aac73ad7a21a8bd30d4141b353f37bf8e29625a4a196b6b3fc847ad5d01dd151cd4f0b75cec7b7dd49905865997775cee3623b6493f59910b4d17c7a4d07fd611b67ecd1b021d85ad9f9296c1d40065c67ac66d9980b78214c16e964752a6ae050de907992ebc051036c1b007d9a24f3d18d1d30cda8be16bd5a2870077fc26a84cb54c9769160a36bc43fb583e99a9ee37748b7819a2b97ea0a08e376a9b8c312cd33e60a5ddb143cb7938e5211dce27d1af7cc40b610224a35d107c814015241b21e941999854449c52ac8edc2c8824aa600a3f91d40b91aa6238937b9e3939ccbce1cb345c103f5e2c0c86e114b354582bcb6ee4fe4b5a07fd15377b4d1d699b036a209aa662b33f24b658338a1a52e38df8ea5661ef53474a0c02c12a5db9229a39f03f089bf28a6bad9a1de5efa3255c0407c94ebce4575f218ff61005f063a27f4bcea1e6b0ff1f6c76eaebf4419f9b5feeee7be04709656629e749d30e2fad2348f8c6506325ceb8da0f527bfe4bd55782aadda08c08857da599ce8fbcd546f3d6162cd5e8b5283830b015a94100a9e647f0e4ee65f436ed5571cee33ca440964641b0c4c906b2d28d8297a7b33f660c6f6ad622216832db91de9f6328b40ad3ac3671bfaf045ee3785720ad0187d834b07a4ebcc55aea088abdbf04e3f40485def5a4e66433983d9f3b985a46166b6fed04c00b59efea3ddd740960263f965c48d3d52ff58c3015929188aac44c83a33c49fd6480af8df6904be175f7a5ddf71f23f51fcbf3434fcee70f956badaf6dc295f26c3b1f626b9db3b338d10b16cd8089a3792cb60003f6a1f4bf66a8f09b10ded1c759a5ab0c758e344dc2081d23127ae3d8c4dd669d655f4adf23b38b57600a1314ca4d48a654481ac2c6145365939d299b731d30287ba3f1c7aeb60a33e4ad53baaa189c811da499cd4c2ae09ec9aa019f03a2fd77a09491797b7f632fa41f47f9b547485870152319db170910c1d3943dc09569aeefa91c507788278adab5ce0ba1d2f3dc1b4f5e09c67320b102159b573146998232eafaca597778848324ca8444b673bab3b4835930f0d3f12e5b8a73d3aa4965d2d25c5fee33e8d2178bf7bf10852ba4134e1011a0d109c7e664827a9feb32a681d8aa50e14cc23cd74</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>草稿</category>
      </categories>
  </entry>
  <entry>
    <title>研一课程笔记内容</title>
    <url>/2024/09/12/07-49-36/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="60960eb93b50c4c142a0845b25538996c28ffe0c3a85755aa8a72e1ccab20082">1cc37a9b4bf89818b07fff6360960bb856aa952e31d1416348243144b6168bb9be55c914eb9242e24784d27713704de0d78d52714faaad71383ea2ab6ebc02035524d20fe21718414dc59f03136ffd9d4cc9ebab281d0e5511768aaf09274e8ccec4d536140a138621bbdb7a55d3f929b9963535e52b364ae95b3168cec4edc43acdcb56e54cbff2e843939bc4737d2e6ec64f3ff16a958d181bfcb0a0bc45cb3e3b2d5a471acd50c5e7659f6c519311693cdb2ebebf795ee102cb6915da3dd1b6dc880dc2ba924c3d469da3fc2187f022e8e6b1742a95ec2cee454c696f73309e370ebf20d41ebcdd0a7929d4763836a44fff2a6ecd23b7af275e1e14c5a1093dbf4e7a55841f7a6e4c5a1baae012674c8d53433190a003eb7d94c3603143d9296c60e70a6d9b6031988930c240a57aa83dede712da6fa4733800bee5aa210b42646a1e8bb319bd54517b48dfcff78666c45d7ea5cea4f7a0e44be20e470cd94e4315a95e7c57f742cbd47ebb468e5910c6dd47363fbb3828bafeb1f72ecf9e07efec2cd816b3661bd0a516564134c410cf72d9107fcc904f9a88a5288408decfb5d9b4eead58e90763f4352291eb181ee6a601d37eb9a97bb8ab1cab79629d5f2a79afa2422597c6d884fd8bd9c2bf3813c9ed64b0bc08d3fd3a7dd0e08fada1911866c561985260e1f57588d9c1d29559c5d26523e678e9da86120c6b3ff5f14c924e2a13854b64f10aea3679b14f3d84fa18881c67113fa6e0b16f46e35bc6c3e152b03f0833449baff778f5788c52df1603317d84f0881e18cacefd6f4ff3b92c9fcdfab7085df8c25eb4eb2ed794bfb39782ad9b6fc53dfd682b056a978ae5b794a59768205e0172364ded3d0b32f4133b087ede81866a30b8969b8caf5bc43c33b27cd7504ff44585bc6bb5131b440c2845cd943dfd131645ac4123a8996ccf4461c6436100442f18348f535a004a62f1a79076815fddf52bd8583ac841535e097fa3d54c237ed3e84092c5eecae3aac8aad37f8a51a2c414dc5226143f5067acb0a6c91430a4066549ee3d27a49e243201b196664af72d4b32d16b75c12217f16557df94dfd20fae2bcfd314ac351565cf0f8c637a45b4b38d40006cf5624c37bc6e042e0169f0960cf486067dece0ceed359399f5abb1cbda6de2d8a34501fffe26482b376f84acd143846acfe2f562eeabc8c30a3c6be0fc729c57d2957ec6f34743b760b8f78fe3ceecba265d3f37bbc2f5b8c90c014f530e57b3e5edc0a7323c85c3adbfa88668d00ea0f8893939514727c30ad919e503d14edf31829bf563a01fed2a6ea88ac64efcd2048da5caab59669ef6257f1b2e0b986ee01e332cb8967ee515ab1f91265c9d898f047cfa1bbfa158ebf288dae92280f78a1476052bf3795ecf58e89f5314679d5a050515bbfdb1af9569d41c72f3c3768677fe0f5174f23b8e43d68cb62a238d1005d48a22302f780665fa0bcee8b7ab0ef168ed8ad73b3a44f022ec01d922ce1672b5aee475583d57ee0943c95f5c8e9b9dfc811b66f8488584fcc9195a9448c1ce32aab1d08bcd17b5831952ef1cafa755f954ecc5a7df1d6e2d5b0035981b5894d24534a99fe5a91ed7215c50e12974d9e187e2658a607c7f6171806b021ddb0a18bfdd780ef36bf226f409345d4103cffe1769a42b540a87cc2c8c96261792647fafe2f2ea9014a849440a47c51d2ea21c2cd656a65db3ef0968e0df277ce3738d4e4a9817d3d7175a501e4e3408a1dc6df00bc3904cdf91848d6f112c422a397034ebcc0fc85e654ebf11517d6beda134d64a2d78394e33850d49ec590a89e1d5837cb02543432bf3d7d2bc67dd454d3d62f0ea6a14837a117808feb7f90485ca72f266a8772d82e0b6176cc0aa23d2941823dfc25e408ff203facbe8c1a148b520b3973aace974f476b7d2fb8ccb15f94f7438eaa6297d092e01a4440b693819d679356a28f813187f521ea2202f9e95be6fa6abd24753be75cc54367de42d1d4241c070e016e21eb3880f76de6de7e64d87c2d9485197f6ab258b3b2ce612273176475e20ffe02dab797eb4a630d67c7653ebcb0685e4fe884a13f3a86153c1f72318660283d488cd996da05a4ce42efeb9f86530f74a4e88979e51c5dbf4235a5acbe22ae68064af5b8f472af79b7731649f0c5fa7ce6b31e0242eaac86e756c7c4aa1f8726132b841c11b98c1f7d992673ff4741b94a3e67d8b8b5ff0a097765593c1ec8864cdcec8eb303cb7f56e9fd0c95c02ddde2e654978e978a5b0f6777340ffdaa1ee68888021af223ac65510657270228fa8f0e7c51a0e29c5aaec64d1c675f505b1c2bdc045774f9aeddd453e910e3720ec7893f0340ead85b8e0a9cf5ad26e9a36b88f2c679a46b2f7e5c08f41de1b32658145cb263ffee0a7cb1f9d26e1732ff01acca8b983006d0ac59eb72f8a0deea04f937b875278ba8a27d30a3de0b4f73f513c1bcec27286e43942fe4db8389b1be096c7096d0a996058eda0accb109964648da905b17c374727b9d5235579b13c2653ea519698555f7d8dd1f48bf0868deb00fd0250e30bdc537eab286f29404800f48cab91e7ede1575c1aec7bbef065332d7d057c5d05fd163a0de45d44e02ccd3c207caa3d84412d236837fcd3adfa09ea61afc7daf71dff31c07f97c6852ad5e53bddfebe6f1e14f4980906ccd67c02e07f989661de81c8143e169efcc92a8f4a488a5d713f601efd1a5e491caf67b8748704d2fad1a4613c9567995a31754b45106077b47bfe896011c6518d092534983bdf312b9d38388237e248ed67a45121c573ae083cb9ec73c9aee7112f1b701ce8843d6a0e29cd81c8d1904a0e4d0af6dc84b8b6729d5829c1fab220b907022f151281a472e366059c04726285632d5f2ca6ba8f5d412e07ef39e1b4e303f76489d7d571096bc6a4a8cd2fd50fd7ce524181278c2de60144767a9abada9044144c52dc0e8d1beefe1230efac1fed1f330e1f4626f437195498ef8742aa5ca9a28e44570e97b07cc8d7f06c855a2deed6ff833424ef5ebd5639c731624133b727d09e373846543e788b0178fb0655ff5f3913cea86222cd6921a69d571e42bb59ab1d1661f164436ac6871763af62f8ff713c8a64a69c2293d5d5388d33b0bd191fe526f17ed4eb1d074524f3b29bbdf763911f86b95758961a8a220b4d846ec4c7790b5292000ed879d8faef30c1f2cf19feff694da08789754f39e3abc93481e66df0b257282415bd1181f7c0b5f61f7964537520d0f30a7c84d35c978b2c1c216281cb6783a58f57b8039b915edefd8b278c7911e278630cdda42a97203474455a507541d7d894382de5f1ecd87faf04e89aa49a46651c28bed82e0b2281ced99233fb98a8172f1fe554691b3f4eb7aa1558d333d056d3c442f3cab1c8bcda6537fc6b6603ea87fde955ff84d8c07fd73514842fb8e1755fa88af50df1bc3c7f254f45f5c05361c8f5b7130a28b8f161a57ac732a27bcb7d8a1aed42e532e8d4378128d2eee15f749dee5dbc2410e8287fe6f9d03e651545c2dbde5a8b193297686233e0876582658df656987cc0f018c9cd92081660fb82d6cd195bfb0d9a93308ff9294b4386d8adb8ce93c6dd7c24e2659baca4885f8f328cf23eb5fcd7335a2ed454645842002c7cf434ea7ce898864194a69dd39e7eb1eb0f40f75484c2b5aef05a1cf3d236f5b8c1df7ca22b07f66a665958fe7b266ddd40d3ecd7a927acf524e92e215d0f98d36ad6877aa1a51a1a43a7ba028d1fdee4ffa3429f6f22bfd989f2007cf5005ec0b5f96c8b8cdf9003e111db000c4b61a1b5fa5fc6e0e489584637e64244d46782189e38c4be9e60d9ea61a8804133eb368cf1d0a7e4c28021e253c0144ca737d2e477188cdf459c7959e541e3ae561ff9eb230198c5d004834022d6afcfd4ec0b1785bfa7de09bcc565493c7a97f9923c0e25cf6ad187010a769c5f323b8da4195bcf2206248c81bc29cd511f88a160a8c9a322f4fadefa78a4393f6d33025823a1987b5c8bbd31c7ccb8163fb1ab346acd896609f4e99a70f2259ae2fbf15be3627b1491732fd981b84a5051263b758b5e96af84bc02cd79cfadcb2223c540250de79caca59e563c02cfca0aa6b8ea52c4aad00f994d8cc975ca46b91e109371106c442053a3207722f5ac7414bed4ebfd6ac86676b0ed50d45d5de35a626a48263a808b38a7260ae03b60a27b0357674b8ce17e9668aa0b97de9d21dfec78b98d54a2c27bd86e642f854f01a87172647da1a620f2fe7e89c14738855058f0fbaacfaab1376dd0897ebb700f19405cc7344517f71069daf3d9987372a55b80a2c4cb92f09afbc598991b26539bd1900c998f68ca93b98af53fd0fcd8af8420c3d8b5d176d3e91ac580e3b9c3110a2d6c7e1e8fff9074780014119d2d9f4d13518929cfb3ec5a9f927e1df810fc0b29c849cb98914135093a64f7ed5634bb21b2df2382a86f7171dca5792741a00d6d9c998bd9ceffc24571d9</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>草稿-</category>
      </categories>
  </entry>
  <entry>
    <title>R-C3D-高效实时的3D活动检测网络</title>
    <url>/2024/09/12/07-46-49/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>时序动作预测</category>
      </categories>
      <tags>
        <tag>论文阅读, 视频检测, TAL</tag>
      </tags>
  </entry>
  <entry>
    <title>docker常用命令以及pycharm连接服务器</title>
    <url>/2024/09/11/18-31-30/</url>
    <content><![CDATA[<h1 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h1><p>新建容器远程连接服务器的命令:</p>
<h2 id="1：新建容器"><a href="#1：新建容器" class="headerlink" title="1：新建容器"></a>1：新建容器</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker run -p 5592:5592 -p 5593:5593 -p 8022:22 --name=&quot;yaoLinux&quot; -v ~/yao/share:/root/share -it --gpus all  nvidia/cuda:12.4.1-cudnn-devel-ubuntu22.04 /bin/bash</span><br></pre></td></tr></table></figure>
<blockquote>
<p>sudo docker run -p 5592:5592 -p 5593:5593 -p 8022:22 —name=”pytorch” -v ~/yao/share:/root/share -it —gpus all —shm-size=64g  image_py38torch:latest /bin/bash</p>
</blockquote>
<p>参数说明：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-it -i参数表示让容器的标准输入保持打开，-t参数表示为容器分配一个伪终端</span><br><span class="line"></span><br><span class="line">--gpus all 与宿主机共享gpu, 要在docker里面使用显卡，务必加上该参数</span><br><span class="line"></span><br><span class="line">--network host 共享ip</span><br><span class="line"></span><br><span class="line">-v /tmp/.X11-unix:/tmp/.X11-unix --env=&quot;DISPLAY=$DISPLAY&quot; 可视化参数 共享窗口</span><br><span class="line"></span><br><span class="line"> -v ~/yao/share:/root/share 文件夹映射 宿主机目录:docker目录, 如果不存在目录会自动新建</span><br><span class="line"></span><br><span class="line">--name  给容器命名，以便后续使用该容器, 自定义</span><br></pre></td></tr></table></figure></p>
<h3 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h3><p>1.查看下载好的镜像<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker images</span><br></pre></td></tr></table></figure><br>2.容器相关命令<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在宿主机终端下运行下面代码，查看容器list</span></span><br><span class="line">sudo docker ps -a</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> 停止容器 name可以换成<span class="built_in">id</span></span></span><br><span class="line">sudo docker stop $&#123;container_name&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> 启动容器</span></span><br><span class="line">sudo docker start $&#123;container_name&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> 重启容器</span> </span><br><span class="line">sudo docker restart $&#123;container_name&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除容器</span>  </span><br><span class="line">sudo docker rm  $&#123;container_name&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-进入容器"><a href="#2-进入容器" class="headerlink" title="2: 进入容器"></a>2: 进入容器</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1 起宿主机新终端，将bev容器处于up状态, 状态可以用sudo docker ps -a查看</span></span><br><span class="line">sudo docker restart bev</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2 在宿主机新起一个终端，运行,运行这个必须保证bev处于up状态</span></span><br><span class="line">sudo docker exec -it bev /bin/bash</span><br></pre></td></tr></table></figure>
<h2 id="3-容器内换源"><a href="#3-容器内换源" class="headerlink" title="3: 容器内换源"></a>3: 容器内换源</h2><p><strong>需要更换相同版本的源</strong><br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm /etc/apt/sources.list</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>echo按个写入，没有vim命令<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;deb http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse&quot; &gt;&gt; /etc/apt/sources.list</span><br><span class="line">echo &quot;deb-src http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse&quot; &gt;&gt; /etc/apt/sources.list</span><br><span class="line">echo &quot;deb http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse&quot; &gt;&gt; /etc/apt/sources.list</span><br><span class="line">echo &quot;deb-src http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse&quot; &gt;&gt; /etc/apt/sources.list</span><br><span class="line">echo &quot;deb http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse&quot; &gt;&gt; /etc/apt/sources.list</span><br><span class="line">echo &quot;deb-src http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse&quot; &gt;&gt; /etc/apt/sources.list</span><br><span class="line">echo &quot;deb http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse&quot; &gt;&gt; /etc/apt/sources.list</span><br><span class="line">echo &quot;deb-src http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse&quot; &gt;&gt; /etc/apt/sources.list</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#  更新apt源</span><br><span class="line">apt update</span><br><span class="line"></span><br><span class="line">&gt; 如果更新失败，源有问题，按照ubuntu版本重新更换源</span><br><span class="line"></span><br><span class="line">#  下载基本的包</span><br><span class="line">apt install sudo vim wget git -y</span><br></pre></td></tr></table></figure></p>
<h1 id="安装中文环境"><a href="#安装中文环境" class="headerlink" title="安装中文环境"></a>安装中文环境</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#直接安装中文语言包</span><br><span class="line">apt-get install -y language-pack-zh-hans</span><br><span class="line"></span><br><span class="line"># 写入 bash.bashrc 文件</span><br><span class="line">echo -e &quot;\n# chinese zh_CN.UTF-8&quot; &gt;&gt; /etc/bash.bashrc</span><br><span class="line">echo -e &quot;export LANG=\&quot;zh_CN.UTF-8\&quot;&quot; &gt;&gt; /etc/bash.bashrc</span><br><span class="line">echo -e &quot;export LANGUAGE=\&quot;zh_CN.UTF-8\&quot;&quot; &gt;&gt; /etc/bash.bashrc</span><br><span class="line">echo -e &quot;export LC_ALL=\&quot;zh_CN.UTF-8\&quot;&quot; &gt;&gt; /etc/bash.bashrc</span><br><span class="line"></span><br><span class="line"># 写入 profile 文件</span><br><span class="line"></span><br><span class="line">echo -e &quot;\n# chinese zh_CN.UTF-8&quot; &gt;&gt; /etc/profile</span><br><span class="line">echo -e &quot;export LANG=\&quot;zh_CN.UTF-8\&quot;&quot; &gt;&gt; /profile</span><br><span class="line">echo -e &quot;export LANGUAGE=\&quot;zh_CN.UTF-8\&quot;&quot; &gt;&gt; /etc/profile</span><br><span class="line">echo -e &quot;export LC_ALL=\&quot;zh_CN.UTF-8\&quot;&quot; &gt;&gt; /etc/profile</span><br></pre></td></tr></table></figure>
<h2 id="4-配置SSH服务"><a href="#4-配置SSH服务" class="headerlink" title="4: 配置SSH服务"></a>4: 配置SSH服务</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt install -y openssh-server</span><br></pre></td></tr></table></figure>
<p>然后建立一个配置文件夹并进行必要的配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> mkdir /var/run/sshd</span><br><span class="line"> echo &#x27;root:passwd&#x27; | chpasswd</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">passwd 为自己的密码</span></span><br><span class="line"> sed &#x27;s@session\s*required\s*pam_loginuid.so@session optional pam_loginuid.so@g&#x27; -i /etc/pam.d/sshd</span><br><span class="line"> echo &quot;export VISIBLE=now&quot; &gt;&gt; /etc/profile</span><br></pre></td></tr></table></figure>
<p>修改配置文件：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/ssh/sshd_config</span><br><span class="line"># 解注释 PermitRootLogin yes</span><br><span class="line"># 解注释 PubkeyAuthentication  yes  改为no</span><br><span class="line"># 解注释 PasswordAuthentication yes</span><br></pre></td></tr></table></figure></p>
<p>重启SSH激活配置<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service ssh restart</span><br></pre></td></tr></table></figure></p>
<h3 id="注"><a href="#注" class="headerlink" title="注"></a>注</h3><p>测试端口是否转发成功<br>在宿主机中<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo docker port [your_container_name] 22</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果前面的配置生效了，你会看到如下输出</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">0.0.0.0:8022</span></span><br></pre></td></tr></table></figure></p>
<p>测试ssh连接docker<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh root@[your_host_ip] -p 8022</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">密码是前面设置的</span></span><br></pre></td></tr></table></figure></p>
<h2 id="5-本机PyCharm里配置部署环境"><a href="#5-本机PyCharm里配置部署环境" class="headerlink" title="5: 本机PyCharm里配置部署环境"></a>5: 本机PyCharm里配置部署环境</h2><h3 id="python-版本"><a href="#python-版本" class="headerlink" title="python 版本"></a>python 版本</h3><blockquote>
<p>容器和宿主机的文件是隔离的，容器中安装的环境，在宿主机内无法访问文件，只能通过相同的文件映射地址，管理这个地址下的文件。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查询python版本</span></span><br><span class="line">python3 -V</span><br><span class="line">wthic python</span><br></pre></td></tr></table></figure>
<p>更换python版本的步骤<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">安装必要依赖</span></span><br><span class="line">apt-get install -y software-properties-common</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">添加deadsnakes PPA：</span></span><br><span class="line">add-apt-repository ppa:deadsnakes/ppa</span><br><span class="line"></span><br><span class="line">apt-get update</span><br><span class="line">apt-get install -y python3.8 python3.8-distutils</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置python命令指向Python 3.8：</span></span><br><span class="line">update-alternatives --install /usr/bin/python python /usr/bin/python3.8 1</span><br><span class="line">update-alternatives --config python</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>打开PyCharmTools &gt; Deployment &gt; Configuration, 新建一个SFTP服务器，名字自己取：</p>
<p>注意这里的端口是你刚刚设置的映射到容器22端口的宿主机中的端口，8022，，Root Path设置一个远程docker容器里的路径:<br>“位置” 指的是你的项目文件在远程服务器（Docker 容器）中的存放路径。</p>
<p>基础解释器：选择docker中的python，位置为<code>usr/bin/</code>，与服务器是相互隔离的。</p>
<p>选择继承全局站点：可以避免重复安装torch之类的包。</p>
<p>最后在Mappings中配置路径，这里的路径是你本地存放代码的路径，与刚刚配置的Root Path相互映射（意思是Mapping里本机的路径映射到远程的Root Path），方便以后在本地和远程docker中进行代码和其他文件同步。</p>
<h2 id="6：-在PyCharm里配置远程解释器"><a href="#6：-在PyCharm里配置远程解释器" class="headerlink" title="6： 在PyCharm里配置远程解释器"></a>6： 在PyCharm里配置远程解释器</h2><p>点击PyCharm &gt; Setting &gt; Project &gt; Project Interpreter &gt; Add Interpreter<br>新增SSH，端口8022</p>
<h3 id="远程安装pycharm软件包"><a href="#远程安装pycharm软件包" class="headerlink" title="远程安装pycharm软件包"></a>远程安装pycharm软件包</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure>
<blockquote>
<p>pip python 解释器目录错误<br><code>vi pip</code><br>第一行修改为真正的目录地址</p>
</blockquote>
<h3 id="部署时，同步省略bin和lib文件"><a href="#部署时，同步省略bin和lib文件" class="headerlink" title="部署时，同步省略bin和lib文件"></a>部署时，同步省略bin和lib文件</h3><p>在设置，部署中选择文件夹省略。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具, 深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>行为识别基础模型总结</title>
    <url>/2024/08/08/07-02-12/</url>
    <content><![CDATA[<h1 id="深度学习方法"><a href="#深度学习方法" class="headerlink" title="深度学习方法"></a>深度学习方法</h1><h2 id="Two-Stream-NIPS2014"><a href="#Two-Stream-NIPS2014" class="headerlink" title="Two-Stream(NIPS2014)"></a>Two-Stream(NIPS2014)</h2><p>Two-Stream Convolutional Networks for Action Recognition in Videos (NIPS 2014)<br>视频理解的开山之作</p>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://mna12478.github.io/action_3/">mna12478-论文阅读笔记</a><br><a href="https://www.bilibili.com/video/BV1mq4y1x7RU/?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=9a9f9a00848a88972d0fcfd341e9e738">李沐老师论文解读</a><br><a href="https://blog.csdn.net/ybacm/article/details/125300863">ybacm-论文阅读笔记</a></p>
<h2 id="SCNN"><a href="#SCNN" class="headerlink" title="SCNN"></a>SCNN</h2><h3 id="代码复现"><a href="#代码复现" class="headerlink" title="代码复现"></a>代码复现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//挂载google硬盘</span></span><br><span class="line">from google.colab import drive</span><br><span class="line">drive.mount(<span class="string">&#x27;/content/drive/&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>配置环境：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">!apt-get update</span><br><span class="line">!apt-get install -y --no-install-recommends \</span><br><span class="line">    build-essential \</span><br><span class="line">    cmake \</span><br><span class="line">    git \</span><br><span class="line">    libgoogle-glog-dev \</span><br><span class="line">    libgflags-dev \</span><br><span class="line">    libprotobuf-dev \</span><br><span class="line">    protobuf-compiler \</span><br><span class="line">    libhdf5-dev \</span><br><span class="line">    libleveldb-dev \</span><br><span class="line">    liblmdb-dev \</span><br><span class="line">    libsnappy-dev \</span><br><span class="line">    libopencv-dev \</span><br><span class="line">    libopenblas-dev \</span><br><span class="line">    libatlas-base-dev \</span><br><span class="line">    libboost-all-dev \</span><br><span class="line">    libgflags-dev \</span><br><span class="line">    libgoogle-glog-dev \</span><br><span class="line">    liblmdb-dev \</span><br><span class="line">    python3-dev \</span><br><span class="line">    python3-numpy \</span><br><span class="line">    python3-pip</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul>
<li><a href="https://www.ee.columbia.edu/ln/dvmm/researchProjects/cdc/scnn.html">作者博文</a></li>
<li><a href="https://www.youtube.com/watch?v=2JwRX3umGKE">作者汇报</a></li>
</ul>
<h1 id="经典方法"><a href="#经典方法" class="headerlink" title="经典方法"></a>经典方法</h1><h2 id="iDT算法"><a href="#iDT算法" class="headerlink" title="iDT算法"></a>iDT算法</h2><p><a href="https://github.com/PKunicor/improved_trajectory_code">improved_trajectory_code仓库</a></p>
<p>来源：<a href="https://blog.csdn.net/qq_21872981/article/details/106936451">行为识别基础模型总结</a></p>
]]></content>
      <categories>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>论文阅读, 计算机视觉, 行为识别</tag>
      </tags>
  </entry>
  <entry>
    <title>Dense trajectories and motion boundary descriptors for action recognition - 密集轨迹DT算法</title>
    <url>/2024/07/22/12-24-41/</url>
    <content><![CDATA[<p>论文：Dense trajectories and motion boundary descriptors for action recognition</p>
<h1 id="密集轨迹算法（DT算法）"><a href="#密集轨迹算法（DT算法）" class="headerlink" title="密集轨迹算法（DT算法）"></a>密集轨迹算法（DT算法）</h1><p>1.1算法基本框架</p>
<p>如图所示即为算法的基本框架，包括密集采样特征点，特征点轨迹跟踪和基于轨迹的特征提取几个部分。后续的特征编码和分类过程则没有在图中画出。下面分别介绍一下这几个部分：</p>
<p>密集采样特征点：<br>DT方法通过网格划分的方式在图片的多个尺度上分别密集采样特征点。在多个空间尺度上采样能保证采样的特征点覆盖了所有空间位置和尺度，通常8个空间尺度已经非常足够了，若图像很大，可以适当增加。后续的特征提取也是在各个尺度上分别进行的。特征点采样的间隔（即网格的大小）W根据经验通常取W=5（其实W=5是可以通用的一个比较好的值）。</p>
<p>由于下一步的目标是在时间序列上跟踪这些特征点，但在没有任何结构的均匀区域（比如一块白色墙壁中间的点，或者一件黑色大衣中的点）中跟踪特征点是无法实现的。因此在进行特征点跟踪前要先去除一些这样的特征点。</p>
<p>此处的方法是计算每个像素点自相关矩阵的特征值，并设置阈值去除低于阈值的特征点。阈值由下式决定，式中0.001是经验值，(λ1i,λ2i)是图像I中像素点<br>i 的特征值：</p>
<p>应用上式，下图即为密集采样的一个示例效果图片，可以看出，同质区域的大部分采样点已被删除。</p>
<p>特征点轨迹跟踪：<br>得到了密集采样后的特征点，现在我们要对这些点进行跟踪得到轨迹，对轨迹的追踪是通过光流。设上一步中密集采样到的某个特征点的坐标为Pt=(xt,yt),则我们用下式来计算该特征点在下一帧图像中的位置，这样该点在后续连续帧的位置连起来就形成了一个轨迹。</p>
<p>式中ωt=(ut,vt)为密集光流场，是由It和It+1计算得到的，u和v分别代表光流的水平和垂直分量。而M则代表中值滤波器，尺寸为3*3。也就是说该式是通过计算特征点邻域内的光流中值来得到特征点的运动方向的。</p>
<p>另外作者提到，由于特征点的跟踪得到的轨迹随着时间会存在漂移现象，也就是从初始位置移动到很远的地方，故长时间的跟踪是不可靠的，所以每L帧要重新密集采样一次特征点，重新进行跟踪。在DT/iDT算法中，选取L=15。这个漂移现象我觉得解释应该是说，跟踪本身就不是绝对的，因为要计算光流场，也取决于中值滤波器的平滑操作，越跟踪，跟踪得到的轨迹可能与原始绝对轨迹之间存在更大误差，进而导致作者所说的长时间的跟踪是不可靠的，需要L帧重新采样一次再跟踪。</p>
<p>对于每个帧，如果在W×W邻域中找不到跟踪点，则会采样一个新点并将其添加到跟踪过程中，以确保轨迹的密集覆盖。至于为什么要在没有跟踪点的W <em> W邻域添加新点然后跟踪它？我认为就是要保证每一帧的W </em> W邻域都要有跟踪点，这样来实现密集轨迹，后续在得到众多轨迹后，会删除静态的轨迹和突出增大位移的轨迹，保留正常轨迹。</p>
<p>轨迹描述子<br>（1）轨迹形状描述子：</p>
<p>轨迹本身也可以构成轨迹形状特征描述子。对于一个长度为L的轨迹，其形状可以用<br>来描述，其中位移矢量ΔPt=(Pt+1−Pt)=<br>。在进行正则化后就可以得到轨迹特征描述子了。正则化方式为：</p>
<p>最终得到的轨迹特征为15*2=30维向量。</p>
<p>除了轨迹形状信息，我们还设计了描述子来嵌入外观 ( appearence ) 和运动 ( Motion ) 信息。</p>
<p>下图展示了HOG/HOF/MBH描述子捕获信息的图示：摄像机从右向左移动，而该人正从摄像机中走开。渐变/流动方向由颜色（色调）和饱和度大小表示。通过光流计算得到的HOF光流信息（第一行第二列这个图），在背景中显示出恒定的运动，（可以看出光流整体向右流动）说明这是由于相机的运动，但是作者觉得还不够完善，因为我们知道有相机的运动，但同时人也在从车里走出，和背景之间本身也会有一个相对运动，为了在一定程度上克服相机运动的影响，我们主要应该看的其实就是背景和前景之间的相对运动，于是作者使用了MBH描述子（不是作者提出的）。运动边界MBH（最右边这一列的两张图）编码人与背景之间的相对运动。</p>
<p>（2）在1.1节中的算法框架中右边就是对轨迹描述子的可视化，包括HOG/HOF/MBH。首先在1.1节这个图中，是在NNL（实验设置N：32像素、L：15帧）的时空体范围内去计算描述子的。而描述子的计算范围是nσ <em> nσ </em> nτ（σ：2 、τ：3）这样一个细分的时空网格。</p>
<h1 id="基础知识-特征描述符"><a href="#基础知识-特征描述符" class="headerlink" title="基础知识-特征描述符"></a>基础知识-特征描述符</h1><h2 id="HOG-histograms-of-oriented-gradients-：方向梯度直方图"><a href="#HOG-histograms-of-oriented-gradients-：方向梯度直方图" class="headerlink" title="HOG (histograms of oriented gradients) ：方向梯度直方图"></a>HOG (histograms of oriented gradients) ：方向梯度直方图</h2><p>目标检测的图像特征提取之（一）HOG特征<br>HOG特征描述子的主要思想是：在一副图像中，局部目标的表象和形状（appearance and shape）能够被梯度或边缘的方向密度分布很好地描述。<br>HOG的实现方法：首先将图像分成小的连通区域，我们把它叫细胞单元cell。然后采集细胞单元中各像素点的梯度的或边缘的方向直方图。最后把这些直方图组合起来就可以构成特征描述器。</p>
<img src="/2024/07/22/12-24-41/v2-db0e86f06f7145d93b56851ea0649562_r.jpg" class>
<p><a href="https://blog.csdn.net/zouxy09/article/details/7929348/">HOG相关链接</a></p>
<h2 id="HOF-histograms-of-optical-flow-：光流直方图。"><a href="#HOF-histograms-of-optical-flow-：光流直方图。" class="headerlink" title="HOF (histograms of optical flow)：光流直方图。"></a>HOF (histograms of optical flow)：光流直方图。</h2><p>同样参考下面这篇博客：HOF特征<br>HOF(Histogramsof Oriented Optical Flow)与HOG类似，是对光流方向进行加权统计，得到光流方向信息直方图。通常用于动作识别中。由于目标的尺寸会随着时间发生变化，相应的光流特征描述子的维度也会变化，同时，光流的计算对背景噪声、尺度变化以及运动方向都较敏感，因此需要寻找一种基于光流的既能表征时域动作信息，又对尺度和运动方向不敏感的特征。HOF则是基于此需求提出来的。</p>
<p>MBH（Motion boundary histograms）：作者认为如果只计算光流信息来描述运动信息的话，光流表示两帧之间的绝对运动，其中包含来自多个来源的运动，即前景对象运动和背景相机运动。 如果将摄影机运动视为动作运动，则可能会破坏动作分类。在真实视频中可以观察到各种类型的相机运动，例如缩放、倾斜、旋转等。在许多情况下，相机运动是局部平移的，并且在图像平面上平滑变化。（这是作者在这篇文章考虑的相机运动情况，被称为DT算法，但是后面作者又提出了改进克服相机运动的考虑，更好的克服了相机运动的影响，因此改进的DT被称为iDT算法。）<br>由于MBH代表光流的梯度，因此去除了局部恒定的摄像机运动，并保留了关于流场变化（即运动边界）的信息。MBH对摄像机运动的鲁棒性比光流更强，因此对动作识别更具辨别力。</p>
<p>小结：DT算法介绍了一种基于密集轨迹和运动边界直方图描述子的高效视频描述方法。<br>解决了上一篇博客的疑问：</p>
<p>如何对输入视频获得密集轨迹：密集采样特征点，通过计算密集光流场对采样得到的特征点进行密集跟踪（同时也解决了另外的一个疑问：为什么在基于时空体方法做车辆异常检测的论文中需要两个输入，一个是stvv时空视频体，一个是对应的光流场？因为得到密集轨迹对它跟踪需要计算密集光流场）<br>对获得的密集轨迹进行外观和运动的描述：HOG、MBH描述子</p>
]]></content>
      <categories>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>论文阅读, 计算机视觉, 行为识别</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机视觉 卷积神经网络</title>
    <url>/2024/05/17/13-57-26/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.05.17：初稿</li>
</ul>
<h2 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h2><ul>
<li><a href="/2024/05/06/10-28-51/" title="eecs498 ML-DL-CV 笔记汇总">计算机视觉-笔记汇总</a>
</li>
</ul>
<p>内容列表：</p>
<ul>
<li><strong>结构概述</strong></li>
<li><p><strong>用来构建卷积神经网络的各种层</strong>  </p>
<ul>
<li>卷积层</li>
<li>汇聚层</li>
<li>归一化层</li>
<li>全连接层</li>
<li>将全连接层转化成卷积层</li>
</ul>
</li>
<li><strong>卷积神经网络的结构</strong><ul>
<li>层的排列规律</li>
<li>层的尺寸设置规律</li>
<li>案例学习（LeNet / AlexNet / ZFNet / GoogLeNet / VGGNet）</li>
<li>计算上的考量</li>
</ul>
</li>
<li><strong>拓展资源</strong></li>
</ul>
<h1 id="卷积神经网络（CNN-ConvNet）"><a href="#卷积神经网络（CNN-ConvNet）" class="headerlink" title="卷积神经网络（CNN / ConvNet）"></a>卷积神经网络（CNN / ConvNet）</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>卷积神经网络和上一章讲的常规神经网络非常相似：它们都是由神经元组成，神经元中有具有学习能力的权重和偏差。每个神经元都得到一些输入数据，进行内积运算后再进行激活函数运算。整个网络依旧是一个可导的评分函数：该函数的输入是原始的图像像素，输出是不同类别的评分。在最后一层（往往是全连接层），网络依旧有一个损失函数（比如SVM或Softmax），并且在神经网络中我们实现的各种技巧和要点依旧适用于卷积神经网络。</p>
<p>那么有哪些地方变化了呢？卷积神经网络的结构基于一个假设，即输入数据是图像，基于该假设，我们就向结构中添加了一些特有的性质。这些特有属性使得前向传播函数实现起来更高效，并且大幅度降低了网络中参数的数量。</p>
<p>或者说，原来的普通神经网络，实际上假设了模式之间不存在结构和交互，然后把图像展开为向量进行输入的，这样就丢失了图像中的空间信息，所以我们需要一种可以采集空间信息的方式 </p>
<h2 id="结构概述"><a href="#结构概述" class="headerlink" title="结构概述"></a>结构概述</h2><p>在上一章中，神经网络的输入是一个向量，然后在一系列的隐藏层中对它做变换。每个隐层都是由若干的神经元组成，每个神经元都与前一层中的所有神经元连接。但是在一个隐层中，神经元相互独立不进行任何连接。最后的全连接层被称为”输出层”，在分类问题中，它输出的值被看做是不同类别的评分值。</p>
<p>_常规神经网络对于大尺寸图像效果不尽人意_。在CIFAR-10中，图像的尺寸是32x32x3（宽高均为32像素，3个颜色通道），因此，对应的的常规神经网络的第一个隐层中，每一个单独的全连接神经元就有32x32x3=3072个权重。这个数量看起来还可以接受，但是很显然这个全连接的结构不适用于更大尺寸的图像。举例说来，一个尺寸为200x200x3的图像，会让神经元包含200x200x3=120,000个权重值。而网络中肯定不止一个神经元，那么参数的量就会快速增加！显而易见，这种全连接方式效率低下，大量的参数也很快会导致网络过拟合。</p>
<p>神经元的三维排列。卷积神经网络针对输入全部是图像的情况，将结构调整得更加合理，获得了不小的优势。与常规神经网络不同，卷积神经网络的各层中的神经元是3维排列的：<strong>宽度</strong>、<strong>高度</strong>和<strong>深度</strong>（这里的<strong>深度</strong>指的是激活数据体的第三个维度，而不是整个网络的深度，整个网络的深度指的是网络的层数）。举个例子，CIFAR-10中的图像是作为卷积神经网络的输入，该数据体的维度是32x32x3（宽度，高度和深度）。我们将看到，层中的神经元将只与前一层中的一小块区域连接，而不是采取全连接方式。对于用来分类CIFAR-10中的图像的卷积网络，其最后的输出层的维度是1x1x10，因为在卷积神经网络结构的最后部分将会把全尺寸的图像压缩为包含分类评分的一个向量，向量是在深度方向排列的。下面是例子：</p>
<img src="/2024/05/17/13-57-26/2ef08bb4cf60805d726b2d6db39dd985_b.jpg" class>
<p>左边是一个3层的神经网络。右边是一个卷积神经网络，图例中网络将它的神经元都排列成3个维度（宽、高和深度）。卷积神经网络的每一层都将3D的输入数据变化为神经元3D的激活数据并输出。在这个例子中，红色的输入层装的是图像，所以它的宽度和高度就是图像的宽度和高度，它的深度是3（代表了红、绿、蓝3种颜色通道）。</p>
<blockquote>
<p>卷积神经网络是由层组成的。每一层都有一个简单的API：用一些含或者不含参数的可导的函数，将输入的3D数据变换为3D的输出数据。</p>
</blockquote>
<h2 id="用来构建卷积网络的各种层"><a href="#用来构建卷积网络的各种层" class="headerlink" title="用来构建卷积网络的各种层"></a>用来构建卷积网络的各种层</h2><p>一个简单的卷积神经网络是由各种层按照顺序排列组成，网络中的每个层使用一个可以微分的函数将激活数据从一个层传递到另一个层。卷积神经网络主要由三种类型的层构成：<strong>卷积层</strong>，<strong>汇聚（Pooling）层</strong>和<strong>全连接层</strong>（全连接层和常规神经网络中的一样）。通过将这些层叠加起来，就可以构建一个完整的卷积神经网络。</p>
<p>网络结构例子：这仅仅是个概述，下面会更详解的介绍细节。一个用于CIFAR-10图像数据分类的卷积神经网络的结构可以是[输入层-卷积层-ReLU层-汇聚层-全连接层]。细节如下：</p>
<ul>
<li>输入[32x32x3]存有图像的原始像素值，本例中图像宽高均为32，有3个颜色通道。  </li>
<li>卷积层中，神经元与输入层中的一个局部区域相连，每个神经元都计算自己与输入层相连的小区域与自己权重的内积<strong>（这个内积作为元素组成下一张特征图，其含义为与模版匹配的程度）</strong>，同时每个卷积核都有一个偏差项。卷积层会计算所有神经元的输出。如果我们使用12个滤波器（也叫作核），得到的输出数据体的维度就是[32x32x12]。  </li>
<li>ReLU层将会逐个元素地进行激活函数操作，比如使用以0为阈值的$max(0,x)$作为激活函数。该层对数据尺寸没有改变，还是[32x32x12]。  </li>
<li>汇聚层在在空间维度（宽度和高度）上进行降采样（downsampling）操作，数据尺寸变为[16x16x12]。  </li>
<li>全连接层将会计算分类评分，数据尺寸变为[1x1x10]，其中10个数字对应的就是CIFAR-10中10个类别的分类评分值。正如其名，全连接层与常规神经网络一样，其中每个神经元都与前一层中所有神经元相连接。</li>
</ul>
<p>由此看来，卷积神经网络一层一层地将图像从原始像素值变换成最终的分类评分值。其中有的层含有参数，有的没有。具体说来，卷积层和全连接层（CONV/FC）对输入执行变换操作的时候，不仅会用到激活函数，还会用到很多参数（神经元的突触权值和偏差）。而ReLU层和汇聚层则是进行一个固定不变的函数操作。卷积层和全连接层中的参数会随着梯度下降被训练，这样卷积神经网络计算出的分类评分就能和训练集中的每个图像的标签吻合了。</p>
<p><strong>小结</strong>：</p>
<ul>
<li>简单案例中卷积神经网络的结构，就是一系列的层将输入数据变换为输出数据（比如分类评分）。  </li>
<li>卷积神经网络结构中有几种不同类型的层（目前最流行的有卷积层、全连接层、ReLU层和汇聚层）。  </li>
<li>每个层的输入是3D数据，然后使用一个可导的函数将其变换为3D的输出数据。  </li>
<li>有的层有参数，有的没有（卷积层和全连接层有，ReLU层和汇聚层没有）。</li>
<li>有的层有额外的超参数，有的没有（卷积层、全连接层和汇聚层有，ReLU层没有）。</li>
</ul>
<img src="/2024/05/17/13-57-26/d9259be829b1cdb3d98a399ebc56defa_b.jpg" class>
<p>一个卷积神经网络的激活输出例子。左边的输入层存有原始图像像素，右边的输出层存有类别分类评分。在处理流程中的每个激活数据体是铺成一列来展示的。因为对3D数据作图比较困难，我们就把每个数据体切成层，然后铺成一列显示。最后一层装的是针对不同类别的分类得分，这里只显示了得分最高的5个评分值和对应的类别。本例中的结构是一个小的VGG网络，VGG网络后面会有讨论。</p>
<p>现在讲解不同的层，层的超参数和连接情况的细节。</p>
<h4 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h4><p>卷积层是构建卷积神经网络的核心层，它产生了网络中大部分的计算量。</p>
<h5 id="卷积操作"><a href="#卷积操作" class="headerlink" title="卷积操作"></a>卷积操作</h5><p>一次卷积操作，示意图如下</p>
<img src="/2024/05/17/13-57-26/15.jpg" class>
<p>我们使用一个卷积核或者过滤器，进行卷积操作，并且将输出结果组成一个特征图，这个过程是线性的，一个核就是一个模板，输出结果就是这块图像与模版的匹配程度</p>
<p>实际上，一个卷积核是不够的，会存在多个卷积核，并且以多维张量的形式表示</p>
<img src="/2024/05/17/13-57-26/17.jpg" class>
<p>这里有六个卷积核，所以卷积核为一个四维张量，每个卷积核大小为3*5*5</p>
<img src="/2024/05/17/13-57-26/23.jpg" class>
<p>如果我们进行多次卷积操作，那么一张3*32*32的图片，经过大小为6*3*5*5的卷积核卷积，就得到六张特征图，大小为6*28*28</p>
<p>但是，我们并不能直接这样操作，因为实际上卷积是线性操作，多个卷积仍然是线性网络，所以我们需要加上激活函数，这样才可以更好的学习</p>
<img src="/2024/05/17/13-57-26/25.jpg" class>
<p>卷积神经网络的核心依然是学习模板，只不过是分层学习，不同层的网络学习不同的模板，第一层学习一些局部的模板（比如说特定边缘），</p>
<p><strong>概述和直观介绍</strong>：首先讨论的是，在没有大脑和生物意义上的神经元之类的比喻下，卷积层到底在计算什么。卷积层的参数是有一些可学习的滤波器集合构成的。每个滤波器在空间上（宽度和高度）都比较小，但是深度和输入数据一致。举例来说，卷积神经网络第一层的一个典型的滤波器的尺寸可以是5x5x3（宽高都是5像素，深度是3是因为图像应为颜色通道，所以有3的深度）。在前向传播的时候，让每个滤波器都在输入数据的宽度和高度上滑动（更精确地说是卷积），然后计算整个滤波器和输入数据任一处的内积。当滤波器沿着输入数据的宽度和高度滑过后，会生成一个2维的激活图（activation map），激活图给出了在每个空间位置处滤波器的反应。直观地来说，网络会让滤波器学习到当它看到某些类型的视觉特征时就激活，具体的视觉特征可能是某些方位上的边界，或者在第一层上某些颜色的斑点，甚至可以是网络更高层上的蜂巢状或者车轮状图案。</p>
<p>在每个卷积层上，我们会有一整个集合的滤波器（比如12个），每个都会生成一个不同的二维激活图。将这些激活映射在深度方向上层叠起来就生成了输出数据。</p>
<p><strong>以大脑做比喻</strong>：如果你喜欢用大脑和生物神经元来做比喻，那么输出的3D数据中的每个数据项可以被看做是神经元的一个输出，而该神经元只观察输入数据中的一小部分，并且和空间上左右两边的所有神经元共享参数（因为这些数字都是使用同一个滤波器得到的结果）。现在开始讨论神经元的连接，它们在空间中的排列，以及它们参数共享的模式。  </p>
<p><strong>局部连接</strong>：在处理图像这样的高维度输入时，让每个神经元都与前一层中的所有神经元进行全连接是不现实的。相反，我们让每个神经元只与输入数据的一个局部区域连接。该连接的空间大小叫做神经元的<strong>感受野（receptive field）</strong>，它的尺寸是一个超参数（其实就是滤波器的空间尺寸）。在深度方向上，这个连接的大小总是和输入量的深度相等。需要再次强调的是，我们对待空间维度（宽和高）与深度维度是不同的：连接在空间（宽高）上是局部的，但是在深度上总是和输入数据的深度一致。</p>
<p>_例1_：假设输入数据体尺寸为[32x32x3]（比如CIFAR-10的RGB图像），如果感受野（或滤波器尺寸）是5x5，那么卷积层中的每个神经元会有输入数据体中[5x5x3]区域的权重，共5x5x3=75个权重（还要加一个偏差参数）。注意这个连接在深度维度上的大小必须为3，和输入数据体的深度一致。</p>
<p>_例2_：假设输入数据体的尺寸是[16x16x20]，感受野尺寸是3x3，那么卷积层中每个神经元和输入数据体就有3x3x20=180个连接。再次提示：在空间上连接是局部的（3x3），但是在深度上是和输入数据体一致的（20）。</p>
<img src="/2024/05/17/13-57-26/ba9dcfa847a71cb695c2653230ea9147_b.jpg" class>
<p><strong>左边</strong>：红色的是输入数据体（比如CIFAR-10中的图像），蓝色的部分是第一个卷积层中的神经元。卷积层中的每个神经元都只是与输入数据体的一个局部在空间上相连，但是与输入数据体的所有深度维度全部相连（所有颜色通道）。在深度方向上有多个神经元（本例中5个），它们都接受输入数据的同一块区域（<strong>感受野</strong>相同）。至于深度列的讨论在下文中有。</p>
<p><strong>右边</strong>：神经网络章节中介绍的神经元保持不变，它们还是计算权重和输入的内积，然后进行激活函数运算，只是它们的连接被限制在一个局部空间。</p>
<p><strong>空间排列</strong>：上文讲解了卷积层中每个神经元与输入数据体之间的连接方式，但是尚未讨论输出数据体中神经元的数量，以及它们的排列方式。3个超参数控制着输出数据体的尺寸：<strong>深度（depth），步长（stride）</strong>和<strong>零填充（zero-padding）</strong>。下面是对它们的讨论：</p>
<ol>
<li>首先，输出数据体的深度是一个超参数：它和使用的滤波器的数量一致，而每个滤波器在输入数据中寻找一些不同的东西。举例来说，如果第一个卷积层的输入是原始图像，那么在深度维度上的不同神经元将可能被不同方向的边界，或者是颜色斑点激活。我们将这些沿着深度方向排列、感受野相同的神经元集合称为<strong>深度列（depth column）</strong>，也有人使用纤维（fibre）来称呼它们。</li>
<li>其次，在滑动滤波器的时候，必须指定步长。当步长为1，滤波器每次移动1个像素。当步长为2（或者不常用的3，或者更多，这些在实际中很少使用），滤波器滑动时每次移动2个像素。这个操作会让输出数据体在空间上变小。</li>
<li>在下文可以看到，有时候将输入数据体用0在边缘处进行填充是很方便的。这个<strong>零填充（zero-padding）</strong>的尺寸是一个超参数。零填充有一个良好性质，即可以控制输出数据体的空间尺寸（最常用的是用来保持输入数据体在空间上的尺寸，这样输入和输出的宽高都相等）。  </li>
</ol>
<p>输出数据体在空间上的尺寸可以通过输入数据体尺寸（W），卷积层中神经元的感受野尺寸（F），步长（S）和零填充的数量（P）的函数来计算。（这里假设输入数组的空间形状是正方形，即高度和宽度相等）输出数据体的空间尺寸为(W-F +2P)/S+1。比如输入是7x7，滤波器是3x3，步长为1，填充为0，那么就能得到一个5x5的输出。如果步长为2，输出就是3x3。下面是例子：</p>
<img src="/2024/05/17/13-57-26/90af0bd67ba498239688c81fd61bbc66_b.jpg" class>
<p>空间排列的图示。在本例中只有一个空间维度（x轴），神经元的感受野尺寸F=3，输入尺寸W=5，零填充P=1。左边：神经元使用的步长S=1，所以输出尺寸是(5-3+2)/1+1=5。右边：神经元的步长S=2，则输出尺寸是(5-3+2)/2+1=3。注意当步长S=3时是无法使用的，因为它无法整齐地穿过数据体。从等式上来说，因为(5-3+2)=4是不能被3整除的。</p>
<p>本例中，神经元的权重是[1,0,-1]，显示在图的右上角，偏差值为0。这些权重是被所有黄色的神经元共享的（参数共享的内容看下文相关内容）。</p>
<h5 id="使用零填充"><a href="#使用零填充" class="headerlink" title="使用零填充"></a>使用零填充</h5><p>在上面左边例子中，注意输入维度是5，输出维度也是5。之所以如此，是因为感受野是3并且使用了1的零填充。如果不使用零填充，则输出数据体的空间维度就只有3，因为这就是滤波器整齐滑过并覆盖原始数据需要的数目。一般说来，当步长$S=1$时，零填充的值是$P=(F-1)/2$，这样就能保证输入和输出数据体有相同的空间尺寸。这样做非常常见，在介绍卷积神经网络的结构的时候我们会详细讨论其原因。  </p>
<p>_步长的限制_：注意这些空间排列的超参数之间是相互限制的。举例说来，当输入尺寸$W=10$，不使用零填充则$P=0$，滤波器尺寸$F=3$，这样步长$S=2$就行不通，因为$(W-F+2P)/S+1=(10-3+0)/2+1=4.5$，结果不是整数，这就是说神经元不能整齐对称地滑过输入数据体。因此，这些超参数的设定就被认为是无效的，一个卷积神经网络库可能会报出一个错误，或者修改零填充值来让设置合理，或者修改输入数据体尺寸来让设置合理，或者其他什么措施。在后面的卷积神经网络结构小节中，读者可以看到合理地设置网络的尺寸让所有的维度都能正常工作，这件事可是相当让人头痛的。而使用零填充和遵守其他一些设计策略将会有效解决这个问题。  </p>
<p>_真实案例_：Krizhevsky构架赢得了2012年的ImageNet挑战，其输入图像的尺寸是[227x227x3]。在第一个卷积层，神经元使用的感受野尺寸$F=11$，步长$S=4$，不使用零填充$P=0$。因为(227-11)/4+1=55，卷积层的深度$K=96$，则卷积层的输出数据体尺寸为[55x55x96]。55x55x96个神经元中，每个都和输入数据体中一个尺寸为[11x11x3]的区域全连接。在深度列上的96个神经元都是与输入数据体中同一个[11x11x3]区域连接，但是权重不同。有一个有趣的细节，在原论文中，说的输入图像尺寸是224x224，这是肯定错误的，因为(224-11)/4+1的结果不是整数。这件事在卷积神经网络的历史上让很多人迷惑，而这个错误到底是怎么发生的没人知道。我的猜测是Alex忘记在论文中指出自己使用了尺寸为3的额外的零填充。  </p>
<p><strong>参数共享</strong>：在卷积层中使用参数共享是用来控制参数的数量。就用上面的例子，在第一个卷积层就有55x55x96=290,400个神经元，每个有11x11x3=364个参数和1个偏差。将这些合起来就是290400x364=105,705,600个参数。单单第一层就有这么多参数，显然这个数目是非常大的。</p>
<p>作一个合理的假设：如果一个特征在计算某个空间位置(x,y)的时候有用，那么它在计算另一个不同位置(x2,y2)的时候也有用。基于这个假设，可以显著地减少参数数量。换言之，就是将深度维度上一个单独的2维切片看做<strong>深度切片（depth slice）</strong>，比如一个数据体尺寸为[55x55x96]的就有96个深度切片，每个尺寸为[55x55]。在每个深度切片上的神经元都使用同样的权重和偏差。在这样的参数共享下，例子中的第一个卷积层就只有96个不同的权重集了，一个权重集对应一个深度切片，共有96x11x11x3=34,848个不同的权重，或34,944个参数（+96个偏差）。在每个深度切片中的55x55个权重使用的都是同样的参数。在反向传播的时候，都要计算每个神经元对它的权重的梯度，但是需要把同一个深度切片上的所有神经元对权重的梯度累加，这样就得到了对共享权重的梯度。这样，每个切片只更新一个权重集。</p>
<p>注意，如果在一个深度切片中的所有权重都使用同一个权重向量，那么卷积层的前向传播在每个深度切片中可以看做是在计算神经元权重和输入数据体的<strong>卷积</strong>（这就是”卷积层”名字由来）。这也是为什么总是将这些权重集合称为<strong>滤波器（filter）</strong>（或<strong>卷积核（kernel）</strong>），因为它们和输入进行了卷积。</p>
<img src="/2024/05/17/13-57-26/dd62e1d75bda9b592dabb91627d68aa6_b.jpg" class>
<p>Krizhevsky等学习到的滤波器例子。这96个滤波器的尺寸都是[11x11x3]，在一个深度切片中，每个滤波器都被55x55个神经元共享。注意参数共享的假设是有道理的：如果在图像某些地方探测到一个水平的边界是很重要的，那么在其他一些地方也会同样是有用的，这是因为图像结构具有平移不变性。所以在卷积层的输出数据体的55x55个不同位置中，就没有必要重新学习去探测一个水平边界了。</p>
<p>注意有时候参数共享假设可能没有意义，特别是当卷积神经网络的输入图像是一些明确的中心结构时候。这时候我们就应该期望在图片的不同位置学习到完全不同的特征。一个具体的例子就是输入图像是人脸，人脸一般都处于图片中心。你可能期望不同的特征，比如眼睛特征或者头发特征可能（也应该）会在图片的不同位置被学习。在这个例子中，通常就放松参数共享的限制，将层称为<strong>局部连接层</strong>（Locally-Connected Layer）。</p>
<p><strong>Numpy例子</strong>：为了让讨论更加的具体，我们用代码来展示上述思路。假设输入数据体是numpy数组<strong>X</strong>。那么：</p>
<ul>
<li>一个位于<strong>(x,y)</strong>的深度列（或纤维）将会是<strong>X[x,y,:]</strong>。  </li>
<li>在深度为<strong>d</strong>处的深度切片，或激活图应该是<strong>X[:,:,d]</strong>。  </li>
</ul>
<p>_卷积层例子_：假设输入数据体<strong>X</strong>的尺寸<strong>X.shape:(11,11,4)</strong>，不使用零填充（$P=0$），滤波器的尺寸是$F=5$，步长$S=2$。那么输出数据体的空间尺寸就是(11-5)/2+1=4，即输出数据体的宽度和高度都是4。那么在输出数据体中的激活映射（称其为<strong>V</strong>）看起来就是下面这样（在这个例子中，只有部分元素被计算）：</p>
<ul>
<li><strong>V[0,0,0] = np.sum(X[:5,:5,:] * W0) + b0  
</strong></li>
<li><strong>V[1,0,0] = np.sum(X[2:7,:5,:] * W0) + b0  
</strong></li>
<li><strong>V[2,0,0] = np.sum(X[4:9,:5,:] * W0) + b0  
</strong></li>
<li><strong>V[3,0,0] = np.sum(X[6:11,:5,:] * W0) + b0</strong>  </li>
</ul>
<p>在numpy中，<strong>*</strong>操作是进行数组间的逐元素相乘。权重向量<strong>W0</strong>是该神经元的权重，<strong>b0</strong>是其偏差。在这里，<strong>W0</strong>被假设尺寸是<strong>W0.shape: (5,5,4)</strong>，因为滤波器的宽高是5，输入数据量的深度是4。注意在每一个点，计算点积的方式和之前的常规神经网络是一样的。同时，计算内积的时候使用的是同一个权重和偏差（因为参数共享），在宽度方向的数字每次上升2（因为步长为2）。要构建输出数据体中的第二张激活图，代码应该是：</p>
<ul>
<li><strong>V[0,0,1] = np.sum(X[:5,:5,:] * W1) + b1  
</strong></li>
<li><strong>V[1,0,1] = np.sum(X[2:7,:5,:] * W1) + b1  
</strong></li>
<li><strong>V[2,0,1] = np.sum(X[4:9,:5,:] * W1) + b1  
</strong></li>
<li><strong>V[3,0,1] = np.sum(X[6:11,:5,:] * W1) + b1</strong>  </li>
<li><strong>V[0,1,1] = np.sum(X[:5,2:7,:] * W1) + b1 </strong>（在y方向上）  </li>
<li><strong>V[2,3,1] = np.sum(X[4:9,6:11,:] * W1) + b1 </strong>（或两个方向上同时）</li>
</ul>
<p>我们访问的是<strong>V</strong>的深度维度上的第二层（即index1），因为是在计算第二个激活图，所以这次试用的参数集就是<strong>W1</strong>了。在上面的例子中，为了简洁略去了卷积层对于输出数组<strong>V</strong>中其他部分的操作。还有，要记得这些卷积操作通常后面接的是ReLU层，对激活图中的每个元素做激活函数运算，这里没有显示。</p>
<p><strong>小结</strong>： 我们总结一下卷积层的性质：</p>
<ul>
<li>输入数据体的尺寸为$W_1times H_1times D_1$</li>
<li>4个超参数：<ul>
<li>滤波器的数量$K$</li>
<li>滤波器的空间尺寸$F$</li>
<li>步长$S$</li>
<li>零填充数量$P$</li>
</ul>
</li>
<li>输出数据体的尺寸为$W_2 \times H_2 \times D_2$ ，其中：<br>$W_2=(W_1-F+2P)/S+1$<ul>
<li>$H_2=(H_1-F+2P)/S+1$ （宽度和高度的计算方法相同）<br>$D_2=K$</li>
</ul>
</li>
<li>由于参数共享，每个滤波器包含$F \cdot F \cdot D_1$个权重，卷积层一共有$F \cdot F \cdot D_1 \cdot K$个权重和$K$个偏置。</li>
<li>在输出数据体中，第$d$个深度切片（空间尺寸是$W_2 \times H_2$），用第$d$个滤波器和输入数据进行有效卷积运算的结果（使用步长$S$），最后在加上第$d$个偏差。</li>
</ul>
<p>对这些超参数，常见的设置是$F=3$，$S=1$，$P=1$。同时设置这些超参数也有一些约定俗成的惯例和经验，可以在下面的卷积神经网络结构章节中查看。</p>
<p>卷积层演示：下面是一个卷积层的运行演示。因为3D数据难以可视化，所以所有的数据（输入数据体是蓝色，权重数据体是红色，输出数据体是绿色）都采取将深度切片按照列的方式排列展现。输入数据体的尺寸是$W_1=5,H_1=5,D_1=3$，卷积层参数$K=2,F=3,S=2,P=1$。就是说，有2个滤波器，滤波器的尺寸是$3 \cdot 3$，它们的步长是2.因此，输出数据体的空间尺寸是(5-3+2)/2+1=3。注意输入数据体使用了零填充$P=1$，所以输入数据体外边缘一圈都是0。下面的例子在绿色的输出激活数据上循环演示，展示了其中每个元素都是先通过蓝色的输入数据和红色的滤波器逐元素相乘，然后求其总和，最后加上偏差得来。  </p>
<img src="/2024/05/17/13-57-26/333077b83ed421d6bd53eb7a44fd5799_b.jpg" class>
<p><strong>用矩阵乘法实现</strong>：卷积运算本质上就是在滤波器和输入数据的局部区域间做点积。卷积层的常用实现方式就是利用这一点，将卷积层的前向传播变成一个巨大的矩阵乘法：</p>
<ol>
<li><p>输入图像的局部区域被<strong>im2col</strong>操作拉伸为列。比如，如果输入是[227x227x3]，要与尺寸为11x11x3的滤波器以步长为4进行卷积，就取输入中的[11x11x3]数据块，然后将其拉伸为长度为11x11x3=363的列向量。重复进行这一过程，因为步长为4，所以输出的宽高为(227-11)/4+1=55，所以得到_im2col_操作的输出矩阵<strong>X_col</strong>的尺寸是[363x3025]，其中每列是拉伸的感受野，共有55x55=3,025个。注意因为感受野之间有重叠，所以输入数据体中的数字在不同的列中可能有重复。  </p>
</li>
<li><p>卷积层的权重也同样被拉伸成行。举例，如果有96个尺寸为[11x11x3]的滤波器，就生成一个矩阵<strong>W_row</strong>，尺寸为[96x363]。  </p>
</li>
<li><p>现在卷积的结果和进行一个大矩阵乘<strong>np.dot(W_row, X_col)</strong>是等价的了，能得到每个滤波器和每个感受野间的点积。在我们的例子中，这个操作的输出是[96x3025]，给出了每个滤波器在每个位置的点积输出。  </p>
</li>
<li><p>结果最后必须被重新变为合理的输出尺寸[55x55x96]。</p>
</li>
</ol>
<p>这个方法的缺点就是占用内存太多，因为在输入数据体中的某些值在<strong>X_col</strong>中被复制了多次。但是，其优点是矩阵乘法有非常多的高效实现方式，我们都可以使用（比如常用的BLAS API）。还有，同样的_im2col_思路可以用在汇聚操作中。</p>
<p>反向传播：卷积操作的反向传播（同时对于数据和权重）还是一个卷积（但是是和空间上翻转的滤波器）。使用一个1维的例子比较容易演示。  </p>
<p><strong>1x1卷积</strong>：一些论文中使用了1x1的卷积，这个方法最早是在论文Network in Network中出现。人们刚开始看见这个1x1卷积的时候比较困惑，尤其是那些具有信号处理专业背景的人。因为信号是2维的，所以1x1卷积就没有意义。但是，在卷积神经网络中不是这样，因为这里是对3个维度进行操作，滤波器和输入数据体的深度是一样的。比如，如果输入是[32x32x3]，那么1x1卷积就是在高效地进行3维点积（因为输入深度是3个通道）。  </p>
<p><strong>扩张卷积</strong>：最近一个研究（Fisher Yu和Vladlen Koltun的论文）给卷积层引入了一个新的叫_扩张（dilation）_的超参数。到目前为止，我们只讨论了卷积层滤波器是连续的情况。但是，让滤波器中元素之间有间隙也是可以的，这就叫做扩张。举例，在某个维度上滤波器<strong>w</strong>的尺寸是3，那么计算输入<strong>x</strong>的方式是：<strong>w[0]<em>x[0] + w[1]</em>x[1] + w[2]*x[2]</strong>，此时扩张为0。如果扩张为1，那么计算为： <strong>w[0]<em>x[0] + w[1]</em>x[2] + w[2]*x[4]</strong>。换句话说，操作中存在1的间隙。在某些设置中，扩张卷积与正常卷积结合起来非常有用，因为在很少的层数内更快地汇集输入图片的大尺度特征。比如，如果上下重叠2个3x3的卷积层，那么第二个卷积层的神经元的感受野是输入数据体中5x5的区域（可以成这些神经元的_有效感受野_是5x5）。如果我们对卷积进行扩张，那么这个有效感受野就会迅速增长。  </p>
<h4 id="汇聚层"><a href="#汇聚层" class="headerlink" title="汇聚层"></a>汇聚层</h4><p>通常，在连续的卷积层之间会周期性地插入一个汇聚层。它的作用是逐渐降低数据体的空间尺寸，这样的话就能减少网络中参数的数量，使得计算资源耗费变少，也能有效控制过拟合。汇聚层使用MAX操作，对输入数据体的每一个深度切片独立进行操作，改变它的空间尺寸。最常见的形式是汇聚层使用尺寸2x2的滤波器，以步长为2来对每个深度切片进行降采样，将其中75%的激活信息都丢掉。每个MAX操作是从4个数字中取最大值（也就是在深度切片中某个2x2的区域）。深度保持不变。汇聚层的一些公式：</p>
<ul>
<li>输入数据体尺寸$W_1 \cdot H_1 \cdot D_1$  </li>
<li><p>有两个超参数：  </p>
<ul>
<li>空间大小$F$</li>
<li>步长$S$</li>
</ul>
</li>
<li><p>输出数据体尺寸$W_2 \cdot H_2 \cdot D_2$，其中<br>$W_2=(W_1-F)/S+1$<br>$H_2=(H_1-F)/S+1$<br>$D_2=D_1$</p>
</li>
<li><p>因为对输入进行的是固定函数计算，所以没有引入参数  </p>
</li>
<li>在汇聚层中很少使用零填充  </li>
</ul>
<p>在实践中，最大汇聚层通常只有两种形式：一种是$F=3,S=2$，也叫重叠汇聚（overlapping pooling），另一个更常用的是$F=2,S=2$。对更大感受野进行汇聚需要的汇聚尺寸也更大，而且往往对网络有破坏性。</p>
<p><strong>普通汇聚（General Pooling）</strong>：除了最大汇聚，汇聚单元还可以使用其他的函数，比如_平均_汇聚_（average pooling）_或_L-2范式_汇聚_（L2-norm pooling）_。平均汇聚历史上比较常用，但是现在已经很少使用了。因为实践证明，最大汇聚的效果比平均汇聚要好。</p>
<img src="/2024/05/17/13-57-26/641c8846abcb02d35938660cf96cef1b_b.jpg" class>
<p>汇聚层在输入数据体的每个深度切片上，独立地对其进行空间上的降采样。左边：本例中，输入数据体尺寸[224x224x64]被降采样到了[112x112x64]，采取的滤波器尺寸是2，步长为2，而深度不变。右边：最常用的降采样操作是取最大值，也就是最大汇聚，这里步长为2，每个取最大值操作是从4个数字中选取（即2x2的方块区域中）。</p>
<p><strong>反向传播：</strong>回顾一下反向传播的内容，其中$max(x,y)$函数的反向传播可以简单理解为将梯度只沿最大的数回传。因此，在向前传播经过汇聚层的时候，通常会把池中最大元素的索引记录下来（有时这个也叫作<strong>道岔（switches）</strong>），这样在反向传播的时候梯度的路由就很高效。</p>
<p><strong>不使用汇聚层</strong>：很多人不喜欢汇聚操作，认为可以不使用它。比如在Striving for Simplicity: The All Convolutional Net一文中，提出使用一种只有重复的卷积层组成的结构，抛弃汇聚层。通过在卷积层中使用更大的步长来降低数据体的尺寸。有发现认为，在训练一个良好的生成模型时，弃用汇聚层也是很重要的。比如变化自编码器（VAEs：variational autoencoders）和生成性对抗网络（GANs：generative adversarial networks）。现在看起来，未来的卷积网络结构中，无汇聚层的结构不太可能扮演重要的角色。</p>
<h4 id="归一化层"><a href="#归一化层" class="headerlink" title="归一化层"></a>归一化层</h4><p>归一化方式的作用，就是使得神经网络更容易训练（或者说可以使得输出具有零均值和单位方差），常见的方式称为批量归一化，即Batch Normalization</p>
<p>这种方式减少了一种称为内部协变偏移的东西，有利于优化</p>
<p>从下图可以看到，加上归一化层之后，更有利于模型收敛</p>
<img src="/2024/05/17/13-57-26/87.jpg" class>
<p>这是因为，每一层看到的都是上一层的输出，但是上一层的权重是会进行学习的，上一次输出的分布也是会改变的，某种意义上不利于优化，所以需要标准化所有层</p>
<p>在卷积神经网络的结构中，提出了很多不同类型的归一化层，有时候是为了实现在生物大脑中观测到的抑制机制。但是这些层渐渐都不再流行，因为实践证明它们的效果即使存在，也是极其有限的。对于不同类型的归一化层，可以看看Alex Krizhevsky的关于cuda-convnet library API的讨论。  </p>
<h4 id="全连接层"><a href="#全连接层" class="headerlink" title="全连接层"></a>全连接层</h4><p>在全连接层中，神经元对于前一层中的所有激活数据是全部连接的，这个常规神经网络中一样。它们的激活可以先用矩阵乘法，再加上偏差。更多细节请查看_神经网络_章节。</p>
<h2 id="把全连接层转化成卷积层"><a href="#把全连接层转化成卷积层" class="headerlink" title="把全连接层转化成卷积层"></a>把全连接层转化成卷积层</h2><p>全连接层和卷积层之间唯一的不同就是卷积层中的神经元只与输入数据中的一个局部区域连接，并且在卷积列中的神经元共享参数。然而在两类层中，神经元都是计算点积，所以它们的函数形式是一样的。因此，将此两者相互转化是可能的：</p>
<ul>
<li>对于任一个卷积层，都存在一个能实现和它一样的前向传播函数的全连接层。权重矩阵是一个巨大的矩阵，除了某些特定块（这是因为有局部连接），其余部分都是零。而在其中大部分块中，元素都是相等的（因为参数共享）。  </li>
<li>相反，任何全连接层都可以被转化为卷积层。比如，一个$K=4096$的全连接层，输入数据体的尺寸是$7 \times 7 \times 512$，这个全连接层可以被等效地看做一个$F=7,P=0,S=1,K=4096$的卷积层。换句话说，就是将滤波器的尺寸设置为和输入数据体的尺寸一致了。因为只有一个单独的深度列覆盖并滑过输入数据体，所以输出将变成$1 \times 1 \times 4096$，这个结果就和使用初始的那个全连接层一样了。  </li>
</ul>
<p><strong>全连接层转化为卷积层</strong>：在两种变换中，将全连接层转化为卷积层在实际运用中更加有用。假设一个卷积神经网络的输入是224x224x3的图像，一系列的卷积层和汇聚层将图像数据变为尺寸为7x7x512的激活数据体（在AlexNet中就是这样，通过使用5个汇聚层来对输入数据进行空间上的降采样，每次尺寸下降一半，所以最终空间尺寸为224/2/2/2/2/2=7）。从这里可以看到，AlexNet使用了两个尺寸为4096的全连接层，最后一个有1000个神经元的全连接层用于计算分类评分。我们可以将这3个全连接层中的任意一个转化为卷积层：  </p>
<ul>
<li>针对第一个连接区域是[7x7x512]的全连接层，令其滤波器尺寸为$F=7$，这样输出数据体就为[1x1x4096]了。  </li>
<li>针对第二个全连接层，令其滤波器尺寸为$F=1$，这样输出数据体为[1x1x4096]。  </li>
<li>对最后一个全连接层也做类似的，令其$F=1$，最终输出为[1x1x1000]  </li>
</ul>
<p>实际操作中，每次这样的变换都需要把全连接层的权重W重塑成卷积层的滤波器。那么这样的转化有什么作用呢？它在下面的情况下可以更高效：让卷积网络在一张更大的输入图片上滑动（_<strong>译者注</strong>：即把一张更大的图片的不同区域都分别带入到卷积网络，得到每个区域的得分_），得到多个输出，这样的转化可以让我们在单个向前传播的过程中完成上述的操作。</p>
<p>举个例子，如果我们想让224x224尺寸的浮窗，以步长为32在384x384的图片上滑动，把每个经停的位置都带入卷积网络，最后得到6x6个位置的类别得分。上述的把全连接层转换成卷积层的做法会更简便。如果224x224的输入图片经过卷积层和汇聚层之后得到了[7x7x512]的数组，那么，384x384的大图片直接经过同样的卷积层和汇聚层之后会得到[12x12x512]的数组（因为途径5个汇聚层，尺寸变为384/2/2/2/2/2 = 12）。然后再经过上面由3个全连接层转化得到的3个卷积层，最终得到[6x6x1000]的输出（因为(12 - 7)/1 + 1 = 6）。这个结果正是浮窗在原图经停的6x6个位置的得分！（_<strong>译者注</strong>：这一段的翻译与原文不同，经过了译者较多的修改，使更容易理解_）</p>
<blockquote>
<p>面对384x384的图像，让（含全连接层）的初始卷积神经网络以32像素的步长独立对图像中的224x224块进行多次评价，其效果和使用把全连接层变换为卷积层后的卷积神经网络进行一次前向传播是一样的。</p>
</blockquote>
<p>自然，相较于使用被转化前的原始卷积神经网络对所有36个位置进行迭代计算，使用转化后的卷积神经网络进行一次前向传播计算要高效得多，因为36次计算都在共享计算资源。这一技巧在实践中经常使用，一次来获得更好的结果。比如，通常将一张图像尺寸变得更大，然后使用变换后的卷积神经网络来对空间上很多不同位置进行评价得到分类评分，然后在求这些分值的平均值。</p>
<p>最后，如果我们想用步长小于32的浮窗怎么办？用多次的向前传播就可以解决。比如我们想用步长为16的浮窗。那么先使用原图在转化后的卷积网络执行向前传播，然后分别沿宽度，沿高度，最后同时沿宽度和高度，把原始图片分别平移16个像素，然后把这些平移之后的图分别带入卷积网络。（_<strong>译者注</strong>：这一段的翻译与原文不同，经过了译者较多的修改，使更容易理解_）</p>
<ul>
<li>Net Surgery上一个使用Caffe演示如何在进行变换的IPython Note教程。  </li>
</ul>
<h3 id="卷积神经网络的结构"><a href="#卷积神经网络的结构" class="headerlink" title="卷积神经网络的结构"></a><strong>卷积神经网络的结构</strong></h3><p>卷积神经网络通常是由三种层构成：卷积层，汇聚层（除非特别说明，一般就是最大值汇聚）和全连接层（简称FC）。ReLU激活函数也应该算是是一层，它逐元素地进行激活函数操作。在本节中将讨论在卷积神经网络中这些层通常是如何组合在一起的。</p>
<h4 id="层的排列规律"><a href="#层的排列规律" class="headerlink" title="层的排列规律"></a>层的排列规律</h4><p>卷积神经网络最常见的形式就是将一些卷积层和ReLU层放在一起，其后紧跟汇聚层，然后重复如此直到图像在空间上被缩小到一个足够小的尺寸，在某个地方过渡成成全连接层也较为常见。最后的全连接层得到输出，比如分类评分等。换句话说，最常见的卷积神经网络结构如下：</p>
<p><strong>INPUT -&gt; [[CONV -&gt; RELU]<em>N -&gt; POOL?]</em>M -&gt; [FC -&gt; RELU]*K -&gt; FC</strong></p>
<p>其中<strong>*</strong>指的是重复次数，<strong>POOL?</strong>指的是一个可选的汇聚层。其中<strong>N &gt;=0</strong>,通常<strong>N&lt;=3</strong>,<strong>M&gt;=0</strong>,<strong>K&gt;=0</strong>,通常<strong>K&lt;3</strong>。例如，下面是一些常见的网络结构规律：</p>
<ul>
<li><strong>INPUT -&gt; FC</strong>,实现一个线性分类器，此处<strong>N = M = K = 0</strong>。  </li>
<li><strong>INPUT -&gt; CONV -&gt; RELU -&gt; FC</strong>  </li>
<li><strong>INPUT -&gt; [CONV -&gt; RELU -&gt; POOL]*2 -&gt; FC -&gt; RELU -&gt; FC</strong>。此处在每个汇聚层之间有一个卷积层。  </li>
<li><strong>INPUT -&gt; [CONV -&gt; RELU -&gt; CONV -&gt; RELU -&gt; POOL]<em>3 -&gt; [FC -&gt; RELU]</em>2 -&gt; FC</strong>。此处每个汇聚层前有两个卷积层，这个思路适用于更大更深的网络，因为在执行具有破坏性的汇聚操作前，多重的卷积层可以从输入数据中学习到更多的复杂特征。  </li>
</ul>
<p>_几个小滤波器卷积层的组合比一个大滤波器卷积层好_：假设你一层一层地重叠了3个3x3的卷积层（层与层之间有非线性激活函数）。在这个排列下，第一个卷积层中的每个神经元都对输入数据体有一个3x3的视野。第二个卷积层上的神经元对第一个卷积层有一个3x3的视野，也就是对输入数据体有5x5的视野。同样，在第三个卷积层上的神经元对第二个卷积层有3x3的视野，也就是对输入数据体有7x7的视野。假设不采用这3个3x3的卷积层，二是使用一个单独的有7x7的感受野的卷积层，那么所有神经元的感受野也是7x7，但是就有一些缺点。首先，多个卷积层与非线性的激活层交替的结构，比单一卷积层的结构更能提取出深层的更好的特征。其次，假设所有的数据有$C$个通道，那么单独的7x7卷积层将会包含$C \times (7 \times 7 \times C)=49C^2$个参数，而3个3x3的卷积层的组合仅有$3 \times (C \times (3 \times 3 \times C))=27C^2$个参数。直观说来，最好选择带有小滤波器的卷积层组合，而不是用一个带有大的滤波器的卷积层。前者可以表达出输入数据中更多个强力特征，使用的参数也更少。唯一的不足是，在进行反向传播时，中间的卷积层可能会导致占用更多的内存。</p>
<p>最新进展：传统的将层按照线性进行排列的方法已经受到了挑战，挑战来自谷歌的Inception结构和微软亚洲研究院的残差网络（Residual Net）结构。这两个网络（下文案例学习小节中有细节）的特征更加复杂，连接结构也不同。</p>
<h4 id="层的尺寸设置规律"><a href="#层的尺寸设置规律" class="headerlink" title="层的尺寸设置规律"></a>层的尺寸设置规律</h4><p>到现在为止，我们都没有提及卷积神经网络中每层的超参数的使用。现在先介绍设置结构尺寸的一般性规则，然后根据这些规则进行讨论：</p>
<p><strong>输入层</strong>（包含图像的）应该能被2整除很多次。常用数字包括32（比如CIFAR-10），64，96（比如STL-10）或224（比如ImageNet卷积神经网络），384和512。</p>
<p><strong>卷积层</strong>应该使用小尺寸滤波器（比如3x3或最多5x5），使用步长$S=1$。还有一点非常重要，就是对输入数据进行零填充，这样卷积层就不会改变输入数据在空间维度上的尺寸。比如，当$F=3$，那就使用$P=1$来保持输入尺寸。当$F=5,P=2$，一般对于任意$F$，当$P=(F-1)/2$的时候能保持输入尺寸。如果必须使用更大的滤波器尺寸（比如7x7之类），通常只用在第一个面对原始图像的卷积层上。</p>
<p><strong>汇聚层</strong>负责对输入数据的空间维度进行降采样。最常用的设置是用用2x2感受野（即$F=2$）的最大值汇聚，步长为2（$S=2$）。注意这一操作将会把输入数据中75%的激活数据丢弃（因为对宽度和高度都进行了2的降采样）。另一个不那么常用的设置是使用3x3的感受野，步长为2。最大值汇聚的感受野尺寸很少有超过3的，因为汇聚操作过于激烈，易造成数据信息丢失，这通常会导致算法性能变差。</p>
<p>_减少尺寸设置的问题_：上文中展示的两种设置是很好的，因为所有的卷积层都能保持其输入数据的空间尺寸，汇聚层只负责对数据体从空间维度进行降采样。如果使用的步长大于1并且不对卷积层的输入数据使用零填充，那么就必须非常仔细地监督输入数据体通过整个卷积神经网络结构的过程，确认所有的步长和滤波器都尺寸互相吻合，卷积神经网络的结构美妙对称地联系在一起。</p>
<p>_为什么在卷积层使用1的步长_？在实际应用中，更小的步长效果更好。上文也已经提过，步长为1可以让空间维度的降采样全部由汇聚层负责，卷积层只负责对输入数据体的深度进行变换。</p>
<p>_为何使用零填充_？使用零填充除了前面提到的可以让卷积层的输出数据保持和输入数据在空间维度的不变，还可以提高算法性能。如果卷积层值进行卷积而不进行零填充，那么数据体的尺寸就会略微减小，那么图像边缘的信息就会过快地损失掉。</p>
<p>_因为内存限制所做的妥协_：在某些案例（尤其是早期的卷积神经网络结构）中，基于前面的各种规则，内存的使用量迅速飙升。例如，使用64个尺寸为3x3的滤波器对224x224x3的图像进行卷积，零填充为1，得到的激活数据体尺寸是[224x224x64]。这个数量就是一千万的激活数据，或者就是72MB的内存（每张图就是这么多，激活函数和梯度都是）。因为GPU通常因为内存导致性能瓶颈，所以做出一些妥协是必须的。在实践中，人们倾向于在网络的第一个卷积层做出妥协。例如，可以妥协可能是在第一个卷积层使用步长为2，尺寸为7x7的滤波器（比如在ZFnet中）。在AlexNet中，滤波器的尺寸的11x11，步长为4。</p>
<h4 id="案例学习"><a href="#案例学习" class="headerlink" title="案例学习"></a>案例学习</h4><p>下面是卷积神经网络领域中比较有名的几种结构：</p>
<ul>
<li><strong>LeNet</strong>： 第一个成功的卷积神经网络应用，是Yann LeCun在上世纪90年代实现的。当然，最著名还是被应用在识别数字和邮政编码等的LeNet结构。</li>
<li><strong>AlexNet</strong>：AlexNet卷积神经网络在计算机视觉领域中受到欢迎，它由Alex Krizhevsky，Ilya Sutskever和Geoff Hinton实现。AlexNet在2012年的ImageNet ILSVRC 竞赛中夺冠，性能远远超出第二名（16%的top5错误率，第二名是26%的top5错误率）。这个网络的结构和LeNet非常类似，但是更深更大，并且使用了层叠的卷积层来获取特征（之前通常是只用一个卷积层并且在其后马上跟着一个汇聚层）。</li>
<li><strong>ZF Net</strong>：Matthew Zeiler和Rob Fergus发明的网络在ILSVRC 2013比赛中夺冠，它被称为 ZFNet（Zeiler &amp; Fergus Net的简称）。它通过修改结构中的超参数来实现对AlexNet的改良，具体说来就是增加了中间卷积层的尺寸，让第一层的步长和滤波器尺寸更小。</li>
<li><strong>GoogLeNet</strong>：ILSVRC 2014的胜利者是谷歌的Szeged等实现的卷积神经网络。它主要的贡献就是实现了一个_奠基模块_，它能够显著地减少网络中参数的数量（AlexNet中有60M，该网络中只有4M）。还有，这个论文中没有使用卷积神经网络顶部使用全连接层，而是使用了一个平均汇聚，把大量不是很重要的参数都去除掉了。GooLeNet还有几种改进的版本，最新的一个是Inception-v4。</li>
<li><strong>VGGNet</strong>：ILSVRC 2014的第二名是Karen Simonyan和 Andrew Zisserman实现的卷积神经网络，现在称其为VGGNet。它主要的贡献是展示出网络的深度是算法优良性能的关键部分。他们最好的网络包含了16个卷积/全连接层。网络的结构非常一致，从头到尾全部使用的是3x3的卷积和2x2的汇聚。他们的预训练模型是可以在网络上获得并在Caffe中使用的。VGGNet不好的一点是它耗费更多计算资源，并且使用了更多的参数，导致更多的内存占用（140M）。其中绝大多数的参数都是来自于第一个全连接层。后来发现这些全连接层即使被去除，对于性能也没有什么影响，这样就显著降低了参数数量。</li>
<li><strong>ResNet</strong>：残差网络（Residual Network）是ILSVRC2015的胜利者，由何恺明等实现。它使用了特殊的_跳跃链接_，大量使用了批量归一化（batch normalization）。这个结构同样在最后没有使用全连接层。读者可以查看何恺明的的演讲，以及一些使用Torch重现网络的实验。ResNet当前最好的卷积神经网络模型（2016年五月）。何开明等最近的工作是对原始结构做一些优化，可以看论文Identity Mappings in Deep Residual Networks，2016年3月发表。</li>
</ul>
<p><strong>VGGNet的细节：</strong>我们进一步对VGGNet的细节进行分析学习。整个VGGNet中的卷积层都是以步长为1进行3x3的卷积，使用了1的零填充，汇聚层都是以步长为2进行了2x2的最大值汇聚。可以写出处理过程中每一步数据体尺寸的变化，然后对数据尺寸和整体权重的数量进行查看：</p>
<p>​<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">INPUT: [224x224x3]        memory:  <span class="number">224</span>*<span class="number">224</span>*<span class="number">3</span>=150K   weights: <span class="number">0</span></span><br><span class="line">CONV3-<span class="number">64</span>: [224x224x64]  memory:  <span class="number">224</span>*<span class="number">224</span>*<span class="number">64</span>=<span class="number">3.2</span>M   weights: (<span class="number">3</span>*<span class="number">3</span>*<span class="number">3</span>)*<span class="number">64</span> = <span class="number">1</span>,<span class="number">728</span></span><br><span class="line">CONV3-<span class="number">64</span>: [224x224x64]  memory:  <span class="number">224</span>*<span class="number">224</span>*<span class="number">64</span>=<span class="number">3.2</span>M   weights: (<span class="number">3</span>*<span class="number">3</span>*<span class="number">64</span>)*<span class="number">64</span> = <span class="number">36</span>,<span class="number">864</span></span><br><span class="line">POOL2: [112x112x64]  memory:  <span class="number">112</span>*<span class="number">112</span>*<span class="number">64</span>=800K   weights: <span class="number">0</span></span><br><span class="line">CONV3-<span class="number">128</span>: [112x112x128]  memory:  <span class="number">112</span>*<span class="number">112</span>*<span class="number">128</span>=<span class="number">1.6</span>M   weights: (<span class="number">3</span>*<span class="number">3</span>*<span class="number">64</span>)*<span class="number">128</span> = <span class="number">73</span>,<span class="number">728</span></span><br><span class="line">CONV3-<span class="number">128</span>: [112x112x128]  memory:  <span class="number">112</span>*<span class="number">112</span>*<span class="number">128</span>=<span class="number">1.6</span>M   weights: (<span class="number">3</span>*<span class="number">3</span>*<span class="number">128</span>)*<span class="number">128</span> = <span class="number">147</span>,<span class="number">456</span></span><br><span class="line">POOL2: [56x56x128]  memory:  <span class="number">56</span>*<span class="number">56</span>*<span class="number">128</span>=400K   weights: <span class="number">0</span></span><br><span class="line">CONV3-<span class="number">256</span>: [56x56x256]  memory:  <span class="number">56</span>*<span class="number">56</span>*<span class="number">256</span>=800K   weights: (<span class="number">3</span>*<span class="number">3</span>*<span class="number">128</span>)*<span class="number">256</span> = <span class="number">294</span>,<span class="number">912</span></span><br><span class="line">CONV3-<span class="number">256</span>: [56x56x256]  memory:  <span class="number">56</span>*<span class="number">56</span>*<span class="number">256</span>=800K   weights: (<span class="number">3</span>*<span class="number">3</span>*<span class="number">256</span>)*<span class="number">256</span> = <span class="number">589</span>,<span class="number">824</span></span><br><span class="line">CONV3-<span class="number">256</span>: [56x56x256]  memory:  <span class="number">56</span>*<span class="number">56</span>*<span class="number">256</span>=800K   weights: (<span class="number">3</span>*<span class="number">3</span>*<span class="number">256</span>)*<span class="number">256</span> = <span class="number">589</span>,<span class="number">824</span></span><br><span class="line">POOL2: [28x28x256]  memory:  <span class="number">28</span>*<span class="number">28</span>*<span class="number">256</span>=200K   weights: <span class="number">0</span></span><br><span class="line">CONV3-<span class="number">512</span>: [28x28x512]  memory:  <span class="number">28</span>*<span class="number">28</span>*<span class="number">512</span>=400K   weights: (<span class="number">3</span>*<span class="number">3</span>*<span class="number">256</span>)*<span class="number">512</span> = <span class="number">1</span>,<span class="number">179</span>,<span class="number">648</span></span><br><span class="line">CONV3-<span class="number">512</span>: [28x28x512]  memory:  <span class="number">28</span>*<span class="number">28</span>*<span class="number">512</span>=400K   weights: (<span class="number">3</span>*<span class="number">3</span>*<span class="number">512</span>)*<span class="number">512</span> = <span class="number">2</span>,<span class="number">359</span>,<span class="number">296</span></span><br><span class="line">CONV3-<span class="number">512</span>: [28x28x512]  memory:  <span class="number">28</span>*<span class="number">28</span>*<span class="number">512</span>=400K   weights: (<span class="number">3</span>*<span class="number">3</span>*<span class="number">512</span>)*<span class="number">512</span> = <span class="number">2</span>,<span class="number">359</span>,<span class="number">296</span></span><br><span class="line">POOL2: [14x14x512]  memory:  <span class="number">14</span>*<span class="number">14</span>*<span class="number">512</span>=100K   weights: <span class="number">0</span></span><br><span class="line">CONV3-<span class="number">512</span>: [14x14x512]  memory:  <span class="number">14</span>*<span class="number">14</span>*<span class="number">512</span>=100K   weights: (<span class="number">3</span>*<span class="number">3</span>*<span class="number">512</span>)*<span class="number">512</span> = <span class="number">2</span>,<span class="number">359</span>,<span class="number">296</span></span><br><span class="line">CONV3-<span class="number">512</span>: [14x14x512]  memory:  <span class="number">14</span>*<span class="number">14</span>*<span class="number">512</span>=100K   weights: (<span class="number">3</span>*<span class="number">3</span>*<span class="number">512</span>)*<span class="number">512</span> = <span class="number">2</span>,<span class="number">359</span>,<span class="number">296</span></span><br><span class="line">CONV3-<span class="number">512</span>: [14x14x512]  memory:  <span class="number">14</span>*<span class="number">14</span>*<span class="number">512</span>=100K   weights: (<span class="number">3</span>*<span class="number">3</span>*<span class="number">512</span>)*<span class="number">512</span> = <span class="number">2</span>,<span class="number">359</span>,<span class="number">296</span></span><br><span class="line">POOL2: [7x7x512]  memory:  <span class="number">7</span>*<span class="number">7</span>*<span class="number">512</span>=25K  weights: <span class="number">0</span></span><br><span class="line">FC: [1x1x4096]  memory:  <span class="number">4096</span>  weights: <span class="number">7</span>*<span class="number">7</span>*<span class="number">512</span>*<span class="number">4096</span> = <span class="number">102</span>,<span class="number">760</span>,<span class="number">448</span></span><br><span class="line">FC: [1x1x4096]  memory:  <span class="number">4096</span>  weights: <span class="number">4096</span>*<span class="number">4096</span> = <span class="number">16</span>,<span class="number">777</span>,<span class="number">216</span></span><br><span class="line">FC: [1x1x1000]  memory:  <span class="number">1000</span> weights: <span class="number">4096</span>*<span class="number">1000</span> = <span class="number">4</span>,096,<span class="number">000</span></span><br><span class="line"></span><br><span class="line">TOTAL memory: 24M * <span class="number">4</span> <span class="built_in">bytes</span> ~= 93MB / image (only forward! ~*<span class="number">2</span> <span class="keyword">for</span> bwd)</span><br><span class="line">TOTAL params: 138M parameters</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>注意，大部分的内存和计算时间都被前面的卷积层占用，大部分的参数都用在后面的全连接层，这在卷积神经网络中是比较常见的。在这个例子中，全部参数有140M，但第一个全连接层就包含了100M的参数。</p>
<h2 id="计算上的考量"><a href="#计算上的考量" class="headerlink" title="计算上的考量"></a>计算上的考量</h2><p>在构建卷积神经网络结构时，最大的瓶颈是内存瓶颈。大部分现代GPU的内存是3/4/6GB，最好的GPU大约有12GB的内存。要注意三种内存占用来源：</p>
<ul>
<li>来自中间数据体尺寸：卷积神经网络中的每一层中都有激活数据体的原始数值，以及损失函数对它们的梯度（和激活数据体尺寸一致）。通常，大部分激活数据都是在网络中靠前的层中（比如第一个卷积层）。在训练时，这些数据需要放在内存中，因为反向传播的时候还会用到。但是在测试时可以聪明点：让网络在测试运行时候每层都只存储当前的激活数据，然后丢弃前面层的激活数据，这样就能减少巨大的激活数据量。  </li>
<li>来自参数尺寸：即整个网络的参数的数量，在反向传播时它们的梯度值，以及使用momentum、Adagrad或RMSProp等方法进行最优化时的每一步计算缓存。因此，存储参数向量的内存通常需要在参数向量的容量基础上乘以3或者更多。  </li>
<li>卷积神经网络实现还有各种零散的内存占用，比如成批的训练数据，扩充的数据等等。  </li>
</ul>
<p>一旦对于所有这些数值的数量有了一个大略估计（包含激活数据，梯度和各种杂项），数量应该转化为以GB为计量单位。把这个值乘以4，得到原始的字节数（因为每个浮点数占用4个字节，如果是双精度浮点数那就是占用8个字节），然后多次除以1024分别得到占用内存的KB，MB，最后是GB计量。如果你的网络工作得不好，一个常用的方法是降低批尺寸（batch size），因为绝大多数的内存都是被激活数据消耗掉了。</p>
]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>计算机视觉, 图像处理, 深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机视觉 反向传播</title>
    <url>/2024/05/17/13-29-46/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.05.17：初稿</li>
</ul>
<h2 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h2><ul>
<li><a href="/2024/05/06/10-28-51/" title="eecs498 ML-DL-CV 笔记汇总">计算机视觉-笔记汇总</a>
</li>
</ul>
<p>内容列表：</p>
<ul>
<li>简介</li>
<li>简单表达式和理解梯度</li>
<li>复合表达式，链式法则，反向传播</li>
<li>直观理解反向传播</li>
<li>模块：Sigmoid例子</li>
<li>反向传播实践：分段计算</li>
<li>回传流中的模式</li>
<li>用户向量化操作的梯度</li>
<li>小结</li>
</ul>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>目标</strong>：本节将帮助读者对<strong>反向传播</strong>形成直观而专业的理解。反向传播是利用<strong>链式法则</strong>递归计算表达式的梯度的方法。理解反向传播过程及其精妙之处，对于理解、实现、设计和调试神经网络非常<strong>关键</strong>。  </p>
<p><strong>问题陈述</strong>：这节的核心问题是：给定函数$f(x)$, 其中$x$是输入数据的向量，需要计算函数$f$关于$x$的梯度，也就是$\nabla f(x)$。</p>
<p><strong>目标</strong>：之所以关注上述问题，是因为在神经网络中$f$对应的是损失函数（$L$），输入$x$里面包含训练数据和神经网络的权重。举个例子，损失函数可以是SVM的损失函数，输入则包含了训练数据$(x_i,y_i),i=1…N$、权重$W$和偏差$b$。注意训练集是给定的（在机器学习中通常都是这样），而权重是可以控制的变量。因此，即使能用反向传播计算输入数据$x_i$ 上的梯度，但在实践为了进行参数更新，通常也只计算参数（比如$W,b$）的梯度。然而$x_i$的梯度有时仍然是有用的：比如将神经网络所做的事情可视化便于直观理解的时候，就能用上。</p>
<p>如果读者之前对于利用链式法则计算偏微分已经很熟练，仍然建议浏览本篇笔记。因为它呈现了一个相对成熟的反向传播视角，在该视角中能看见基于实数值回路的反向传播过程，而对其细节的理解和收获将帮助读者更好地通过本课程。  </p>
<h2 id="简单表达式和理解梯度"><a href="#简单表达式和理解梯度" class="headerlink" title="简单表达式和理解梯度"></a>简单表达式和理解梯度</h2><p>从简单表达式入手可以为复杂表达式打好符号和规则基础。先考虑一个简单的二元乘法函数$f(x,y)=xy$。对两个输入变量分别求偏导数还是很简单的：  </p>
<p>$\displaystyle f(x,y)=xy \to \frac {df}{dx}=y \quad \frac {df}{dy}=x$  </p>
<p><strong>解释</strong>：牢记这些导数的意义：函数变量在某个点周围的极小区域内变化，而导数就是变量变化导致的函数在该方向上的变化率。  </p>
<p>$\displaystyle \frac{df(x)}{dx}= \lim_{h \to 0}\frac{f(x+h)-f(x)}{h}$</p>
<p>注意等号左边的分号和等号右边的分号不同，不是代表分数。相反，这个符号表示操作符$\frac{d}{dx}$被应用于函数$f$，并返回一个不同的函数（导数）。对于上述公式，可以认为$h$值非常小，函数可以被一条直线近似，而导数就是这条直线的斜率。换句话说，每个变量的导数指明了整个表达式对于该变量的值的敏感程度。比如，若$x=4,y=-3$，则$f(x,y)=-12$，$x$的导数$\frac{\partial f}{\partial x}=-3$。这就说明如果将变量$x$的值变大一点，整个表达式的值就会变小（原因在于负号），而且变小的量是$x$变大的量的三倍。通过重新排列公式可以看到这一点（$f(x+h)=f(x)+h \frac{df(x)}{dx}$）。同样，因为$\frac{\partial f}{\partial y}=4$，可以知道如果将$y$的值增加$h$，那么函数的输出也将增加（原因在于正号），且增加量是$4h$。  </p>
<p>&gt; 函数关于每个变量的导数指明了整个表达式对于该变量的敏感程度。  </p>
<p>如上所述，梯度$\nabla f$是偏导数的向量，所以有$\nabla f(x)=[\frac{\partial f}{\partial x},\frac{\partial f}{\partial y}]=[y,x]$。即使是梯度实际上是一个向量，仍然通常使用类似”x上的梯度”的术语，而不是使用如”x的偏导数”的正确说法，原因是因为前者说起来简单。</p>
<p>我们也可以对加法操作求导：  </p>
<p>$\displaystyle f(x,y)=x+y \to \frac {df}{dx}=1 \quad \frac {df}{dy}=1$</p>
<p>这就是说，无论其值如何，$x,y$的导数均为1。这是有道理的，因为无论增加$x,y$中任一个的值，函数$f$的值都会增加，并且增加的变化率独立于$[x,y]$的具体值（情况和乘法操作不同）。取最大值操作也是常常使用的：<br>$\displaystyle f(x,y)=max(x,y) \to \frac {df}{dx}=1 (x&gt;=y) \quad \frac {df}{dy}=1 (y&gt;=x)$ </p>
<p>上式是说，如果该变量比另一个变量大，那么梯度是1，反之为0。例如，若$x=4,y=2$，那么$max$是4，所以函数对于$y$就不敏感。也就是说，在$y$上增加$h$，函数还是输出为4，所以梯度是0：因为对于函数输出是没有效果的。当然，如果给$y$增加一个很大的量，比如大于2，那么函数$f$的值就变化了，但是导数并没有指明输入量有巨大变化情况对于函数的效果，他们只适用于输入量变化极小时的情况，因为定义已经指明：$\displaystyle \lim_{h \to 0}$。  </p>
<h2 id="使用链式法则计算复合表达式"><a href="#使用链式法则计算复合表达式" class="headerlink" title="使用链式法则计算复合表达式"></a>使用链式法则计算复合表达式</h2><p>现在考虑更复杂的包含多个函数的复合函数，比如$f(x,y,z)=(x+y)z$。虽然这个表达足够简单，可以直接微分，但是在此使用一种有助于读者直观理解反向传播的方法。将公式分成两部分：$q=x+y$和$f=qz$。在前面已经介绍过如何对这分开的两个公式进行计算，因为$f$是$q$和$z$相乘，所以$\displaystyle \frac{\partial f}{\partial q}=z,\frac{\partial f}{\partial z}=q$，又因为$q$是$x$加$y$，所以$\displaystyle \frac{\partial q}{\partial x}=1,\frac{\partial q}{\partial y}=1$。然而，并不需要关心中间量$q$的梯度，因为$\frac{\partial f}{\partial q}$没有用。相反，函数$f$关于$x,y,z$的梯度才是需要关注的。<strong>链式法则</strong>指出将这些梯度表达式链接起来的正确方式是相乘，比如$\displaystyle \frac{\partial f}{\partial x}=\frac{\partial f}{\partial q}\frac{\partial q}{\partial x}$。在实际操作中，这只是简单地将两个梯度数值相乘，示例代码如下：</p>
<p>​<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置输入值</span></span><br><span class="line">x = -<span class="number">2</span>; y = <span class="number">5</span>; z = -<span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行前向传播</span></span><br><span class="line">q = x + y <span class="comment"># q becomes 3</span></span><br><span class="line">f = q * z <span class="comment"># f becomes -12</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行反向传播:</span></span><br><span class="line"><span class="comment"># 首先回传到 f = q * z</span></span><br><span class="line">dfdz = q <span class="comment"># df/dz = q, 所以关于z的梯度是3</span></span><br><span class="line">dfdq = z <span class="comment"># df/dq = z, 所以关于q的梯度是-4</span></span><br><span class="line"><span class="comment"># 现在回传到q = x + y</span></span><br><span class="line">dfdx = <span class="number">1.0</span> * dfdq <span class="comment"># dq/dx = 1. 这里的乘法是因为链式法则</span></span><br><span class="line">dfdy = <span class="number">1.0</span> * dfdq <span class="comment"># dq/dy = 1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>最后得到变量的梯度[<strong>dfdx, dfdy, dfdz]</strong>，它们告诉我们函数<strong>f</strong>对于变量[<strong>x, y, z]</strong>的敏感程度。这是一个最简单的反向传播。一般会使用一个更简洁的表达符号，这样就不用写<strong>df</strong>了。这就是说，用<strong>dq</strong>来代替<strong>dfdq</strong>，且总是假设梯度是关于最终输出的。</p>
<p>这次计算可以被可视化为如下计算线路图像：  </p>
<img src="/2024/05/17/13-29-46/213da7f66594510b45989bd134fc2d8b_b.jpg" class>
<p>上图的真实值计算线路展示了计算的视觉化过程。<strong>前向传播</strong>从输入计算到输出（绿色），<strong>反向传播</strong>从尾部开始，根据链式法则递归地向前计算梯度（显示为红色），一直到网络的输入端。可以认为，梯度是从计算链路中回流。</p>
<h2 id="反向传播的直观理解"><a href="#反向传播的直观理解" class="headerlink" title="反向传播的直观理解"></a>反向传播的直观理解</h2><p>反向传播是一个优美的局部过程。在整个计算线路图中，每个门单元都会得到一些输入并立即计算两个东西：1. 这个门的输出值，和2.其输出值关于输入值的局部梯度。门单元完成这两件事是完全独立的，它不需要知道计算线路中的其他细节。然而，一旦前向传播完毕，在反向传播的过程中，门单元门将最终获得整个网络的最终输出值在自己的输出值上的梯度。链式法则指出，门单元应该将回传的梯度乘以它对其的输入的局部梯度，从而得到整个网络的输出对该门单元的每个输入值的梯度。</p>
<p>&gt; 这里对于每个输入的乘法操作是基于链式法则的。该操作让一个相对独立的门单元变成复杂计算线路中不可或缺的一部分，这个复杂计算线路可以是神经网络等。  </p>
<p>下面通过例子来对这一过程进行理解。加法门收到了输入[-2, 5]，计算输出是3。既然这个门是加法操作，那么对于两个输入的局部梯度都是+1。网络的其余部分计算出最终值为-12。在反向传播时将递归地使用链式法则，算到加法门（是乘法门的输入）的时候，知道加法门的输出的梯度是-4。如果网络如果想要输出值更高，那么可以认为它会想要加法门的输出更小一点（因为负号），而且还有一个4的倍数。继续递归并对梯度使用链式法则，加法门拿到梯度，然后把这个梯度分别乘到每个输入值的局部梯度（就是让-4乘以<strong>x</strong>和<strong>y</strong>的局部梯度，x和y的局部梯度都是1，所以最终都是-4）。可以看到得到了想要的效果：如果<strong>x，y减小</strong>（它们的梯度为负），那么加法门的输出值减小，这会让乘法门的输出值增大。  </p>
<p>因此，反向传播可以看做是门单元之间在通过梯度信号相互通信，只要让它们的输入沿着梯度方向变化，无论它们自己的输出值在何种程度上升或降低，都是为了让整个网络的输出值更高。  </p>
<h2 id="模块化：Sigmoid例子"><a href="#模块化：Sigmoid例子" class="headerlink" title="模块化：Sigmoid例子"></a>模块化：Sigmoid例子</h2><p>上面介绍的门是相对随意的。任何可微分的函数都可以看做门。可以将多个门组合成一个门，也可以根据需要将一个函数分拆成多个门。现在看看一个表达式：  </p>
<p>$\displaystyle f(w,x)=\frac{1}{1+e^{-(w_0x_0+w_1x_1+w_2)}}$</p>
<p>在后面的课程中可以看到，这个表达式描述了一个含输入<strong>x</strong>和权重<strong>w</strong>的2维的神经元，该神经元使用了_sigmoid激活_函数。但是现在只是看做是一个简单的输入为$x$和$w$，输出为一个数字的函数。这个函数是由多个门组成的。除了上文介绍的加法门，乘法门，取最大值门，还有下面这4种：</p>
<p>$\displaystyle f(x)=frac{1}{x} \to \frac{df}{dx}=-1/x^2$<br>$\displaystyle f_c(x)=c+x \to \frac{df}{dx}=1$<br>$\displaystyle f(x)=e^x \to \frac{df}{dx}=e^x$<br>$\displaystyle f_a(x)=ax \to \frac{df}{dx}=a$</p>
<p>其中，函数$f_c$使用对输入值进行了常量$c$的平移，$f_a$将输入值扩大了常量$a$倍。它们是加法和乘法的特例，但是这里将其看做一元门单元，因为确实需要计算常量$c,a$的梯度。整个计算线路如下：</p>
<img src="/2024/05/17/13-29-46/0799b3d6e5e92245ee937db3c26d1b80_b.png" class>
<p>使用sigmoid激活函数的2维神经元的例子。输入是[x0, x1]，可学习的权重是[w0, w1, w2]。一会儿会看见，这个神经元对输入数据做点积运算，然后其激活数据被sigmoid函数挤压到0到1之间。  </p>
<p>在上面的例子中可以看见一个函数操作的长链条，链条上的门都对<strong>w</strong>和<strong>x</strong>的点积结果进行操作。该函数被称为sigmoid函数$\sigma (x)$。sigmoid函数关于其输入的求导是可以简化的(使用了在分子上先加后减1的技巧)：</p>
<p>$\displaystyle \sigma(x)=\frac{1}{1+e^{-x}}$<br>$\displaystyle \to \frac{d \sigma(x)}{dx}=\frac{e^{-x}}{(1+e^{-x})^2}=(\frac{1+e^{-x}-1}{1+e^{-x}})(\frac{1}{1+e^{-x}})=(1-\sigma(x))\sigma(x)$</p>
<p>可以看到梯度计算简单了很多。举个例子，sigmoid表达式输入为1.0，则在前向传播中计算出输出为0.73。根据上面的公式，局部梯度为(1-0.73)*0.73~=0.2，和之前的计算流程比起来，现在的计算使用一个单独的简单表达式即可。因此，在实际的应用中将这些操作装进一个单独的门单元中将会非常有用。该神经元反向传播的代码实现如下：  </p>
<p>​<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">w = [<span class="number">2</span>,-<span class="number">3</span>,-<span class="number">3</span>] <span class="comment"># 假设一些随机数据和权重</span></span><br><span class="line">x = [-<span class="number">1</span>, -<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 前向传播</span></span><br><span class="line">dot = w[<span class="number">0</span>]*x[<span class="number">0</span>] + w[<span class="number">1</span>]*x[<span class="number">1</span>] + w[<span class="number">2</span>]</span><br><span class="line">f = <span class="number">1.0</span> / (<span class="number">1</span> + math.exp(-dot)) <span class="comment"># sigmoid函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对神经元反向传播</span></span><br><span class="line">ddot = (<span class="number">1</span> - f) * f <span class="comment"># 点积变量的梯度, 使用sigmoid函数求导</span></span><br><span class="line">dx = [w[<span class="number">0</span>] * ddot, w[<span class="number">1</span>] * ddot] <span class="comment"># 回传到x</span></span><br><span class="line">dw = [x[<span class="number">0</span>] * ddot, x[<span class="number">1</span>] * ddot, <span class="number">1.0</span> * ddot] <span class="comment"># 回传到w</span></span><br><span class="line"><span class="comment"># 完成！得到输入的梯度</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><br><strong>实现提示：分段反向传播</strong>。上面的代码展示了在实际操作中，为了使反向传播过程更加简洁，把向前传播分成不同的阶段将是很有帮助的。比如我们创建了一个中间变量<strong>dot</strong>，它装着<strong>w</strong>和<strong>x</strong>的点乘结果。在反向传播的时，就可以（反向地）计算出装着<strong>w</strong>和<strong>x</strong>等的梯度的对应的变量（比如<strong>ddot</strong>，<strong>dx</strong>和<strong>dw</strong>）。</p>
<p>本节的要点就是展示反向传播的细节过程，以及前向传播过程中，哪些函数可以被组合成门，从而可以进行简化。知道表达式中哪部分的局部梯度计算比较简洁非常有用，这样他们可以”链”在一起，让代码量更少，效率更高。  </p>
<h2 id="反向传播实践：分段计算"><a href="#反向传播实践：分段计算" class="headerlink" title="反向传播实践：分段计算"></a>反向传播实践：分段计算</h2><p>看另一个例子。假设有如下函数：  </p>
<p>$\displaystyle f(x,y)=\frac{x+\sigma(y)}{\sigma(x)+(x+y)^2}$</p>
<p>首先要说的是，这个函数完全没用，读者是不会用到它来进行梯度计算的，这里只是用来作为实践反向传播的一个例子，需要强调的是，如果对$x$或$y$进行微分运算，运算结束后会得到一个巨大而复杂的表达式。然而做如此复杂的运算实际上并无必要，因为我们不需要一个明确的函数来计算梯度，只需知道如何使用反向传播计算梯度即可。下面是构建前向传播的代码模式：  </p>
<p>​<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">x = <span class="number">3</span> <span class="comment"># 例子数值</span></span><br><span class="line">y = -<span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 前向传播</span></span><br><span class="line">sigy = <span class="number">1.0</span> / (<span class="number">1</span> + math.exp(-y)) <span class="comment"># 分子中的sigmoi          #(1)</span></span><br><span class="line">num = x + sigy <span class="comment"># 分子                                    #(2)</span></span><br><span class="line">sigx = <span class="number">1.0</span> / (<span class="number">1</span> + math.exp(-x)) <span class="comment"># 分母中的sigmoid         #(3)</span></span><br><span class="line">xpy = x + y                                              <span class="comment">#(4)</span></span><br><span class="line">xpysqr = xpy**<span class="number">2</span>                                          <span class="comment">#(5)</span></span><br><span class="line">den = sigx + xpysqr <span class="comment"># 分母                                #(6)</span></span><br><span class="line">invden = <span class="number">1.0</span> / den                                       <span class="comment">#(7)</span></span><br><span class="line">f = num * invden <span class="comment"># 搞定！                                 #(8)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>到了表达式的最后，就完成了前向传播。注意在构建代码s时创建了多个中间变量，每个都是比较简单的表达式，它们计算局部梯度的方法是已知的。这样计算反向传播就简单了：我们对前向传播时产生每个变量(<strong>sigy, num, sigx, xpy, xpysqr, den, invden</strong>)进行回传。我们会有同样数量的变量，但是都以<strong>d</strong>开头，用来存储对应变量的梯度。注意在反向传播的每一小块中都将包含了表达式的局部梯度，然后根据使用链式法则乘以上游梯度。对于每行代码，我们将指明其对应的是前向传播的哪部分。</p>
<p>​<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 回传 f = num * invden</span></span><br><span class="line">dnum = invden <span class="comment"># 分子的梯度                                         #(8)</span></span><br><span class="line">dinvden = num                                                     <span class="comment">#(8)</span></span><br><span class="line"><span class="comment"># 回传 invden = 1.0 / den </span></span><br><span class="line">dden = (-<span class="number">1.0</span> / (den**<span class="number">2</span>)) * dinvden                                <span class="comment">#(7)</span></span><br><span class="line"><span class="comment"># 回传 den = sigx + xpysqr</span></span><br><span class="line">dsigx = (<span class="number">1</span>) * dden                                                <span class="comment">#(6)</span></span><br><span class="line">dxpysqr = (<span class="number">1</span>) * dden                                              <span class="comment">#(6)</span></span><br><span class="line"><span class="comment"># 回传 xpysqr = xpy**2</span></span><br><span class="line">dxpy = (<span class="number">2</span> * xpy) * dxpysqr                                        <span class="comment">#(5)</span></span><br><span class="line"><span class="comment"># 回传 xpy = x + y</span></span><br><span class="line">dx = (<span class="number">1</span>) * dxpy                                                   <span class="comment">#(4)</span></span><br><span class="line">dy = (<span class="number">1</span>) * dxpy                                                   <span class="comment">#(4)</span></span><br><span class="line"><span class="comment"># 回传 sigx = 1.0 / (1 + math.exp(-x))</span></span><br><span class="line">dx += ((<span class="number">1</span> - sigx) * sigx) * dsigx <span class="comment"># Notice += !! See notes below  #(3)</span></span><br><span class="line"><span class="comment"># 回传 num = x + sigy</span></span><br><span class="line">dx += (<span class="number">1</span>) * dnum                                                  <span class="comment">#(2)</span></span><br><span class="line">dsigy = (<span class="number">1</span>) * dnum                                                <span class="comment">#(2)</span></span><br><span class="line"><span class="comment"># 回传 sigy = 1.0 / (1 + math.exp(-y))</span></span><br><span class="line">dy += ((<span class="number">1</span> - sigy) * sigy) * dsigy                                 <span class="comment">#(1)</span></span><br><span class="line"><span class="comment"># 完成! 嗷~~</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>需要注意的一些东西：</p>
<p><strong>对前向传播变量进行缓存</strong>：在计算反向传播时，前向传播过程中得到的一些中间变量非常有用。在实际操作中，最好代码实现对于这些中间变量的缓存，这样在反向传播的时候也能用上它们。如果这样做过于困难，也可以（但是浪费计算资源）重新计算它们。</p>
<p><strong>在不同分支的梯度要相加</strong>：如果变量x，y在前向传播的表达式中出现多次，那么进行反向传播的时候就要非常小心，使用 <strong>+=</strong> 而不是 <strong>=</strong> 来累计这些变量的梯度（不然就会造成覆写）。这是遵循了在微积分中的_多元链式法则_，该法则指出如果变量在线路中分支走向不同的部分，那么梯度在回传的时候，就应该进行累加。</p>
<h2 id="回传流中的模式"><a href="#回传流中的模式" class="headerlink" title="回传流中的模式"></a>回传流中的模式</h2><p>一个有趣的现象是在多数情况下，反向传播中的梯度可以被很直观地解释。例如神经网络中最常用的加法、乘法和取最大值这三个门单元，它们在反向传播过程中的行为都有非常简单的解释。先看下面这个例子：  </p>
<img src="/2024/05/17/13-29-46/39162d0c528144362cc09f1965d710d1_b.jpg" class>
<p>一个展示反向传播的例子。加法操作将梯度相等地分发给它的输入。取最大操作将梯度路由给更大的输入。乘法门拿取输入激活数据，对它们进行交换，然后乘以梯度。  </p>
<p>从上例可知：</p>
<p><strong>加法门单元</strong>把输出的梯度相等地分发给它所有的输入，这一行为与输入值在前向传播时的值无关。这是因为加法操作的局部梯度都是简单的+1，所以所有输入的梯度实际上就等于输出的梯度，因为乘以1.0保持不变。上例中，加法门把梯度2.00不变且相等地路由给了两个输入。</p>
<p><strong>取最大值门单元</strong>对梯度做路由。和加法门不同，取最大值门将梯度转给其中一个输入，这个输入是在前向传播中值最大的那个输入。这是因为在取最大值门中，最高值的局部梯度是1.0，其余的是0。上例中，取最大值门将梯度2.00转给了<strong>z</strong>变量，因为<strong>z</strong>的值比<strong>w</strong>高，于是<strong>w</strong>的梯度保持为0。</p>
<p><strong>乘法门单元</strong>相对不容易解释。它的局部梯度就是输入值，但是是相互交换之后的，然后根据链式法则乘以输出值的梯度。上例中，<strong>x</strong>的梯度是-4.00x2.00=-8.00。<br>$f=x*y\ \frac{\partial f}{\partial x}=y$<br>_非直观影响及其结果_。注意一种比较特殊的情况，如果乘法门单元的其中一个输入非常小，而另一个输入非常大，那么乘法门的操作将会不是那么直观：它将会把大的梯度分配给小的输入，把小的梯度分配给大的输入。在线性分类器中，权重和输入是进行点积$w^Tx_i$，这说明输入数据的大小对于权重梯度的大小有影响。例如，在计算过程中对所有输入数据样本$x_i$乘以1000，那么权重的梯度将会增大1000倍，这样就必须降低学习率来弥补。这就是为什么数据预处理关系重大，它即使只是有微小变化，也会产生巨大影响。对于梯度在计算线路中是如何流动的有一个直观的理解，可以帮助读者调试网络。</p>
<h2 id="用向量化操作计算梯度"><a href="#用向量化操作计算梯度" class="headerlink" title="用向量化操作计算梯度"></a>用向量化操作计算梯度</h2><p>上述内容考虑的都是单个变量情况，但是所有概念都适用于矩阵和向量操作。然而，在操作的时候要注意关注维度和转置操作。</p>
<p>关于向量的求导中维度的变化，公式如下<br><img src="/2024/05/17/13-29-46/69-1682754437671-1.jpg" class></p>
<p>得到的实际上是雅克比矩阵，这个矩阵可以描述每个输出对输入的影响</p>
<p><strong>矩阵相乘的梯度</strong>：可能最有技巧的操作是矩阵相乘（也适用于矩阵和向量，向量和向量相乘）的乘法操作：  </p>
<p>​<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 前向传播</span></span><br><span class="line">W = np.random.randn(<span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">X = np.random.randn(<span class="number">10</span>, <span class="number">3</span>)</span><br><span class="line">D = W.dot(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设我们得到了D的梯度</span></span><br><span class="line">dD = np.random.randn(*D.shape) <span class="comment"># 和D一样的尺寸</span></span><br><span class="line">dW = dD.dot(X.T) <span class="comment">#.T就是对矩阵进行转置</span></span><br><span class="line">dX = W.T.dot(dD)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>_提示：要分析维度！_注意不需要去记忆<strong>dW</strong>和<strong>dX</strong>的表达，因为它们很容易通过维度推导出来。例如，权重的梯度dW的尺寸肯定和权重矩阵W的尺寸是一样的，而这又是由<strong>X</strong>和<strong>dD</strong>的矩阵乘法决定的（在上面的例子中<strong>X</strong>和<strong>W</strong>都是数字不是矩阵）。总有一个方式是能够让维度之间能够对的上的。例如，<strong>X</strong>的尺寸是[10x3]，<strong>dD</strong>的尺寸是[5x3]，如果你想要dW和W的尺寸是[5x10]，那就要<strong>dD.dot(X.T)</strong>。</p>
<p><strong>使用小而具体的例子</strong>：有些读者可能觉得向量化操作的梯度计算比较困难，建议是写出一个很小很明确的向量化例子，在纸上演算梯度，然后对其一般化，得到一个高效的向量化操作形式。  </p>
<p><strong>矩阵相乘反向传播的通用策略</strong></p>
<p>那么在实际操作中，如何实现反向传播呢？下面这个是一个例子，我们从接收到的上游梯度（实际上是一个N*M的矩阵）<br>$<br>\frac{\mathrm{d} L }{\mathrm{d} y}:[N\times M]<br>$<br>这个矩阵可以告诉我们，y对L的影响是什么样的</p>
<p>我们需要找到一种隐式的计算的方式<br><img src="/2024/05/17/13-29-46/88.jpg" class></p>
<p>我们先从输入的一个元素开始考虑，我们假设这个元素为<br>$<br>x_{11}<br>$<br>我们从这个元素开始考虑，这时候有<br>$<br>\frac{\mathrm{d} L }{\mathrm{d} x_{11}}=\frac{\mathrm{d} y }{\mathrm{d} x_{11}}\cdot \frac{\mathrm{d} L }{\mathrm{d} y}<br>$<br>其中上流梯度一支，我们只需求y对x的梯度即可</p>
<img src="/2024/05/17/13-29-46/92.jpg" class>
<p>然后我们根据矩阵乘法可知，y的第一行第一列的元素是x第一行与w第一列的乘积，对x_11求导的结果就是w_11</p>
<p>类似的可以推广到y的所有元素，然后就可以得到y对x_11的导数以及y对x的导数</p>
<img src="/2024/05/17/13-29-46/6-105.jpg" class>
<p>矩阵乘法例子下的隐式雅克比矩阵计算，计算稀疏矩阵的有效方法</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>对梯度的含义有了直观理解，知道了梯度是如何在网络中反向传播的，知道了它们是如何与网络的不同部分通信并控制其升高或者降低，并使得最终输出值更高的。</li>
<li>讨论了<strong>分段计算</strong>在反向传播的实现中的重要性。应该将函数分成不同的模块，这样计算局部梯度相对容易，然后基于链式法则将其”链”起来。重要的是，不需要把这些表达式写在纸上然后演算它的完整求导公式，因为实际上并不需要关于输入变量的梯度的数学公式。只需要将表达式分成不同的可以求导的模块（模块可以是矩阵向量的乘法操作，或者取最大值操作，或者加法操作等），然后在反向传播中一步一步地计算梯度。</li>
</ul>
<p>在下节课中，将会开始定义神经网络，而反向传播使我们能高效计算神经网络各个节点关于损失函数的梯度。换句话说，我们现在已经准备好训练神经网络了，本课程最困难的部分已经过去了！ConvNets相比只是向前走了一小步。</p>
]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>计算机视觉, 图像处理, 深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机视觉 神经网络</title>
    <url>/2024/05/07/12-17-20/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.05.07：初稿</li>
</ul>
<h2 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h2><ul>
<li><a href="/2024/05/06/10-28-51/" title="eecs498 ML-DL-CV 笔记汇总">计算机视觉-笔记汇总</a>
</li>
</ul>
<h2 id="特征变换"><a href="#特征变换" class="headerlink" title="特征变换"></a>特征变换</h2><p>我们从几何学的角度看到了这一点，记得从线性分类器的几何学角度来看，我们认为线性分类器是在画高维超平面，将这个高维的欧几里得空间分割成两块</p>
<p>当我们从视觉角度考虑线性分类器时，我们认为线性分类器只为每个类别学习一个模板，因此它们无法代表同一对象类别的多种模式。</p>
<p>总之，模板是一种用于表示目标对象特征的数据结构，可以采用多种形式。在模板匹配和模板学习任务中，模板被用来在输入数据中搜索和识别目标对象</p>
<p>对于某些线性不可分的数据集，我们可以提出一种特征变换的方式（feature transform），将这些数据映射到特征空间去进行分类，或者说找到一种合适分类的映射方式来完成分类任务，这样就可以克服线性分类器的一些缺点；在这里我们是在特征空间中训练分类器</p>
<img src="/2024/05/07/12-17-20/image-20230425220806741.png" class>
<p>这就是一个将笛卡尔坐标系变换到极坐标系下的例子，这样的话，原本在笛卡尔坐标系下线性不可分的数据集，在极坐标系下线性可分了，也就是说我们可以在特征空间下构建线性分类器</p>
<p>特征变换的思想在计算机视觉中应用广泛，一种就是颜色直方图的概念</p>
<p>我们可以将图像中的颜色空间的RGB光谱进行分解与统计，然后得到颜色直方图，这种方式丢弃了图像中的空间信息，只关心图像中的颜色分布，更具有空间不变性（对不同位置的相同特征可以很好的处理）</p>
<h2 id="图像特征：定向梯度直方图"><a href="#图像特征：定向梯度直方图" class="headerlink" title="图像特征：定向梯度直方图"></a>图像特征：定向梯度直方图</h2><p>还有一种进行图像特征提取的方式就是定向梯度直方图</p>
<img src="/2024/05/07/12-17-20/10.jpg" class>
<p>这种方式可以通过一系列处理得到图像的局部梯度信息，具有很好的区分性和鲁棒性，然后，这些特征可以被用于训练分类器</p>
<h2 id="图像特征：词袋模型（数据驱动）"><a href="#图像特征：词袋模型（数据驱动）" class="headerlink" title="图像特征：词袋模型（数据驱动）"></a>图像特征：词袋模型（数据驱动）</h2><p>数据驱动，实际上是由我们在训练集中看到的数据驱动的，而数据驱动的特征转换的一个例子就是视觉词袋模型</p>
<p>想法是有一个大型训练数据集，可以提取大量不同比例和大小的随机补丁（也就是从图像上随机切下一小块），然后我们对这些随机补丁进行聚类，就获得了所谓的密码本或者一组视觉词，他们可以表示图像中倾向于出现哪种特征，如果这些补丁在训练集中大量出现，那么我们希望可以学习某种视觉词表示，它可以识别你的训练集中的每一个常见特征</p>
<p>之后的步骤是构建视觉词的代码本，使用学习到的视觉词的代码本来编码你的图像，来表示每个视觉词在单个输入图像中出现了多少次</p>
<img src="/2024/05/07/12-17-20/16.jpg" class>
<p>实际上，2011年的ImageNet挑战赛里面的冠军方案，就是基于这种模型；他们的方案分为两部分：特征提取器和可学习分类器</p>
<h2 id="神经网络概述"><a href="#神经网络概述" class="headerlink" title="神经网络概述"></a>神经网络概述</h2><p>在不诉诸大脑的类比的情况下，依然是可以对神经网络算法进行介绍的。在线性分类一节中，在给出图像的情况下，是使用$s=Wx$来计算不同视觉类别的评分，其中$W$是一个矩阵，$x$是一个输入列向量，它包含了图像的全部像素数据。在使用数据库CIFAR-10的案例中，$x$是一个[3072x1]的列向量，$W$是一个[10x3072]的矩阵，所以输出的评分是一个包含10个分类评分的向量。</p>
<p>在之前我们使用线性分类器进行分类，但是接下来我们使用一种两层神经网络来进行学习</p>
<p>神经网络算法不同于线性网络，它的计算公式是$s=W_2max(0,W_1x)$。其中$W_1$的含义是这样的：举个例子来说，它可以是一个[100x3072]的矩阵，其作用是将图像转化为一个100维的过渡向量。函数$max(0,-)$是非线性的，它会作用到每个元素。这个非线性函数有多种选择，后续将会学到。但这个形式是一个最常用的选择，它就是简单地设置阈值，将所有小于0的值变成0。最终，矩阵$W_2$的尺寸是[10x100]，因此将得到10个数字，这10个数字可以解释为是分类的评分。注意非线性函数在计算上是至关重要的，如果略去这一步，那么两个矩阵将会合二为一，对于分类的评分计算将重新变成关于输入的线性函数。这个非线性函数就是改变的关键点。参数$W_1,W_2$将通过随机梯度下降来学习到，他们的梯度在反向传播过程中，通过链式法则来求导计算得出。</p>
<p>一个三层的神经网络可以类比地看做$s=W_3max(0,W_2max(0,W_1x))$，其中$W_1,W_2,W_3$是需要进行学习的参数。中间隐层的尺寸是网络的超参数，后续将学习如何设置它们。现在让我们先从神经元或者网络的角度理解上述计算</p>
<p>之前的线性函数为<br>$<br>\begin{split}<br>f=Wx<br>\end{split}<br>$<br>现在使用的两层神经网络为<br>$<br>\begin{split}<br>f=W_2\max(0,W_1x)\\<br>W_2\in \mathbb{R}^{C\times H}\quad<br>W_1\in \mathbb{R}^{H\times D}\quad<br>x\in \mathbb{R}^{D}<br>\end{split}<br>$<br>其中包括两个可学习的权重矩阵$W_1,W_2$，当然在实践过程中，这些向量乘法都会隐式的包含一个可学习的偏差项</p>
<p>当然我们也可以使用这种图形化的形式来表示神经网络，因为其中的每个部分都相互连接，所以也被称为全连接神经网络</p>
<img src="/2024/05/07/12-17-20/24.jpg" class>
<p>这个激活函数的功能就是可以拓宽神经网络的拟合能力，因为如果有多个线性分类器组合，那么结果还是一个线性分类器，多个分类器等于一个分类器</p>
<h2 id="快速简介"><a href="#快速简介" class="headerlink" title="快速简介"></a>快速简介</h2><h2 id="神经网络的几何解释"><a href="#神经网络的几何解释" class="headerlink" title="神经网络的几何解释"></a>神经网络的几何解释</h2><p>面对一个线性可分的数据集，线性分类器的功能就是找到一个或者多个超平面，可以对不同的数据进行分割，但是存在某些线性不可分的数据集，这个时候，就无法使用超平面进行分割了，或者说找不到一种线性方式进行分割，比如说下面的数据集</p>
<img src="/2024/05/07/12-17-20/55.jpg" class>
<p>我们发现，找不到一个合适的变换矩阵$W$来分割这个数据集，所以就需要找到一种非线性方式来分割，也就是激活函数的方式，这样就可以完成某些无法线性分割的数据集的分割，比如说下面这种方式，就是使用ReLu函数进行特征变换，然后可以看到，BCD三个区间都并不对应新空间下的三个象限，而是分别落在坐标轴和原点上</p>
<img src="/2024/05/07/12-17-20/60-1682664488898-3.jpg" class>
<p>这样，就可以完成某些数据集的分割了，比如说下图</p>
<img src="/2024/05/07/12-17-20/64.jpg" class>
<h1 id="单个神经元建模"><a href="#单个神经元建模" class="headerlink" title="单个神经元建模"></a>单个神经元建模</h1><p>神经网络算法领域最初是被对生物神经系统建模这一目标启发，但随后与其分道扬镳，成为一个工程问题，并在机器学习领域取得良好效果。然而，讨论将还是从对生物系统的一个高层次的简略描述开始，因为神经网络毕竟是从这里得到了启发。  </p>
<h2 id="生物动机与连接"><a href="#生物动机与连接" class="headerlink" title="生物动机与连接"></a>生物动机与连接</h2><p>大脑的基本计算单位是<strong>神经元（neuron）</strong>。人类的神经系统中大约有860亿个神经元，它们被大约$10^{14}-10^{15}$个<strong>突触（synapses）</strong>连接起来。下面图表的左边展示了一个生物学的神经元，右边展示了一个常用的数学模型。每个神经元都从它的<strong>树突</strong>获得输入信号，然后沿着它唯一的<strong>轴突（axon）</strong>产生输出信号。轴突在末端会逐渐分枝，通过突触和其他神经元的树突相连。</p>
<p>在神经元的计算模型中，沿着轴突传播的信号（比如$x_0$）将基于突触的突触强度（比如$w_0$），与其他神经元的树突进行乘法交互（比如$w_0x_0$）。其观点是，突触的强度（也就是权重$w$），是可学习的且可以控制一个神经元对于另一个神经元的影响强度（还可以控制影响方向：使其兴奋（正权重）或使其抑制（负权重））。在基本模型中，树突将信号传递到细胞体，信号在细胞体中相加。如果最终之和高于某个阈值，那么神经元将会激活，向其轴突输出一个峰值信号。在计算模型中，我们假设峰值信号的准确时间点不重要，是激活信号的频率在交流信息。基于这个速率编码的观点，将神经元的激活率建模为<strong>激活函数（activation function）$f$</strong>，它表达了轴突上激活信号的频率。由于历史原因，激活函数常常选择使用<strong>sigmoid函数$\sigma$</strong>，该函数输入实数值（求和后的信号强度），然后将输入值压缩到0-1之间。在本节后面部分会看到这些激活函数的各种细节。</p>
<img src="/2024/05/07/12-17-20/d0cbce2f2654b8e70fe201fec2982c7d_b.png" class>
<p>左边是生物神经元，右边是数学模型。  </p>
<p>一个神经元前向传播的实例代码如下：  </p>
<p>​<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Neuron</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">  <span class="comment"># ... </span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">inputs</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 假设输入和权重是1-D的numpy数组，偏差是一个数字 &quot;&quot;&quot;</span></span><br><span class="line">    cell_body_sum = np.<span class="built_in">sum</span>(inputs * self.weights) + self.bias</span><br><span class="line">    firing_rate = <span class="number">1.0</span> / (<span class="number">1.0</span> + math.exp(-cell_body_sum)) <span class="comment"># sigmoid激活函数</span></span><br><span class="line">    <span class="keyword">return</span> firing_rate</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>换句话说，每个神经元都对它的输入和权重进行点积，然后加上偏差，最后使用非线性函数（或称为激活函数）。本例中使用的是sigmoid函数$\sigma(x)=1/(1+e^{-x})$。在本节的末尾部分将介绍不同激活函数的细节。</p>
<p><strong>粗糙模型</strong>：要注意这个对于生物神经元的建模是非常粗糙的：在实际中，有很多不同类型的神经元，每种都有不同的属性。生物神经元的树突可以进行复杂的非线性计算。突触并不就是一个简单的权重，它们是复杂的非线性动态系统。很多系统中，输出的峰值信号的精确时间点非常重要，说明速率编码的近似是不够全面的。鉴于所有这些已经介绍和更多未介绍的简化，如果你画出人类大脑和神经网络之间的类比，有神经科学背景的人对你的板书起哄也是非常自然的。</p>
<h2 id="作为线性分类器的单个神经元"><a href="#作为线性分类器的单个神经元" class="headerlink" title="作为线性分类器的单个神经元"></a>作为线性分类器的单个神经元</h2><p>神经元模型的前向计算数学公式看起来可能比较眼熟。就像在线性分类器中看到的那样，神经元有能力”喜欢”（激活函数值接近1），或者不喜欢（激活函数值接近0）输入空间中的某些线性区域。因此，只要在神经元的输出端有一个合适的损失函数，就能让单个神经元变成一个线性分类器。</p>
<p><strong>二分类Softmax分类器</strong>。举例来说，可以把$\displaystyle\sigma(\sigma_iw_ix_i+b)$看做其中一个分类的概率$P(y_i=1|x_i;w)$，其他分类的概率为$P(y_i=0|x_i;w)=1-P(y_i=1|x_i;w)$，因为它们加起来必须为1。根据这种理解，可以得到交叉熵损失，这个在线性分一节中已经介绍。然后将它最优化为二分类的Softmax分类器（也就是逻辑回归）。因为sigmoid函数输出限定在0-1之间，所以分类器做出预测的基准是神经元的输出是否大于0.5。  </p>
<p><strong>二分类SVM分类器</strong>。或者可以在神经元的输出外增加一个最大边界折叶损失（max-margin hinge loss）函数，将其训练成一个二分类的支持向量机。  </p>
<p><strong>理解正则化</strong>。在SVM/Softmax的例子中，正则化损失从生物学角度可以看做逐渐遗忘，因为它的效果是让所有突触权重$w$在参数更新过程中逐渐向着0变化。  </p>
<p>&gt; 一个单独的神经元可以用来实现一个二分类分类器，比如二分类的Softmax或者SVM分类器。  </p>
<h2 id="常用激活函数"><a href="#常用激活函数" class="headerlink" title="常用激活函数"></a>常用激活函数</h2><p>激活函数是一种很有用的方式，可以增强模型的拟合能力，来完成对各种数据的拟合</p>
<p>每个激活函数（或非线性函数）的输入都是一个数字，然后对其进行某种固定的数学操作。下面是在实践中可能遇到的几种激活函数：  </p>
<img src="/2024/05/07/12-17-20/677187e96671a4cac9c95352743b3806_b.png" class>
<p>左边是Sigmoid非线性函数，将实数压缩到[0,1]之间。右边是tanh函数，将实数压缩到[-1,1]。  </p>
<p><strong>Sigmoid。</strong>sigmoid非线性函数的数学公式是$\displaystyle\sigma(x)=1/(1+e^{-x})$，函数图像如上图的左边所示。在前一节中已经提到过，它输入实数值并将其”挤压”到0到1范围内。更具体地说，很大的负数变成0，很大的正数变成1。在历史上，sigmoid函数非常常用，这是因为它对于神经元的激活频率有良好的解释：从完全不激活（0）到在求和后的最大频率处的完全饱和（<strong>saturated</strong>）的激活（1）。然而现在sigmoid函数已经不太受欢迎，实际很少使用了，这是因为它有两个主要缺点：</p>
<ul>
<li>_ Sigmoid函数饱和使梯度消失_。sigmoid神经元有一个不好的特性，就是当神经元的激活在接近0或1处时会饱和：在这些区域，梯度几乎为0。回忆一下，在反向传播的时候，这个（局部）梯度将会与整个损失函数关于该门单元输出的梯度相乘。因此，如果局部梯度非常小，那么相乘的结果也会接近零，这会有效地”杀死”梯度，几乎就有没有信号通过神经元传到权重再到数据了。还有，为了防止饱和，必须对于权重矩阵初始化特别留意。比如，如果初始化权重过大，那么大多数神经元将会饱和，导致网络就几乎不学习了。</li>
<li>_Sigmoid函数的输出不是零中心的_。这个性质并不是我们想要的，因为在神经网络后面层中的神经元得到的数据将不是零中心的。这一情况将影响梯度下降的运作，因为如果输入神经元的数据总是正数（比如在$f=w^Tx+b$中每个元素都$x&gt;0$），那么关于$w$的梯度在反向传播的过程中，将会要么全部是正数，要么全部是负数（具体依整个表达式$f$而定）。这将会导致梯度下降权重更新时出现z字型的下降。然而，可以看到整个批量的数据的梯度被加起来后，对于权重的最终更新将会有不同的正负，这样就从一定程度上减轻了这个问题。因此，该问题相对于上面的神经元饱和问题来说只是个小麻烦，没有那么严重。</li>
</ul>
<p><strong>Tanh。</strong>tanh非线性函数图像如上图右边所示。它将实数值压缩到[-1,1]之间。和sigmoid神经元一样，它也存在饱和问题，但是和sigmoid神经元不同的是，它的输出是零中心的。因此，在实际操作中，_tanh非线性函数比sigmoid非线性函数更受欢迎_。注意tanh神经元是一个简单放大的sigmoid神经元，具体说来就是：$tanh(x)=2\sigma(2x)-1$。  </p>
<img src="/2024/05/07/12-17-20/83682a138f6224230f5b0292d9c01bd2_b.png" class>
<p>左边是ReLU（校正线性单元：Rectified Linear Unit）激活函数，当$x=0$时函数值为0。当$x&gt;0$函数的斜率为1。</p>
<p><strong>ReLU。</strong>在近些年ReLU变得非常流行。它的函数公式是$f(x)=max(0,x)$。换句话说，这个激活函数就是一个关于0的阈值（如上图左侧）。使用ReLU有以下一些优缺点：</p>
<ul>
<li>优点：相较于sigmoid和tanh函数，ReLU对于随机梯度下降的收敛有巨大的加速作用。据称这是由它的线性，非饱和的公式导致的。</li>
<li>优点：sigmoid和tanh神经元含有指数运算等耗费计算资源的操作，而ReLU可以简单地通过对一个矩阵进行阈值计算得到。</li>
<li>缺点：在训练的时候，ReLU单元比较脆弱并且可能”死掉”。举例来说，当一个很大的梯度流过ReLU的神经元的时候，可能会导致梯度更新到一种特别的状态，在这种状态下神经元将无法被其他任何数据点再次激活。如果这种情况发生，那么从此所以流过这个神经元的梯度将都变成0。也就是说，这个ReLU单元在训练中将不可逆转的死亡，因为这导致了数据多样化的丢失。例如，如果学习率设置得太高，可能会发现网络中40%的神经元都会死掉（在整个训练集中这些神经元都不会被激活）。通过合理设置学习率，这种情况的发生概率会降低。</li>
</ul>
<p><strong>Leaky ReLU。</strong>Leaky ReLU是为解决”ReLU死亡”问题的尝试。ReLU中当x&lt;0时，函数值为0。而Leaky ReLU则是给出一个很小的负数梯度值，比如0.01。所以其函数公式为$f(x)=max(0,x)+\alpha\cdot min(0,x)$其中$\alpha$是一个小的常量。有些研究者的论文指出这个激活函数表现很不错，但是其效果并不是很稳定。Kaiming He等人在2015年发布的论文中介绍了一种新方法PReLU，把负区间上的斜率当做每个神经元中的一个参数。然而该激活函数在在不同任务中均有益处的一致性并没有特别清晰。</p>
<p><strong>Maxout。</strong>一些其他类型的单元被提了出来，它们对于权重和数据的内积结果不再使用$f(w^Tx+b)$函数形式。一个相关的流行选择是Maxout神经元。Maxout是对ReLU和leaky ReLU的一般化归纳，它的函数是：$max(w^T_1x+b_1,w^T_2x+b_2)$。ReLU和Leaky ReLU都是这个公式的特殊情况（比如ReLU就是当$w_1,b_1=0$的时候）。这样Maxout神经元就拥有ReLU单元的所有优点（线性操作和不饱和），而没有它的缺点（死亡的ReLU单元）。然而和ReLU对比，它每个神经元的参数数量增加了一倍，这就导致整体参数的数量激增。</p>
<p>以上就是一些常用的神经元及其激活函数。最后需要注意一点：在同一个网络中混合使用不同类型的神经元是非常少见的，虽然没有什么根本性问题来禁止这样做。  </p>
<p><strong>一句话</strong>：”那么该用那种呢？”用ReLU非线性函数。注意设置好学习率，或许可以监控你的网络中死亡的神经元占的比例。如果单元死亡问题困扰你，就试试Leaky ReLU或者Maxout，不要再用sigmoid了。也可以试试tanh，但是其效果应该不如ReLU或者Maxout。  </p>
]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>计算机视觉, 图像处理, 深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机视觉 最优化</title>
    <url>/2024/05/07/11-38-48/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.05.07：初稿</li>
</ul>
<h2 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h2><ul>
<li><a href="/2024/05/06/10-28-51/" title="eecs498 ML-DL-CV 笔记汇总">计算机视觉-笔记汇总</a>
</li>
</ul>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在上一节中，我们介绍了图像分类任务中的两个关键部分：</p>
<ol>
<li>基于参数的<strong>评分函数。</strong>该函数将原始图像像素映射为分类评分值（例如：一个线性函数）。</li>
<li><strong>损失函数</strong>。该函数能够根据分类评分和训练集图像数据实际分类的一致性，衡量某个具体参数集的质量好坏。损失函数有多种版本和不同的实现方式（例如：Softmax或SVM）。</li>
</ol>
<p>上节中，线性函数的形式是$f(x_i, W)=Wx_i$，而SVM实现的公式是：  </p>
<p>$L=\frac1N\sum_i\sum_{j\neq y_i}[max(0,f(x_i;W)_j-f(x_i;W)_{y_i}+1)]+\alpha R(W)$</p>
<p>对于图像数据$x_i$，如果基于参数集$W$做出的分类预测与真实情况比较一致，那么计算出来的损失值$L$就很低。现在介绍第三个，也是最后一个关键部分：<strong>最优化Optimization</strong>。最优化是寻找能使得损失函数值最小化的参数$W$的过程。</p>
<p><strong>铺垫</strong>：一旦理解了这三个部分是如何相互运作的，我们将会回到第一个部分（基于参数的函数映射），然后将其拓展为一个远比线性函数复杂的函数：首先是神经网络，然后是卷积神经网络。而损失函数和最优化过程这两个部分将会保持相对稳定。</p>
<h2 id="损失函数可视化"><a href="#损失函数可视化" class="headerlink" title="损失函数可视化"></a>损失函数可视化</h2><p>本课中讨论的损失函数一般都是定义在高维度的空间中（比如，在CIFAR-10中一个线性分类器的权重矩阵大小是[10x3073]，就有30730个参数），这样要将其可视化就很困难。然而办法还是有的，在1个维度或者2个维度的方向上对高维空间进行切片，就能得到一些直观感受。例如，随机生成一个权重矩阵$W$，该矩阵就与高维空间中的一个点对应。然后沿着某个维度方向前进的同时记录损失函数值的变化。换句话说，就是生成一个随机的方向$W_1$并且沿着此方向计算损失值，计算方法是根据不同的$a$值来计算$L(W+aW_1)$。这个过程将生成一个图表，其$x$轴是$a$值，$y$轴是损失函数值。同样的方法还可以用在两个维度上，通过改变$a,b$来计算损失值$L(W+aW_1+bW_2)$，从而给出二维的图像。在图像中，$a,b$可以分别用x和y轴表示，而损失函数的值可以用颜色变化表示：</p>
<img src="/2024/05/07/11-38-48/94dd0714f65ef94b3cbfff4780b1988d_b.png" class>
<p>一个无正则化的多类SVM的损失函数的图示。左边和中间只有一个样本数据，右边是CIFAR-10中的100个数据。<strong>左</strong>：a值变化在某个维度方向上对应的的损失值变化。<strong>中和右</strong>：两个维度方向上的损失值切片图，蓝色部分是低损失值区域，红色部分是高损失值区域。注意损失函数的分段线性结构。多个样本的损失值是总体的平均值，所以右边的碗状结构是很多的分段线性结构的平均（比如中间这个就是其中之一）。</p>
<p>我们可以通过数学公式来解释损失函数的分段线性结构。对于一个单独的数据，有损失函数的计算公式如下：  </p>
<p>$\large Li=\sum_{j\neq y_i}[max(0,w_j^Tx_i-w_{y_i}^Tx_i+1)]$</p>
<p>通过公式可见，每个样本的数据损失值是以$W$为参数的线性函数的总和（零阈值来源于$max(0,-)$函数）。$W$的每一行（即$w_j$），有时候它前面是一个正号（比如当它对应错误分类的时候），有时候它前面是一个负号（比如当它是是正确分类的时候）。为进一步阐明，假设有一个简单的数据集，其中包含有3个只有1个维度的点，数据集数据点有3个类别。那么完整的无正则化SVM的损失值计算如下：</p>
<p>$L_0=max(0,w^T_1x_0-w^T_0x_0+1)+max(0,w^T_2x_0-w^T_0x_0+1)$<br>$L_1=max(0,w^T_0x_1-w^T_1x_1+1)+max(0,w^T_2x_1-w^T_1x_1+1)$<br>$L_2=max(0,w^T_0x_2-w^T_2x_2+1)+max(0,w^T_1x_2-w^T_2x_2+1)$<br>$L=(L_0+L_1+L_2)/3$</p>
<p>因为这些例子都是一维的，所以数据$x_i$和权重$w_j$都是数字。观察$w_0$，可以看到上面的式子中一些项是$w_0$的线性函数，且每一项都会与0比较，取两者的最大值。可作图如下：</p>
<img src="/2024/05/07/11-38-48/3f6fbcd487b1c214e8fea1ea66eb413e_b.png" class>
<p>从一个维度方向上对数据损失值的展示。x轴方向就是一个权重，y轴就是损失值。数据损失是多个部分组合而成。其中每个部分要么是某个权重的独立部分，要么是该权重的线性函数与0阈值的比较。完整的SVM数据损失就是这个形状的30730维版本。  </p>
<p>需要多说一句的是，你可能根据SVM的损失函数的碗状外观猜出它是一个凸函数。。但是一旦我们将$f$函数扩展到神经网络，目标函数就就不再是凸函数了，图像也不会像上面那样是个碗状，而是凹凸不平的复杂地形形状。  </p>
<p>不可导的损失函数。作为一个技术笔记，你要注意到：由于max操作，损失函数中存在一些不可导点（kinks），这些点使得损失函数不可微，因为在这些不可导点，梯度是没有定义的。但是次梯度（subgradient）依然存在且常常被使用。在本课中，我们将交换使用次梯度和梯度两个术语。  </p>
<h2 id="最优化-Optimization"><a href="#最优化-Optimization" class="headerlink" title="最优化 Optimization"></a>最优化 Optimization</h2><p>重申一下：损失函数可以量化某个具体权重集<strong>W</strong>的质量。而最优化的目标就是找到能够最小化损失函数值的<strong>W</strong> 。我们现在就朝着这个目标前进，实现一个能够最优化损失函数的方法。对于有一些经验的同学，这节课看起来有点奇怪，因为使用的例子（SVM 损失函数）是一个凸函数问题。但是要记得，最终的目标是不仅仅对凸函数做最优化，而是能够最优化一个神经网络，而对于神经网络是不能简单的使用凸函数的最优化技巧的。  </p>
<p><strong>策略#1：一个差劲的初始方案：随机搜索</strong></p>
<p>既然确认参数集<strong>W</strong>的好坏蛮简单的，那第一个想到的（差劲）方法，就是可以随机尝试很多不同的权重，然后看其中哪个最好。过程如下：  </p>
<p>​<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">    <span class="comment"># 假设X_train的每一列都是一个数据样本（比如3073 x 50000）</span></span><br><span class="line">    <span class="comment"># 假设Y_train是数据样本的类别标签（比如一个长50000的一维数组）</span></span><br><span class="line">    <span class="comment"># 假设函数L对损失函数进行评价</span></span><br><span class="line">    </span><br><span class="line">    bestloss = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>) <span class="comment"># Python assigns the highest possible float value</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> xrange(<span class="number">1000</span>):</span><br><span class="line">      W = np.random.randn(<span class="number">10</span>, <span class="number">3073</span>) * <span class="number">0.0001</span> <span class="comment"># generate random parameters</span></span><br><span class="line">      loss = L(X_train, Y_train, W) <span class="comment"># get the loss over the entire training set</span></span><br><span class="line">      <span class="keyword">if</span> loss &amp;lt; bestloss: <span class="comment"># keep track of the best solution</span></span><br><span class="line">        bestloss = loss</span><br><span class="line">        bestW = W</span><br><span class="line">      <span class="built_in">print</span> <span class="string">&#x27;in attempt %d the loss was %f, best %f&#x27;</span> % (num, loss, bestloss)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 输出:</span></span><br><span class="line">    <span class="comment"># in attempt 0 the loss was 9.401632, best 9.401632</span></span><br><span class="line">    <span class="comment"># in attempt 1 the loss was 8.959668, best 8.959668</span></span><br><span class="line">    <span class="comment"># in attempt 2 the loss was 9.044034, best 8.959668</span></span><br><span class="line">    <span class="comment"># in attempt 3 the loss was 9.278948, best 8.959668</span></span><br><span class="line">    <span class="comment"># in attempt 4 the loss was 8.857370, best 8.857370</span></span><br><span class="line">    <span class="comment"># in attempt 5 the loss was 8.943151, best 8.857370</span></span><br><span class="line">    <span class="comment"># in attempt 6 the loss was 8.605604, best 8.605604</span></span><br><span class="line">    <span class="comment"># ... (trunctated: continues for 1000 lines)</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">在上面的代码中，我们尝试了若干随机生成的权重矩阵**W**，其中某些的损失值较小，而另一些的损失值大些。我们可以把这次随机搜索中找到的最好的权重**W**取出，然后去跑测试集：  </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 假设X_test尺寸是[3073 x 10000], Y_test尺寸是[10000 x 1]</span></span><br><span class="line">    scores = Wbest.dot(Xte_cols) <span class="comment"># 10 x 10000, the class scores for all test examples</span></span><br><span class="line">    <span class="comment"># 找到在每列中评分值最大的索引（即预测的分类）</span></span><br><span class="line">    Yte_predict = np.argmax(scores, axis = <span class="number">0</span>)</span><br><span class="line">    <span class="comment"># 以及计算准确率</span></span><br><span class="line">    np.mean(Yte_predict == Yte)</span><br><span class="line">    <span class="comment"># 返回 0.1555</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>验证集上表现最好的权重<strong>W</strong>跑测试集的准确率是<strong>15.5%，</strong>而完全随机猜的准确率是10%，如此看来，这个准确率对于这样一个不经过大脑的策略来说，还算不错嘛！  </p>
<p><strong>核心思路：迭代优化</strong>。当然，我们肯定能做得更好些。核心思路是：虽然找到最优的权重<strong>W</strong>非常困难，甚至是不可能的（尤其当<strong>W</strong>中存的是整个神经网络的权重的时候），但如果问题转化为：对一个权重矩阵集<strong>W</strong>取优，使其损失值稍微减少。那么问题的难度就大大降低了。换句话说，我们的方法从一个随机的<strong>W</strong>开始，然后对其迭代取优，每次都让它的损失值变得更小一点。  </p>
<p>&gt; 我们的策略是从随机权重开始，然后迭代取优，从而获得更低的损失值。  </p>
<p><strong>蒙眼徒步者的比喻</strong>：一个助于理解的比喻是把你自己想象成一个蒙着眼睛的徒步者，正走在山地地形上，目标是要慢慢走到山底。在CIFAR-10的例子中，这山是30730维的（因为<strong>W</strong>是3073x10）。我们在山上踩的每一点都对应一个的损失值，该损失值可以看做该点的海拔高度。  </p>
<p><strong>策略#2：随机本地搜索</strong></p>
<p>第一个策略可以看做是每走一步都尝试几个随机方向，如果某个方向是向山下的，就向该方向走一步。这次我们从一个随机$W$开始，然后生成一个随机的扰动$\delta W$ ，只有当$W+\delta W$的损失值变低，我们才会更新。</p>
<img src="/2024/05/07/11-38-48/4_1.jpg" class>
<blockquote>
<p>加入扰动后的梯度计算如图所示<br>这个过程的具体代码如下：  </p>
</blockquote>
<p>​<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">W = np.random.randn(<span class="number">10</span>, <span class="number">3073</span>) * <span class="number">0.001</span> <span class="comment"># 生成随机初始W</span></span><br><span class="line">bestloss = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1000</span>):</span><br><span class="line">  step_size = <span class="number">0.0001</span></span><br><span class="line">  Wtry = W + np.random.randn(<span class="number">10</span>, <span class="number">3073</span>) * step_size</span><br><span class="line">  loss = L(Xtr_cols, Ytr, Wtry)</span><br><span class="line">  <span class="keyword">if</span> loss &amp;lt; bestloss:</span><br><span class="line">    W = Wtry</span><br><span class="line">    bestloss = loss</span><br><span class="line">  <span class="built_in">print</span> <span class="string">&#x27;iter %d loss is %f&#x27;</span> % (i, bestloss)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>使用同样的数据（1000），这个方法可以得到<strong>21.4%</strong>的分类准确率。这个比策略一好，但是依然过于浪费计算资源。  </p>
<p><strong>策略#3：跟随梯度</strong>  </p>
<p>前两个策略中，我们是尝试在权重空间中找到一个方向，沿着该方向能降低损失函数的损失值。其实不需要随机寻找方向，因为可以直接计算出最好的方向，这就是从数学上计算出最陡峭的方向。这个方向就是损失函数的<strong>梯度（gradient）</strong>。在蒙眼徒步者的比喻中，这个方法就好比是感受我们脚下山体的倾斜程度，然后向着最陡峭的下降方向下山。</p>
<p>在一维函数中，斜率是函数在某一点的瞬时变化率。梯度是函数的斜率的一般化表达，它不是一个值，而是一个向量。在输入空间中，梯度是各个维度的斜率组成的向量（或者称为导数<strong>derivatives</strong>）。对一维函数的求导公式如下：</p>
<p>$\frac{df(x)}{dx}=\displaystyle\lim_{h\to0}\frac{f(x+h)-f(x)}{h}$</p>
<p>当函数有多个参数的时候，我们称导数为偏导数。而梯度就是在每个维度上偏导数所形成的向量。</p>
<h2 id="梯度计算"><a href="#梯度计算" class="headerlink" title="梯度计算"></a>梯度计算</h2><p>计算梯度有两种方法：一个是缓慢的近似方法（<strong>数值梯度法</strong>），但实现相对简单。另一个方法（<strong>分析梯度法</strong>）计算迅速，结果精确，但是实现时容易出错，且需要使用微分。现在对两种方法进行介绍：</p>
<p><strong>利用有限差值计算梯度</strong></p>
<p>上节中的公式已经给出数值计算梯度的方法。下面代码是一个输入为函数<strong>f</strong>和向量<strong>x，</strong>计算<strong>f</strong>的梯度的通用函数，它返回函数<strong>f</strong>在点<strong>x处</strong>的梯度：</p>
<p>​<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">eval_numerical_gradient</span>(<span class="params">f, x</span>):</span><br><span class="line">  <span class="string">&quot;&quot;&quot;  </span></span><br><span class="line"><span class="string">  一个f在x处的数值梯度法的简单实现</span></span><br><span class="line"><span class="string">  - f是只有一个参数的函数</span></span><br><span class="line"><span class="string">  - x是计算梯度的点</span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span> </span><br><span class="line"></span><br><span class="line">  fx = f(x) <span class="comment"># 在原点计算函数值</span></span><br><span class="line">  grad = np.zeros(x.shape)</span><br><span class="line">  h = <span class="number">0.00001</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 对x中所有的索引进行迭代</span></span><br><span class="line">  it = np.nditer(x, flags=[<span class="string">&#x27;multi_index&#x27;</span>], op_flags=[<span class="string">&#x27;readwrite&#x27;</span>])</span><br><span class="line">  <span class="keyword">while</span> <span class="keyword">not</span> it.finished:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算x+h处的函数值</span></span><br><span class="line">    ix = it.multi_index</span><br><span class="line">    old_value = x[ix]</span><br><span class="line">    x[ix] = old_value + h <span class="comment"># 增加h</span></span><br><span class="line">    fxh = f(x) <span class="comment"># 计算f(x + h)</span></span><br><span class="line">    x[ix] = old_value <span class="comment"># 存到前一个值中 (非常重要)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算偏导数</span></span><br><span class="line">    grad[ix] = (fxh - fx) / h <span class="comment"># 坡度</span></span><br><span class="line">    it.iternext() <span class="comment"># 到下个维度</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> grad</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>根据上面的梯度公式，代码对所有维度进行迭代，在每个维度上产生一个很小的变化$h$，通过观察函数值变化，计算函数在该维度上的偏导数。最后，所有的梯度存储在变量$grad$中。</p>
<p><strong>实践考量</strong>：注意在数学公式中，$h$的取值是趋近于0的，然而在实际中，用一个很小的数值（比如例子中的1e-5）就足够了。在不产生数值计算出错的理想前提下，你会使用尽可能小的$h$。还有，实际中用<strong>中心差值公式（centered difference formula）</strong>$[f(x+h)-f(x-h)]/2h$效果较好。</p>
<p>可以使用上面这个公式来计算任意函数在任意点上的梯度。下面计算权重空间中的某些随机点上，CIFAR-10损失函数的梯度：</p>
<p>​<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 要使用上面的代码我们需要一个只有一个参数的函数</span></span><br><span class="line"><span class="comment"># (在这里参数就是权重)所以也包含了X_train和Y_train</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">CIFAR10_loss_fun</span>(<span class="params">W</span>):</span><br><span class="line">  <span class="keyword">return</span> L(X_train, Y_train, W)</span><br><span class="line"></span><br><span class="line">W = np.random.rand(<span class="number">10</span>, <span class="number">3073</span>) * <span class="number">0.001</span> <span class="comment"># 随机权重向量</span></span><br><span class="line">df = eval_numerical_gradient(CIFAR10_loss_fun, W) <span class="comment"># 得到梯度</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>梯度告诉我们损失函数在每个维度上的斜率，以此来进行更新：  </p>
<p>​<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">loss_original = CIFAR10_loss_fun(W) <span class="comment"># 初始损失值</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;original loss: %f&#x27;</span> % (loss_original, )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看不同步长的效果</span></span><br><span class="line"><span class="keyword">for</span> step_size_log <span class="keyword">in</span> [-<span class="number">10</span>, -<span class="number">9</span>, -<span class="number">8</span>, -<span class="number">7</span>, -<span class="number">6</span>, -<span class="number">5</span>,-<span class="number">4</span>,-<span class="number">3</span>,-<span class="number">2</span>,-<span class="number">1</span>]:</span><br><span class="line">  step_size = <span class="number">10</span> ** step_size_log</span><br><span class="line">  W_new = W - step_size * df <span class="comment"># 权重空间中的新位置</span></span><br><span class="line">  loss_new = CIFAR10_loss_fun(W_new)</span><br><span class="line">  <span class="built_in">print</span> <span class="string">&#x27;for step size %f new loss: %f&#x27;</span> % (step_size, loss_new)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出:</span></span><br><span class="line"><span class="comment"># original loss: 2.200718</span></span><br><span class="line"><span class="comment"># for step size 1.000000e-10 new loss: 2.200652</span></span><br><span class="line"><span class="comment"># for step size 1.000000e-09 new loss: 2.200057</span></span><br><span class="line"><span class="comment"># for step size 1.000000e-08 new loss: 2.194116</span></span><br><span class="line"><span class="comment"># for step size 1.000000e-07 new loss: 2.135493</span></span><br><span class="line"><span class="comment"># for step size 1.000000e-06 new loss: 1.647802</span></span><br><span class="line"><span class="comment"># for step size 1.000000e-05 new loss: 2.844355</span></span><br><span class="line"><span class="comment"># for step size 1.000000e-04 new loss: 25.558142</span></span><br><span class="line"><span class="comment"># for step size 1.000000e-03 new loss: 254.086573</span></span><br><span class="line"><span class="comment"># for step size 1.000000e-02 new loss: 2539.370888</span></span><br><span class="line"><span class="comment"># for step size 1.000000e-01 new loss: 25392.214036</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p><strong>在梯度负方向上更新</strong>：在上面的代码中，为了计算$W_new$，要注意我们是向着梯度$df$的负方向去更新，这是因为我们希望损失函数值是降低而不是升高。</p>
<p><strong>步长的影响</strong>：梯度指明了函数在哪个方向是变化率最大的，但是没有指明在这个方向上应该走多远。在后续的课程中可以看到，选择步长（也叫作_习率）将会是神经网络训练中最重要的超参数设定之一。还是用蒙眼徒步者下山的比喻，这就好比我们可以感觉到脚朝向的不同方向上，地形的倾斜程度不同。但是该跨出多长的步长呢？不确定。如果谨慎地小步走，情况可能比较稳定但是进展较慢（这就是步长较小的情况）。相反，如果想尽快下山，那就大步走吧，但结果也不一定尽如人意。在上面的代码中就能看见反例，在某些点如果步长过大，反而可能越过最低点导致更高的损失值。</p>
<img src="/2024/05/07/11-38-48/d8b52b9b9ca31e2132c436c39af2943c_b.jpg" class>
<p>将步长效果视觉化的图例。从某个具体的点W开始计算梯度（白箭头方向是负梯度方向），梯度告诉了我们损失函数下降最陡峭的方向。小步长下降稳定但进度慢，大步长进展快但是风险更大。采取大步长可能导致错过最优点，让损失值上升。步长（后面会称其为<strong>学习率</strong>）将会是我们在调参中最重要的超参数之一。  </p>
<p><strong>效率问题</strong>：你可能已经注意到，计算数值梯度的复杂性和参数的量线性相关。在本例中有30730个参数，所以损失函数每走一步就需要计算30731次损失函数的梯度。现代神经网络很容易就有上千万的参数，因此这个问题只会越发严峻。显然这个策略不适合大规模数据，我们需要更好的策略。</p>
<h3 id="微分分析计算梯度"><a href="#微分分析计算梯度" class="headerlink" title="微分分析计算梯度"></a>微分分析计算梯度</h3><p>使用有限差值近似计算梯度比较简单，但缺点在于终究只是近似（因为我们对于$h$值是选取了一个很小的数值，但真正的梯度定义中$h$趋向0的极限），且耗费计算资源太多。第二个梯度计算方法是利用微分来分析，能得到计算梯度的公式（不是近似），用公式计算梯度速度很快，唯一不好的就是实现的时候容易出错。为了解决这个问题，在实际操作时常常将分析梯度法的结果和数值梯度法的结果作比较，以此来检查其实现的正确性，这个步骤叫做<strong>梯度检查</strong>。</p>
<p>用SVM的损失函数在某个数据点上的计算来举例：</p>
<p>$L_i=\displaystyle\sum_{j\not =y_i}[max(0,w^T_jx_i-w^T_{y_i}x_i+\delta)]$ </p>
<p>可以对函数进行微分。比如，对$w_{y_i}$进行微分得到：</p>
<p>$\displaystyle\nabla_{w_{y_i}}L_i=-(\sum_{j\not=y_i}\mathbb{1}(w^T_jx_i-w^T_{y_i}x_i+\delta&gt;0))x_i$</p>
<p>其中$\mathbb{1}$是一个示性函数，如果括号中的条件为真，那么函数值为1，如果为假，则函数值为0。虽然上述公式看起来复杂，但在代码实现的时候比较简单：只需要计算没有满足边界值的分类的数量（因此对损失函数产生了贡献），然后乘以$x_i$就是梯度了。注意，这个梯度只是对应正确分类的W的行向量的梯度，那些$j\not =y_i$行的梯度是：  </p>
<p>$\displaystyle\nabla_{w_j}L_i=\mathbb{1}(w^T_jx_i-w^T_{y_i}x_i+\delta&gt;0)x_i$  </p>
<p>一旦将梯度的公式微分出来，代码实现公式并用于梯度更新就比较顺畅了。  </p>
<h2 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h2><p>现在可以计算损失函数的梯度了，程序重复地计算梯度然后对参数进行更新，这一过程称为梯度下降，他的<strong>普通</strong>版本是这样的：  </p>
<p>​<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 普通的梯度下降</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">  weights_grad = evaluate_gradient(loss_fun, data, weights)</span><br><span class="line">  weights += - step_size * weights_grad <span class="comment"># 进行梯度更新</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>这个简单的循环在所有的神经网络核心库中都有。虽然也有其他实现最优化的方法（比如LBFGS），但是到目前为止，梯度下降是对神经网络的损失函数最优化中最常用的方法。课程中，我们会在它的循环细节增加一些新的东西（比如更新的具体公式），但是核心思想不变，那就是我们一直跟着梯度走，直到结果不再变化。</p>
<p><strong>小批量数据梯度下降（Mini-batch gradient descent）</strong>：在大规模的应用中（比如ILSVRC挑战赛），训练数据可以达到百万级量级。如果像这样计算整个训练集，来获得仅仅一个参数的更新就太浪费了。一个常用的方法是计算训练集中的<strong>小批量（batches）</strong>数据。例如，在目前最高水平的卷积神经网络中，一个典型的小批量包含256个例子，而整个训练集是多少呢？一百二十万个。这个小批量数据就用来实现一个参数更新：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 普通的小批量数据梯度下降</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">  data_batch = sample_training_data(data, <span class="number">256</span>) <span class="comment"># 256个数据</span></span><br><span class="line">  weights_grad = evaluate_gradient(loss_fun, data_batch, weights)</span><br><span class="line">  weights += - step_size * weights_grad <span class="comment"># 参数更新</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个方法之所以效果不错，是因为训练集中的数据都是相关的。要理解这一点，可以想象一个极端情况：在ILSVRC中的120万个图像是1000张不同图片的复制（每个类别1张图片，每张图片有1200张复制）。那么显然计算这1200张复制图像的梯度就应该是一样的。对比120万张图片的数据损失的均值与只计算1000张的子集的数据损失均值时，结果应该是一样的。实际情况中，数据集肯定不会包含重复图像，那么小批量数据的梯度就是对整个数据集梯度的一个近似。因此，在实践中通过计算小批量数据的梯度可以实现更快速地收敛，并以此来进行更频繁的参数更新。</p>
<p>小批量数据策略有个极端情况，那就是每个批量中只有1个数据样本，这种策略被称为<strong>随机梯度下降（Stochastic Gradient Descent 简称SGD）</strong>，有时候也被称为在线梯度下降。这种策略在实际情况中相对少见，因为向量化操作的代码一次计算100个数据 比100次计算1个数据要高效很多。即使SGD在技术上是指每次使用1个数据来计算梯度，你还是会听到人们使用SGD来指代小批量数据梯度下降（或者用MGD来指代小批量数据梯度下降，而BGD来指代则相对少见）。小批量数据的大小是一个超参数，但是一般并不需要通过交叉验证来调参。它一般由存储器的限制来决定的，或者干脆设置为同样大小，比如32，64，128等。之所以使用2的指数，是因为在实际中许多向量化操作实现的时候，如果输入数据量是2的倍数，那么运算更快。</p>
<p><strong>两个潜在问题：</strong></p>
<ul>
<li>学习率如果过大，那么就会出现震荡的情况，学习率过小的话，虽然没有震荡情况出现，但是学习速度会很慢，这个问题在技术上有时候被称为具有高条件数的问题</li>
<li>存在局部最小点和鞍点，在某些维度上可能无法优化，也就是高维度下优化难题，这样模型无法达到最佳</li>
</ul>
<p>或者可以使用动量法进行优化，尝试越过鞍点和局部最小点，会产生很不错的效果，同时还可以抑制震荡，是一种很有用的方法</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><img src="/2024/05/07/11-38-48/03b3eccf18ee3760e219f9f95ec14305_b.png" class>
<p>信息流的总结图例。数据集中的$(x,y)$是给定的。权重从一个随机数字开始，且可以改变。在前向传播时，评分函数计算出类别的分类评分并存储在向量$f$中。损失函数包含两个部分：数据损失和正则化损失。其中，数据损失计算的是分类评分$f$和实际标签$y$之间的差异，正则化损失只是一个关于权重的函数。在梯度下降过程中，我们计算权重的梯度（如果愿意的话，也可以计算数据上的梯度），然后使用它们来实现参数的更新。</p>
<p>在本节课中：</p>
<ul>
<li>将损失函数比作了一个<strong>高维度的最优化地形</strong>，并尝试到达它的最底部。最优化的工作过程可以看做一个蒙着眼睛的徒步者希望摸索着走到山的底部。在例子中，可见SVM的损失函数是分段线性的，并且是碗状的。</li>
<li>提出了迭代优化的思想，从一个随机的权重开始，然后一步步地让损失值变小，直到最小。</li>
<li>函数的<strong>梯度</strong>给出了该函数最陡峭的上升方向。介绍了利用有限的差值来近似计算梯度的方法，该方法实现简单但是效率较低（有限差值就是$h$，用来计算数值梯度）。</li>
<li>参数更新需要有技巧地设置<strong>步长</strong>。也叫学习率。如果步长太小，进度稳定但是缓慢，如果步长太大，进度快但是可能有风险。</li>
<li>讨论权衡了数值梯度法和分析梯度法。数值梯度法计算简单，但结果只是近似且耗费计算资源。分析梯度法计算准确迅速但是实现容易出错，而且需要对梯度公式进行推导的数学基本功。因此，在实际中使用分析梯度法，然后使用<strong>梯度检查</strong>来检查其实现正确与否，其本质就是将分析梯度法的结果与数值梯度法的计算结果对比。</li>
</ul>
<ul>
<li>介绍了<strong>梯度下降</strong>算法，它在循环中迭代地计算梯度并更新参数。</li>
</ul>
]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>计算机视觉, 图像处理, 深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机视觉 线性分类器</title>
    <url>/2024/05/06/15-22-39/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.05.06：初稿</li>
</ul>
<h2 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h2><ul>
<li><a href="/2024/05/06/10-28-51/" title="eecs498 ML-DL-CV 笔记汇总">计算机视觉-笔记汇总</a>
</li>
</ul>
<h1 id="线性分类"><a href="#线性分类" class="headerlink" title="线性分类"></a>线性分类</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>上一篇笔记介绍了图像分类问题。图像分类的任务，就是从已有的固定分类标签集合中选择一个并分配给一张图像。我们还介绍了k-Nearest Neighbor （k-NN）分类器，该分类器的基本思想是通过将测试图像与训练集带标签的图像进行比较，来给测试图像打上分类标签。k-Nearest Neighbor分类器存在以下不足：</p>
<ul>
<li>分类器必须记住所有训练数据并将其存储起来，以便于未来测试数据用于比较。这在存储空间上是低效的，数据集的大小很容易就以GB计。</li>
<li>对一个测试图像进行分类需要和所有训练图像作比较，算法计算资源耗费高。</li>
</ul>
<p>所有我们使用了一种更广泛的构建机器学习模型的方法，那就是参数方法，这种方法的想法是参数可学习</p>
<p><strong>概述</strong>：我们将要实现一种更强大的方法来解决图像分类问题，该方法可以自然地延伸到神经网络和卷积神经网络上。这种方法主要有两部分组成：一个是<strong>评分函数（score function）</strong>，它是原始图像数据到类别分值的映射。另一个是<strong>损失函数（loss function）</strong>，它是用来量化预测分类标签的得分与真实标签之间一致性的。该方法可转化为一个最优化问题，在最优化过程中，将通过更新评分函数的参数来最小化损失函数值。</p>
<h2 id="从图像到标签分值的参数化映射"><a href="#从图像到标签分值的参数化映射" class="headerlink" title="从图像到标签分值的参数化映射"></a>从图像到标签分值的参数化映射</h2><p>该方法的第一部分就是定义一个评分函数，这个函数将图像的像素值映射为各个分类类别的得分，得分高低代表图像属于该类别的可能性高低。下面会利用一个具体例子来展示该方法。现在假设有一个包含很多图像的训练集$x_{i}\in R^{D}$，每个图像都有一个对应的分类标签$y_{i}$。这里$y=1,2,3…N$并且$y_{i}\in 1…K$。这就是说，我们有<strong>N</strong>个图像样例，每个图像的维度是<strong>D</strong>，共有<strong>K</strong>种不同的分类。</p>
<p>举例来说，在CIFAR-10中，我们有一个<strong>N</strong>=50000的训练集，每个图像有<strong>D</strong>=32x32x3=3072个像素，而<strong>K</strong>=10，这是因为图片被分为10个不同的类别（狗，猫，汽车等）。我们现在定义评分函数为：$f:R^{D}\rightarrow R^{K}$，该函数是原始图像像素到分类分值的映射。</p>
<p><strong>线性分类器</strong>：在本模型中，我们从最简单的概率函数开始，单变量线性映射：  </p>
<p>$f(x_{i},W,b)=Wx_{i}+b$</p>
<p>在上面的公式中，假设每个图像数据都被拉长为一个长度为D的列向量，大小为[D x 1]。其中大小为[K x D]的矩阵<strong>W</strong>和大小为[K x 1]列向量<strong>b</strong>为该函数的<strong>参数（parameters）</strong>。还是以CIFAR-10为例，$x_i$就包含了第i个图像的所有像素信息，这些信息被拉成为一个[3072 x 1]的列向量，<strong>W</strong>大小为[10x3072]，<strong>b</strong>的大小为[10x1]。因此，3072个数字（原始像素数值）输入函数，函数输出10个数字（不同分类得到的分值）。参数<strong>W</strong>被称为<strong>权重（weights）</strong>。<strong>b</strong>被称为<strong>偏差向量（bias vector）</strong>，这是因为它影响输出数值，但是并不和原始数据$x_i$产生关联。在实际情况中，人们常常混用<strong>权重</strong>和<strong>参数</strong>这两个术语。</p>
<p>需要注意的几点：</p>
<ul>
<li>首先，一个单独的矩阵乘法$W_{x_{i}}$就高效地并行评估10个不同的分类器（每个分类器针对一个分类），其中每个类的分类器就是W的一个行向量。</li>
<li>注意我们认为输入数据$(x_{i},y_{i})$是给定且不可改变的，但参数<strong>W</strong>和<strong>b</strong>是可控制改变的。我们的目标就是通过设置这些参数，使得计算出来的分类分值情况和训练集中图像数据的真实类别标签相符。在接下来的课程中，我们将详细介绍如何做到这一点，但是目前只需要直观地让正确分类的分值比错误分类的分值高即可。</li>
<li>该方法的一个优势是训练数据是用来学习到参数<strong>W</strong>和<strong>b</strong>的，一旦训练完成，训练数据就可以丢弃，留下学习到的参数即可。这是因为一个测试图像可以简单地输入函数，并基于计算出的分类分值来进行分类。</li>
<li>最后，注意只需要做一个矩阵乘法和一个矩阵加法就能对一个测试数据分类，这比k-NN中将测试图像和所有训练数据做比较的方法快多了。</li>
<li>当然，我们这里只是将偏差作为一个单独的可学习参数，我们也可以进行合并，将其合并到权重矩阵之中，这样的方式无非就是给权重矩阵扩张一下列向量，并且给输入向量增加一个常量维度</li>
</ul>
<p>&gt; 预告：卷积神经网络映射图像像素值到分类分值的方法和上面一样，但是映射 <strong>(f)</strong> 就要复杂多了，其包含的参数也更多。</p>
<h2 id="理解线性分类器"><a href="#理解线性分类器" class="headerlink" title="理解线性分类器"></a>理解线性分类器</h2><p>线性分类器计算图像中3个颜色通道中所有像素的值与权重的矩阵乘，从而得到分类分值。根据我们对权重设置的值，对于图像中的某些位置的某些颜色，函数表现出喜好或者厌恶（根据每个权重的符号而定）。举个例子，可以想象”船”分类就是被大量的蓝色所包围（对应的就是水）。那么”船”分类器在蓝色通道上的权重就有很多的正权重（它们的出现提高了”船”分类的分值），而在绿色和红色通道上的权重为负的就比较多（它们的出现降低了”船”分类的分值）。</p>
<img src="/2024/05/06/15-22-39/7c204cd1010c0af1e7b50000bfff1d8e_b.jpg" class>
<p>一个将图像映射到分类分值的例子。为了便于可视化，假设图像只有4个像素（都是黑白像素，这里不考虑RGB通道），有3个分类（红色代表猫，绿色代表狗，蓝色代表船，注意，这里的红、绿和蓝3种颜色仅代表分类，和RGB通道没有关系）。首先将图像像素拉伸为一个列向量，与W进行矩阵乘，然后得到各个分类的分值。需要注意的是，这个W一点也不好：猫分类的分值非常低。从上图来看，算法倒是觉得这个图像是一只狗。  </p>
<p><strong>将图像看做高维度的点</strong>：既然图像被伸展成为了一个高维度的列向量，那么我们可以把图像看做这个高维度空间中的一个点（即每张图像是3072维空间中的一个点）。整个数据集就是一个点的集合，每个点都带有1个分类标签。</p>
<p>既然定义每个分类类别的分值是权重和图像的矩阵乘，那么每个分类类别的分数就是这个空间中的一个线性函数的函数值。我们没办法可视化3072维空间中的线性函数，但假设把这些维度挤压到二维，那么就可以看看这些分类器在做什么了：</p>
<img src="/2024/05/06/15-22-39/cfcb46408daa5353c38cb37e9bb6eb01_b.jpg" class>
<p>图像空间的示意图。其中每个图像是一个点，有3个分类器。以红色的汽车分类器为例，红线表示空间中汽车分类分数为0的点的集合，红色的箭头表示分值上升的方向。所有红线右边的点的分数值均为正，且线性升高。红线左边的点分值为负，且线性降低。  </p>
<p>从上面可以看到，<strong>W</strong>的每一行都是一个分类类别的分类器。对于这些数字的几何解释是：如果改变其中一行的数字，会看见分类器在空间中对应的直线开始向着不同方向旋转。而偏差<strong>b</strong>，则允许分类器对应的直线平移。需要注意的是，如果没有偏差，无论权重如何，在$x_i=0$时分类分值始终为0。这样所有分类器的线都不得不穿过原点。</p>
<p><strong>将线性分类器看做模板匹配</strong>：关于权重<strong>W</strong>的另一个解释是<strong>它</strong>的每一行对应着一个分类的模板（有时候也叫作原型）。一张图像对应不同分类的得分，是通过使用内积（也叫点积）来比较图像和模板，然后找到和哪个模板最相似。从这个角度来看，线性分类器就是在利用学习到的模板，针对图像做模板匹配。从另一个角度来看，可以认为还是在高效地使用k-NN，不同的是我们没有使用所有的训练集的图像来比较，而是每个类别只用了一张图片（这张图片是我们学习到的，而不是训练集中的某一张），而且我们会使用（负）内积来计算向量间的距离，而不是使用L1或者L2距离。</p>
<img src="/2024/05/06/15-22-39/13e72e4ce83c11b49d36bbbb51d29ab4_b.jpg" class>
<p>将课程进度快进一点。这里展示的是以CIFAR-10为训练集，学习结束后的权重的例子。注意，船的模板如期望的那样有很多蓝色像素。如果图像是一艘船行驶在大海上，那么这个模板利用内积计算图像将给出很高的分数。  </p>
<p>可以看到马的模板看起来似乎是两个头的马，这是因为训练集中的马的图像中马头朝向各有左右造成的。线性分类器将这两种情况融合到一起了。类似的，汽车的模板看起来也是将几个不同的模型融合到了一个模板中，并以此来分辨不同方向不同颜色的汽车。这个模板上的车是红色的，这是因为CIFAR-10中训练集的车大多是红色的。线性分类器对于不同颜色的车的分类能力是很弱的，但是后面可以看到神经网络是可以完成这一任务的。神经网络可以在它的隐藏层中实现中间神经元来探测不同种类的车（比如绿色车头向左，蓝色车头向前等）。而下一层的神经元通过计算不同的汽车探测器的权重和，将这些合并为一个更精确的汽车分类分值。</p>
<p><strong>偏差和权重的</strong>合并技巧：在进一步学习前，要提一下这个经常使用的技巧。它能够将我们常用的参数W和b合二为一。回忆一下，分类评分函数定义为：</p>
<p>$f(x_{i},W,b)=Wx_{i}+b$</p>
<p>分开处理这两个参数（权重参数<strong>W</strong>和偏差参数<strong>b</strong>）有点笨拙，一般常用的方法是把两个参数放到同一个矩阵中，同时$x_{i}$向量就要增加一个维度，这个维度的数值是常量1，这就是默认的<em>偏差维度</em>。这样新的公式就简化成下面这样：</p>
<p>$f(x_{i},W)=W{x_{i}}$</p>
<p>还是以CIFAR-10为例，那么$x_i$的大小就变成 <strong>[3073x1]</strong>，而不是 <strong>[3072x1]</strong> 了，多出了包含常量1的1个维度）。$W$大小就是 <strong>[10x3073]</strong> 了。$W$中多出来的这一列对应的就是偏差值b，具体见下图：</p>
<img src="/2024/05/06/15-22-39/3c69a5c87a43bfb07e2b59bfcbd2f149_b.jpg" class>
<p>偏差技巧的示意图。左边是先做矩阵乘法然后做加法，右边是将所有输入向量的维度增加1个含常量1的维度，并且在权重矩阵中增加一个偏差列，最后做一个矩阵乘法即可。左右是等价的。通过右边这样做，我们就只需要学习一个权重矩阵，而不用去学习两个分别装着权重和偏差的矩阵了。</p>
<p><strong>图像数据预处理</strong>：在上面的例子中，所有图像都是使用的原始像素值（从0到255）。在机器学习中，对于输入的特征做归一化（normalization）处理是常见的套路。而在图像分类的例子中，图像上的每个像素可以看做一个特征。在实践中，对每个特征减去平均值来<strong>中心化</strong>数据是非常重要的。在这些图片的例子中，该步骤意味着根据训练集中所有的图像计算出一个平均图像值，然后每个图像都减去这个平均值，这样图像的像素值就大约分布在[-127, 127]之间了。下一个常见步骤是，让所有数值分布的区间变为[-1, 1]。<strong>零均值的中心化</strong>是很重要的，等我们理解了梯度下降后再来详细解释。</p>
<h2 id="损失函数-Loss-function"><a href="#损失函数-Loss-function" class="headerlink" title="损失函数 Loss function"></a>损失函数 Loss function</h2><p>在上一节定义了从图像像素值到所属类别的评分函数（score function），该函数的参数是权重矩阵$W$。在函数中，数据$(x_i,y_i)$是给定的，不能修改。但是我们可以调整权重矩阵这个参数，使得评分函数的结果与训练数据集中图像的真实类别一致，即评分函数在正确的分类的位置应当得到最高的评分（score）。</p>
<p>回到之前那张猫的图像分类例子，它有针对”猫”，”狗”，”船”三个类别的分数。我们看到例子中权重值非常差，因为猫分类的得分非常低（-96.8），而狗（437.9）和船（61.95）比较高。我们将使用<strong>损失函数（Loss Function）</strong>-样本误差（有时也叫<strong>代价函数</strong>Cost Function-单个误差或<strong>目标函数</strong>Objective）来衡量我们对结果的不满意程度。直观地讲，当评分函数输出结果与真实结果之间差异越大，损失函数输出越大，反之越小。</p>
<p>同时，损失函数有多种类型，不同类型有不同偏好，我们在不同任务中可以选择不同类型的损失函数。</p>
<h2 id="多类支持向量机损失-Multiclass-Support-Vector-Machine-Loss"><a href="#多类支持向量机损失-Multiclass-Support-Vector-Machine-Loss" class="headerlink" title="多类支持向量机损失 Multiclass Support Vector Machine Loss"></a>多类支持向量机损失 Multiclass Support Vector Machine Loss</h2><p>损失函数的具体形式多种多样。首先，介绍常用的多类支持向量机（SVM）损失函数。SVM的损失函数想要SVM在正确分类上的得分始终比不正确分类上的得分高出一个边界值$\delta$。我们可以把损失函数想象成一个人，这位SVM先生（或者女士）对于结果有自己的品位，如果某个结果能使得损失值更低，那么SVM就更加喜欢它。</p>
<p>让我们更精确一些。回忆一下，第i个数据中包含图像$x_i$的像素和代表正确类别的标签$y_i$。评分函数输入像素数据，然后通过公式 $f(x_i,W)$来计算不同分类类别的分值。这里我们将分值简写为$s$。比如，针对第j个类别的得分就是第j个元素：$s_{j}=f(x_{i},W)$。针对第i个数据的多类SVM的损失函数定义如下：</p>
<p>$L_i=\sum_{j\not=y_i}\max(0,s_j-s_{y_i}+\Delta)$</p>
<p><strong>举例</strong>：用一个例子演示公式是如何计算的。假设有3个分类，并且得到了分值$s = [13,-7,11]$。其中第一个类别是正确类别，即$y_i=0$。同时假设$\Delta$是10（后面会详细介绍该超参数）。上面的公式是将所有不正确分类（$j\not=y_i$）加起来，所以我们得到两个部分：  </p>
<p>$L_i=\max(0,-7-13+10)+\max(0,11-13+10)$</p>
<p>可以看到第一个部分结果是0，这是因为[-7-13+10]得到的是负数，经过$\max(0,-)$函数处理后得到0。这一对类别分数和标签的损失值是0，这是因为正确分类的得分13与错误分类的得分-7的差为20，高于边界值10。而SVM只关心差距至少要大于10，更大的差值还是算作损失值为0。第二个部分计算[11-13+10]得到8。虽然正确分类的得分比不正确分类的得分要高（13&gt;11），但是比10的边界值还是小了，分差只有2，这就是为什么损失值等于8。简而言之，SVM的损失函数想要正确分类类别$y_i$的分数比不正确类别分数高，而且至少要高$\Delta$。如果不满足这点，就开始计算损失值。</p>
<p>那么在这次的模型中，我们面对的是线性评分函数($f(x_i,W)=Wx_i$)，所以我们可以将损失函数的公式稍微改写一下：</p>
<p>$L_i=\sum_{j\not=y_i}\max(0,w^T_jx_i-w^T_{y_i}x_i+\Delta)$</p>
<p>其中$w_j$是权重$W$的第j行，被变形为列向量。然而，一旦开始考虑更复杂的评分函数$f$公式，这样做就不是必须的了。</p>
<p>在结束这一小节前，还必须提一下的属于是关于0的阀值：$\max(0,-)$函数，它常被称为<strong>折叶损失（hinge loss）</strong>。有时候会听到人们使用平方折叶损失SVM（即L2-SVM），它使用的是$\max(0,-)^2$，将更强烈（平方地而不是线性地）地惩罚过界的边界值。不使用平方是更标准的版本，但是在某些数据集中，平方折叶损失会工作得更好。可以通过交叉验证来决定到底使用哪个。</p>
<p>&gt; 我们对于预测训练集数据分类标签的情况总有一些不满意的，而损失函数就能将这些不满意的程度量化。  </p>
<img src="/2024/05/06/15-22-39/%E5%A4%9A%E7%B1%BBsvm_scores.jpg" class>
<p>多类SVM”想要”正确类别的分类分数比其他不正确分类类别的分数要高，而且至少高出delta的边界值。如果其他分类分数进入了红色的区域，甚至更高，那么就开始计算损失。如果没有这些情况，损失值为0。我们的目标是找到一些权重，它们既能够让训练集中的数据样例满足这些限制，也能让总的损失值尽可能地低。  </p>
<p><strong>正则化（Regularization）：</strong>上面损失函数有一个问题。假设有一个数据集和一个权重集<strong>W</strong>能够正确地分类每个数据（即所有的边界都满足，对于所有的i都有$L_i=0$）。问题在于这个<strong>W</strong>并不唯一：可能有很多相似的<strong>W</strong>都能正确地分类所有的数据。一个简单的例子：如果<strong>W</strong>能够正确分类所有数据，即对于每个数据，损失值都是0。那么当 $\lambda &gt;1$时，任何数乘$\lambda W$都能使得损失值为0，因为这个变化将所有分值的大小都均等地扩大了，所以它们之间的绝对差值也扩大了。举个例子，如果一个正确分类的分值和举例它最近的错误分类的分值的差距是15，对<strong>W</strong>乘以2将使得差距变成30。</p>
<p>换句话说，我们希望能向某些特定的权重<strong>W</strong>添加一些偏好，对其他权重则不添加，以此来消除模糊性。这一点是能够实现的，方法是向损失函数增加一个<strong>正则化惩罚（regularization penalty）</strong>$R(W)$部分。最常用的正则化惩罚是L2范式，L2范式通过对所有参数进行逐元素的平方惩罚来抑制大数值的权重：</p>
<p>$R(W)=\sum_k\sum_lW^2_{k,l}$</p>
<p>上面的表达式中，将$W$中所有元素平方后求和。注意正则化函数不是数据的函数，仅基于权重。包含正则化惩罚后，就能够给出完整的多类SVM损失函数了，它由两个部分组成：<strong>数据损失（data loss）</strong>，即所有样例的的平均损失$L_i$，以及<strong>正则化损失（regularization loss）</strong>。完整公式如下所示：  </p>
<p>$ L= \underbrace{ \frac{1}{N}\sum_i L_i}_{data   loss}+\underbrace{\lambda R(W)}_{regularization  loss} $</p>
<p>将其展开完整公式是：</p>
<p>$ L= \frac{1}{N}\sum_i\sum_{j\not=y_i} \left[ \max(0,f(x_i;W)_j-f(x_i;W)_{y_i}+\Delta )\right] + \lambda\sum_k\sum_l W_{k,l}^2$</p>
<p>其中，$N$是训练集的数据量。现在正则化惩罚添加到了损失函数里面，并用超参数$\lambda$来计算其权重。该超参数无法简单确定，需要通过交叉验证来获取。</p>
<p>除了上述理由外，引入正则化惩罚还带来很多良好的性质，这些性质大多会在后续章节介绍。比如引入了L2惩罚后，SVM们就有了<strong>最大边界（max margin）</strong>这一良好性质。（如果感兴趣，可以查看CS229课程）。</p>
<p>其中最好的性质就是对大数值权重进行惩罚，可以提升其泛化能力，因为这就意味着没有哪个维度能够独自对于整体分值有过大的影响。举个例子，假设输入向量$x = [1,1,1,1]$，两个权重向量 $w_1=[1,0,0,0]$，$w_2=[0.25,0.25,0.25,0.25]$。那么 $w^T_1x=w^T_2=1$，两个权重向量都得到同样的内积，但是$w_1$的L2惩罚是1.0，而$w_2$的L2惩罚是0.25。因此，根据L2惩罚来看，$w_2$更好，因为它的正则化损失更小。从直观上来看，这是因为$w_2$的权重值更小且更分散。既然L2惩罚倾向于更小更分散的权重向量，这就会鼓励分类器最终将所有维度上的特征都用起来，而不是强烈依赖其中少数几个维度。在后面的课程中可以看到，这一效果将会提升分类器的泛化能力，并避免<strong>过拟合</strong>。</p>
<p>需要注意的是，和权重不同，偏差没有这样的效果，因为它们并不控制输入维度上的影响强度。因此通常只对权重$W$正则化，而不正则化偏差$b$。在实际操作中，可发现这一操作的影响可忽略不计。最后，因为正则化惩罚的存在，不可能在所有的例子中得到0的损失值，这是因为只有当$W=0$的特殊情况下，才能得到损失值为0。</p>
<p><strong>代码</strong>：下面是一个无正则化部分的损失函数的Python实现，有非向量化和半向量化两个形式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">L_i</span>(<span class="params">x, y, W</span>):</span><br><span class="line">     <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">     unvectorized version. Compute the multiclass svm loss for a single example (x,y)</span></span><br><span class="line"><span class="string">     - x is a column vector representing an image (e.g. 3073 x 1 in CIFAR-10)</span></span><br><span class="line"><span class="string">       with an appended bias dimension in the 3073-rd position (i.e. bias trick)</span></span><br><span class="line"><span class="string">     - y is an integer giving index of correct class (e.g. between 0 and 9 in CIFAR-10)</span></span><br><span class="line"><span class="string">     - W is the weight matrix (e.g. 10 x 3073 in CIFAR-10)</span></span><br><span class="line"><span class="string">     &quot;&quot;&quot;</span></span><br><span class="line">     delta = <span class="number">1.0</span> <span class="comment"># see notes about delta later in this section</span></span><br><span class="line">     scores = W.dot(x) <span class="comment"># scores becomes of size 10 x 1, the scores for each class</span></span><br><span class="line">     correct_class_score = scores[y]</span><br><span class="line">     D = W.shape[<span class="number">0</span>] <span class="comment"># number of classes, e.g. 10</span></span><br><span class="line">     loss_i = <span class="number">0.0</span></span><br><span class="line">     <span class="keyword">for</span> j <span class="keyword">in</span> xrange(D): <span class="comment"># iterate over all wrong classes</span></span><br><span class="line">       <span class="keyword">if</span> j == y:</span><br><span class="line">         <span class="comment"># skip for the true class to only loop over incorrect classes</span></span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">       <span class="comment"># accumulate loss for the i-th example</span></span><br><span class="line">       loss_i += <span class="built_in">max</span>(<span class="number">0</span>, scores[j] - correct_class_score + delta)</span><br><span class="line">     <span class="keyword">return</span> loss_i</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">L_i_vectorized</span>(<span class="params">x, y, W</span>):</span><br><span class="line">     <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">     A faster half-vectorized implementation. half-vectorized</span></span><br><span class="line"><span class="string">     refers to the fact that for a single example the implementation contains</span></span><br><span class="line"><span class="string">     no for loops, but there is still one loop over the examples (outside this function)</span></span><br><span class="line"><span class="string">     &quot;&quot;&quot;</span></span><br><span class="line">     delta = <span class="number">1.0</span></span><br><span class="line">     scores = W.dot(x)</span><br><span class="line">     <span class="comment"># compute the margins for all classes in one vector operation</span></span><br><span class="line">     margins = np.maximum(<span class="number">0</span>, scores - scores[y] + delta)</span><br><span class="line">     <span class="comment"># on y-th position scores[y] - scores[y] canceled and gave delta. We want</span></span><br><span class="line">     <span class="comment"># to ignore the y-th position and only consider margin on max wrong class</span></span><br><span class="line">     margins[y] = <span class="number">0</span></span><br><span class="line">     loss_i = np.<span class="built_in">sum</span>(margins)</span><br><span class="line">     <span class="keyword">return</span> loss_i</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">L</span>(<span class="params">X, y, W</span>):</span><br><span class="line">     <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">     fully-vectorized implementation :</span></span><br><span class="line"><span class="string">     - X holds all the training examples as columns (e.g. 3073 x 50,000 in CIFAR-10)</span></span><br><span class="line"><span class="string">     - y is array of integers specifying correct class (e.g. 50,000-D array)</span></span><br><span class="line"><span class="string">     - W are weights (e.g. 10 x 3073)</span></span><br><span class="line"><span class="string">     &quot;&quot;&quot;</span></span><br><span class="line">     <span class="comment"># evaluate loss over all examples in X without using any for loops</span></span><br><span class="line">     <span class="comment"># left as exercise to reader in the assignment</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在本小节的学习中，一定要记得SVM损失采取了一种特殊的方法，使得能够衡量对于训练数据预测分类和实际分类标签的一致性。还有，对训练集中数据做出准确分类预测和让损失值最小化这两件事是等价的。  </p>
<p>&gt; 接下来要做的，就是找到能够使损失值最小化的权重了。  </p>
<h2 id="实际考虑"><a href="#实际考虑" class="headerlink" title="实际考虑"></a>实际考虑</h2><p><strong>设置$\delta$</strong>：你可能注意到上面的内容对超参数$\delta$及其设置是一笔带过，那么它应该被设置成什么值？需要通过交叉验证来求得吗？现在看来，该超参数在绝大多数情况下设为$\delta=1.0$都是安全的。超参数$\delta$和$\lambda$看起来是两个不同的超参数，但实际上他们一起控制同一个权衡：即损失函数中的数据损失和正则化损失之间的权衡。理解这一点的关键是要知道，权重$W$的大小对于分类分值有直接影响（当然对他们的差异也有直接影响）：当我们将$W$中值缩小，分类分值之间的差异也变小，反之亦然。因此，不同分类分值之间的边界的具体值（比如$\delta=1$或$\delta=100$）从某些角度来看是没意义的，因为权重自己就可以控制差异变大和缩小。也就是说，真正的权衡是我们允许权重能够变大到何种程度（通过正则化强度$\lambda$来控制）。</p>
<p><strong>与二元支持向量机（Binary Support Vector Machine）的关系</strong>：在学习本课程前，你可能对于二元支持向量机有些经验，它对于第i个数据的损失计算公式是：</p>
<p>$ L_i=C\max(0,1-y_iw^Tx_i)+R(W)$</p>
<p>其中，$C$是一个超参数，并且$y_i\in{\left\{-1,1\right\}}$。可以认为本章节介绍的SVM公式包含了上述公式，上述公式是多类支持向量机公式只有两个分类类别的特例。也就是说，如果我们要分类的类别只有两个，那么公式就化为二元SVM公式。这个公式中的$C$和多类SVM公式中的$\lambda$都控制着同样的权衡，而且它们之间的关系是$C\propto\frac{1}{\lambda}$</p>
<p><strong>备注：在初始形式中进行最优化</strong>。如果在本课程之前学习过SVM，那么对kernels，duals，SMO算法等将有所耳闻。在本课程（主要是神经网络相关）中，损失函数的最优化的始终在非限制初始形式下进行。很多这些损失函数从技术上来说是不可微的（比如当$x=y$时，$\max(x,y)$函数就不可微分），但是在实际操作中并不存在问题，因为通常可以使用次梯度。</p>
<p><strong>备注：其他多类SVM公式</strong>。需要指出的是，本课中展示的多类SVM只是多种SVM公式中的一种。另一种常用的公式是_One-Vs-All_（OVA）SVM，它针对每个类和其他类训练一个独立的二元分类器。还有另一种更少用的叫做_All-Vs-All_（AVA）策略。我们的公式是按照[Weston and Watkins 1999 (pdf)]版本，比OVA性能更强（在构建有一个多类数据集的情况下，这个版本可以在损失值上取到0，而OVA就不行。感兴趣的话在论文中查阅细节）。最后一个需要知道的公式是Structured SVM，它将正确分类的分类分值和非正确分类中的最高分值的边界最大化。理解这些公式的差异超出了本课程的范围。本课程笔记介绍的版本可以在实践中安全使用，而被论证为最简单的OVA策略在实践中看起来也能工作的同样出色（在 Rikin等人2004年的论文[In Defense of One-Vs-All Classification (pdf)中可查）。</p>
<h2 id="Softmax分类器"><a href="#Softmax分类器" class="headerlink" title="Softmax分类器"></a>Softmax分类器</h2><p>SVM是最常用的两个分类器之一，而另一个就是<strong>Softmax分类器，</strong>它的损失函数与SVM的损失函数不同。对于学习过二元逻辑回归分类器的读者来说，Softmax分类器就可以理解为逻辑回归分类器面对多个分类的一般化归纳。SVM将输出$f(x_i,W)$作为每个分类的评分（因为无定标，所以难以直接解释）。与SVM不同，Softmax的输出（归一化的分类概率）更加直观，并且从概率上可以解释，这一点后文会讨论。在Softmax分类器中，函数映射$f(x_i;W)=Wx_i$保持不变，其输出是线性分类器预测的原始分数，但将这些评分值视为每个分类的未归一化的对数概率（或者叫做非标准化的对数概率），进行指数计算之后，所有的分数转化为正数，并且将<strong>折叶损失（hinge loss）</strong>替换为<strong>交叉熵损失</strong>（<strong>cross-entropy loss）</strong>。公式如下：</p>
<p>$Li=-log(\frac{e^{f_{y_i}}}{\sum_je^{f_j}})$ 或等价的 $L_i=-f_{y_i}+log(\sum_je^{f_j})$</p>
<p>在上式中，使用$f_j$来表示分类评分向量$f$中的第j个元素。和之前一样，整个数据集的损失值是数据集中所有样本数据的损失值$L_i$的均值与正则化损失$R(W)$之和。其中函数$f_j(z)=\frac{e^{z_j}}{\sum_ke^{z_k}}$被称作<strong>softmax 函数</strong>：其输入值是一个向量，向量中元素为任意实数的评分值（$z$中的），函数对其进行压缩，输出一个向量，其中每个元素值在0到1之间，且所有元素之和为1。所以，包含softmax函数的完整交叉熵损失看起唬人，实际上还是比较容易理解的。  </p>
<p>因为原始的线性分类器输出的是原始分数，可以看做是非标准化/未归一化的对数概率，然后取对数，得到非标准化/未归一化概率，然后进行归一化，就可以得到所有类的离散概率分布了</p>
<p><strong>信息理论视角</strong>：在”真实”分布$p$和估计分布$q$之间的<strong>交叉熵</strong>定义如下：  </p>
<p>$H(p,q)=-\sum_xp(x) logq(x)$  </p>
<p>因此，Softmax分类器所做的就是最小化在估计分类概率（ 就是上面的$\frac{e^{f_{y_i} } }{\sum_{j}e^{f_j} }$）和”真实”分布之间的交叉熵，在这个解释中，”真实”分布就是所有概率密度都分布在正确的类别上（比如：$p=[0,\ldots1,\ldots,0]$中在$y_i$的位置就有一个单独的1）。还有，既然交叉熵可以写成熵和相对熵（Kullback-Leibler divergence）$H(p,q)=H(p)+D_{KL}(p||q)$，并且$\delta$函数$p$的熵是0，那么就能等价的看做是对两个分布之间的相对熵做最小化操作。换句话说，交叉熵损失函数”想要”预测分布的所有<strong>概率密度</strong>都在正确分类上。</p>
<p><strong>注</strong>：Kullback-Leibler差异（Kullback-Leibler Divergence）也叫做相对熵（Relative Entropy），它衡量的是相同事件空间里的两个概率分布的差异情况。</p>
<p><strong>概率论解释</strong>：先看下面的公式：  </p>
<p>$P(y_i|x_i,W)=\frac{e^{f_{y_i}}}{\sum_je^{f_j}}$</p>
<p>可以解释为是给定图像数据$x_i$，以$W$为参数，分配给正确分类标签$y_i$的归一化概率。为了理解这点，请回忆一下Softmax分类器将输出向量$f$中的评分值解释为没有归一化的<strong>对数概率</strong>。那么以这些数值做指数函数的幂就得到了没有归一化的概率，而除法操作则对数据进行了归一化处理，使得这些概率的和为1。从概率论的角度来理解，我们就是在最小化正确分类的负对数概率，这可以看做是在进行<strong>最大似然估计</strong>（MLE）。该解释的另一个好处是，损失函数中的正则化部分$R(W)$可以被看做是权重矩阵$W$的高斯先验，这里进行的是最大后验估计（MAP）而不是最大似然估计。提及这些解释只是为了让读者形成直观的印象，具体细节就超过本课程范围了。</p>
<p><strong>实操事项：数值稳定。</strong>编程实现softmax函数计算的时候，中间项$e^{f_{y_i}}$和$\sum_j e^{f_j}$因为存在指数函数，所以数值可能非常大。除以大数值可能导致数值计算的不稳定，所以学会使用归一化技巧非常重要。如果在分式的分子和分母都乘以一个常数$C$，并把它变换到求和之中，就能得到一个从数学上等价的公式：</p>
<p>$\frac{e^{f_{y_i}}}{\sum_je^{f_j}}=\frac{Ce^{f_{y_i}}}{C\sum_je^{f_j}}=\frac{e^{f_{y_i}+logC}}{\sum_je^{f_j+logC}}$ </p>
<p>$C$的值可自由选择，不会影响计算结果，通过使用这个技巧可以提高计算中的数值稳定性。通常将$C$设为$logC=-max_jf_j$。该技巧简单地说，就是应该将向量$f$中的数值进行平移，使得最大值为0。代码实现如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">f = np.array([<span class="number">123</span>, <span class="number">456</span>, <span class="number">789</span>]) <span class="comment"># 例子中有3个分类，每个评分的数值都很大</span></span><br><span class="line">p = np.exp(f) / np.<span class="built_in">sum</span>(np.exp(f)) <span class="comment"># 不妙：数值问题，可能导致数值爆炸</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 那么将f中的值平移到最大值为0：</span></span><br><span class="line">f -= np.<span class="built_in">max</span>(f) <span class="comment"># f becomes [-666, -333, 0]</span></span><br><span class="line">p = np.exp(f) / np.<span class="built_in">sum</span>(np.exp(f)) <span class="comment"># 现在OK了，将给出正确结果</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>让人迷惑的命名规则</strong>：精确地说，SVM分类器使用的是<strong>折叶损失（hinge loss）</strong>，有时候又被称为<strong>最大边界损失（max-margin loss）</strong>。Softmax分类器使用的是<strong>交叉熵损失（corss-entropy loss）</strong>。Softmax分类器的命名是从<strong>softmax函数</strong>那里得来的，softmax函数将原始分类评分变成正的归一化数值，所有数值和为1，这样处理后交叉熵损失才能应用。注意从技术上说”softmax损失（softmax loss）”是没有意义的，因为softmax只是一个压缩数值的函数。但是在这个说法常常被用来做简称。</p>
<h2 id="SVM和Softmax的比较"><a href="#SVM和Softmax的比较" class="headerlink" title="SVM和Softmax的比较"></a>SVM和Softmax的比较</h2><p>下图有助于区分这 Softmax和SVM这两种分类器：</p>
<img src="/2024/05/06/15-22-39/a90ce9e0ff533f3efee4747305382064_b.png" class>
<p>针对一个数据点，SVM和Softmax分类器的不同处理方式的例子。两个分类器都计算了同样的分值向量<strong>f</strong>（本节中是通过矩阵乘来实现）。不同之处在于对<strong>f</strong>中分值的解释：SVM分类器将它们看做是分类评分，它的损失函数鼓励正确的分类（本例中是蓝色的类别2）的分值比其他分类的分值高出至少一个边界值。Softmax分类器将这些数值看做是每个分类没有归一化的<strong>对数概率</strong>，鼓励正确分类的归一化的对数概率变高，其余的变低。SVM的最终的损失值是1.58，Softmax的最终的损失值是0.452，但要注意这两个数值没有可比性。只在给定同样数据，在同样的分类器的损失值计算中，它们才有意义。</p>
<p><strong>Softmax分类器为每个分类提供了”可能性”</strong>：SVM的计算是无标定的，而且难以针对所有分类的评分值给出直观解释。Softmax分类器则不同，它允许我们计算出对于所有分类标签的可能性。举个例子，针对给出的图像，SVM分类器可能给你的是一个[12.5, 0.6, -23.0]对应分类”猫”，”狗”，”船”。而softmax分类器可以计算出这三个标签的”可能性”是[0.9, 0.09, 0.01]，这就让你能看出对于不同分类准确性的把握。为什么我们要在”可能性”上面打引号呢？这是因为可能性分布的集中或离散程度是由正则化参数λ直接决定的，λ是你能直接控制的一个输入参数。举个例子，假设3个分类的原始分数是[1, -2, 0]，那么softmax函数就会计算：</p>
<p>$[1,-2,0]\to[e^1,e^{-2},e^0]=[2.71,0.14,1]\to[0.7,0.04,0.26]$  </p>
<p>现在，如果正则化参数λ更大，那么权重W就会被惩罚的更多，然后他的权重数值就会更小。这样算出来的分数也会更小，假设小了一半吧[0.5, -1, 0]，那么softmax函数的计算就是：  </p>
<p>$[0.5,-1,0]\to[e^{0.5},e^{-1},e^0]=[1.65,0.73,1]\to[0.55,0.12,0.33]$  </p>
<p>现在看起来，概率的分布就更加分散了。还有，随着正则化参数λ不断增强，权重数值会越来越小，最后输出的概率会接近于均匀分布。这就是说，softmax分类器算出来的概率最好是看成一种对于分类正确性的自信。和SVM一样，数字间相互比较得出的大小顺序是可以解释的，但其绝对值则难以直观解释<strong>。</strong></p>
<p><strong>在实际使用中，SVM和Softmax经常是相似的</strong>：通常说来，两种分类器的表现差别很小，不同的人对于哪个分类器更好有不同的看法。相对于Softmax分类器，SVM更加”局部目标化（local objective）”，这既可以看做是一个特性，也可以看做是一个劣势。考虑一个评分是[10, -2, 3]的数据，其中第一个分类是正确的。那么一个SVM（$\delta =1$）会看到正确分类相较于不正确分类，已经得到了比边界值还要高的分数，它就会认为损失值是0。SVM对于数字个体的细节是不关心的：如果分数是[10, -100, -100]或者[10, 9, 9]，对于SVM来说没设么不同，只要满足超过边界值等于1，那么损失值就等于0。</p>
<p>对于softmax分类器，情况则不同。对于[10, 9, 9]来说，计算出的损失值就远远高于[10, -100, -100]的。换句话来说，softmax分类器对于分数是永远不会满意的：正确分类总能得到更高的可能性，错误分类总能得到更低的可能性，损失值总是能够更小。但是，SVM只要边界值被满足了就满意了，不会超过限制去细微地操作具体分数。这可以被看做是SVM的一种特性。举例说来，一个汽车的分类器应该把他的大量精力放在如何分辨小轿车和大卡车上，而不应该纠结于如何与青蛙进行区分，因为区分青蛙得到的评分已经足够低了。</p>
<h2 id="交互式的网页Demo"><a href="#交互式的网页Demo" class="headerlink" title="交互式的网页Demo"></a>交互式的网页Demo</h2><img src="/2024/05/06/15-22-39/a68bbfd4465689c6d65b3eae9c24c934_b.jpg" class>
<p>我们实现了一个交互式的网页原型，来帮助读者直观地理解线性分类器。原型将损失函数进行可视化，画面表现的是对于2维数据的3种类别的分类。原型在课程进度上稍微超前，展现了最优化的内容，最优化将在下一节课讨论。  </p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>总结如下：</p>
<ul>
<li>定义了从图像像素映射到不同类别的分类评分的评分函数。在本节中，评分函数是一个基于权重<strong>W</strong>和偏差<strong>b</strong>的线性函数。</li>
<li>与k-NN分类器不同，<strong>参数方法</strong>的优势在于一旦通过训练学习到了参数，就可以将训练数据丢弃了。同时该方法对于新的测试数据的预测非常快，因为只需要与权重<strong>W</strong>进行一个矩阵乘法运算。</li>
<li>介绍了偏差技巧，让我们能够将偏差向量和权重矩阵合二为一，然后就可以只跟踪一个矩阵。</li>
<li>定义了损失函数（介绍了SVM和Softmax线性分类器最常用的2个损失函数）。损失函数能够衡量给出的参数集与训练集数据真实类别情况之间的一致性。在损失函数的定义中可以看到，对训练集数据做出良好预测与得到一个足够低的损失值这两件事是等价的。</li>
</ul>
<p>现在我们知道了如何基于参数，将数据集中的图像映射成为分类的评分，也知道了两种不同的损失函数，它们都能用来衡量算法分类预测的质量。但是，如何高效地得到能够使损失值最小的参数呢？这个求得最优参数的过程被称为最优化，将在下节课中进行介绍。</p>
]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>计算机视觉, 图像处理, 深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机视觉 图像分类</title>
    <url>/2024/05/06/14-24-17/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.05.06：初稿</li>
</ul>
<h2 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h2><ul>
<li><a href="/2024/05/06/10-28-51/" title="eecs498 ML-DL-CV 笔记汇总">计算机视觉-笔记汇总</a>
</li>
</ul>
<h1 id="图像分类"><a href="#图像分类" class="headerlink" title="图像分类"></a>图像分类</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>目标</strong>：这一节我们将介绍图像分类问题。所谓图像分类问题，就是已有固定的分类标签集合，然后对于输入的图像，从分类标签集合中找出一个分类标签，最后把分类标签分配给该输入图像，或者简单的说，就是对于一个给定的图像，预测它属于哪个类别（或者给出属于一系列不同标签的可能性）。虽然看起来挺简单的，但这可是计算机视觉领域的核心问题之一，并且有着各种各样的实际应用。在这里我们面临的挑战就是语义鸿沟。在后面的课程中，我们可以看到计算机视觉领域中很多看似不同的问题（比如物体检测和分割），都可以被归结为图像分类问题。</p>
<p><strong>例子</strong>：以下图为例，图像分类模型读取该图片，并生成该图片属于集合 {cat, dog, hat, mug}中各个标签的概率。需要注意的是，对于计算机来说，图像是一个由数字组成的巨大的3维数组（在深度学习工具中，图像就是一个三维张量）。在下图这个例子中，猫的图像大小是宽248像素，高400像素，有3个颜色通道，分别是红、绿和蓝（简称RGB）。</p>
<p>如此，该图像就包含了248X400X3=297600个数字，每个数字都是在范围0-255之间的整型，其中0表示全黑，255表示全白。我们的任务就是把这些上百万的数字变成一个简单的标签，比如”猫”。或者说，我们需要借助某种方法将这个原始数字网络转变为相应的有意义的语义——比如说“猫”标签</p>
<img src="/2024/05/06/14-24-17/baab9e4b97aceb77ec70abeda6be022d_b.png" class>
<h2 id="困难和挑战"><a href="#困难和挑战" class="headerlink" title="困难和挑战"></a>困难和挑战</h2><p>对于人来说，识别出一个像”猫”一样视觉概念是简单至极的，然而从计算机视觉算法的角度来看就值得深思了。我们在下面列举了计算机视觉算法在图像识别方面遇到的一些困难</p>
<ul>
<li><strong>视角变化（</strong>Viewpoint variation<strong>）</strong>：同一个物体，摄像机可以从多个角度来展现，尽管可能角度的变化很轻微，但是可能使得这些数字发生不直观的某种改变</li>
<li><strong>类内差异（</strong>Intra-class variation<strong>）</strong>：一类物体的个体之间的外形差异很大，比如椅子。这一类物体有许多不同的对象，每个都有自己的外形。比如说猫就是一种很会变形的生物</li>
<li><strong>相似类（</strong>Fine-Grained Categories<strong>）</strong>：不同类物体的个体之间的外形差异小</li>
<li><strong>背景干扰（</strong>Background clutter<strong>）</strong>：物体可能混入背景之中，使之难以被辨认</li>
<li><strong>光照条件（</strong>Illumination conditions<strong>）</strong>：在像素层面上，光照的影响非常大，比如说光照和昏暗情况下图像会有不同情况</li>
<li><strong>形变（</strong>Deformation<strong>）</strong>：很多东西的形状并非一成不变，会有很大变化。</li>
<li><strong>遮挡（</strong>Occlusion<strong>）</strong>：目标物体可能被挡住。有时候只有物体的一小部分（可以小到几个像素）是可见的，比如说猫隐藏在草丛中，并不明显</li>
<li><strong>大小变化（</strong>Scale variation<strong>）</strong>：物体可视的大小通常是会变化的（不仅是在图片中，在真实世界中大小也是变化的）。</li>
</ul>
<p>面对以上所有变化及其组合，好的图像分类模型能够在维持分类结论稳定的同时，保持对类间差异足够敏感。  </p>
<img src="/2024/05/06/14-24-17/1ee9457872f773d671dd5b225647ef45_b.jpg" class>
<h2 id="目标检测任务"><a href="#目标检测任务" class="headerlink" title="目标检测任务"></a>目标检测任务</h2><p>当然，计算机视觉不止有图像分类，还有另一个相关的任务——目标检测，这个任务我们需要将图像中的目标对象圈出来</p>
<p>结果证明，图像分类本来就是一个基础，可以用来构建更多更复杂的应用程序，比如说目标检测等</p>
<img src="/2024/05/06/14-24-17/object_detection.jpg" class>
<p>—————————————————————————————————————————</p>
<p><strong>想法</strong>：如何实现图像分类？</p>
<p>根据之前所了解到的方法，我们可能首先想到通过对照片进行<strong>边缘检测</strong>来提取特征，如何尝试找到角点或者其他类型的可解释模式，比如说猫有三角形尖耳朵，所以可以通过检测这方面的边缘信息，或者我们知道猫有胡须，所以我们可以提取胡须的边缘信息，我们根据这些信息来写一个算法来检测他们</p>
<p>当然，这并不是一个很好的方法，比如说会有没有胡须的猫，会有没有尖耳朵的猫，或者有时候边缘检测器会失效从而无法正常提交所需的边缘，而且这很难进行迁移——当我们可以成功识别猫的时候，如果我们想将其用到其他方面，比如说识别狗，那么之前的工作将毫无意义，所以我们需要找到一种具有可扩展性的算法</p>
<h2 id="数据驱动方法"><a href="#数据驱动方法" class="headerlink" title="数据驱动方法"></a>数据驱动方法</h2><p>如何写一个图像分类的算法呢？这和写个排序算法可是大不一样。怎么写一个从图像中认出猫的算法？搞不清楚。因此，与其在代码中直接写明各类物体到底看起来是什么样的，倒不如说我们采取的方法和教小孩儿看图识物类似：给计算机很多数据，然后实现学习算法，让计算机学习到每个类的外形。这种方法，就是_数据驱动方法_。也就是使用拥有从数据中学习如何识别不同类型对象与图像的算法。既然该方法的第一步就是收集大量已经做好分类标注的图片来作为训练集，那么下面就看看数据集到底长什么样：  </p>
<p>—————————————————————————————————————————</p>
<img src="/2024/05/06/14-24-17/bbbfd2e6878d6f5d2a82f8239addbbc0_b.jpg" class>
<p>这是一个有4个视觉类别的训练集，尽管这个数据集非常简陋。在实际中，我们可能有上千的分类，每个分类都有成千上万的图像。</p>
<p><strong>图像分类流程</strong>。在课程视频中已经学习过，<strong>图像分类</strong>就是输入一个元素为像素值的数组，然后给它分配一个分类标签。完整流程如下：</p>
<ul>
<li><strong>输入</strong>：输入是包含N个图像的集合，每个图像的标签是K种分类标签中的一种。这个集合称为训练集。</li>
<li><strong>学习</strong>：这一步的任务是使用训练集来学习每个类到底长什么样。一般该步骤叫做<strong>训练分类器</strong>或者学习一个模型。</li>
<li><strong>评价</strong>：让分类器来预测它未曾见过的图像的分类标签，并以此来评价分类器的质量。我们会把分类器预测的标签和图像真正的分类标签对比。毫无疑问，如果分类器预测的分类标签和图像真正的分类标签一致，那就是好事，这样的情况越多越好。</li>
</ul>
<h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><h3 id="MNIST数据集：计算机视觉中的果蝇"><a href="#MNIST数据集：计算机视觉中的果蝇" class="headerlink" title="MNIST数据集：计算机视觉中的果蝇"></a>MNIST数据集：计算机视觉中的果蝇</h3><p>MNIST数据集是一种手写数字数据集，其中的每张图片都包括一个不同的手写数字，大小统一为28 $\times$ 28，十个类别，有五万张作为训练集和一万张作为测试集</p>
<p>它更像一种玩具数据集，或者也被称为计算机视觉的果蝇，可以做很多测试，因为这个数据集很小而且简单，可以快速验证新想法</p>
<h3 id="CIFAR数据集"><a href="#CIFAR数据集" class="headerlink" title="CIFAR数据集"></a>CIFAR数据集</h3><p><strong>CIFAR-10</strong>：一个非常流行的图像分类数据集是CIFAR-10。这个数据集包含了60000张32X32的小图像。每张图像都有10种分类标签中的一种。这60000张图像被分为包含50000张图像的训练集和包含10000张图像的测试集。</p>
<p>在下图中你可以看见10个类的10张随机图片。</p>
<img src="/2024/05/06/14-24-17/fff49fd8cec00f77f657a4c4a679b030_b.jpg" class>
<p><strong>左边</strong>：从数据库来的样本图像。<strong>右边</strong>：第一列是测试图像，然后第一列的每个测试图像右边是使用Nearest Neighbor算法，根据像素差异，从训练集中选出的10张最类似的图片。  </p>
<p>此外还有CIFAR100数据集（100类）</p>
<h3 id="ImageNet：黄金数据集"><a href="#ImageNet：黄金数据集" class="headerlink" title="ImageNet：黄金数据集"></a>ImageNet：黄金数据集</h3><p>这是一个非常大的数据，有一千种类别，同时有一百三十万张图片（每个类别1300张），五万张验证集，十万张测试集，性能标准是Top5准确率，图像大小不统一</p>
<h2 id="Nearest-Neighbor分类器"><a href="#Nearest-Neighbor分类器" class="headerlink" title="Nearest Neighbor分类器"></a>Nearest Neighbor分类器</h2><p>作为课程介绍的第一个方法，我们来实现一个<strong>Nearest Neighbor分类器</strong>。虽然这个分类器和卷积神经网络没有任何关系，实际中也极少使用而且其非常简单，但通过实现它，可以让读者对于解决图像分类问题的方法有个基本的认识，也就是机器学习系统的两个基本部分——训练、预测。</p>
<p>其中，训练函数，就是记住所有的数据和标签（或者说进行学习），预测函数，就是预测出图像最可能的标签</p>
<img src="/2024/05/06/14-24-17/fff49fd8cec00f77f657a4c4a679b030_b.jpg" class>
<p>假设现在我们有CIFAR-10的50000张图片（每种分类5000张）作为训练集，我们希望将余下的10000作为测试集并给他们打上标签。Nearest Neighbor算法将会拿着测试图片和训练集中每一张图片去比较，然后将它认为最相似的那个训练集图片的标签赋给这张测试图片。上面右边的图片就展示了这样的结果。请注意上面10个分类中，只有3个是准确的。比如第8行中，马头被分类为一个红色的跑车，原因在于红色跑车的黑色背景非常强烈，所以这匹马就被错误分类为跑车了。</p>
<p>那么具体如何比较两张图片的相似程度呢（或者可以将相似程度理解为距离，距离越近，图片越相似）？在本例中，就是比较32x32x3的像素块。最简单的方法就是逐个像素比较，最后将差异值全部加起来。换句话说，就是将两张图片先转化为两个向量$I_1$和$I_2$，然后计算他们的<strong>L1距离（曼哈顿距离）：</strong></p>
<p>$displaystyle d_1(I_1,I_2)=sum_p|I^p_1-I^p_2|$</p>
<p>这里的求和是针对所有的像素。下面是整个比较流程的图例：  </p>
<img src="/2024/05/06/14-24-17/95cfe7d9efb83806299c218e0710a6c5_b.jpg" class>
<p>以图片中的一个颜色通道为例来进行说明。两张图片使用L1距离来进行比较。逐个像素求差值，然后将所有差值加起来得到一个数值。如果两张图片一模一样，那么L1距离为0，但是如果两张图片很是不同，那L1值将会非常大。</p>
<p>下面，让我们看看如何用代码来实现这个分类器。首先，我们将CIFAR-10的数据加载到内存中，并分成4个数组：训练数据和标签，测试数据和标签。在下面的代码中，<strong>Xtr</strong>（大小是50000x32x32x3）存有训练集中所有的图像，<strong>Ytr</strong>是对应的长度为50000的1维数组，存有图像对应的分类标签（从0到9）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Xtr, Ytr, Xte, Yte = load_CIFAR10(<span class="string">&#x27;data/cifar10/&#x27;</span>) <span class="comment"># a magifunction we provide</span></span><br><span class="line"><span class="comment"># flatten out all images to be one-dimensional</span></span><br><span class="line">Xtr_rows = Xtr.reshape(Xtr.shape[<span class="number">0</span>], <span class="number">32</span> * <span class="number">32</span> * <span class="number">3</span>) <span class="comment"># Xtr_rowbecomes 50000 x 3072</span></span><br><span class="line">Xte_rows = Xte.reshape(Xte.shape[<span class="number">0</span>], <span class="number">32</span> * <span class="number">32</span> * <span class="number">3</span>) <span class="comment"># Xte_rowbecomes 10000 x 3072</span></span><br></pre></td></tr></table></figure>
<p>现在我们得到所有的图像数据，并且把他们拉长成为行向量了。接下来展示如何训练并评价一个分类器：  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">    nn = NearestNeighbor() <span class="comment"># create a Nearest Neighbor classifier class</span></span><br><span class="line">​    nn.train(Xtr_rows, Ytr) <span class="comment"># train the classifier on the training images and labels</span></span><br><span class="line">​    Yte_predict = nn.predict(Xte_rows) <span class="comment"># predict labels on the test images</span></span><br><span class="line">​    <span class="comment"># and now print the classification accuracy, which is the average number</span></span><br><span class="line">​    <span class="comment"># of examples that are correctly predicted (i.e. label matches)</span></span><br><span class="line">​    <span class="built_in">print</span> <span class="string">&#x27;accuracy: %f&#x27;</span> % ( np.mean(Yte_predict == Yte) )</span><br></pre></td></tr></table></figure>
<p>作为评价标准，我们常常使用<strong>准确率</strong>，它描述了我们预测正确的得分。请注意以后我们实现的所有分类器都需要有这个API：<strong>train(X, y)</strong>函数。该函数使用训练集的数据和标签来进行训练。从其内部来看，类应该实现一些关于标签和标签如何被预测的模型。这里还有个<strong>predict(X)</strong>函数，它的作用是预测输入的新数据的分类标签。现在还没介绍分类器的实现，下面就是使用L1距离的Nearest Neighbor分类器的实现套路：  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">​    </span><br><span class="line">​    <span class="keyword">class</span> <span class="title class_">NearestNeighbor</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">​      <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">​        <span class="keyword">pass</span></span><br><span class="line">​    </span><br><span class="line">      <span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">self, X, y</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot; X is N x D where each row is an example. Y is 1-dimension of size N &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># the nearest neighbor classifier simply remembers all the training data</span></span><br><span class="line">        self.Xtr = X</span><br><span class="line">        self.ytr = y</span><br><span class="line">    </span><br><span class="line">      <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self, X</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot; X is N x D where each row is an example we wish to predict label for &quot;&quot;&quot;</span></span><br><span class="line">        num_test = X.shape[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># lets make sure that the output type matches the input type</span></span><br><span class="line">        Ypred = np.zeros(num_test, dtype = self.ytr.dtype)</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># loop over all test rows</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(num_test):</span><br><span class="line">          <span class="comment"># find the nearest training image to the i&#x27;th test image</span></span><br><span class="line">          <span class="comment"># using the L1 distance (sum of absolute value differences)</span></span><br><span class="line">          distances = np.<span class="built_in">sum</span>(np.<span class="built_in">abs</span>(self.Xtr - X[i,:]), axis = <span class="number">1</span>)</span><br><span class="line">          min_index = np.argmin(distances) <span class="comment"># get the index with smallest distance</span></span><br><span class="line">          Ypred[i] = self.ytr[min_index] <span class="comment"># predict the label of the nearest example</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> Ypred</span><br></pre></td></tr></table></figure>
<p>如果你用这段代码跑CIFAR-10，你会发现准确率能达到<strong>38.6%</strong>。这比随机猜测的10%要好，但是比人类识别的水平（据研究推测是94%）和卷积神经网络能达到的95%还是差多了。</p>
<p><strong>距离选择</strong>：计算向量间的距离有很多种方法，另一个常用的方法是<strong>L2距离</strong>，从几何学的角度，可以理解为它在计算两个向量间的欧式距离。L2距离的公式如下：  </p>
<p>$displaystyle d_2(I_1,I_2)=sqrt{ sum_p(I^p_1-I^p_2)^2}$</p>
<img src="/2024/05/06/14-24-17/60.jpg" class>
<p>换句话说，我们依旧是在计算像素间的差值，只是先求其平方，然后把这些平方全部加起来，最后对这个和开方。在Numpy中，我们只需要替换上面代码中的1行代码就行：  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">distances = np.sqrt(np.<span class="built_in">sum</span>(np.square(self.Xtr - X[i,:]), axis = <span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>注意在这里使用了<strong>np.sqrt</strong>，但是在实际中可能不用。因为求平方根函数是一个单调函数，它对不同距离的绝对值求平方根虽然改变了数值大小，但依然保持了不同距离大小的顺序。所以用不用它，都能够对像素差异的大小进行正确比较。如果你在CIFAR-10上面跑这个模型，正确率是<strong>35.4%</strong>，比刚才低了一点。</p>
<p><strong>L1和L2比较</strong>。比较这两个度量方式是挺有意思的。在面对两个向量之间的差异时，L2比L1更加不能容忍这些差异。也就是说，相对于1个巨大的差异，L2距离更倾向于接受多个中等程度的差异。L1和L2都是在<a href="https://planetmath.org/vectorpnorm">p-norm__</a>常用的特殊形式。</p>
<img src="/2024/05/06/14-24-17/60.jpg" class>
<h2 id="k-Nearest-Neighbor分类器"><a href="#k-Nearest-Neighbor分类器" class="headerlink" title="k-Nearest Neighbor分类器"></a>k-Nearest Neighbor分类器</h2><p>你可能注意到了，为什么只用最相似的1张图片的标签来作为测试图像的标签呢？这不是很奇怪吗！是的，使用<strong>k-Nearest Neighbor分类器</strong>就能做得更好。它的思想很简单：与其只找最相近的那1个图片的标签，我们找最相似的k个图片的标签，然后让他们针对测试图片进行投票，最后把票数最高的标签作为对测试图片的预测。所以当k=1的时候，k-Nearest Neighbor分类器就是Nearest Neighbor分类器。从直观感受上就可以看到，更高的k值可以让分类的效果更平滑，使得分类器对于异常值更有抵抗力。  </p>
<img src="/2024/05/06/14-24-17/237615075-bdd1fa05-cb3c-4dc5-b24f-940987cdb225.jpg" class>
<p>上面示例展示了Nearest Neighbor分类器和5-Nearest Neighbor分类器的区别。例子使用了2维的点来表示，分成3类（红、蓝和绿）。不同颜色区域代表的是使用L2距离的分类器的<strong>决策边界</strong>。白色的区域是分类模糊的例子（即图像与两个以上的分类标签绑定）。需要注意的是，在NN分类器中，异常的数据点（比如：在蓝色区域中的绿点）制造出一个不正确预测的孤岛。5-NN分类器将这些不规则都平滑了，使得它针对测试数据的<strong>泛化（generalization）</strong>能力更好（例子中未展示）。注意，5-NN中也存在一些灰色区域，这些区域是因为近邻标签的最高票数相同导致的（比如：2个邻居是红色，2个邻居是蓝色，还有1个是绿色)。</p>
<p>在实际中，大多使用k-NN分类器。但是k值如何确定呢？接下来就讨论这个问题。  </p>
<h2 id="用于超参数调优的验证集"><a href="#用于超参数调优的验证集" class="headerlink" title="用于超参数调优的验证集"></a>用于超参数调优的验证集</h2><p>k-NN分类器需要设定k值，那么选择哪个k值最合适的呢？我们可以选择不同的距离函数，比如L1范数和L2范数等，那么选哪个好？还有不少选择我们甚至连考虑都没有考虑到（比如：点积）。所有这些选择，被称为<strong>超参数（hyperparameter）</strong>。在基于数据进行学习的机器学习算法设计中，超参数是很常见的。一般说来，这些超参数具体怎么设置或取值并不是显而易见的。</p>
<p>你可能会建议尝试不同的值，看哪个值表现最好就选哪个。好主意！我们就是这么做的，但这样做的时候要非常细心。特别注意：<strong>决不能使用测试集来进行调优</strong>。当你在设计机器学习算法的时候，应该把测试集看做非常珍贵的资源，不到最后一步，绝不使用它。如果你使用测试集来调优，而且算法看起来效果不错，那么真正的危险在于：算法实际部署后，性能可能会远低于预期。这种情况，称之为算法对测试集<strong>过拟合</strong>。从另一个角度来说，如果使用测试集来调优，实际上就是把测试集当做训练集，由测试集训练出来的算法再跑测试集，自然性能看起来会很好。这其实是过于乐观了，实际部署起来效果就会差很多。所以，最终测试的时候再使用测试集，可以很好地近似度量你所设计的分类器的泛化性能（在接下来的课程中会有很多关于泛化性能的讨论）。</p>
<p>&gt; 测试数据集只使用一次，即在训练完成后评价最终的模型时使用。</p>
<p>但是只有训练集和测试集会有一个问题，那就是不知道算法在新数据上表现如何。 </p>
<p>好在我们有不用测试集调优的方法。其思路是：从训练集中取出一部分数据用来调优，我们称之为<strong>验证集（validation set）</strong>。以CIFAR-10为例，我们可以用49000个图像作为训练集，用1000个图像作为验证集。验证集其实就是作为假的测试集来调优。下面就是代码：</p>
<p>​<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># assume we have Xtr_rows, Ytr, Xte_rows, Yte as before</span></span><br><span class="line"><span class="comment"># recall Xtr_rows is 50,000 x 3072 matrix</span></span><br><span class="line">Xval_rows = Xtr_rows[:<span class="number">1000</span>, :] <span class="comment"># take first 1000 for validation</span></span><br><span class="line">Yval = Ytr[:<span class="number">1000</span>]</span><br><span class="line">Xtr_rows = Xtr_rows[<span class="number">1000</span>:, :] <span class="comment"># keep last 49,000 for train</span></span><br><span class="line">Ytr = Ytr[<span class="number">1000</span>:]</span><br><span class="line"></span><br><span class="line"><span class="comment"># find hyperparameters that work best on the validation set</span></span><br><span class="line">validation_accuracies = []</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">100</span>]:</span><br><span class="line"></span><br><span class="line">  <span class="comment"># use a particular value of k and evaluation on validation data</span></span><br><span class="line">  nn = NearestNeighbor()</span><br><span class="line">  nn.train(Xtr_rows, Ytr)</span><br><span class="line">  <span class="comment"># here we assume a modified NearestNeighbor class that can take a k as input</span></span><br><span class="line">  Yval_predict = nn.predict(Xval_rows, k = k)</span><br><span class="line">  acc = np.mean(Yval_predict == Yval)</span><br><span class="line">  <span class="built_in">print</span> <span class="string">&#x27;accuracy: %f&#x27;</span> % (acc,)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># keep track of what works on the validation set</span></span><br><span class="line">  validation_accuracies.append((k, acc))</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>程序结束后，我们会作图分析出哪个k值表现最好，然后用这个k值来跑真正的测试集，并作出对算法的评价。  </p>
<p>&gt; 把训练集分成训练集和验证集。使用验证集来对所有超参数调优。最后只在测试集上跑一次并报告结果。</p>
<p><strong>交叉验证</strong>。有时候，训练集数量较小（因此验证集的数量更小），人们会使用一种被称为<strong>交叉验证</strong>的方法，这种方法更加复杂些。还是用刚才的例子，如果是交叉验证集，我们就不是取1000个图像，而是将训练集平均分成5份，其中4份用来训练，1份用来验证。然后我们循环着取其中4份来训练，其中1份来验证，最后取所有5次验证结果的平均值作为算法验证结果。</p>
<img src="/2024/05/06/14-24-17/6a3ceec60cc0a379b4939c37ee3e89e8_b.png" class>
<p>这就是5份交叉验证对k值调优的例子。针对每个k值，得到5个准确率结果，取其平均值，然后对不同k值的平均表现画线连接。本例中，当k=7的时算法表现最好（对应图中的准确率峰值）。如果我们将训练集分成更多份数，直线一般会更加平滑（噪音更少）。</p>
<p><strong>实际应用</strong>。在实际情况下，人们不是很喜欢用交叉验证，主要是因为它会耗费较多的计算资源。一般直接把训练集按照50%-90%的比例分成训练集和验证集。但这也是根据具体情况来定的：如果超参数数量多，你可能就想用更大的验证集，而验证集的数量不够，那么最好还是用交叉验证吧。至于分成几份比较好，一般都是分成3、5和10份。  </p>
<img src="/2024/05/06/14-24-17/cc88207c6c3c5e91df8b6367368f6450_b.jpg" class>
<p>常用的数据分割模式。给出训练集和测试集后，训练集一般会被均分。这里是分成5份。前面4份用来训练，黄色那份用作验证集调优。如果采取交叉验证，那就各份轮流作为验证集。最后模型训练完毕，超参数都定好了，让模型跑一次（而且只跑一次）测试集，以此测试结果评价算法。</p>
<h2 id="Nearest-Neighbor分类器的优劣"><a href="#Nearest-Neighbor分类器的优劣" class="headerlink" title="Nearest Neighbor分类器的优劣"></a>Nearest Neighbor分类器的优劣</h2><p>现在对Nearest Neighbor分类器的优缺点进行思考。首先，Nearest Neighbor分类器易于理解，实现简单。其次，算法的训练不需要花时间，因为其训练过程只是将训练集数据存储起来。然而测试要花费大量时间计算，因为每个测试图像需要和所有存储的训练图像进行比较，这显然是一个缺点。在实际应用中，我们关注测试效率远远高于训练效率。其实，我们后续要学习的卷积神经网络在这个权衡上走到了另一个极端：虽然训练花费很多时间，但是一旦训练完成，对新的测试数据进行分类非常快。这样的模式就符合实际使用需求。</p>
<p>Nearest Neighbor分类器的计算复杂度研究是一个活跃的研究领域，若干<strong>Approximate Nearest Neighbor </strong>(ANN)算法和库的使用可以提升Nearest Neighbor分类器在数据上的计算速度(比如：FLANN)。这些算法可以在准确率和时空复杂度之间进行权衡，并通常依赖一个预处理/索引过程，这个过程中一般包含kd树的创建和k-means算法的运用。</p>
<p>Nearest Neighbor分类器在某些特定情况（比如数据维度较低）下，可能是不错的选择。但是在实际的图像分类工作中，很少使用。因为图像都是高维度数据（他们通常包含很多像素），而高维度向量之间的距离通常是反直觉的。下面的图片展示了基于像素的相似和基于感官的相似是有很大不同的：</p>
<img src="/2024/05/06/14-24-17/fd42d369eebdc5d81c89593ec1082e32_b.png" class>
<p>在高维度数据上，基于像素的的距离和感官上的非常不同。上图中，右边3张图片和左边第1张原始图片的L2距离是一样的。很显然，基于像素比较的相似和感官上以及语义上的相似是不同的。  </p>
<p>这里还有个视觉化证据，可以证明使用像素差异来比较图像是不够的。这是一个叫做t-SNE的可视化技术，它将CIFAR-10中的图片按照二维方式排布，这样能很好展示图片之间的像素差异值。在这张图片中，排列相邻的图片L2距离就小。  </p>
<img src="/2024/05/06/14-24-17/0f4980edb8710eaba0f3e661b1cbb830_b.jpg" class>
<p>上图使用t-SNE的可视化技术将CIFAR-10的图片进行了二维排列。排列相近的图片L2距离小。可以看出，图片的排列是被背景主导而不是图片语义内容本身主导。  </p>
<p>具体说来，这些图片的排布更像是一种颜色分布函数，或者说是基于背景的，而不是图片的语义主体。比如，狗的图片可能和青蛙的图片非常接近，这是因为两张图片都是白色背景。从理想效果上来说，我们肯定是希望同类的图片能够聚集在一起，而不被背景或其他不相关因素干扰。为了达到这个目的，我们不能止步于原始像素比较，得继续前进。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>简要说来：</p>
<ul>
<li>介绍了<strong>图像分类</strong>问题。在该问题中，给出一个由被标注了分类标签的图像组成的集合，要求算法能预测没有标签的图像的分类标签，并根据算法预测准确率进行评价。</li>
<li>介绍了一个简单的图像分类器：<strong>最近邻分类器(Nearest Neighbor classifier)</strong>。分类器中存在不同的超参数(比如k值或距离类型的选取)，要想选取好的超参数不是一件轻而易举的事。</li>
<li>选取超参数的正确方法是：将原始训练集分为训练集和<strong>验证集</strong>，我们在验证集上尝试不同的超参数，最后保留表现最好那个。</li>
<li>如果训练数据量不够，使用<strong>交叉验证</strong>方法，它能帮助我们在选取最优超参数的时候减少噪音。</li>
<li>一旦找到最优的超参数，就让算法以该参数在测试集跑且只跑一次，并根据测试结果评价算法。</li>
<li>最近邻分类器能够在CIFAR-10上得到将近40%的准确率。该算法简单易实现，但需要存储所有训练数据，并且在测试的时候过于耗费计算能力。</li>
<li>最后，我们知道了仅仅使用L1和L2范数来进行像素比较是不够的，图像更多的是按照背景和颜色被分类，而不是语义主体分身。</li>
</ul>
<p>在接下来的课程中，我们将专注于解决这些问题和挑战，并最终能够得到超过90%准确率的解决方案。该方案能够在完成学习就丢掉训练集，并在一毫秒之内就完成一张图片的分类。</p>
<h2 id="小结：实际应用k-NN"><a href="#小结：实际应用k-NN" class="headerlink" title="小结：实际应用k-NN"></a>小结：实际应用k-NN</h2><p>如果你希望将k-NN分类器用到实处（最好别用到图像上，若是仅仅作为练手还可以接受），那么可以按照以下流程：</p>
<ol>
<li>预处理你的数据：对你数据中的特征进行归一化（normalize），让其具有零平均值（zero mean）和单位方差（unit variance）。在后面的小节我们会讨论这些细节。本小节不讨论，是因为图像中的像素都是同质的，不会表现出较大的差异分布，也就不需要标准化处理了。</li>
<li>如果数据是高维数据，考虑使用降维方法，比如PCA或随机投影。</li>
<li>将数据随机分入训练集和验证集。按照一般规律，70%-90% 数据作为训练集。这个比例根据算法中有多少超参数，以及这些超参数对于算法的预期影响来决定。如果需要预测的超参数很多，那么就应该使用更大的验证集来有效地估计它们。如果担心验证集数量不够，那么就尝试交叉验证方法。如果计算资源足够，使用交叉验证总是更加安全的（份数越多，效果越好，也更耗费计算资源）。</li>
<li>在验证集上调优，尝试足够多的k值，尝试L1和L2两种范数计算方式。</li>
<li>如果分类器跑得太慢，尝试使用Approximate Nearest Neighbor库（比如FLANN）来加速这个过程，其代价是降低一些准确率。</li>
<li>对最优的超参数做记录。记录最优参数后，是否应该让使用最优参数的算法在完整的训练集上运行并再次训练呢？因为如果把验证集重新放回到训练集中（自然训练集的数据量就又变大了），有可能最优参数又会有所变化。在实践中，<strong>不要这样做</strong>。千万不要在最终的分类器中使用验证集数据，这样做会破坏对于最优参数的估计。<strong>直接使用测试集来测试用最优参数设置好的最优模型</strong>，得到测试集数据的分类准确率，并以此作为你的kNN分类器在该数据上的性能表现。</li>
</ol>
<h1 id="数据集代码实现"><a href="#数据集代码实现" class="headerlink" title="数据集代码实现"></a>数据集代码实现</h1><p>我们这里介绍了一系列的数据集和验证集的概念，但是我们肯定不会手动去进行计算和验证，必须依靠计算机来实现，所以我们应该如何使用代码去准备一个数据集呢？这就需要靠一些框架来完成这个操作</p>
<p>大家在算数的时候，会使用计算器来加快计算过程，在这里计算器只是一个工具，核心是你怎么去计算和要计算什么，在深度学习中也是，代码和相关的框架只不过是工具，可以起到计算器的作用，让你免于手动计算和自己搭建代码的困境，使你可以快速完成模型的学习</p>
<p>目前常用的深度学习框架是PyTorch、TensorFlow等，在学术界，PyTorch是主流的框架，而且简单易学，我们在这里使用PyTorch来完成一系列深度学习的代码任务</p>
<h2 id="数据集类——Dataset"><a href="#数据集类——Dataset" class="headerlink" title="数据集类——Dataset"></a>数据集类——Dataset</h2><p>在PyTorch中，Dataset是一个抽象的数据集类，可以用来自定义一些数据集类，用来实现从磁盘中读取数据集、读取标签和样本等操作，借助pytorch中dataset类，你可以创建适应任意模型的数据集接口</p>
<p>所谓数据集，无非就是一组{x:y}的集合吗，你只需要在这个类里说明“有一组{x:y}的集合”就可以了。x是样本的数据内容，y是样本标签</p>
<p>对于图像分类任务，图像+分类</p>
<p>对于目标检测任务，图像+bbox、分类</p>
<p>对于超分辨率任务，低分辨率图像+超分辨率图像</p>
<p>对于文本分类任务，文本+分类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dataset</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;An abstract class representing a Dataset.</span></span><br><span class="line"><span class="string">    All other datasets should subclass it. All subclasses should override</span></span><br><span class="line"><span class="string">    ``__len__``, that provides the size of the dataset, and ``__getitem__``,</span></span><br><span class="line"><span class="string">    supporting integer indexing in range from 0 to len(self) exclusive.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> ConcatDataset([self, other])</span><br></pre></td></tr></table></figure>
<p>上面的代码是pytorch给出的官方代码，其中__getitem__和__len__是子类必须继承的，或者说pytorch给出的官方代码限制了标准，你要按照它的标准进行数据集建立，其中__getitem__函数就是获取样本对（内容+标签），__len__就是获取数据集大小（或者说长度、样本数量）</p>
<p>比如说，我有一个图像分类的数据集，我想训练一个分类器，那么我就可以构建一个这样的数据集，它只需要满足下面的条件</p>
<ol>
<li>可以通过序号，得到图片和对应的分类标签</li>
<li>可以知道图片的数量（也就是数据集大小，从0开始计数）</li>
</ol>
<p>只要满足这两个条件，那么这个类就可以实例化为一个符合要求的数据集对象</p>
<p>我们考虑一个实际情况，图像分类的数据集放在文件夹D中，有三个类别的样本，分别在D下的a、b、c三个子文件夹中，子文件夹的名称就是类别的名称，那么我们如何自制一个数据集类来读取呢？</p>
<p>首先我们要告诉程序，数据集在哪里（或者说告诉路径），然后说明要对数据做什么变换，明确这是训练数据集还是验证数据集等等，所以我们需要在__init__函数中读取这些</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyDataSet</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, image_dir, dataset_type, transform=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        image_dir: 路径</span></span><br><span class="line"><span class="string">        dataset_type: [&#x27;train&#x27;, &#x27;test&#x27;]</span></span><br><span class="line"><span class="string">        transform：各种处理</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"> </span><br><span class="line">        self.dataset_path = image_dir</span><br><span class="line">        self.transform = transform</span><br><span class="line">        self.dataset_type = dataset_type</span><br><span class="line">        self.class_name=[]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> img_dir,class_name,_ <span class="keyword">in</span> os.walk(self.dataset_path) :</span><br><span class="line">            self.class_name.append(class_name)</span><br><span class="line">        lines = f.readlines()</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">            self.sample_list.append(line.strip())</span><br><span class="line">        f.close()</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line">        item = self.sample_list[index]</span><br><span class="line">        <span class="comment"># img = cv2.imread(item.split(&#x27; _&#x27;)[0])</span></span><br><span class="line">        img = Image.<span class="built_in">open</span>(item.split(<span class="string">&#x27; _&#x27;</span>)[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> self.transform <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            img = self.transform(img)</span><br><span class="line">        label = <span class="built_in">int</span>(item.split(<span class="string">&#x27; _&#x27;</span>)[-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> img, label</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.sample_list)</span><br></pre></td></tr></table></figure>
<h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><p>下面是一些你可能感兴趣的拓展阅读链接：</p>
<ul>
<li><a href="http://homes.cs.washington.edu/%7Epedrod/papers/cacm12.pdf">A Few Useful Things to Know about Machine Learning__</a>，文中第6节与本节相关，但是整篇文章都强烈推荐。  </li>
<li><a href="http://people.csail.mit.edu/torralba/shortCourseRLOC/index.html">Recognizing and Learning Object Categories__</a>，ICCV 2005上的一节关于物体分类的课程。  </li>
</ul>
]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>计算机视觉, 图像处理, 深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>eecs498 ML-DL-CV 笔记汇总</title>
    <url>/2024/05/06/10-28-51/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.05.06：初稿</li>
</ul>
<h2 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h2><ul>
<li><a href="/2024/05/06/10-28-38/" title="计算机视觉 Python常用库">计算机视觉笔记-第一章 Python常用库</a></li>
<li><a href="/2024/05/06/14-24-17/" title="计算机视觉 图像分类">计算机视觉笔记-第二章 图像分类</a></li>
<li><a href="/2024/05/06/15-22-39/" title="计算机视觉 线性分类器">计算机视觉笔记-第三章 线性分类器</a></li>
<li><a href="/2024/05/07/11-38-48/" title="计算机视觉 最优化">计算机视觉笔记-第四章 最优化</a></li>
<li><a href="/2024/05/07/12-17-20/" title="计算机视觉 神经网络">计算机视觉笔记-第五章 神经网络</a></li>
<li><a href="/2024/05/17/13-29-46/" title="计算机视觉 反向传播">计算机视觉笔记-第六章 反向传播</a></li>
<li><a href="/2024/05/17/13-57-26/" title="计算机视觉 卷积神经网络">计算机视觉笔记-第七章 卷积神经网络</a>
</li>
</ul>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>笔记来源：<a href="https://github.com/Momordicin/ML_DL_CV_with_pytorch">Momordicin</a><br>课程视频：<a href="https://www.bilibili.com/video/BV1zg411a7Wi/?p=1&amp;vd_source=d5a3522259c17126f1b623c977d04c3e">bilibili</a></p>
]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>计算机视觉, 图像处理, 深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机视觉 Python常用库</title>
    <url>/2024/05/06/10-28-38/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.05.06：初稿</li>
</ul>
<h2 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h2><ul>
<li><a href="/2024/05/06/10-28-51/" title="eecs498 ML-DL-CV 笔记汇总">计算机视觉-笔记汇总</a>
</li>
</ul>
<p>我们将使用Python编程语言来完成本课程的所有作业。Python是一门伟大的通用编程语言，在一些常用库（numpy, scipy, matplotlib）的帮助下，它又会变成一个强大的科学计算环境。</p>
<p>内容列表：</p>
<ul>
<li>Python<ul>
<li>基本数据类型</li>
<li>容器</li>
<li>函数</li>
<li>类</li>
</ul>
</li>
<li>Numpy<ul>
<li>数组</li>
<li>访问数组</li>
<li>数据类型</li>
<li>数组计算</li>
<li>广播</li>
</ul>
</li>
<li>SciPy<ul>
<li>图像操作</li>
<li>MATLAB文件</li>
<li>点之间的距离</li>
</ul>
</li>
<li>Matplotlib<ul>
<li>绘制图形</li>
<li>绘制多个图形</li>
<li>图像</li>
</ul>
</li>
</ul>
<h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p>Python是一种高级的，动态类型的多范型编程语言。很多时候，大家会说Python看起来简直和伪代码一样，这是因为你能够通过很少行数的代码表达出很有力的思想。举个例子，下面是用Python实现的经典的quicksort算法例子：  </p>
<pre><code class="lang-py">    def quicksort(arr):
        if len(arr) &lt;= 1:
            return arr
        pivot = arr[len(arr) / 2]
        left = [x for x in arr if x &lt; pivot]
        middle = [x for x in arr if x == pivot]
        right = [x for x in arr if x &gt; pivot]
        return quicksort(left) + middle + quicksort(right)

    print quicksort([3,6,8,10,1,2,1])
    # Prints &quot;[1, 1, 2, 3, 6, 8, 10]&quot;
</code></pre>
<h2 id="Python版本"><a href="#Python版本" class="headerlink" title="Python版本"></a>Python版本</h2><p>Python有两个支持的版本，分别是2.7和3.4。这有点让人迷惑，3.0向语言中引入了很多不向后兼容的变化，2.7下的代码有时候在3.4下是行不通的。在这个课程中，我们使用的是2.7版本。</p>
<p>如何查看版本呢？使用<strong>python —version</strong>命令。</p>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>和大多数编程语言一样，Python拥有一系列的基本数据类型，比如整型、浮点型、布尔型和字符串等。这些类型的使用方式和在其他语言中的使用方式是类似的。</p>
<p><strong>数字</strong>：整型和浮点型的使用与其他语言类似。</p>
<pre><code class="lang-py">    x = 3
    print type(x) # Prints &quot;&quot;
    print x       # Prints &quot;3&quot;
    print x + 1   # Addition; prints &quot;4&quot;
    print x - 1   # Subtraction; prints &quot;2&quot;
    print x * 2   # Multiplication; prints &quot;6&quot;
    print x ** 2  # Exponentiation; prints &quot;9&quot;
    x += 1
    print x  # Prints &quot;4&quot;
    x *= 2
    print x  # Prints &quot;8&quot;
    y = 2.5
    print type(y) # Prints &quot;&quot;
    print y, y + 1, y * 2, y ** 2 # Prints &quot;2.5 3.5 5.0 6.25&quot;
</code></pre>
<p>需要注意的是，Python中没有 x++ 和 x— 的操作符。</p>
<p><strong>布尔型</strong>：Python实现了所有的布尔逻辑，但用的是英语，而不是我们习惯的操作符（比如&amp;&amp;和||等）。</p>
<pre><code class="lang-py">    t = True
    f = False
    print type(t) # Prints &quot;&quot;
    print t and f # Logical AND; prints &quot;False&quot;
    print t or f  # Logical OR; prints &quot;True&quot;
    print not t   # Logical NOT; prints &quot;False&quot;
    print t != f  # Logical XOR; prints &quot;True&quot;
</code></pre>
<p><strong>字符串</strong>：Python对字符串的支持非常棒。  </p>
<pre><code class="lang-py">    hello = &#39;hello&#39;   # String literals can use single quotes
    world = &quot;world&quot;   # or double quotes; it does not matter.
    print hello       # Prints &quot;hello&quot;
    print len(hello)  # String length; prints &quot;5&quot;
    hw = hello + &#39; &#39; + world  # String concatenation
    print hw  # prints &quot;hello world&quot;
    hw12 = &#39;%s %s %d&#39; % (hello, world, 12)  # sprintf style string formatting
    print hw12  # prints &quot;hello world 12&quot;
</code></pre>
<p>字符串对象有一系列有用的方法，比如：  </p>
<pre><code class="lang-py">    s = &quot;hello&quot;
    print s.capitalize()  # Capitalize a string; prints &quot;Hello&quot;
    print s.upper()       # Convert a string to uppercase; prints &quot;HELLO&quot;
    print s.rjust(7)      # Right-justify a string, padding with spaces; prints &quot;  hello&quot;
    print s.center(7)     # Center a string, padding with spaces; prints &quot; hello &quot;
    print s.replace(&#39;l&#39;, &#39;(ell)&#39;)  # Replace all instances of one substring with another;
                                   # prints &quot;he(ell)(ell)o&quot;
    print &#39;  world &#39;.strip()  # Strip leading and trailing whitespace; prints &quot;world&quot;
</code></pre>
<h2 id="容器Containers"><a href="#容器Containers" class="headerlink" title="容器Containers"></a>容器Containers</h2><p><strong>译者注</strong>：有知友建议container翻译为复合数据类型，供读者参考。</p>
<p>Python有以下几种容器类型：列表（lists）、字典（dictionaries）、集合（sets）和元组（tuples）。</p>
<h2 id="列表Lists"><a href="#列表Lists" class="headerlink" title="列表Lists"></a>列表Lists</h2><p>列表就是Python中的数组，但是列表长度可变，且能包含不同类型元素。</p>
<pre><code class="lang-py">    xs = [3, 1, 2]   # Create a list
    print xs, xs[2]  # Prints &quot;[3, 1, 2] 2&quot;
    print xs[-1]     # Negative indices count from the end of the list; prints &quot;2&quot;
    xs[2] = &#39;foo&#39;    # Lists can contain elements of different types
    print xs         # Prints &quot;[3, 1, &#39;foo&#39;]&quot;
    xs.append(&#39;bar&#39;) # Add a new element to the end of the list
    print xs         # Prints 
    x = xs.pop()     # Remove and return the last element of the list
    print x, xs      # Prints &quot;bar [3, 1, &#39;foo&#39;]&quot;
</code></pre>
<p><strong>切片Slicing</strong>：为了一次性地获取列表中的元素，Python提供了一种简洁的语法，这就是切片。  </p>
<pre><code class="lang-py">    nums = range(5)    # range is a built-in function that creates a list of integers
    print nums         # Prints &quot;[0, 1, 2, 3, 4]&quot;
    print nums[2:4]    # Get a slice from index 2 to 4 (exclusive); prints &quot;[2, 3]&quot;
    print nums[2:]     # Get a slice from index 2 to the end; prints &quot;[2, 3, 4]&quot;
    print nums[:2]     # Get a slice from the start to index 2 (exclusive); prints &quot;[0, 1]&quot;
    print nums[:]      # Get a slice of the whole list; prints [&quot;0, 1, 2, 3, 4]&quot;
    print nums[:-1]    # Slice indices can be negative; prints [&quot;0, 1, 2, 3]&quot;
    nums[2:4] = [8, 9] # Assign a new sublist to a slice
    print nums         # Prints &quot;[0, 1, 8, 8, 4]&quot;
</code></pre>
<p>在Numpy数组的内容中，我们会再次看到切片语法。</p>
<p><strong>循环Loops</strong>：我们可以这样遍历列表中的每一个元素：</p>
<pre><code class="lang-py">    animals = [&#39;cat&#39;, &#39;dog&#39;, &#39;monkey&#39;]
    for animal in animals:
        print animal
    # Prints &quot;cat&quot;, &quot;dog&quot;, &quot;monkey&quot;, each on its own line.
</code></pre>
<p>如果想要在循环体内访问每个元素的指针，可以使用内置的<strong>enumerate</strong>函数  </p>
<pre><code class="lang-py">    animals = [&#39;cat&#39;, &#39;dog&#39;, &#39;monkey&#39;]
    for idx, animal in enumerate(animals):
        print &#39;#%d: %s&#39; % (idx + 1, animal)
    # Prints &quot;#1: cat&quot;, &quot;#2: dog&quot;, &quot;#3: monkey&quot;, each on its own line
</code></pre>
<p><strong>列表推导List comprehensions</strong>：在编程的时候，我们常常想要将一种数据类型转换为另一种。下面是一个简单例子，将列表中的每个元素变成它的平方。  </p>
<pre><code class="lang-py">    nums = [0, 1, 2, 3, 4]
    squares = []
    for x in nums:
        squares.append(x ** 2)
    print squares   # Prints [0, 1, 4, 9, 16]
</code></pre>
<p>使用列表推导，你就可以让代码简化很多：  </p>
<pre><code class="lang-py">    nums = [0, 1, 2, 3, 4]
    squares = [x ** 2 for x in nums]
    print squares   # Prints [0, 1, 4, 9, 16]
</code></pre>
<p>列表推导还可以包含条件：  </p>
<pre><code class="lang-py">    nums = [0, 1, 2, 3, 4]
    even_squares = [x ** 2 for x in nums if x % 2 == 0]
    print even_squares  # Prints &quot;[0, 4, 16]&quot;
</code></pre>
<h3 id="字典Dictionaries"><a href="#字典Dictionaries" class="headerlink" title="字典Dictionaries"></a>字典Dictionaries</h3><p>字典用来储存（键, 值）对，这和Java中的Map差不多。你可以这样使用它：</p>
<pre><code class="lang-py">    d = &#123;&#39;cat&#39;: &#39;cute&#39;, &#39;dog&#39;: &#39;furry&#39;&#125;  # Create a new dictionary with some data
    print d[&#39;cat&#39;]       # Get an entry from a dictionary; prints &quot;cute&quot;
    print &#39;cat&#39; in d     # Check if a dictionary has a given key; prints &quot;True&quot;
    d[&#39;fish&#39;] = &#39;wet&#39;    # Set an entry in a dictionary
    print d[&#39;fish&#39;]      # Prints &quot;wet&quot;
    # print d[&#39;monkey&#39;]  # KeyError: &#39;monkey&#39; not a key of d
    print d.get(&#39;monkey&#39;, &#39;N/A&#39;)  # Get an element with a default; prints &quot;N/A&quot;
    print d.get(&#39;fish&#39;, &#39;N/A&#39;)    # Get an element with a default; prints &quot;wet&quot;
    del d[&#39;fish&#39;]        # Remove an element from a dictionary
    print d.get(&#39;fish&#39;, &#39;N/A&#39;) # &quot;fish&quot; is no longer a key; prints &quot;N/A&quot;
</code></pre>
<p><strong>循环Loops</strong>：在字典中，用键来迭代更加容易。</p>
<pre><code class="lang-py">    d = &#123;&#39;person&#39;: 2, &#39;cat&#39;: 4, &#39;spider&#39;: 8&#125;
    for animal in d:
        legs = d[animal]
        print &#39;A %s has %d legs&#39; % (animal, legs)
    # Prints &quot;A person has 2 legs&quot;, &quot;A spider has 8 legs&quot;, &quot;A cat has 4 legs&quot;
</code></pre>
<p>如果你想要访问键和对应的值，那就使用<strong>iteritems</strong>方法：  </p>
<pre><code class="lang-py">    d = &#123;&#39;person&#39;: 2, &#39;cat&#39;: 4, &#39;spider&#39;: 8&#125;
    for animal, legs in d.iteritems():
        print &#39;A %s has %d legs&#39; % (animal, legs)
    # Prints &quot;A person has 2 legs&quot;, &quot;A spider has 8 legs&quot;, &quot;A cat has 4 legs&quot;
</code></pre>
<p><strong>字典推导Dictionary comprehensions</strong>：和列表推导类似，但是允许你方便地构建字典。  </p>
<pre><code class="lang-py">    nums = [0, 1, 2, 3, 4]
    even_num_to_square = &#123;x: x ** 2 for x in nums if x % 2 == 0&#125;
    print even_num_to_square  # Prints &quot;&#123;0: 0, 2: 4, 4: 16&#125;&quot;
</code></pre>
<h3 id="集合Sets"><a href="#集合Sets" class="headerlink" title="集合Sets"></a>集合Sets</h3><p>集合是独立不同个体的无序集合。示例如下：  </p>
<pre><code class="lang-py">    animals = &#123;&#39;cat&#39;, &#39;dog&#39;&#125;
    print &#39;cat&#39; in animals   # Check if an element is in a set; prints &quot;True&quot;
    print &#39;fish&#39; in animals  # prints &quot;False&quot;
    animals.add(&#39;fish&#39;)      # Add an element to a set
    print &#39;fish&#39; in animals  # Prints &quot;True&quot;
    print len(animals)       # Number of elements in a set; prints &quot;3&quot;
    animals.add(&#39;cat&#39;)       # Adding an element that is already in the set does nothing
    print len(animals)       # Prints &quot;3&quot;
    animals.remove(&#39;cat&#39;)    # Remove an element from a set
    print len(animals)       # Prints &quot;2&quot;
</code></pre>
<p><strong>循环Loops</strong>：在集合中循环的语法和在列表中一样，但是集合是无序的，所以你在访问集合的元素的时候，不能做关于顺序的假设。</p>
<pre><code class="lang-py">    animals = &#123;&#39;cat&#39;, &#39;dog&#39;, &#39;fish&#39;&#125;
    for idx, animal in enumerate(animals):
        print &#39;#%d: %s&#39; % (idx + 1, animal)
    # Prints &quot;#1: fish&quot;, &quot;#2: dog&quot;, &quot;#3: cat&quot;
</code></pre>
<p><strong>集合推导**</strong>Set comprehensions**：和字典推导一样，可以很方便地构建集合：</p>
<pre><code class="lang-py">    from math import sqrt
    nums = &#123;int(sqrt(x)) for x in range(30)&#125;
    print nums  # Prints &quot;set([0, 1, 2, 3, 4, 5])&quot;
</code></pre>
<h3 id="元组Tuples"><a href="#元组Tuples" class="headerlink" title="元组Tuples"></a>元组Tuples</h3><p>元组是一个值的有序列表（不可改变）。从很多方面来说，元组和列表都很相似。和列表最重要的不同在于，元组可以在字典中用作键，还可以作为集合的元素，而列表不行。例子如下：  </p>
<pre><code class="lang-py">    d = &#123;(x, x + 1): x for x in range(10)&#125;  # Create a dictionary with tuple keys
    print d
    t = (5, 6)       # Create a tuple
    print type(t)    # Prints &quot;&quot;
    print d[t]       # Prints &quot;5&quot;
    print d[(1, 2)]  # Prints &quot;1&quot;
</code></pre>
<h2 id="函数Functions"><a href="#函数Functions" class="headerlink" title="函数Functions"></a>函数Functions</h2><p>Python函数使用def来定义函数：  </p>
<pre><code class="lang-py">    def sign(x):
        if x &gt; 0:
            return &#39;positive&#39;
        elif x &lt; 0:
            return &#39;negative&#39;
        else:
            return &#39;zero&#39;

    for x in [-1, 0, 1]:
        print sign(x)
    # Prints &quot;negative&quot;, &quot;zero&quot;, &quot;positive&quot;
</code></pre>
<p>我们常常使用可选参数来定义函数：  </p>
<pre><code class="lang-py">    def hello(name, loud=False):
        if loud:
            print &#39;HELLO, %s&#39; % name.upper()
        else:
            print &#39;Hello, %s!&#39; % name

    hello(&#39;Bob&#39;) # Prints &quot;Hello, Bob&quot;
    hello(&#39;Fred&#39;, loud=True)  # Prints &quot;HELLO, FRED!&quot;
</code></pre>
<h2 id="类Classes"><a href="#类Classes" class="headerlink" title="类Classes"></a>类Classes</h2><p>Python对于类的定义是简单直接的：</p>
<pre><code class="lang-py">    class Greeter(object):

        # Constructor
        def __init__(self, name):
            self.name = name  # Create an instance variable

        # Instance method
        def greet(self, loud=False):
            if loud:
                print &#39;HELLO, %s!&#39; % self.name.upper()
            else:
                print &#39;Hello, %s&#39; % self.name

    g = Greeter(&#39;Fred&#39;)  # Construct an instance of the Greeter class
    g.greet()            # Call an instance method; prints &quot;Hello, Fred&quot;
    g.greet(loud=True)   # Call an instance method; prints &quot;HELLO, FRED!&quot;
</code></pre>
<p>Numpy是Python中用于科学计算的核心库。它提供了高性能的多维数组对象，以及相关工具。</p>
<h2 id="数组Arrays"><a href="#数组Arrays" class="headerlink" title="数组Arrays"></a>数组Arrays</h2><p>一个numpy数组是一个由不同数值组成的网格。网格中的数据都是同一种数据类型，可以通过非负整型数的元组来访问。维度的数量被称为数组的阶，数组的大小是一个由整型数构成的元组，可以描述数组不同维度上的大小。</p>
<p>我们可以从列表创建数组，然后利用方括号访问其中的元素：</p>
<pre><code class="lang-py">    import numpy as np

    a = np.array([1, 2, 3])  # Create a rank 1 array
    print type(a)            # Prints &quot;&quot;
    print a.shape            # Prints &quot;(3,)&quot;
    print a[0], a[1], a[2]   # Prints &quot;1 2 3&quot;
    a[0] = 5                 # Change an element of the array
    print a                  # Prints &quot;[5, 2, 3]&quot;

    b = np.array([[1,2,3],[4,5,6]])   # Create a rank 2 array
    print b                           # 显示一下矩阵b
    print b.shape                     # Prints &quot;(2, 3)&quot;
    print b[0, 0], b[0, 1], b[1, 0]   # Prints &quot;1 2 4&quot;
</code></pre>
<p>Numpy还提供了很多其他创建数组的方法：  </p>
<pre><code class="lang-py">    import numpy as np

    a = np.zeros((2,2))  # Create an array of all zeros
    print a              # Prints &quot;[[ 0.  0.]
                         #          [ 0.  0.]]&quot;

    b = np.ones((1,2))   # Create an array of all ones
    print b              # Prints &quot;[[ 1.  1.]]&quot;

    c = np.full((2,2), 7) # Create a constant array
    print c               # Prints &quot;[[ 7.  7.]
                          #          [ 7.  7.]]&quot;

    d = np.eye(2)        # Create a 2x2 identity matrix
    print d              # Prints &quot;[[ 1.  0.]
                         #          [ 0.  1.]]&quot;

    e = np.random.random((2,2)) # Create an array filled with random values
    print e                     # Might print &quot;[[ 0.91940167  0.08143941]
                                #               [ 0.68744134  0.87236687]]&quot;
</code></pre>
<h2 id="访问数组"><a href="#访问数组" class="headerlink" title="访问数组"></a>访问数组</h2><p>Numpy提供了多种访问数组的方法。</p>
<p><strong>切片</strong>：和Python列表类似，numpy数组可以使用切片语法。因为数组可以是多维的，所以你<strong>必须</strong>为每个维度指定好切片。</p>
<pre><code class="lang-py">    import numpy as np

    # Create the following rank 2 array with shape (3, 4)
    # [[ 1  2  3  4]
    #  [ 5  6  7  8]
    #  [ 9 10 11 12]]
    a = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])

    # Use slicing to pull out the subarray consisting of the first 2 rows
    # and columns 1 and 2; b is the following array of shape (2, 2):
    # [[2 3]
    #  [6 7]]
    b = a[:2, 1:3]

    # A slice of an array is a view into the same data, so modifying it
    # will modify the original array.
    print a[0, 1]   # Prints &quot;2&quot;
    b[0, 0] = 77    # b[0, 0] is the same piece of data as a[0, 1]
    print a[0, 1]   # Prints &quot;77&quot;
</code></pre>
<p>你可以同时使用整型和切片语法来访问数组。但是，这样做会产生一个比原数组低阶的新数组。需要注意的是，这里和MATLAB中的情况是不同的：  </p>
<pre><code class="lang-py">    import numpy as np

    # Create the following rank 2 array with shape (3, 4)
    # [[ 1  2  3  4]
    #  [ 5  6  7  8]
    #  [ 9 10 11 12]]
    a = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])

    # Two ways of accessing the data in the middle row of the array.
    # Mixing integer indexing with slices yields an array of lower rank,
    # while using only slices yields an array of the same rank as the
    # original array:
    row_r1 = a[1, :]    # Rank 1 view of the second row of a  
    row_r2 = a[1:2, :]  # Rank 2 view of the second row of a
    print row_r1, row_r1.shape  # Prints &quot;[5 6 7 8] (4,)&quot;
    print row_r2, row_r2.shape  # Prints &quot;[[5 6 7 8]] (1, 4)&quot;

    # We can make the same distinction when accessing columns of an array:
    col_r1 = a[:, 1]
    col_r2 = a[:, 1:2]
    print col_r1, col_r1.shape  # Prints &quot;[ 2  6 10] (3,)&quot;
    print col_r2, col_r2.shape  # Prints &quot;[[ 2]
                                #          [ 6]
                                #          [10]] (3, 1)&quot;
</code></pre>
<p><strong>整型数组访问</strong>：当我们使用切片语法访问数组时，得到的总是原数组的一个子集。整型数组访问允许我们利用其它数组的数据构建一个新的数组：  </p>
<pre><code class="lang-py">    import numpy as np

    a = np.array([[1,2], [3, 4], [5, 6]])

    # An example of integer array indexing.
    # The returned array will have shape (3,) and 
    print a[[0, 1, 2], [0, 1, 0]]  # Prints &quot;[1 4 5]&quot;

    # The above example of integer array indexing is equivalent to this:
    print np.array([a[0, 0], a[1, 1], a[2, 0]])  # Prints &quot;[1 4 5]&quot;

    # When using integer array indexing, you can reuse the same
    # element from the source array:
    print a[[0, 0], [1, 1]]  # Prints &quot;[2 2]&quot;

    # Equivalent to the previous integer array indexing example
    print np.array([a[0, 1], a[0, 1]])  # Prints &quot;[2 2]&quot;
</code></pre>
<p>整型数组访问语法还有个有用的技巧，可以用来选择或者更改矩阵中每行中的一个元素：  </p>
<pre><code class="lang-py">    import numpy as np

    # Create a new array from which we will select elements
    a = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])

    print a  # prints &quot;array([[ 1,  2,  3],
             #                [ 4,  5,  6],
             #                [ 7,  8,  9],
             #                [10, 11, 12]])&quot;

    # Create an array of indices
    b = np.array([0, 2, 0, 1])

    # Select one element from each row of a using the indices in b
    print a[np.arange(4), b]  # Prints &quot;[ 1  6  7 11]&quot;

    # Mutate one element from each row of a using the indices in b
    a[np.arange(4), b] += 10

    print a  # prints &quot;array([[11,  2,  3],
             #                [ 4,  5, 16],
             #                [17,  8,  9],
             #                [10, 21, 12]])
</code></pre>
<p><strong>布尔型数组访问</strong>：布尔型数组访问可以让你选择数组中任意元素。通常，这种访问方式用于选取数组中满足某些条件的元素，举例如下：  </p>
<pre><code class="lang-py">    import numpy as np

    a = np.array([[1,2], [3, 4], [5, 6]])

    bool_idx = (a &gt; 2)  # Find the elements of a that are bigger than 2;
                        # this returns a numpy array of Booleans of the same
                        # shape as a, where each slot of bool_idx tells
                        # whether that element of a is &gt; 2.

    print bool_idx      # Prints &quot;[[False False]
                        #          [ True  True]
                        #          [ True  True]]&quot;

    # We use boolean array indexing to construct a rank 1 array
    # consisting of the elements of a corresponding to the True values
    # of bool_idx
    print a[bool_idx]  # Prints &quot;[3 4 5 6]&quot;

    # We can do all of the above in a single concise statement:
    print a[a &gt; 2]     # Prints &quot;[3 4 5 6]&quot;
</code></pre>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>每个Numpy数组都是数据类型相同的元素组成的网格。Numpy提供了很多的数据类型用于创建数组。当你创建数组的时候，Numpy会尝试猜测数组的数据类型，你也可以通过参数直接指定数据类型，例子如下：</p>
<pre><code class="lang-py">    import numpy as np

    x = np.array([1, 2])  # Let numpy choose the datatype
    print x.dtype         # Prints &quot;int64&quot;

    x = np.array([1.0, 2.0])  # Let numpy choose the datatype
    print x.dtype             # Prints &quot;float64&quot;

    x = np.array([1, 2], dtype=np.int64)  # Force a particular datatype
    print x.dtype                         # Prints &quot;int64&quot;
</code></pre>
<h2 id="数组计算"><a href="#数组计算" class="headerlink" title="数组计算"></a>数组计算</h2><p>基本数学计算函数会对数组中元素逐个进行计算，既可以利用操作符重载，也可以使用函数方式：  </p>
<pre><code class="lang-py">    import numpy as np

    x = np.array([[1,2],[3,4]], dtype=np.float64)
    y = np.array([[5,6],[7,8]], dtype=np.float64)

    # Elementwise sum; both produce the array
    # [[ 6.0  8.0]
    #  [10.0 12.0]]
    print x + y
    print np.add(x, y)

    # Elementwise difference; both produce the array
    # [[-4.0 -4.0]
    #  [-4.0 -4.0]]
    print x - y
    print np.subtract(x, y)

    # Elementwise product; both produce the array
    # [[ 5.0 12.0]
    #  [21.0 32.0]]
    print x * y
    print np.multiply(x, y)

    # Elementwise division; both produce the array
    # [[ 0.2         0.33333333]
    #  [ 0.42857143  0.5       ]]
    print x / y
    print np.divide(x, y)

    # Elementwise square root; produces the array
    # [[ 1.          1.41421356]
    #  [ 1.73205081  2.        ]]
    print np.sqrt(x)
</code></pre>
<p>和MATLAB不同，*是元素逐个相乘，而不是矩阵乘法。在Numpy中使用dot来进行矩阵乘法：  </p>
<pre><code class="lang-py">    import numpy as np

    x = np.array([[1,2],[3,4]])
    y = np.array([[5,6],[7,8]])

    v = np.array([9,10])
    w = np.array([11, 12])

    # Inner product of vectors; both produce 219
    print v.dot(w)
    print np.dot(v, w)

    # Matrix / vector product; both produce the rank 1 array [29 67]
    print x.dot(v)
    print np.dot(x, v)

    # Matrix / matrix product; both produce the rank 2 array
    # [[19 22]
    #  [43 50]]
    print x.dot(y)
    print np.dot(x, y)
</code></pre>
<p>Numpy提供了很多计算数组的函数，其中最常用的一个是<strong>sum</strong>：  </p>
<pre><code class="lang-py">    import numpy as np

    x = np.array([[1,2],[3,4]])

    print np.sum(x)  # Compute sum of all elements; prints &quot;10&quot;
    print np.sum(x, axis=0)  # Compute sum of each column; prints &quot;[4 6]&quot;
    print np.sum(x, axis=1)  # Compute sum of each row; prints &quot;[3 7]&quot;
</code></pre>
<p>除了计算，我们还常常改变数组或者操作其中的元素。其中将矩阵转置是常用的一个，在Numpy中，使用<strong>T</strong>来转置矩阵：</p>
<pre><code class="lang-py">    import numpy as np

    x = np.array([[1,2], [3,4]])
    print x    # Prints &quot;[[1 2]
               #          [3 4]]&quot;
    print x.T  # Prints &quot;[[1 3]
               #          [2 4]]&quot;

    # Note that taking the transpose of a rank 1 array does nothing:
    v = np.array([1,2,3])
    print v    # Prints &quot;[1 2 3]&quot;
    print v.T  # Prints &quot;[1 2 3]&quot;
</code></pre>
<h2 id="广播Broadcasting"><a href="#广播Broadcasting" class="headerlink" title="广播Broadcasting"></a>广播Broadcasting</h2><p>广播是一种强有力的机制，它让Numpy可以让不同大小的矩阵在一起进行数学计算。我们常常会有一个小的矩阵和一个大的矩阵，然后我们会需要用小的矩阵对大的矩阵做一些计算。</p>
<p>举个例子，如果我们想要把一个向量加到矩阵的每一行，我们可以这样做：</p>
<pre><code class="lang-py">    import numpy as np

    # We will add the vector v to each row of the matrix x,
    # storing the result in the matrix y
    x = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])
    v = np.array([1, 0, 1])
    y = np.empty_like(x)   # Create an empty matrix with the same shape as x

    # Add the vector v to each row of the matrix x with an explicit loop
    for i in range(4):
        y[i, :] = x[i, :] + v

    # Now y is the following
    # [[ 2  2  4]
    #  [ 5  5  7]
    #  [ 8  8 10]
    #  [11 11 13]]
    print y
</code></pre>
<p>这样是行得通的，但是当x矩阵非常大，利用循环来计算就会变得很慢很慢。我们可以换一种思路：  </p>
<pre><code class="lang-py">    import numpy as np

    # We will add the vector v to each row of the matrix x,
    # storing the result in the matrix y
    x = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])
    v = np.array([1, 0, 1])
    vv = np.tile(v, (4, 1))  # Stack 4 copies of v on top of each other
    print vv                 # Prints &quot;[[1 0 1]
                             #          [1 0 1]
                             #          [1 0 1]
                             #          [1 0 1]]&quot;
    y = x + vv  # Add x and vv elementwise
    print y  # Prints &quot;[[ 2  2  4
             #          [ 5  5  7]
             #          [ 8  8 10]
             #          [11 11 13]]&quot;
</code></pre>
<p>Numpy广播机制可以让我们不用创建vv，就能直接运算，看看下面例子：  </p>
<pre><code class="lang-py">    import numpy as np

    # We will add the vector v to each row of the matrix x,
    # storing the result in the matrix y
    x = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])
    v = np.array([1, 0, 1])
    y = x + v  # Add v to each row of x using broadcasting
    print y  # Prints &quot;[[ 2  2  4]
             #          [ 5  5  7]
             #          [ 8  8 10]
             #          [11 11 13]]&quot;
</code></pre>
<p>对两个数组使用广播机制要遵守下列规则：</p>
<ol>
<li>如果数组的秩不同，使用1来将秩较小的数组进行扩展，直到两个数组的尺寸的长度都一样。</li>
<li>如果两个数组在某个维度上的长度是一样的，或者其中一个数组在该维度上长度为1，那么我们就说这两个数组在该维度上是<strong>相容</strong>的。</li>
<li>如果两个数组在所有维度上都是相容的，他们就能使用广播。</li>
<li>如果两个输入数组的尺寸不同，那么注意其中较大的那个尺寸。因为广播之后，两个数组的尺寸将和那个较大的尺寸一样。</li>
<li>在任何一个维度上，如果一个数组的长度为1，另一个数组长度大于1，那么在该维度上，就好像是对第一个数组进行了复制。</li>
</ol>
<p>支持广播机制的函数是全局函数。</p>
<p>下面是一些广播机制的使用：</p>
<pre><code class="lang-py">    import numpy as np

    # Compute outer product of vectors
    v = np.array([1,2,3])  # v has shape (3,)
    w = np.array([4,5])    # w has shape (2,)
    # To compute an outer product, we first reshape v to be a column
    # vector of shape (3, 1); we can then broadcast it against w to yield
    # an output of shape (3, 2), which is the outer product of v and w:
    # [[ 4  5]
    #  [ 8 10]
    #  [12 15]]
    print np.reshape(v, (3, 1)) * w

    # Add a vector to each row of a matrix
    x = np.array([[1,2,3], [4,5,6]])
    # x has shape (2, 3) and v has shape (3,) so they broadcast to (2, 3),
    # giving the following matrix:
    # [[2 4 6]
    #  [5 7 9]]
    print x + v

    # Add a vector to each column of a matrix
    # x has shape (2, 3) and w has shape (2,).
    # If we transpose x then it has shape (3, 2) and can be broadcast
    # against w to yield a result of shape (3, 2); transposing this result
    # yields the final result of shape (2, 3) which is the matrix x with
    # the vector w added to each column. Gives the following matrix:
    # [[ 5  6  7]
    #  [ 9 10 11]]
    print (x.T + w).T

    # Another solution is to reshape w to be a row vector of shape (2, 1);
    # we can then broadcast it directly against x to produce the same
    # output.
    print x + np.reshape(w, (2, 1))

    # Multiply a matrix by a constant:
    # x has shape (2, 3). Numpy treats scalars as arrays of shape ();
    # these can be broadcast together to shape (2, 3), producing the
    # following array:
    # [[ 2  4  6]
    #  [ 8 10 12]]
    print x * 2
</code></pre>
<p>广播机制能够让你的代码更简洁更迅速，能够用的时候请尽量使用！  </p>
<h2 id="Numpy文档"><a href="#Numpy文档" class="headerlink" title="Numpy文档"></a>Numpy文档</h2><p>这篇教程涉及了你需要了解的numpy中的一些重要内容，但是numpy远不止如此。</p>
<p>Numpy提供了高性能的多维数组，以及计算和操作数组的基本工具。SciPy基于Numpy，提供了大量的计算和操作数组的函数，这些函数对于不同类型的科学和工程计算非常有用。</p>
<p>熟悉SciPy的最好方法就是阅读文档。我们会强调对于本课程有用的部分。</p>
<h2 id="图像操作"><a href="#图像操作" class="headerlink" title="图像操作"></a>图像操作</h2><p>SciPy提供了一些操作图像的基本函数。比如，它提供了将图像从硬盘读入到数组的函数，也提供了将数组中数据写入的硬盘成为图像的函数。下面是一个简单的例子：</p>
<pre><code class="lang-py">    from scipy.misc import imread, imsave, imresize

    # Read an JPEG image into a numpy array
    img = imread(&#39;assets/cat.jpg&#39;)
    print img.dtype, img.shape  # Prints &quot;uint8 (400, 248, 3)&quot;

    # We can tint the image by scaling each of the color channels
    # by a different scalar constant. The image has shape (400, 248, 3);
    # we multiply it by the array [1, 0.95, 0.9] of shape (3,);
    # numpy broadcasting means that this leaves the red channel unchanged,
    # and multiplies the green and blue channels by 0.95 and 0.9
    # respectively.
    img_tinted = img * [1, 0.95, 0.9]

    # Resize the tinted image to be 300 by 300 pixels.
    img_tinted = imresize(img_tinted, (300, 300))

    # Write the tinted image back to disk
    imsave(&#39;assets/cat_tinted.jpg&#39;, img_tinted)
</code></pre>
<img src="/2024/05/06/10-28-38/ff5f35bdb1a53c5e8dd5a16b391f63df_b.png" class>
<p>左边是原始图片，右边是变色和变形的图片。</p>
<h2 id="MATLAB文件"><a href="#MATLAB文件" class="headerlink" title="MATLAB文件"></a>MATLAB文件</h2><p>函数<strong>scipy.io.loadmat</strong>和<strong>scipy.io.savemat</strong>能够让你读和写MATLAB文件。</p>
<h2 id="点之间的距离"><a href="#点之间的距离" class="headerlink" title="点之间的距离"></a>点之间的距离</h2><p>SciPy定义了一些有用的函数，可以计算集合中点之间的距离。</p>
<p>函数<strong>scipy.spatial.distance.pdist</strong>能够计算集合中所有两点之间的距离：</p>
<pre><code class="lang-py">    import numpy as np
    from scipy.spatial.distance import pdist, squareform

    # Create the following array where each row is a point in 2D space:
    # [[0 1]
    #  [1 0]
    #  [2 0]]
    x = np.array([[0, 1], [1, 0], [2, 0]])
    print x

    # Compute the Euclidean distance between all rows of x.
    # d[i, j] is the Euclidean distance between x[i, :] and x[j, :],
    # and d is the following array:
    # [[ 0.          1.41421356  2.23606798]
    #  [ 1.41421356  0.          1.        ]
    #  [ 2.23606798  1.          0.        ]]
    d = squareform(pdist(x, &#39;euclidean&#39;))
    print d
</code></pre>
<p>函数<strong>scipy.spatial.distance.cdist</strong>可以计算不同集合中点的距离，## Matplotlib</p>
<p>Matplotlib是一个作图库。这里简要介绍<strong>matplotlib.pyplot</strong>模块，功能和MATLAB的作图功能类似。</p>
<h3 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h3><p>matplotlib库中最重要的函数是<strong>Plot</strong>。该函数允许你做出2D图形，如下：  </p>
<pre><code class="lang-py">    import numpy as np
    import matplotlib.pyplot as plt

    # Compute the x and y coordinates for points on a sine curve
    x = np.arange(0, 3 * np.pi, 0.1)
    y = np.sin(x)

    # Plot the points using matplotlib
    plt.plot(x, y)
    plt.show()  # You must call plt.show() to make graphics appear.
</code></pre>
<p>运行上面代码会产生下面的作图：  </p>
<img src="/2024/05/06/10-28-38/47169e8280088396107e0c62d7689e07_b.png" class>
<p>只需要少量工作，就可以一次画不同的线，加上标签，坐标轴标志等。  </p>
<pre><code class="lang-py">    import numpy as np
    import matplotlib.pyplot as plt

    # Compute the x and y coordinates for points on sine and cosine curves
    x = np.arange(0, 3 * np.pi, 0.1)
    y_sin = np.sin(x)
    y_cos = np.cos(x)

    # Plot the points using matplotlib
    plt.plot(x, y_sin)
    plt.plot(x, y_cos)
    plt.xlabel(&#39;x axis label&#39;)
    plt.ylabel(&#39;y axis label&#39;)
    plt.title(&#39;Sine and Cosine&#39;)
    plt.legend([&#39;Sine&#39;, &#39;Cosine&#39;])
    plt.show()
</code></pre>
<img src="/2024/05/06/10-28-38/955a7bcd45981728e91693961c21fbae_b.png" class>
<h2 id="绘制多个图像"><a href="#绘制多个图像" class="headerlink" title="绘制多个图像"></a>绘制多个图像</h2><p>可以使用<strong>subplot</strong>函数来在一幅图中画不同的东西：  </p>
<pre><code class="lang-py">    import numpy as np
    import matplotlib.pyplot as plt

    # Compute the x and y coordinates for points on sine and cosine curves
    x = np.arange(0, 3 * np.pi, 0.1)
    y_sin = np.sin(x)
    y_cos = np.cos(x)

    # Set up a subplot grid that has height 2 and width 1,
    # and set the first such subplot as active.
    plt.subplot(2, 1, 1)

    # Make the first plot
    plt.plot(x, y_sin)
    plt.title(&#39;Sine&#39;)

    # Set the second subplot as active, and make the second plot.
    plt.subplot(2, 1, 2)
    plt.plot(x, y_cos)
    plt.title(&#39;Cosine&#39;)

    # Show the figure.
    plt.show()
</code></pre>
<img src="/2024/05/06/10-28-38/c2abf551074a0db7445067f460417a08_b.png" class>
<h2 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h2><p>你可以使用<strong>imshow</strong>函数来显示图像，如下所示：  </p>
<pre><code class="lang-py">    import numpy as np
    from scipy.misc import imread, imresize
    import matplotlib.pyplot as plt

    img = imread(&#39;assets/cat.jpg&#39;)
    img_tinted = img * [1, 0.95, 0.9]

    # Show the original image
    plt.subplot(1, 2, 1)
    plt.imshow(img)

    # Show the tinted image
    plt.subplot(1, 2, 2)

    # A slight gotcha with imshow is that it might give strange results
    # if presented with data that is not uint8. To work around this, we
    # explicitly cast the image to uint8 before displaying it.
    plt.imshow(np.uint8(img_tinted))
    plt.show()
</code></pre>
<img src="/2024/05/06/10-28-38/81197033afe9b507dea565ed558a6239_b.png" class>
]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>计算机视觉, 图像处理, 深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机视觉概论 光反射成像，亮度，阴影</title>
    <url>/2024/05/03/12-11-15/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.05.03：初稿</li>
</ul>
<h2 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h2><ul>
<li><a href="/2024/04/27/08-42-03/" title="Ud810 Intro-to-cv 笔记汇总">计算机视觉概率-笔记汇总</a>
</li>
</ul>
<h2 id="图像的成像"><a href="#图像的成像" class="headerlink" title="图像的成像"></a>图像的成像</h2><h3 id="表面纹理"><a href="#表面纹理" class="headerlink" title="表面纹理"></a>表面纹理</h3><img src="/2024/05/03/12-11-15/QQ20240505-101936@2x.png" class>
<p>图像由：一小块表面法线，表面折射率，照明组成。</p>
<h4 id="辐射率"><a href="#辐射率" class="headerlink" title="辐射率"></a>辐射率</h4><img src="/2024/05/03/12-11-15/QQ20240505-102048@2x.png" class>
<p>辐射率：单位面积上吸收的能量<br>单位：瓦每平方米 $Wm^{-2}Sr^{-1}$</p>
<p>到达表面的能量：E<br>单位：$Wm^{-2}$</p>
<img src="/2024/05/03/12-11-15/QQ20240505-102428@2x.png" class>
<h4 id="双向反射分布函数-BRDF"><a href="#双向反射分布函数-BRDF" class="headerlink" title="双向反射分布函数 BRDF"></a>双向反射分布函数 BRDF</h4><p>入射，反射<br><img src="/2024/05/03/12-11-15/QQ20240505-102527@2x.png" class><br><img src="/2024/05/03/12-11-15/QQ20240505-102622@2x.png" class></p>
<p>BRDF公式：$f(\theta_i,\varphi_i;\theta_r,\varphi_r)=\frac{L^{surface}(\theta_r,\varphi_r)}{E^{surface}(\theta_i,\varphi_i)}$<br>反射与入射的比例</p>
<p>重要属性：<br>交换光源和照相机，比例不变：<br>$f(\theta_i,\varphi_i;\theta_r,\varphi_r)=f(\theta_r,\varphi_r;\theta_i,\varphi_i)$</p>
<p>旋转对称性：<br>$f(\theta_i,\varphi_i;\theta_r,\varphi_r)=f(\theta_i,\theta_r,\varphi_i-\varphi_r)$<br>表明公式与绝对角度无关，只有他们之间的相对角度有关。</p>
<h3 id="反射模型"><a href="#反射模型" class="headerlink" title="反射模型"></a>反射模型</h3><p>漫反射<br><img src="/2024/05/03/12-11-15/QQ20240505-103332@2x.png" class></p>
<p>镜面反射<br><img src="/2024/05/03/12-11-15/QQ20240505-103403@2x.png" class></p>
<p>反射光强度</p>
<img src="/2024/05/03/12-11-15/QQ20240505-103443@2x.png" class>
<h4 id="Lambertian-BRDF"><a href="#Lambertian-BRDF" class="headerlink" title="Lambertian BRDF"></a>Lambertian BRDF</h4><p>所有方向看起来一样亮</p>
<img src="/2024/05/03/12-11-15/QQ20240505-103722@2x.png" class>
<p>光的反射是按照角度衰减的。<br>为什么看到的光亮度相同？<br>因为垂直角度看到的面积小，但亮度高，接近平行的面积大，亮度低，总体看起来亮度相同。</p>
<img src="/2024/05/03/12-11-15/QQ20240505-104119@2x.png" class>
<p>光的反射率是一个常数<br>$albedo$:$f\left(\theta_i,\varphi_i;\theta_r,\varphi_r\right)=\rho_d$</p>
<p>表面辐射：$L=\rho_d I\cos\theta_i=\rho_d I ( \vec{n} \cdot\vec{s})$</p>
<p>镜面BRDF：<br><img src="/2024/05/03/12-11-15/QQ20240505-104452@2x.png" class><br>BRDF:$f(\theta_i,\phi_i;\theta_v,\phi_v)=\rho_s\delta(\theta_i-\theta_v)\delta(\phi_i+\pi-\phi_v)$<br>表面辐射：$L=I\rho_S\delta(\theta_i-\theta_v)\delta(\varphi_i+\pi-\varphi_v)$</p>
<p>另一种写法：$L=I\rho_s\delta(\vec{m}-\vec{v})\mathrm{~or~}I\rho_s\delta(\vec{n}-\vec{h})$<br>$\vec{h}$：半角</p>
<h4 id="光泽BRDF-Glossy"><a href="#光泽BRDF-Glossy" class="headerlink" title="光泽BRDF  Glossy"></a>光泽BRDF  Glossy</h4><img src="/2024/05/03/12-11-15/QQ20240505-104912@2x.png" class>
<p>表面辐射：$L=I\rho_s(\vec{m}\cdot\vec{v})^k$</p>
<h3 id="Phong-反射模型"><a href="#Phong-反射模型" class="headerlink" title="Phong 反射模型"></a>Phong 反射模型</h3><img src="/2024/05/03/12-11-15/QQ20240505-105128@2x.png" class>
<h2 id="亮度"><a href="#亮度" class="headerlink" title="亮度"></a>亮度</h2><h4 id="亮度假设"><a href="#亮度假设" class="headerlink" title="亮度假设"></a>亮度假设</h4><img src="/2024/05/03/12-11-15/QQ20240505-105533@2x.png" class>
<img src="/2024/05/03/12-11-15/QQ20240505-105617@2x.png" class>
<p>实际上两个方块的亮度是相同的，但大脑一直在补偿阴影。</p>
<img src="/2024/05/03/12-11-15/QQ20240505-105812@2x.png" class>
<img src="/2024/05/03/12-11-15/QQ20240505-105812@2x.png" class>
<p>亮度：等于反射率乘能量<br><img src="/2024/05/03/12-11-15/QQ20240505-110117@2x.png" class></p>
<h3 id="蒙德里安世界-The-Mondrian-world"><a href="#蒙德里安世界-The-Mondrian-world" class="headerlink" title="蒙德里安世界 The Mondrian world"></a>蒙德里安世界 The Mondrian world</h3><p>计算机的假设：</p>
<ol>
<li>光是缓慢变化的</li>
<li>反射率是常数</li>
<li>物体之间的反射率变化急剧<img src="/2024/05/03/12-11-15/QQ20240505-110352@2x.png" class>
</li>
</ol>
<p>强度恒定的斑块：<br><img src="/2024/05/03/12-11-15/QQ20240505-110431@2x.png" class></p>
<p>假设光照强度是低频的，缓慢变化。<br>边缘的反射率是恒定的。<br>图像相加？：<br><img src="/2024/05/03/12-11-15/QQ20240505-110637@2x.png" class></p>
<p>如何恢复反射率：<br><img src="/2024/05/03/12-11-15/QQ20240505-110754@2x.png" class></p>
<h4 id="视网膜色素-Land’s-Retinex-Theory"><a href="#视网膜色素-Land’s-Retinex-Theory" class="headerlink" title="视网膜色素 Land’s Retinex Theory"></a>视网膜色素 Land’s Retinex Theory</h4><p>展示了人类如何感知不同色素<br>目标：消除缓慢变化<br>$\log(L(x,y))~=~\log(R(x,y))~+~\log(E(x,y))$<br>高通滤波保留高波，去掉阀值。</p>
<p>一维亮度：<br><img src="/2024/05/03/12-11-15/QQ20240505-111110@2x.png" class><br>处理阀值，整合成反射率，但是多一个常数。<br><img src="/2024/05/03/12-11-15/QQ20240505-111242@2x.png" class></p>
<p>例子：彩色视网膜<br><img src="/2024/05/03/12-11-15/QQ20240505-111441@2x.png" class><br>重新校准强度</p>
<h4 id="颜色恒定率，强度恒定率"><a href="#颜色恒定率，强度恒定率" class="headerlink" title="颜色恒定率，强度恒定率"></a>颜色恒定率，强度恒定率</h4><img src="/2024/05/03/12-11-15/QQ20240505-111924@2x.png" class>
<p>颜色恒定率：某种颜色，在不用光照下，仍然可以看到颜色<br>强度恒定率：在不同环境，可以感知相同的强度。</p>
<h2 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h2><h3 id="阴影的形状"><a href="#阴影的形状" class="headerlink" title="阴影的形状"></a>阴影的形状</h3><p>阴影作为恢复形状的提示</p>
<h4 id="反射率图"><a href="#反射率图" class="headerlink" title="反射率图"></a>反射率图</h4><img src="/2024/05/03/12-11-15/QQ20240506-093432@2x.png" class>
<img src="/2024/05/03/12-11-15/QQ20240506-093505@2x.png" class>
<p>曲线法向量：$\mathbf{n}=\frac N{\left\|N\right\|}=\frac{t_x\times t_y}{\left\|t_x\times t_y\right\|}=\frac1{\sqrt{p^2+q^2+1}}\left(p,q,1\right)^T$</p>
<h4 id="高斯球和梯度空间投影"><a href="#高斯球和梯度空间投影" class="headerlink" title="高斯球和梯度空间投影"></a>高斯球和梯度空间投影</h4><p>存在从所有法线到高斯球的映射：<br><img src="/2024/05/03/12-11-15/QQ20240506-093838@2x.png" class><br><img src="/2024/05/03/12-11-15/QQ20240506-093909@2x.png" class><br><img src="/2024/05/03/12-11-15/QQ20240506-093921@2x.png" class></p>
<h4 id="源向量梯度空间和法向量梯度空间"><a href="#源向量梯度空间和法向量梯度空间" class="headerlink" title="源向量梯度空间和法向量梯度空间"></a>源向量梯度空间和法向量梯度空间</h4><img src="/2024/05/03/12-11-15/QQ20240506-094225@2x.png" class>
<p>单位法向量：$\mathbf{n=\frac N{|N|}=\frac{(p,q,1)}{\sqrt{p^2+q^2+1}}}$</p>
<p>单位源向量：$\mathbf{s}=\frac{\mathbf{S}}{|\mathbf{S}|}=\frac{(p_S,q_S,1)}{\sqrt{p_S^2+q_S^2+1}}$</p>
<p>向量夹角：$\cos\theta_i=\mathbf{n}\cdot\mathbf{s}=\frac{(pp_S+qq_S+1)}{\sqrt{p^2+q^2+1}\sqrt{p_S^2+q_S^2+1}}$</p>
<h3 id="阴影形状的定义"><a href="#阴影形状的定义" class="headerlink" title="阴影形状的定义"></a>阴影形状的定义</h3><img src="/2024/05/03/12-11-15/QQ20240506-094504@2x.png" class>
<h4 id="朗伯案例"><a href="#朗伯案例" class="headerlink" title="朗伯案例"></a>朗伯案例</h4><img src="/2024/05/03/12-11-15/QQ20240506-094718@2x.png" class>
<p>反射图：<br><img src="/2024/05/03/12-11-15/QQ20240506-094852@2x.png" class></p>
<p>Iso 亮度轮廓：<br><img src="/2024/05/03/12-11-15/QQ20240506-094911@2x.png" class></p>
<h3 id="光度立体"><a href="#光度立体" class="headerlink" title="光度立体"></a>光度立体</h3><p>相同的物体，不同的光照<br><img src="/2024/05/03/12-11-15/QQ20240506-095328@2x.png" class></p>
<img src="/2024/05/03/12-11-15/QQ20240506-095430@2x.png" class>
<img src="/2024/05/03/12-11-15/QQ20240506-095508@2x.png" class>
<img src="/2024/05/03/12-11-15/QQ20240506-095523@2x.png" class>
<p>最终pq空间图：<br><img src="/2024/05/03/12-11-15/QQ20240506-095554@2x.png" class></p>
]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>计算机视觉, 图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机视觉概论 图像特征</title>
    <url>/2024/05/02/13-20-59/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.05.02：初稿</li>
</ul>
<h2 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h2><ul>
<li><a href="/2024/04/27/08-42-03/" title="Ud810 Intro-to-cv 笔记汇总">计算机视觉概率-笔记汇总</a>
</li>
</ul>
<h2 id="特征检测"><a href="#特征检测" class="headerlink" title="特征检测"></a>特征检测</h2><p>一种寻找对应关系的方法</p>
<h4 id="图像点匹配问题"><a href="#图像点匹配问题" class="headerlink" title="图像点匹配问题"></a>图像点匹配问题</h4><p>Local Features：局部特征<br>目标：在其他图像中找到点的精确位置</p>
<p>特征匹配的过程：</p>
<ol>
<li>检测一些兴趣点(特征)</li>
<li>匹配两张图中的特征点</li>
<li>使用对应点，对齐图像</li>
</ol>
<img src="/2024/05/02/13-20-59/QQ20240502-132909@2x.png" class>
<p>特征匹配的问题：</p>
<ol>
<li>独立的特征， 需要重复检测器</li>
<li>重复相似匹配，使用特征描述符descriptor</li>
</ol>
<h4 id="好的特征"><a href="#好的特征" class="headerlink" title="好的特征"></a>好的特征</h4><p>可重复性：Repeatability/Precision<br>好的特征应该在同一场景的不同图片中被检测出来</p>
<p>显著性/可匹配性：Saliency/Matchability<br>有不同的区分描述</p>
<p>紧凑型和效率：Compactness and efficiency<br>比图像像素更少的特征</p>
<p>局部性：Locality<br>描述具有好的局部性,可以解决遮挡</p>
<h2 id="寻找角点"><a href="#寻找角点" class="headerlink" title="寻找角点"></a>寻找角点</h2><p>一个白墙上有一个黑色方块：<br>黑块不是一个好特征，无法定位。<br>边缘也不是好特征，角是一个好特征。</p>
<img src="/2024/05/02/13-20-59/QQ20240502-142106@2x.png" class>
<p>角是一个梯度变换的地方。</p>
<h4 id="哈里斯角-Harris-Corners"><a href="#哈里斯角-Harris-Corners" class="headerlink" title="哈里斯角 Harris Corners:"></a>哈里斯角 Harris Corners:</h4><p>$E\left(u,\nu\right)=\sum_{x,y}w\left(x,y\right)\left[I\left(x+u,y+\nu\right)-I\left(x,y\right)\right]^{2}$</p>
<ul>
<li>$w\left(x,y\right)$ 是一个窗口<img src="/2024/05/02/13-20-59/QQ20240502-142537@2x.png" class>
</li>
</ul>
<p>哈里斯角图：</p>
<img src="/2024/05/02/13-20-59/QQ20240502-142639@2x.png" class>
<ul>
<li>误差为0，是黑色</li>
<li>左图中红色方块是角图中心，误差为0，绿色移动后，出现误差</li>
</ul>
<p>哈里斯角在很小的移动会产生误差：<br>二阶泰勒展开：<br>$F\left(\delta x\right)\approx F\left(0\right)+\delta x\cdot\frac{dF\left(0\right)}{dx}+\frac12\delta x^2\cdot\frac{d^2F\left(0\right)}{dx^2}$</p>
<p>二维泰勒展开：<br><img src="/2024/05/02/13-20-59/QQ20240502-143009@2x.png" class></p>
<p>推导过程：<br>$E_u\left(u,\nu\right)=\sum_{x,y}2w\left(x,y\right)\left[I\left(x+u,y+\nu\right)-I\left(x,y\right)\right]I_x\left(x+u,y+v\right)$</p>
<p>$\begin{split}<br>E_{\textit{ u }\nu}\left(u,\nu\right)&amp; =\sum_{x,y}2w(x,y)I_y(x+u,y+v)I_x(x+u,y+v) \\<br>&amp;+\sum_{x,y}2w(x,y)\Big[I(x+u,y+v)-I(x,y)\Big]I_{xy}(x+u,y+v)<br>\end{split}$</p>
<p>$\begin{split}E_{u\nu}(u,\nu)&amp;=\sum_{x,y}2w(x,y)I_y(x+u,y+v)I_x(x+u,y+v)\\&amp;+\sum_{x,y}2w(x,y)\Big[I(x+u,y+v)-I(x,y)\Big]I_{xy}(x+u,y+v)\end{split}$</p>
<p>带入点$(0,0)$，消去得：</p>
<p>$E\left(u ,\nu\right) \approx \begin{bmatrix}u&amp;\nu\end{bmatrix} M\quad\begin{bmatrix}u\\\nu\end{bmatrix}$</p>
<p>$M=\sum_{x,y}w(x,y)\begin{bmatrix}I_x^2&amp;&amp;I_xI_y\\I_xI_y&amp;&amp;I_y^2\end{bmatrix}$</p>
<p>当没有权重$w(x,y)$时：</p>
<p>$M=\begin{bmatrix}\sum I_xI_x&amp;\sum I_xI_y\\\sum I_xI_y&amp;\sum I_yI_y\end{bmatrix}=\sum\left(\begin{bmatrix}I_x\\I_y\end{bmatrix}-\begin{bmatrix}I_x&amp;I_y\end{bmatrix}\right)=\sum\nabla I\left(\nabla I\right)^T$</p>
<p>其中$\nabla I$：是一个秩为1的列向量，所有等式右边是一个秩为1的二阶方阵。</p>
<p>? 必须让窗口内所有方向都有梯度，才可以求和后得到一个满秩矩阵？？</p>
<h4 id="解释二阶近似方程"><a href="#解释二阶近似方程" class="headerlink" title="解释二阶近似方程"></a>解释二阶近似方程</h4><p>代数表达式：椭圆方程<br>$\sum I_x^2u^2+2\sum I_xI_yu\nu+\sum I_y^2\nu^2=k$</p>
<p>椭圆图：<br><img src="/2024/05/02/13-20-59/QQ20240502-145419@2x.png" class></p>
<p>考虑，窗口内的梯度永远是水平或垂直，所有$I_xI_y$为0。<br>化简：<br>$M=\sum_{x,y}w(x,y)\begin{bmatrix}I_x^2&amp;&amp;I_xI_y\\I_xI_y&amp;&amp;I_y^2\end{bmatrix}=\begin{bmatrix}\lambda&amp;0\\0&amp;\lambda_2\end{bmatrix}$</p>
<p>$M$可以被相似对角化：<br>$M~=~R^{-1}\left[\begin{array}{cc}\lambda&amp;0\\0&amp;\lambda_2\end{array}\right]R$</p>
<p>特征值的作用：<br><img src="/2024/05/02/13-20-59/QQ20240502-145313@2x.png" class><br>在短边处：变换很快，长边处变换速度很慢，需要移动很多才有变化。</p>
<h4 id="解释特征值"><a href="#解释特征值" class="headerlink" title="解释特征值"></a>解释特征值</h4><p>计算哈里斯矩阵：<br><img src="/2024/05/02/13-20-59/QQ20240502-150536@2x.png" class></p>
<ul>
<li>平坦区域：flat<br>梯度为0，怎么移动都不会变化。</li>
<li>如果一个特征值特别大<br>朝这个方向的边缘移动，变换很快</li>
<li>两个特征值大小相似<br>角：在任何方向变化相同</li>
</ul>
<h4 id="哈里斯响应函数："><a href="#哈里斯响应函数：" class="headerlink" title="哈里斯响应函数："></a>哈里斯响应函数：</h4><p>$R=\det(M^2)-\alpha\mathrm{~trace}(M)^2=\lambda_1\lambda_2-\alpha(\lambda_1+\lambda_2)^2$<br>$\alpha$:特别小 0.04 to 0.06</p>
<p>$R$取决于特征值，但不需要计算特征值，<br>原因：</p>
<ul>
<li>角：两个特征值都很大，$R$正的大数</li>
<li>边：一个特征值很大,$R$是负的大数</li>
<li>平坦：$R$ 的绝对值很小</li>
</ul>
<h4 id="哈里斯函数如何工作"><a href="#哈里斯函数如何工作" class="headerlink" title="哈里斯函数如何工作"></a>哈里斯函数如何工作</h4><p>低纹理区域：<br><img src="/2024/05/02/13-20-59/QQ20240502-151651@2x.png" class></p>
<p>边缘区域：<br><img src="/2024/05/02/13-20-59/QQ20240502-151730@2x.png" class></p>
<p>高纹理区域：<br><img src="/2024/05/02/13-20-59/QQ20240502-151825@2x.png" class></p>
<h4 id="哈里斯检测器算法："><a href="#哈里斯检测器算法：" class="headerlink" title="哈里斯检测器算法："></a>哈里斯检测器算法：</h4><img src="/2024/05/02/13-20-59/QQ20240502-152016@2x.png" class>
<p>例子：<br><img src="/2024/05/02/13-20-59/QQ20240502-152156@2x.png" class></p>
<p>响应函数图：<br><img src="/2024/05/02/13-20-59/QQ20240502-152223@2x.png" class></p>
<p>非极大值抑制：<br><img src="/2024/05/02/13-20-59/QQ20240502-152309@2x.png" class></p>
<p>局部最大值的像素点：<br><img src="/2024/05/02/13-20-59/QQ20240502-152430@2x.png" class></p>
<p>在原图中的位置：<br><img src="/2024/05/02/13-20-59/QQ20240502-152454@2x.png" class></p>
<p>最终发现很多相同的特征点。</p>
<h2 id="尺度不变性-Scale-invariance"><a href="#尺度不变性-Scale-invariance" class="headerlink" title="尺度不变性  Scale invariance"></a>尺度不变性  Scale invariance</h2><h4 id="哈里斯检测器的一些特性"><a href="#哈里斯检测器的一些特性" class="headerlink" title="哈里斯检测器的一些特性"></a>哈里斯检测器的一些特性</h4><ul>
<li>对于旋转不变</li>
<li>图像强度：加法乘法不改变<br>加法：导数不变<br>乘法：导数整体变化</li>
<li>缩放，会改变</li>
</ul>
<h4 id="尺度不变性的检测"><a href="#尺度不变性的检测" class="headerlink" title="尺度不变性的检测"></a>尺度不变性的检测</h4><img src="/2024/05/02/13-20-59/QQ20240502-153839@2x.png" class>
<p>增大窗口，保持尺度不变</p>
<p>领域大小对函数的影响：<br><img src="/2024/05/02/13-20-59/QQ20240502-154050@2x.png" class><br>$S_1$, $S_2$，具有相同的缩放比例</p>
<h4 id="一个好的尺寸检测函数"><a href="#一个好的尺寸检测函数" class="headerlink" title="一个好的尺寸检测函数"></a>一个好的尺寸检测函数</h4><img src="/2024/05/02/13-20-59/QQ20240502-154434@2x.png" class>
<img src="/2024/05/02/13-20-59/QQ20240502-154635@2x.png" class>
<p>拉普拉斯差和高斯差几乎相同，选择高斯简化计算。</p>
<h4 id="关键点定位"><a href="#关键点定位" class="headerlink" title="关键点定位"></a>关键点定位</h4><p><strong>SIFT</strong>: Scale Invariant Feature Transform<br>尺度不变特征变换<br><img src="/2024/05/02/13-20-59/QQ20240502-154917@2x.png" class><br>取不同尺寸的图像，不断模糊图像，两两相减，计算他们的高斯图像差异。<br>像素与周围九个像素比较，以及不同比例邻居上的比较，的看是不是极值。</p>
<img src="/2024/05/02/13-20-59/QQ20240502-155145@2x.png" class>
<p>例子：<br><img src="/2024/05/02/13-20-59/QQ20240502-155601@2x.png" class></p>
<p><strong>哈里斯-拉普拉斯算法：</strong><br>先试用哈里斯角点检测<br>然后在看尺度方向上的拉普拉斯算子，找空间极值</p>
<h2 id="特征描述"><a href="#特征描述" class="headerlink" title="特征描述"></a>特征描述</h2><p>描述符：对领域进行描述</p>
<ul>
<li>独特：不同的点有不同的描述符</li>
<li>可区分</li>
<li>几乎相同</li>
</ul>
<h3 id="SIFT-Scale-Invariant-Feature-Detection"><a href="#SIFT-Scale-Invariant-Feature-Detection" class="headerlink" title="SIFT: Scale Invariant Feature Detection"></a>SIFT: Scale Invariant Feature Detection</h3><p>尺度不变特征变换</p>
<p>思想：</p>
<ul>
<li>图像内容是一组特征：对于平移，旋转,放缩等图像处理操作是不变的</li>
<li>描述符是稳健的</li>
</ul>
<img src="/2024/05/02/13-20-59/QQ20240503-094607@2x.png" class>
<h4 id="总体SIFT识别过程"><a href="#总体SIFT识别过程" class="headerlink" title="总体SIFT识别过程"></a>总体SIFT识别过程</h4><ol>
<li>确定关键点尺寸</li>
<li>定位关键点</li>
<li>找到领域的局部的方向</li>
<li>关键点描述</li>
</ol>
<img src="/2024/05/02/13-20-59/QQ20240503-094908@2x.png" class>
<p>右图中的方向箭头，就是局部方向。</p>
<h4 id="计算局部方向"><a href="#计算局部方向" class="headerlink" title="计算局部方向"></a>计算局部方向</h4><img src="/2024/05/02/13-20-59/QQ20240503-095051@2x.png" class>
<p>图中是方向直方图</p>
<p>找到一个峰值，就是主导方向，我们需要使用的方向，以这个方向为北方。</p>
<h4 id="关键点描述符"><a href="#关键点描述符" class="headerlink" title="关键点描述符"></a>关键点描述符</h4><p>标准化：<br>旋转到新的北方朝上<br>放缩到相同尺寸</p>
<p>SIFT特征向量：<br><img src="/2024/05/02/13-20-59/QQ20240503-095512@2x.png" class><br>右图是一个：2X2的图，最好是使用4X4的直方图，一个里面有8个方向，叠加到一起，一个特征会有128个向量<br>将所有的向量，标准化到内积为1。</p>
<p>梯度：直方图加权梯度，方向最大的权最高</p>
<p>评估SIFT描述符:<br>通常一个直方图有8个方向，采用4X4的直方图，向量长128。</p>
<h3 id="匹配特征点"><a href="#匹配特征点" class="headerlink" title="匹配特征点"></a>匹配特征点</h3><p>如何在两个图的特征中，找到匹配的特征点？</p>
<h4 id="最邻近算法匹配"><a href="#最邻近算法匹配" class="headerlink" title="最邻近算法匹配"></a>最邻近算法匹配</h4><p>best-bin-first 算法基于k-d树</p>
<img src="/2024/05/02/13-20-59/QQ20240503-101702@2x.png" class>
<h4 id="基于小波的散列"><a href="#基于小波的散列" class="headerlink" title="基于小波的散列"></a>基于小波的散列</h4><img src="/2024/05/02/13-20-59/QQ20240503-101843@2x.png" class>
<p>小波：是一种接近滤波器的形式，从三个滤波器里输出三个数。</p>
<p>思想类似局部敏感哈希：<br><img src="/2024/05/02/13-20-59/QQ20240503-102231@2x.png" class><br>考虑了空间两点的距离</p>
<h4 id="例子-3D物体识别"><a href="#例子-3D物体识别" class="headerlink" title="例子 3D物体识别"></a>例子 3D物体识别</h4><img src="/2024/05/02/13-20-59/QQ20240503-102435@2x.png" class>
<p>从测试图中匹配：<br><img src="/2024/05/02/13-20-59/QQ20240503-102518@2x.png" class></p>
<h4 id="例子-遮挡下的识别"><a href="#例子-遮挡下的识别" class="headerlink" title="例子 遮挡下的识别"></a>例子 遮挡下的识别</h4><p>通过部分关键点，预测其他点去哪里了。</p>
<h2 id="鲁棒误差函数"><a href="#鲁棒误差函数" class="headerlink" title="鲁棒误差函数"></a>鲁棒误差函数</h2><p>SSD：差的平方和<br>NN: 最近邻居</p>
<h4 id="Lowe-a-better-way"><a href="#Lowe-a-better-way" class="headerlink" title="Lowe a better way"></a>Lowe a better way</h4><img src="/2024/05/02/13-20-59/QQ20240503-104558@2x.png" class>
<p>意义：<br>如果最佳匹配被遮挡了，第一和第二匹配相差不大，说明没有找到正确的匹配。</p>
<h3 id="模型拟合"><a href="#模型拟合" class="headerlink" title="模型拟合"></a>模型拟合</h3><h4 id="最小二乘线拟合-Typical-least-squares-line-fitting"><a href="#最小二乘线拟合-Typical-least-squares-line-fitting" class="headerlink" title="最小二乘线拟合 Typical least squares line fitting"></a>最小二乘线拟合 Typical least squares line fitting</h4><p>机器学习内容<br>只是$y$方向上的拟合。</p>
<h4 id="总体最小二乘法"><a href="#总体最小二乘法" class="headerlink" title="总体最小二乘法"></a>总体最小二乘法</h4><p>$ax+by=d$<br>$E=\sum_{i=1}^n(ax_i+by_i-d)^2$<br><img src="/2024/05/02/13-20-59/QQ20240503-105511@2x.png" class></p>
<p>推导公式：<br>\begin{split}<br>\frac{\partial E}{\partial d}=\sum_{i=1}^n-2\left(ax_i+by_i-d\right)=0\\<br>\Rightarrow d=\frac an\sum_{i=1}^nx_i+\frac bn\sum_{i=1}^nx_i=a\overline{x}+b\overline{y}<br>\end{split}</p>
<p>\begin{split}<br>&amp;E = \sum_{i=1}^{n}(a (x_{i}-\overline{x})+b (y_{i}-<br>\overline{y}))^{2}\\<br>&amp;=\left\|\begin{bmatrix}x_{i}-\overline{x}&amp;y_{i}-<br>\overline{y}\\<br>\vdots&amp;\vdots&amp;\vdots\\<br>\lfloor x_{i}-\overline{x}&amp;y_{i}-\overline{y}\rfloor<br>\end{bmatrix}\begin{bmatrix}a\\<br>b\end{bmatrix}\right\|^{2} \\<br>&amp;=\left(U \mathbf{h}\right)^{T}\left(U \mathbf{h}\right)\\<br>&amp;\frac{dE}{d\mathbf{h}}=2(U^TU)\mathbf{h}=0<br>\end{split}</p>
<img src="/2024/05/02/13-20-59/QQ20240503-110151@2x.png" class>
<ul>
<li>实际测量点$(x,y)$ 等于真实点$(u,v)$垂直于$a,b$方向上的偏动。</li>
<li>符合高斯噪声</li>
</ul>
<h3 id="鲁棒估计器"><a href="#鲁棒估计器" class="headerlink" title="鲁棒估计器"></a>鲁棒估计器</h3><p>求一个最小化：$\sum_i\rho\left(r_i\left(x_i,\theta_1\right);<br>\sigma_1\right)$</p>
<ul>
<li>$r_i\left(x_i,\theta_1\right)$：代表残差值,该点距离拟合曲线的距离</li>
<li>$\rho$：有尺度参数$\sigma$鲁棒函数</li>
</ul>
<p>一种鲁棒函数：<br><img src="/2024/05/02/13-20-59/QQ20240503-110931@2x.png" class></p>
<ul>
<li>当$u$很小的时候：</li>
<li>当$u$很大的时候：误差很大</li>
</ul>
<h2 id="RANSAC算法-RANdom-SAmple-Consensus"><a href="#RANSAC算法-RANdom-SAmple-Consensus" class="headerlink" title="RANSAC算法 RANdom SAmple Consensus"></a>RANSAC算法 RANdom SAmple Consensus</h2><h3 id="一般模型"><a href="#一般模型" class="headerlink" title="一般模型"></a>一般模型</h3><p>选取模型的最小集点数量：<br>距离阀值：<br>$f(d)=\frac{\sqrt{2}e^{-(\frac{d^2}{2\sigma^2})} }<br>{\sqrt{\pi}\sigma},d\geq0$</p>
<h4 id="计算N"><a href="#计算N" class="headerlink" title="计算N"></a>计算N</h4><img src="/2024/05/02/13-20-59/QQ20240503-112533@2x.png" class>
<p>模型所需的样本点数：<br>$N &gt; \log(1 - p ) / \log(1 - (1 - e )^S )$</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>两个匹配的特征：<br><img src="/2024/05/02/13-20-59/QQ20240503-113228@2x.png" class></p>
<ul>
<li>有5个特征匹配，2个不匹配，认为这两张图是相同的，错误</li>
<li>因为匹配特征中有噪音</li>
</ul>
<p>RANSAC算法<br><img src="/2024/05/02/13-20-59/QQ20240503-113151@2x.png" class></p>
<ul>
<li>去除高斯噪音，选择平均值</li>
</ul>
<h4 id="RANSAC算法-循环"><a href="#RANSAC算法-循环" class="headerlink" title="RANSAC算法 循环"></a>RANSAC算法 循环</h4><img src="/2024/05/02/13-20-59/QQ20240503-113501@2x.png" class>
]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>计算机视觉, 图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机视觉概论 相机和图像</title>
    <url>/2024/04/29/16-24-21/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.04.29：初稿</li>
</ul>
<h2 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h2><ul>
<li><a href="/2024/04/27/08-42-03/" title="Ud810 Intro-to-cv 笔记汇总">计算机视觉概率-笔记汇总</a>
</li>
</ul>
<h2 id="透视成像"><a href="#透视成像" class="headerlink" title="透视成像"></a>透视成像</h2><h4 id="建模投影"><a href="#建模投影" class="headerlink" title="建模投影"></a>建模投影</h4><p>坐标系：</p>
<img src="/2024/04/29/16-24-21/QQ20240501-091850@2x.png" class>
<ul>
<li>Center OF Projection:光学中心，在原点</li>
<li>不用担心翻转，图像放在坐标系前</li>
<li>坐标系符合右手定则，$z$轴指向相机，而不是指向世界</li>
</ul>
<p>坐标转换：<br>$(X,Y,Z)\to(-d\frac XZ,-d\frac YZ,-d)$</p>
<h4 id="齐次坐标-Homogeneous-coordinates"><a href="#齐次坐标-Homogeneous-coordinates" class="headerlink" title="齐次坐标 Homogeneous coordinates"></a>齐次坐标 Homogeneous coordinates</h4><p>二维：<br>$(x,y)\Rightarrow\left[\begin{array}{c}x\\y\\\mathbf{1}\end{array}\right]$</p>
<p>三维：<br>$(x,y,z)\Rightarrow\left[\begin{array}{c}x\\y\\z\\\mathbf{1}\end{array}\right]$</p>
<p>齐次转常规：<br>$\left[\begin{array}{c}x\\y\\z\\w\end{array}\right]\Rightarrow\left(x/w,y/w,z/w\right)$</p>
<p>例子：</p>
<p>\begin{split}<br>\begin{bmatrix}1&amp;0&amp;0&amp;0\\0&amp;1&amp;0&amp;0\\0&amp;0&amp;1/f&amp;0\end{bmatrix}\begin{bmatrix}x\\|&amp;|\\y\\z\\1\end{bmatrix}&amp;=\begin{bmatrix}x\\y\\z/f\end{bmatrix}&amp;\Rightarrow\left(f\frac xz,f\frac yz\right)\\&amp;\Rightarrow\left(u,\nu\right)<br>\end{split}</p>
<p>通过焦距为$f$的投影，投影到世界上某个点$(x,y,z)$的图像中的坐标。<br>焦距：从中心投影到图像的距离</p>
<h4 id="投影的几何性质"><a href="#投影的几何性质" class="headerlink" title="投影的几何性质"></a>投影的几何性质</h4><img src="/2024/04/29/16-24-21/QQ20240501-093454@2x.png" class>
<ul>
<li>$O$，是投影中心</li>
<li>点，线，投影到点，线</li>
<li>多边形投影会改变</li>
</ul>
<p>平行线会改变：<br><strong>数学解释：</strong><br>三维平行线：<br>$x\left(t\right)=x_0+at\\y\left(t\right)=y_0+bt\\z\left(t\right)=z_0+ct$</p>
<p>投影坐标的投影方程：<br>$x’(t)=\frac{fx}z=\frac{f\left(x_0+at\right)}{z_0+ct}\\y’(t)=\frac{fy}z=\frac{f\left(y_0+bt\right)}{z_0+ct}$</p>
<p>$\begin{split}&amp;\text{In the limit as }t\to\pm\infty\quad x’(t)\to\frac{fa}c,\quad y’(t)\to\frac{fb}c\\&amp;\text{we have (for }c\neq0){:}\end{split}$</p>
<ul>
<li>公式中没有$x_0,y_0,z_0$，直线的起点不重要，直线沿着直线一直向前</li>
<li>不同的直线会汇聚到同一个点，(点不一定相同，取决于视角)</li>
<li>$c$不能为0，如果c为0，意味着平行线与$z$轴垂直，与投影面平行，永远不会相交</li>
</ul>
<p>平行线会在无限远的地方汇聚消失：消失点</p>
<p>三点透视</p>
<img src="/2024/04/29/16-24-21/QQ20240501-094912@2x.png" class>
<p>人类视觉：Müller-LyerIllusion</p>
<img src="/2024/04/29/16-24-21/QQ20240501-095137@2x.png" class>
<p>红线哪个更长，透视错觉</p>
<h4 id="其他投影模型"><a href="#其他投影模型" class="headerlink" title="其他投影模型"></a>其他投影模型</h4><p>正交投影： Orthographic<br>特殊的平行投影，假设光源无限远，光是平行的。<br><img src="/2024/04/29/16-24-21/QQ20240501-095431@2x.png" class><br>投影矩阵：<br>$\left[\begin{array}{cccc}1&amp;0&amp;0&amp;0\\0&amp;1&amp;0&amp;0\\0&amp;0&amp;0&amp;1\end{array}\right]\left[\begin{array}{c}x\\y\\z\\1\end{array}\right]\boldsymbol{=}\left[\begin{array}{c}x\\y\\1\end{array}\right]\boldsymbol{\Rightarrow}(x,y)$</p>
<p>弱视角投影： Weak perspective<br>缩放投影<br>$\begin{bmatrix}1&amp;0&amp;0&amp;0\\0&amp;1&amp;0&amp;0\\\\0&amp;0&amp;0&amp;1/s\end{bmatrix}\begin{bmatrix}x\\y\\z\\1\end{bmatrix}=\begin{bmatrix}x\\y\\1/s\end{bmatrix}\Rightarrow(sx,sy)$</p>
<ul>
<li>$s$:缩放因子</li>
</ul>
<h2 id="立体几何"><a href="#立体几何" class="headerlink" title="立体几何"></a>立体几何</h2><h4 id="多视角图像"><a href="#多视角图像" class="headerlink" title="多视角图像"></a>多视角图像</h4><img src="/2024/04/29/16-24-21/QQ20240501-100044@2x.png" class>
<p>结构和深度是模糊的，所以出现了多视角，本质来自投影</p>
<p>人类视觉具有感知深度的能力,主要元素：</p>
<ol>
<li>阴影 shading</li>
<li>纹理 texture</li>
<li>焦点/深度焦点 focus/defocus</li>
<li>移动 motion</li>
</ol>
<h4 id="立体视觉"><a href="#立体视觉" class="headerlink" title="立体视觉"></a>立体视觉</h4><p>两个眼睛看的图像不同，从两个视觉中恢复立体</p>
<p>双视觉图像，中心元素，前后的元素都在像它移动</p>
<p>随机点立体图：</p>
<p>人类可以直接融合双视角图像</p>
<img src="/2024/04/29/16-24-21/QQ20240501-101547@2x.png" class>
<p>相机是由光学中心(optical center)定义的</p>
<ul>
<li>校准，相机姿态</li>
<li>图像对应点</li>
</ul>
<h4 id="简单的立体系统"><a href="#简单的立体系统" class="headerlink" title="简单的立体系统"></a>简单的立体系统</h4><p>相机的俯视图：</p>
<img src="/2024/04/29/16-24-21/QQ20240501-102205@2x.png" class>
<p>计算深度的公式：<br>$\begin{split}\frac{B-x_l+x_r}{Z-f}&amp;=\frac BZ\\\\Z = f \frac B{x_l - x_r}\end{split}$</p>
<p>视角差为0，深度为无穷，月亮为什么一直会跟着，因为深度无限远，视角没有变化。</p>
<p>视角差的例子：</p>
<img src="/2024/04/29/16-24-21/QQ20240501-102755@2x.png" class>
<p>找出两张图，哪个在左边，哪个在右边，从上面的烟囱可以看出，右边图在右方拍摄。<br>红点是一个图像相同位置的点，右图向左移动一直，那个点才能到左图中的窗口点，这就是视角差。</p>
<p>从视差到深度：<br><img src="/2024/04/29/16-24-21/QQ20240501-103010@2x.png" class></p>
<p>通过视差图像，亮的地方视差大，暗的地方视差小。<br>根据视差与深度的反比关系，我们可以得到深度。</p>
<p>从深度到视差：<br>因为$y没有变化，视差来源于$x$，所以$D(x,y)$也是x的变化。</p>
<p>$(x’,y’)=(x+D(x,y), y)$</p>
<h2 id="对极几何"><a href="#对极几何" class="headerlink" title="对极几何"></a>对极几何</h2><h4 id="立体对应约束"><a href="#立体对应约束" class="headerlink" title="立体对应约束"></a>立体对应约束</h4><img src="/2024/04/29/16-24-21/QQ20240501-122809@2x.png" class>
<p>左侧的图像点p，可以点在一条直线上的任意一点，所以它对应在另一个图像中的点，是一条直线上任何一点。这条线成为极线。<br>这就叫做：极线约束 Epipolar constraint</p>
<ul>
<li>基线：相机点和位置点形成的</li>
</ul>
<p>为什么极线约束有用？<br>在极线中找对应另一个图像中的点。</p>
<p>例子：<br><img src="/2024/04/29/16-24-21/QQ20240501-123218@2x.png" class><br>极点是一个数学概念，所有的极线会在屏幕外面聚合。</p>
<p>平行图像的例子：<br><img src="/2024/04/29/16-24-21/QQ20240501-123433@2x.png" class></p>
<h2 id="立体对应-Stereo-correspondence"><a href="#立体对应-Stereo-correspondence" class="headerlink" title="立体对应 Stereo correspondence"></a>立体对应 Stereo correspondence</h2><p>软约束：对应点之间的关系</p>
<ol>
<li>相似性</li>
<li>唯一性</li>
<li>有序</li>
<li>视差梯度有限-深度变化不会太大</li>
</ol>
<h4 id="相似性"><a href="#相似性" class="headerlink" title="相似性"></a>相似性</h4><img src="/2024/04/29/16-24-21/QQ20240501-135443@2x.png" class>
<p>强度分布图：匹配位置具有差异</p>
<img src="/2024/04/29/16-24-21/QQ20240501-135637@2x.png" class>
<p>视差图的相似性:匹配的地方峰值最高</p>
<img src="/2024/04/29/16-24-21/QQ20240501-135743@2x.png" class>
<p>没有纹理的地方做匹配，没有匹配的地方？<br>原因：窗口太小，没有获得足够的纹理信息。</p>
<p>窗口大小的影响：<br><img src="/2024/04/29/16-24-21/QQ20240501-135937@2x.png" class><br>显示的是视差图</p>
<ul>
<li>小窗口，获得了树干信息</li>
<li>大窗口，树干和背景融合到了一起</li>
</ul>
<h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>单一固体中：<br>左图中的点 $a,b,c$，在右图中有相同的顺序$a,b,c$。</p>
<p>例外：在一个透明的表面<br><img src="/2024/04/29/16-24-21/QQ20240501-140403@2x.png" class><br>顺序会改变</p>
<p>例外：狭窄的遮挡<br><img src="/2024/04/29/16-24-21/QQ20240501-140508@2x.png" class></p>
<p>立体的最新技术:<br>优化算法的两种方法：</p>
<ol>
<li>一次扫描一条线</li>
<li>在二维图像中，多扫描一条垂直的线</li>
</ol>
<h4 id="动态规划公式"><a href="#动态规划公式" class="headerlink" title="动态规划公式"></a>动态规划公式</h4><img src="/2024/04/29/16-24-21/QQ20240501-141156@2x.png" class>
<p>假设已知左上角像素在右图中对应的位置。</p>
<ul>
<li>一对一：两个图中像素点都存在</li>
<li>左遮挡：左图可见，而右图不可见<br>左边的像素被映射到右边同一像素位置，所以看不见</li>
<li>右遮挡：相似</li>
</ul>
<h4 id="立体相似度"><a href="#立体相似度" class="headerlink" title="立体相似度"></a>立体相似度</h4><p>什么是一个好的立体相似：</p>
<ol>
<li>数据质量</li>
<li>平滑度，相邻像素差异最小<img src="/2024/04/29/16-24-21/QQ20240501-141943@2x.png" class>
Data term:  $E_\text{ data }=\sum_i\left(W_1(i)-W_2(i+D(i))\right)^2$<br>Smoothness term: $E_\text{ smooth }=\sum_{\text{ neighbors }i,j}\rho\left(D(i)-D(j)\right)$</li>
</ol>
<p>Total energy：$E = \alpha E_{_{\mathrm{data}}}(I_{_1},I_{_2},D)+ \beta E_{_{\mathrm{smooth}}}(D)$</p>
<p>找到一个使总体能量最小的参数。</p>
<p>更好的算法：<br>将图分割算法应用到立体相似处理。</p>
<h2 id="外置相机校准"><a href="#外置相机校准" class="headerlink" title="外置相机校准"></a>外置相机校准</h2><h4 id="几何相机标准"><a href="#几何相机标准" class="headerlink" title="几何相机标准"></a>几何相机标准</h4><p>两个方面：</p>
<ol>
<li>任何的世界坐标系</li>
<li>从3D到2D的相机坐标系<img src="/2024/04/29/16-24-21/QQ20240501-142833@2x.png" class>
从世界坐标系转换到相机坐标系</li>
</ol>
<h4 id="刚体变换"><a href="#刚体变换" class="headerlink" title="刚体变换"></a>刚体变换</h4><p>刚体有6个自由度：<br><img src="/2024/04/29/16-24-21/QQ20240501-143138@2x.png" class></p>
<ol>
<li>一个点可以定位刚体：$(x,y,z)$，三个自由度</li>
<li>加一个点，在矢量方向，经纬度，加两个自由度</li>
<li>可以旋转，加一个自由度</li>
</ol>
<h4 id="符号-F-amp-P"><a href="#符号-F-amp-P" class="headerlink" title="符号 F&amp;P"></a>符号 F&amp;P</h4><img src="/2024/04/29/16-24-21/QQ20240501-143635@2x.png" class>
<p>$^AP=\left(\begin{array}{c}^Ax\\^Ay\\^Az\\\end{array}\right)\Leftrightarrow\overline{OP}=\left(\begin{array}{c}^Ax\cdot\overline{i}\\\end{array}\right)+\left(\begin{array}{c}^Ay\cdot\overline{j}\\\end{array}\right)+\left(\begin{array}{c}^Az\cdot\overline{k}\\\end{array}\right)$</p>
<ul>
<li>上标代表所在坐标系</li>
</ul>
<img src="/2024/04/29/16-24-21/QQ20240501-143832@2x.png" class>
<p>坐标转换：已知了两个坐标原点之间的向量<br>$^BP=^AP+^B\left(O_A\right)$<br>或<br>$^BP=2^B\left(O_A\right)+2^AP$<br>就是向量加法</p>
<p>齐次坐标法：<br>\begin{split}\left[\begin{array}{c}^BP\\1\end{array}\right]=\left[\begin{array}{cc}K^BO_A\\0^T&amp;1\end{array}\right]\left[\begin{array}{c}^AP\\1\end{array}\right]\end{split}</p>
<p>变换可逆</p>
<h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><img src="/2024/04/29/16-24-21/QQ20240501-144200@2x.png" class>
<p>坐标原点重合<br>$\overrightarrow{OP}=\begin{pmatrix}i_A&amp;&amp;j_A&amp;&amp;k_A\end{pmatrix}\left(\begin{array}{c}A\\X\\\\A\\y\\\\A\\z\end{array}\right)=\begin{pmatrix}i_B&amp;&amp;j_B&amp;&amp;k_B\end{pmatrix}\left(\begin{array}{c}B\\X\\\\B\\z\end{array}\right)$</p>
<p>转换公式：基变换</p>
<p>$^BP=_A^BR^AP$<br>$_A^BR$: 在B的坐标系中描述A</p>
<p>旋转不可交换</p>
<h4 id="刚体变换-1"><a href="#刚体变换-1" class="headerlink" title="刚体变换"></a>刚体变换</h4><img src="/2024/04/29/16-24-21/QQ20240501-144753@2x.png" class>
<p>$^BP=\frac BAR^AP+^BO_A$<br>将坐标点旋转到B坐标系，加上加上A坐标系在B坐标系中的偏移量。</p>
<p>从世界坐标到相机坐标的转换：<br><img src="/2024/04/29/16-24-21/QQ20240501-145316@2x.png" class></p>
<h2 id="相机内部校准"><a href="#相机内部校准" class="headerlink" title="相机内部校准"></a>相机内部校准</h2><p>从3D相机坐标到2D图像坐标</p>
<h4 id="实际的参数"><a href="#实际的参数" class="headerlink" title="实际的参数"></a>实际的参数</h4><img src="/2024/04/29/16-24-21/QQ20240501-145813@2x.png" class>
<p>\begin{split}&amp;u = \alpha \frac{x}{z}-\alpha \cot(\theta ) \frac{y}{z}+u_{_0}\\&amp;\nu=\frac\beta{\sin(\theta)}\quad\frac{y}z+\nu_0\end{split}</p>
<ul>
<li>光学中心不在图像中间</li>
<li>坐标系不垂直</li>
<li>长宽像素缩放比不相同</li>
</ul>
<p>改善转换方程：<br>齐次坐标法：</p>
<p>\begin{split}<br>\begin{pmatrix}z^*u\\\\z^*\\\\nu\\\\z\end{pmatrix}=\begin{pmatrix}\alpha&amp;-\alpha\cot(\theta)&amp;u_0&amp;0\\\\0&amp;\frac{\beta}{\sin(\theta)}&amp;\nu_0&amp;0\\\\0&amp;0&amp;1&amp;0\end{pmatrix}\begin{pmatrix}x\\\\y\\\\z\\\\1\end{pmatrix}\\\vec{p^{\prime}}=K^c\vec{p}<br>\end{split}</p>
<p>5个自由度：<br><img src="/2024/04/29/16-24-21/QQ20240501-150253@2x.png" class></p>
<h4 id="结合内部参数和外部参数"><a href="#结合内部参数和外部参数" class="headerlink" title="结合内部参数和外部参数"></a>结合内部参数和外部参数</h4><img src="/2024/04/29/16-24-21/QQ20240501-150413@2x.png" class>
<h4 id="相机的全部参数"><a href="#相机的全部参数" class="headerlink" title="相机的全部参数"></a>相机的全部参数</h4><p>11个自由度：<br><img src="/2024/04/29/16-24-21/QQ20240501-150520@2x.png" class></p>
<h2 id="使用光谱校准相机"><a href="#使用光谱校准相机" class="headerlink" title="使用光谱校准相机"></a>使用光谱校准相机</h2><h4 id="校准方法"><a href="#校准方法" class="headerlink" title="校准方法"></a>校准方法</h4><p>利用已知点进行校准</p>
<p>切割法校准：<br>获取一些已知点，建立世界坐标系，测量设置点的坐标在世界中的相对位置，然后回恢复校准坐标。</p>
<h4 id="齐次校准"><a href="#齐次校准" class="headerlink" title="齐次校准"></a>齐次校准</h4><img src="/2024/04/29/16-24-21/QQ20240501-151052@2x.png" class>
<p>坐标系下的直线校准：<br><img src="/2024/04/29/16-24-21/QQ20240502-121531@2x.png" class></p>
<p><strong>SVD分解</strong>:奇异值分解</p>
<img src="/2024/04/29/16-24-21/QQ20240502-121634@2x.png" class>
<img src="/2024/04/29/16-24-21/QQ20240502-121827@2x.png" class>
<p>非齐次方法</p>
<h2 id="误差函数"><a href="#误差函数" class="headerlink" title="误差函数"></a>误差函数</h2><p>$\text{minimize }E=\sum_id(x_i^\prime,\hat{x}_i^\prime)$</p>
<p>如果有复杂的映射：<br>$\min_\mathbf{M}\sum_id(x_i^{\prime},\mathbf{MX}_i)$<br>用参数$M$修正</p>
<h4 id="黄金标准算法："><a href="#黄金标准算法：" class="headerlink" title="黄金标准算法："></a>黄金标准算法：</h4><p>标准归一化：<br>$\tilde{\mathbf{X}}_i=\mathbf{U}\mathbf{X}_i\tilde{\mathbf{x}}_i=\mathbf{T}\mathbf{x}_i$</p>
<p>$\min_\mathbf{M}\sum_id\left(\tilde{\mathbf{x}}_i,\tilde{\mathbf{M}}\tilde{\mathbf{X}}_i\right)$</p>
<p>$\mathbf{M}=\mathbf{T}^{-1}\tilde{\mathbf{M}}\mathbf{U}$</p>
<p>类似特征向量，转换为标准正交基上</p>
<h4 id="从M中找3D相机中心"><a href="#从M中找3D相机中心" class="headerlink" title="从M中找3D相机中心"></a>从M中找3D相机中心</h4><p>直接的方法：<br>如果能找到一个点$C$， 使得$\textbf{M C = 0}$，就是相机中心。<br>原理：<br>$\mathbf{X}=\lambda\mathbf{P}+(1-\lambda)\mathbf{C}$<br>$\mathbf{x}=\mathbf{M}\mathbf{X}=\lambda\mathbf{M}\mathbf{P}+(1-\lambda)\mathbf{M}\mathbf{C}$</p>
<p>简单的方法：<br>$\mathbf{C}=\begin{pmatrix}-\mathbf{Q}^{-1}\mathbf{b}\\\\1\end{pmatrix}$</p>
<h4 id="多平面校准"><a href="#多平面校准" class="headerlink" title="多平面校准"></a>多平面校准</h4><p>目前最常使用的：</p>
<p>优点：</p>
<ol>
<li>只需要一张纸</li>
<li>不需要知道相机内部参数</li>
<li>代码是公开的</li>
</ol>
<h2 id="多视角"><a href="#多视角" class="headerlink" title="多视角"></a>多视角</h2><h4 id="图像到图像投影"><a href="#图像到图像投影" class="headerlink" title="图像到图像投影"></a>图像到图像投影</h4><p>2D变换：<br><img src="/2024/04/29/16-24-21/QQ20240502-123620@2x.png" class></p>
<p>特殊投影变换：<br>变换：<br><img src="/2024/04/29/16-24-21/QQ20240502-123832@2x.png" class></p>
<p>刚体变换：<br><img src="/2024/04/29/16-24-21/QQ20240502-123903@2x.png" class></p>
<p>相似变换：<br><img src="/2024/04/29/16-24-21/QQ20240502-123927@2x.png" class></p>
<p>仿射变换：Affine transform<br><img src="/2024/04/29/16-24-21/QQ20240502-123942@2x.png" class></p>
<p>一般投影变换：<br><img src="/2024/04/29/16-24-21/QQ20240502-124130@2x.png" class></p>
<h2 id="马赛克"><a href="#马赛克" class="headerlink" title="马赛克"></a>马赛克</h2><p>平面图：<br><img src="/2024/04/29/16-24-21/QQ20240502-124454@2x.png" class><br>射线上任一点，投影到平面上，都是交点重合。</p>
<h4 id="图像重影"><a href="#图像重影" class="headerlink" title="图像重影"></a>图像重影</h4><p>相机中心相同，拍摄了两张照片：<br><img src="/2024/04/29/16-24-21/QQ20240502-124653@2x.png" class></p>
<p>全景图像：<br>保存相机中心不变，移动水平角度，拍摄照片，重合起来就是全景图像。</p>
<p>自然几何：<br><img src="/2024/04/29/16-24-21/QQ20240502-125002@2x.png" class><br>将图像投影到大平面上，组成全景图像，重叠部分混合。</p>
<p>相同位置的不同坐标：<br><img src="/2024/04/29/16-24-21/QQ20240502-125348@2x.png" class></p>
<p>关键是求解：<br><img src="/2024/04/29/16-24-21/QQ20240502-125433@2x.png" class></p>
<p>转换图像(图像扭曲)：是一种插值<br><img src="/2024/04/29/16-24-21/QQ20240502-125553@2x.png" class></p>
<p>全景图像方法：可以用于去除图像中元素<br><img src="/2024/04/29/16-24-21/QQ20240502-125804@2x.png" class></p>
<h4 id="3D图像"><a href="#3D图像" class="headerlink" title="3D图像"></a>3D图像</h4><img src="/2024/04/29/16-24-21/QQ20240502-125917@2x.png" class>
<h4 id="两种图像扭曲方法"><a href="#两种图像扭曲方法" class="headerlink" title="两种图像扭曲方法"></a>两种图像扭曲方法</h4><p>向前扭曲：错误方式<br><img src="/2024/04/29/16-24-21/QQ20240502-130407@2x.png" class></p>
<p>像素离散化时，某一点的像素位置移动了，需要分散给其他像素。<br><img src="/2024/04/29/16-24-21/QQ20240502-130543@2x.png" class></p>
<p>反向扭曲：<br><img src="/2024/04/29/16-24-21/QQ20240502-130652@2x.png" class></p>
<p>中间像素的插值法：<br><img src="/2024/04/29/16-24-21/QQ20240502-130719@2x.png" class></p>
<h2 id="投影几何"><a href="#投影几何" class="headerlink" title="投影几何"></a>投影几何</h2><p>基本平面知识</p>
<h2 id="基本矩阵"><a href="#基本矩阵" class="headerlink" title="基本矩阵"></a>基本矩阵</h2><img src="/2024/04/29/16-24-21/QQ20240502-131351@2x.png" class>
<img src="/2024/04/29/16-24-21/QQ20240502-131523@2x.png" class>
<img src="/2024/04/29/16-24-21/QQ20240502-131532@2x.png" class>
<h2 id="基础矩阵"><a href="#基础矩阵" class="headerlink" title="基础矩阵"></a>基础矩阵</h2><h4 id="弱校准"><a href="#弱校准" class="headerlink" title="弱校准"></a>弱校准</h4><img src="/2024/04/29/16-24-21/QQ20240502-131844@2x.png" class>
<img src="/2024/04/29/16-24-21/QQ20240502-131901@2x.png" class>
<img src="/2024/04/29/16-24-21/QQ20240502-131918@2x.png" class>
]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>计算机视觉, 图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机视觉概论 计算机视觉的图像处理</title>
    <url>/2024/04/27/09-07-10/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.04.27：初稿</li>
</ul>
<h2 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h2><ul>
<li><a href="/2024/04/27/08-42-03/" title="Ud810 Intro-to-cv 笔记汇总">计算机视觉概率-笔记汇总</a>
</li>
</ul>
<h2 id="图像作为函数"><a href="#图像作为函数" class="headerlink" title="图像作为函数"></a>图像作为函数</h2><h4 id="理解图像函数"><a href="#理解图像函数" class="headerlink" title="理解图像函数"></a>理解图像函数</h4><img src="/2024/04/27/09-07-10/QQ20240427-092957@2x.png" class>
<p>通常我们认为图像就是看到的东西，实际上，图像是一个函数$I(x, y)$，值为像素值。</p>
<img src="/2024/04/27/09-07-10/QQ20240427-093048@2x.png" class>
<p>上面两种形式是一个相同的函数，只是展示方式不同。</p>
<p>对图像做平滑处理，函数变为：<br><img src="/2024/04/27/09-07-10/QQ20240427-093326@2x.png" class></p>
<p>对图像做模糊处理，函数变为：<br><img src="/2024/04/27/09-07-10/QQ20240427-093357@2x.png" class></p>
<h4 id="图像函数"><a href="#图像函数" class="headerlink" title="图像函数"></a>图像函数</h4><p>$f(x, y)$：是图像在点$(x, y)$处的光强度或值<br>限制$x$,$y$的范围，以及强度的范围：$f:[a, b] x[c, d] \rightarrow[\min , \max ]$</p>
<blockquote>
<p>图像定义：$x$为列，$y$为行, 原点在图像左上角</p>
</blockquote>
<p>图像范围不是0-255，而是0-1，0为黑，1为白，最小值为黑色，最大值为白色，甚至可以存在负值图像。</p>
<blockquote>
<p>黑白定义来源光的强度，值越大，强度越高，为白色</p>
</blockquote>
<p>彩色图像：</p>
<p>\begin{split}<br>f(x, y)=\left[\begin{array}{l}<br>r(x, y) \\<br>g(x, y) \\<br>b(x, y)<br>\end{array}\right]<br>\end{split}</p>
<p>每个像素为一个向量，RGB：值分别为，红，绿，蓝的颜色强度。</p>
<h4 id="真实的菲利斯"><a href="#真实的菲利斯" class="headerlink" title="真实的菲利斯"></a>真实的菲利斯</h4><img src="/2024/04/27/09-07-10/QQ20240427-095451@2x.png" class>
<p>这与眼睛看到的图像是相同的函数。</p>
<h4 id="数字图像"><a href="#数字图像" class="headerlink" title="数字图像"></a>数字图像</h4><p>Sample：采样，对2D图像进行采样, 即像素<br>Quantize：量化，用一个有限数量的位数来表示它</p>
<blockquote>
<p>量化使用浮点图像？</p>
</blockquote>
<img src="/2024/04/27/09-07-10/QQ20240427-095943@2x.png" class>
<p>图像由$(x,y)$确定，而计算中的$(i,j)$，为行，列值，与$x$,$y$，相反。</p>
<p>有时图像也可用一维信号表示。</p>
<h4 id="图像是矩阵存储"><a href="#图像是矩阵存储" class="headerlink" title="图像是矩阵存储"></a>图像是矩阵存储</h4><blockquote>
<p>课程使用的MATLAB，目前多使用OpenCV，所以不记笔记。</p>
</blockquote>
<h4 id="图像噪声"><a href="#图像噪声" class="headerlink" title="图像噪声"></a>图像噪声</h4><p>$\vec{I}^{\prime}(x, y)=\vec{I}(x, y)+\vec{\eta}(x, y)$</p>
<img src="/2024/04/27/09-07-10/QQ20240427-100924@2x.png" class>
<p>椒盐噪声: 产生黑白像素点</p>
<img src="/2024/04/27/09-07-10/QQ20240427-101112@2x.png" class>
<p>脉冲噪声: 产生白色像素点</p>
<img src="/2024/04/27/09-07-10/QQ20240427-101206@2x.png" class>
<p>高斯噪声或正态分布噪声: 产生某些正态分布或某些高斯分布独立同分布的值</p>
<h4 id="Sigma-对高斯噪声的影响"><a href="#Sigma-对高斯噪声的影响" class="headerlink" title="Sigma 对高斯噪声的影响"></a>Sigma 对高斯噪声的影响</h4><img src="/2024/04/27/09-07-10/QQ20240427-101547@2x.png" class>
<p>不同sigma的图像函数。</p>
<ul>
<li>噪声有什么意思？<br>“零”<br>对于负值图像，错误的想法是0是黑色，255是白色，黑色白色，只是值范围内的最小值与最大值，0代表的是两者之间，灰色。非常小的sigma，是一个恒灰函数。</li>
<li>不同的sigma对应不同的图像值范围，(0-255), sigma5是合理的。</li>
</ul>
<h2 id="过滤和噪声"><a href="#过滤和噪声" class="headerlink" title="过滤和噪声"></a>过滤和噪声</h2><h4 id="如何过滤高斯噪声"><a href="#如何过滤高斯噪声" class="headerlink" title="如何过滤高斯噪声"></a>如何过滤高斯噪声</h4><p>采用平滑图像，在一维像素中，周围像素平均值设置为当前像素值，可以消除噪声。</p>
<h4 id="平均值的假设"><a href="#平均值的假设" class="headerlink" title="平均值的假设"></a>平均值的假设</h4><ul>
<li>真实像素值可能与周围像素值相近</li>
<li>每个像素的噪声相互独立<br>意味着如果取噪声的平均值，噪声将为0</li>
</ul>
<h4 id="加权移动平均线"><a href="#加权移动平均线" class="headerlink" title="加权移动平均线"></a>加权移动平均线</h4><img src="/2024/04/27/09-07-10/QQ20240427-103425@2x.png" class>
<p>非均匀权重：距离像素越近，权重越大，可以使图像更平滑。</p>
<h4 id="2D-移动平均线"><a href="#2D-移动平均线" class="headerlink" title="2D 移动平均线"></a>2D 移动平均线</h4><img src="/2024/04/27/09-07-10/1.png" class>
<p>简单的平均权重</p>
<img src="/2024/04/27/09-07-10/QQ20240427-103933@2x.png" class>
<p>移动平均之后的结果</p>
<h4 id="相关过滤"><a href="#相关过滤" class="headerlink" title="相关过滤"></a>相关过滤</h4><p>上述过滤为统一权重过滤，公式为：<br>核的size： 2 * k + 1；</p>
<p>$G[i, j]=\frac{1}{(2 k+1)^2} \sum_{u=-k}^k \sum_{v=-k}^k F[i+u, j+v]$</p>
<p>非均值权重的公式为：<br>$G[i, j]=\sum_{u=-k}^k \sum_{v=-k}^k H[u, v] F[i+u, j+v]$</p>
<h4 id="平均滤波器"><a href="#平均滤波器" class="headerlink" title="平均滤波器"></a>平均滤波器</h4><img src="/2024/04/27/09-07-10/QQ20240427-104618@2x.png" class>
<p>均值平滑后的结果：<br><img src="/2024/04/27/09-07-10/QQ20240427-104655@2x.png" class></p>
<p>效果不好的原因：<br>  如果一个两点失去了焦点，看起来就像是：<br><img src="/2024/04/27/09-07-10/QQ20240427-104815@2x.png" class></p>
<h4 id="高斯过滤"><a href="#高斯过滤" class="headerlink" title="高斯过滤"></a>高斯过滤</h4><p>高斯函数：<br><img src="/2024/04/27/09-07-10/QQ20240427-105107@2x.png" class></p>
<p>高斯过滤后的图像：更加平滑<br><img src="/2024/04/27/09-07-10/QQ20240427-105212@2x.png" class><br>不会出现尖锐的部分</p>
<h4 id="方差与标准差"><a href="#方差与标准差" class="headerlink" title="方差与标准差"></a>方差与标准差</h4><p>sigma越大，模糊程度越高, 是高斯的高度，平方是高斯的方差。<br>关注的有两点，矩阵大小和sigma的值。<br>高斯过滤:<br>不同的sigma：<br><img src="/2024/04/27/09-07-10/QQ20240427-105612@2x.png" class><br>sigma越大，过滤的内容越多。</p>
<p>不同的内核大小：<br><img src="/2024/04/27/09-07-10/QQ20240427-105651@2x.png" class></p>
<p>内核更大，平滑效果越好，</p>
<h4 id="两种高斯直线"><a href="#两种高斯直线" class="headerlink" title="两种高斯直线"></a>两种高斯直线</h4><img src="/2024/04/27/09-07-10/QQ20240427-110026@2x.png" class>
<ul>
<li>sigma越大，噪音越大</li>
<li>高斯过滤，相同平滑量的噪声量较小的会更加平滑</li>
</ul>
<blockquote>
<p>两个sigma对应不同阶段的参数</p>
</blockquote>
<h2 id="线性算子和卷积"><a href="#线性算子和卷积" class="headerlink" title="线性算子和卷积"></a>线性算子和卷积</h2><p>线性变换特点：可加性, 倍乘性</p>
<p>线性算子如何影响整个图像？</p>
<p>脉冲函数：<br><img src="/2024/04/27/09-07-10/QQ20240427-131003@2x.png" class><br>脉冲是一个很小的信号，体积为1。</p>
<p>输入一个脉冲，在黑盒中输出一个响应。<br><img src="/2024/04/27/09-07-10/QQ20240427-131216@2x.png" class></p>
<p>如果知道黑盒如何影响单个脉冲，就可以解释影响整个图像。</p>
<h4 id="过滤脉冲信号"><a href="#过滤脉冲信号" class="headerlink" title="过滤脉冲信号"></a>过滤脉冲信号</h4><img src="/2024/04/27/09-07-10/QQ20240427-131451@2x.png" class>
<p>展示了脉冲过滤的翻转情况，假设中心元素为脉冲元素e。</p>
<h4 id="互相关和卷积"><a href="#互相关和卷积" class="headerlink" title="互相关和卷积"></a>互相关和卷积</h4><p><strong>互相关</strong><br>直接应用过滤器：<br>$G[i, j]=\sum_{u=-k}^k \sum_{v=-k}^k H[u, v] F[i+u, j+v]$</p>
<p>$G=H \otimes F$</p>
<p><strong>卷积</strong><br>翻转上下，左右：</p>
<blockquote>
<p>相当于先把核进行上下左右翻转，然后在应用过滤器：</p>
</blockquote>
<p>$G[i, j]=\sum_{u=-k}^k \sum_{v=-k}^k H[u, v] F[i-u, j-v]$</p>
<p>$G=H \star F$</p>
<p>翻转过程为：(*为了方便看到翻转效果)<br><img src="/2024/04/27/09-07-10/QQ20240427-132224@2x.png" class></p>
<img src="/2024/04/27/09-07-10/QQ20240427-132133@2x.png" class>
<p>卷积实际是一种物理学</p>
<ul>
<li>在对称滤波器中，两种操作都是结果都是相同的</li>
<li>只有在非对称滤波器中，才能看到区别</li>
</ul>
<p><strong>卷积的性质</strong></p>
<ul>
<li>线性运算</li>
<li>结合律</li>
<li>交换律</li>
<li>单位脉冲和整个脉冲操作相同</li>
<li>微分性质<br>卷积的导数等于第一个元素的导数与第二个元素的卷积<br>$\frac\partial{\partial x}(f*g)=\frac{\partial f}{\partial x}*g$<br>边缘检测和梯度查找会用到</li>
</ul>
<h4 id="计算的复杂性和可分离性"><a href="#计算的复杂性和可分离性" class="headerlink" title="计算的复杂性和可分离性"></a>计算的复杂性和可分离性</h4><img src="/2024/04/27/09-07-10/QQ20240427-134946@2x.png" class>
<p>乘法的操作次数需要：$N<em>N</em>W*W$</p>
<p>线性可分离核：<br><img src="/2024/04/27/09-07-10/QQ20240427-135116@2x.png" class><br>假设其他位置元素为0，结果为一列向量乘行向量。</p>
<p>可分离卷积操作：<br>$G=H*F=(C*R)*F=C*(R*F)$<br>乘法操作次数为：$2{\cdot}W{\cdot}N^2&lt;&lt;W^2{\cdot}N^2$</p>
<h4 id="边界问题"><a href="#边界问题" class="headerlink" title="边界问题"></a>边界问题</h4><p>过滤器会不会从边界掉下去？<br>一共有三种边界处理方式：<br><img src="/2024/04/27/09-07-10/QQ20240427-140836@2x.png" class></p>
<p>具体的方法：</p>
<ul>
<li><p>剪辑-clip filter<br>假设边缘是黑的，结果会让边缘变暗，因为黑色渗入了</p>
<img src="/2024/04/27/09-07-10/QQ20240427-141058@2x.png" class>
</li>
<li><p>环绕法-wrap around<br>与傅里叶分析有关<br>假设图片一周围绕的像素与图像边缘有关：右边填充为左边的图像，上边填充为下边的图像</p>
<img src="/2024/04/27/09-07-10/QQ20240427-141413@2x.png" class>
<p>过滤效果：</p>
<img src="/2024/04/27/09-07-10/QQ20240427-141603@2x.png" class>
<p>图像的上边缘会泛红，来源于下边</p>
<blockquote>
<p>类似一种周期性信号，但是在图像过滤中效果不好</p>
</blockquote>
</li>
<li><p>边缘复制法-copy edge<br>填充复制图像边缘</p>
<img src="/2024/04/27/09-07-10/QQ20240427-141754@2x.png" class>
<p>效果: 图像基本保持不变，是一个合理的结果</p>
<img src="/2024/04/27/09-07-10/QQ20240427-141927@2x.png" class> 
</li>
<li><p>反射法-reflect across edge<br>填充的是边缘的反射</p>
<img src="/2024/04/27/09-07-10/QQ20240427-142124@2x.png" class> 
<p>效果也是很好：</p>
<img src="/2024/04/27/09-07-10/QQ20240427-142207@2x.png" class> 
</li>
</ul>
<h4 id="联联系线性滤波器"><a href="#联联系线性滤波器" class="headerlink" title="联联系线性滤波器"></a>联联系线性滤波器</h4><p>用脉冲对图像过滤，得到的还是原图像：<br><img src="/2024/04/27/09-07-10/QQ20240427-142606@2x.png" class></p>
<p>使用向右移动了一位的脉冲，过滤结果：<strong>图中进行的是相关操作</strong><br><img src="/2024/04/27/09-07-10/QQ20240427-142802@2x.png" class></p>
<blockquote>
<p>取向左还是向右，取决于做相关还是卷积操作：</p>
</blockquote>
<p>模糊的平滑滤镜：<br><img src="/2024/04/27/09-07-10/QQ20240427-143056@2x.png" class></p>
<p>特殊的过滤器：(脉冲的两倍，减去模糊)<br><img src="/2024/04/27/09-07-10/QQ20240427-143220@2x.png" class></p>
<blockquote>
<p>锐化图像，强调差异<br>  应用：<br>  <img src="/2024/04/27/09-07-10/QQ20240427-143339@2x.png" class> </p>
</blockquote>
<p>非锐化滤镜:(unsharp mask)<br>类似冲洗胶片，将白光照射，得到底片的负片。</p>
<p>对应上图的锐化：底片的负片减去模糊的部分，得到的是更清晰的图片。</p>
<p>模糊的部分是不清晰的蒙版，加入图像后得到了更清晰的图像。</p>
<h4 id="其他类型的噪音与对应的非线性过滤器"><a href="#其他类型的噪音与对应的非线性过滤器" class="headerlink" title="其他类型的噪音与对应的非线性过滤器"></a>其他类型的噪音与对应的非线性过滤器</h4><p>高斯噪音与椒盐噪音<br><img src="/2024/04/27/09-07-10/QQ20240427-144017@2x.png" class><br>过滤的本质是从周围的像素点找一个局部平均值替换。</p>
<p>当噪音趋于0时，可以很好的过滤噪音，如果把完全随机的值加入图像，就需要其他过滤方法，比如中值过滤器。</p>
<p>中值过滤器：(median filter)<br>将中间的白色像素90，替换为中值，非线性的，不可以复原.<br><img src="/2024/04/27/09-07-10/QQ20240427-145325@2x.png" class> </p>
<p>对椒盐噪音效果很好：<br><img src="/2024/04/27/09-07-10/QQ20240427-145558@2x.png" class> </p>
<p>非线性的过滤：<br><img src="/2024/04/27/09-07-10/QQ20240427-145725@2x.png" class><br>有时也称为边缘保留</p>
<blockquote>
<p>相对于均值过滤，它保留了图像像素边缘非平滑。</p>
</blockquote>
<h2 id="过滤用作模式匹配"><a href="#过滤用作模式匹配" class="headerlink" title="过滤用作模式匹配"></a>过滤用作模式匹配</h2><p>归一化相关性<br>两件事：1. 对过滤器进行标准化。2.用过滤器将box内的像素变为标准差为1。</p>
<h4 id="1D-信号"><a href="#1D-信号" class="headerlink" title="1D 信号"></a>1D 信号</h4><img src="/2024/04/27/09-07-10/QQ20240427-153302@2x.png" class> 
<p>用所示的滤波器，对信号进行归一化相关：<br>滤波器来源于信号的某一段，在此处，归一化相关后得到峰值。</p>
<blockquote>
<p>原理，在归一化处理后的正负图像中，乘一个自己相同的滤波器，得到的值最大，负负为正。峰值处：正值与正值对齐，负值与负值对齐。</p>
</blockquote>
<p>对应于图像：<br><img src="/2024/04/27/09-07-10/QQ20240427-154142@2x.png" class> </p>
<p>相关后的图像函数图，在相似位置的值为峰值<br><img src="/2024/04/27/09-07-10/QQ20240427-154201@2x.png" class> </p>
<blockquote>
<p>解释了过滤器如何用作模式匹配。</p>
</blockquote>
<h4 id="模式识别"><a href="#模式识别" class="headerlink" title="模式识别"></a>模式识别</h4><p>简单的例子：<br><img src="/2024/04/27/09-07-10/QQ20240428-104609@2x.png" class> </p>
<p>使用相关性进行检测：<br><img src="/2024/04/27/09-07-10/QQ20240428-104723@2x.png" class> </p>
<p>最亮的点就是检测到的位置。</p>
<p>沃尔多在哪里？<br><img src="/2024/04/27/09-07-10/QQ20240428-104903@2x.png" class> </p>
<img src="/2024/04/27/09-07-10/QQ20240428-104923@2x.png" class>
<p>相同的结果：找到最亮的点。</p>
<p>图像不同的情况：<br><img src="/2024/04/27/09-07-10/QQ20240428-105048@2x.png" class> </p>
<img src="/2024/04/27/09-07-10/QQ20240428-104923@2x.png" class>
<blockquote>
<p>匹配错误。</p>
</blockquote>
<h2 id="边缘检测：梯度"><a href="#边缘检测：梯度" class="headerlink" title="边缘检测：梯度"></a>边缘检测：梯度</h2><p>如果事先不知道要找的图像模板，如何在图像中找到有用的信息，图像的特征。</p>
<p>简化图像：</p>
<p>图中的所有信息大多来源于边缘。</p>
<img src="/2024/04/27/09-07-10/QQ20240428-105632@2x.png" class>
<p>边缘：<br><img src="/2024/04/27/09-07-10/QQ20240428-105718@2x.png" class></p>
<p>上图中分别有深度边缘，阴影边缘，颜色的边缘，形状的边缘。</p>
<img src="/2024/04/27/09-07-10/QQ20240428-105810@2x.png" class>
<p>图中包含了纹理边缘。</p>
<p>边缘检测：<br>找出图像函数的边缘像素：<br><img src="/2024/04/27/09-07-10/QQ20240428-110004@2x.png" class></p>
<p>从高度函数中可以看到，急剧变化的位置就是边缘像素。</p>
<p>边缘检测的问题：</p>
<ol>
<li>边缘有多大</li>
<li>变化的范围是多少</li>
</ol>
<p><strong>导数和边缘</strong></p>
<img src="/2024/04/27/09-07-10/QQ20240428-110311@2x.png" class>
<p>右图中的一阶导数函数图，极值点对应的就是图像边缘像素。</p>
<p><strong>什么是梯度</strong></p>
<img src="/2024/04/27/09-07-10/QQ20240428-111127@2x.png" class>
<p>梯度是：图像变化最快的方向。大小是单位长度上变化的强度。</p>
<p>图像的梯度：$\nabla f = [\frac{\partial f}{\partial x},\frac{\partial f}{\partial y}]$</p>
<p>梯度的方向：$\theta^2=\tan^{-1}(\frac{\partial f}{\partial y}/\frac{\partial f}{\partial x})$</p>
<p>边缘变化的强度：$\left\|\nabla f\right\|=\sqrt{(\frac{\partial f}{\partial x})^2+(\frac{\partial f}{\partial y})^2}$</p>
<p>幅度检测：</p>
<p>离散梯度：（在离散数中，极限无法靠近，只能使用有限差分）<br>定义为：<br>\begin{split}<br>\frac{\partial f\left(x,y\right)}{\partial x}&amp;\approx\frac{f\left(x+1,y\right)-f\left(x,y\right)}1\\&amp;\approx f\left(x+1,y\right)-f\left(x,y\right)<br>\end{split}</p>
<p>梯度是对$x$，还是$y$做偏导？<br><img src="/2024/04/27/09-07-10/QQ20240428-111919@2x.png" class></p>
<p>上图中可以看出，在垂直方向对x的梯度可以求出边缘像素，但是在水平方向的边缘像素效果不好。<strong>上图是一个对x的有限差分</strong><br>上图也是一个正负图，负数为黑色，正数为白色，零是灰色。</p>
<p><strong>图像的偏导数</strong><br><img src="/2024/04/27/09-07-10/QQ20240428-112419@2x.png" class><br>很容易可以看出：左边是对x的偏导图，右边是对y的偏导图。</p>
<p>使用的相关过滤器：</p>
<ul>
<li>对x：将右边的像素减去左边的像素，增强对比。</li>
<li>对y：有两种，取决于想让y上升还是下降</li>
</ul>
<p>离散梯度：使用运算符$H$实现<br>由公式可以得出，梯度为左边的像素减去自己的像素。<br><img src="/2024/04/27/09-07-10/QQ20240428-113714@2x.png" class></p>
<ul>
<li>第一种运算符：没有中间元素，且只输出了右边的梯度</li>
<li>第二种运算符：输出左边和右边的梯度平均值<br>公式推导：</li>
</ul>
<p>\begin{split}<br>\frac{\partial f\left(x,y\right)}{\partial x} \\<br>&amp;\approx\frac{1}{2}\{(f\left(x+1,y\right)-f\left(x,y\right) + f\left(x,y\right)-f\left(x - 1,y\right)\}\\<br>&amp;\approx\frac{1}{2}\{f\left(x+1,y\right)-f\left(x - 1,y\right)\}<br>\end{split}</p>
<p>经典的边缘算法：Sobel算子<br><img src="/2024/04/27/09-07-10/QQ20240428-123328@2x.png" class></p>
<ul>
<li>$S_x$：左右和左上右上，左下右下的方向导数。</li>
<li>$S_y$：同理</li>
</ul>
<p>梯度：$\nabla\mathbf{I}=[\mathbf{g}_\mathbf{X}\quad\mathbf{g}_\mathbf{y}]^\mathbf{T}$<br>强度：$\mathrm{g=(g_X^2+g_y^2)^{1/2}}$<br>方向：$\theta=\operatorname{atan2}(\mathfrak{g}_\mathrm{y},\mathfrak{g}_\mathrm{x})$</p>
<p>Sobel古老的例子：X windows</p>
<img src="/2024/04/27/09-07-10/QQ20240428-123839@2x.png" class>
<blockquote>
<p>右边的图像是做了阀值化thresholded</p>
</blockquote>
<p>著名的边缘算子：<br><img src="/2024/04/27/09-07-10/QQ20240428-123955@2x.png" class></p>
<h4 id="现实世界"><a href="#现实世界" class="headerlink" title="现实世界"></a>现实世界</h4><p>上述算子在现实中不会起作用，噪声太多。<br><img src="/2024/04/27/09-07-10/QQ20240428-124215@2x.png" class><br>所以必须先处理噪音，在边缘化。</p>
<p>解决方案：平滑<br><img src="/2024/04/27/09-07-10/QQ20240428-124357@2x.png" class><br>山峰就是边缘像素。</p>
<p><strong>算子的线性结合性</strong><br>利用卷积的求导公式: $\frac\partial{\partial x}(f*g)=\frac{\partial f}{\partial x}*g$</p>
<img src="/2024/04/27/09-07-10/QQ20240428-124636@2x.png" class>
<p><strong>二阶导数</strong></p>
<img src="/2024/04/27/09-07-10/QQ20240428-124732@2x.png" class>
<blockquote>
<p>零强度的位置就是边缘像素，不需要再找峰值了</p>
</blockquote>
<h2 id="2D边缘检测"><a href="#2D边缘检测" class="headerlink" title="2D边缘检测"></a>2D边缘检测</h2><h4 id="二维高斯滤波器的导数"><a href="#二维高斯滤波器的导数" class="headerlink" title="二维高斯滤波器的导数"></a>二维高斯滤波器的导数</h4><img src="/2024/04/27/09-07-10/QQ20240428-125006@2x.png" class>
<ul>
<li>公式：$(I\otimes g)\otimes h=I\otimes(g\otimes h)$<br>根据结合性</li>
<li>$h$: 只对x求导</li>
<li>$g$: 高斯平滑</li>
</ul>
<p>高斯滤波器的导数：<br><img src="/2024/04/27/09-07-10/QQ20240428-125509@2x.png" class></p>
<ul>
<li>左图：可以看出是一个相关操作,因为往右增为正方向。</li>
<li>右图：</li>
</ul>
<p>sigma的大小：<br><img src="/2024/04/27/09-07-10/QQ20240428-125956@2x.png" class> </p>
<p>不同的sigma对于图像边缘的影响：较小的值，有精细的特征,而较大的值仅仅检测到较大尺度的边缘。</p>
<h4 id="如何找到边缘？"><a href="#如何找到边缘？" class="headerlink" title="如何找到边缘？"></a>如何找到边缘？</h4><p>Canny算子:</p>
<ol>
<li>对高斯图像进行滤波</li>
<li>找幅度最大的方向，进行非极大值抑制，即细化操作</li>
<li>连接操作，将边缘连接起来<br>定义了两个阀值：极大阀值和极小阀值</li>
</ol>
<p>原图：<br><img src="/2024/04/27/09-07-10/QQ20240428-130730@2x.png" class> </p>
<p>梯度图：<br><img src="/2024/04/27/09-07-10/QQ20240428-130742@2x.png" class> </p>
<p>阀值处理图：消除一部分梯度够高的像素<br><img src="/2024/04/27/09-07-10/QQ20240428-130804@2x.png" class> </p>
<p>细化处理：(非极大值抑制)<br><img src="/2024/04/27/09-07-10/QQ20240428-130903@2x.png" class> </p>
<p>做法：某个局部有很多梯度点，只保留极值最高的点，抑制非极大值</p>
<p>为什么要进行细化操作：<br><img src="/2024/04/27/09-07-10/QQ20240428-131216@2x.png" class> </p>
<p>超过阀值的粗部分,只保留极大值，细化为一条直线。</p>
<img src="/2024/04/27/09-07-10/QQ20240428-131343@2x.png" class>
<p>在梯度方向找到极大值</p>
<p>另一个问题：下巴的边缘没有检测出来？<br><img src="/2024/04/27/09-07-10/QQ20240428-131520@2x.png" class><br>阀值太高，下巴的梯度没有通过阀值。</p>
<p>Canny阀值滞后:</p>
<ol>
<li>用高阀值检测边缘,找出强边缘像素</li>
<li>连接成强边缘</li>
<li>应用低阀值找出弱边缘像素</li>
<li>把强边缘延长到弱像素上<blockquote>
<p>如果一条边缘上只有弱边缘像素，就不是一个需要的边缘<br>强边缘可能会穿过一些弱边缘像素</p>
</blockquote>
</li>
</ol>
<p>Canny 算子的结果：<br><img src="/2024/04/27/09-07-10/QQ20240428-132327@2x.png" class></p>
<p>什么样的边缘图是好的？取决于你想用什么样的边缘图。</p>
<h4 id="简单的二维边缘检测滤波器"><a href="#简单的二维边缘检测滤波器" class="headerlink" title="简单的二维边缘检测滤波器"></a>简单的二维边缘检测滤波器</h4><img src="/2024/04/27/09-07-10/QQ20240428-132553@2x.png" class>
<p>偏导有多种顺序</p>
<p><strong>拉普拉斯算子</strong>用于求二阶偏导</p>
<img src="/2024/04/27/09-07-10/QQ20240428-132734@2x.png" class>
<p>公式：$\nabla^2h^2=\frac{\partial^2f}{\partial x^2}+\frac{\partial^2f}{\partial y^2}$</p>
<ul>
<li>$\nabla^2$: 拉普拉斯算子</li>
<li>0为边缘像素</li>
</ul>
<h2 id="霍夫变换（Hough-transform）-直线"><a href="#霍夫变换（Hough-transform）-直线" class="headerlink" title="霍夫变换（Hough transform）:直线"></a>霍夫变换（Hough transform）:直线</h2><p>如何找到任意形状？</p>
<h4 id="参数模型（Parametric-model）"><a href="#参数模型（Parametric-model）" class="headerlink" title="参数模型（Parametric model）"></a>参数模型（Parametric model）</h4><p>参数模型是一个类</p>
<p>直线匹配：<br><img src="/2024/04/27/09-07-10/QQ20240428-133955@2x.png" class></p>
<p>边缘图：<br><img src="/2024/04/27/09-07-10/QQ20240428-133947@2x.png" class><br>困难：</p>
<ul>
<li>有很其他形状,多种模型</li>
<li>线不连续</li>
<li>噪音</li>
</ul>
<p>投票：</p>
<ol>
<li>每个像素点对有用模型投票</li>
<li>找出最高的模型</li>
</ol>
<blockquote>
<p>原因：有很多无效的像素点，但只要有真正的像素点投票是有效的，选出匹配的模型，就可以淘汰掉噪音。</p>
</blockquote>
<p>拟合直线的几个问题？</p>
<ol>
<li>给定一些点，哪些是一条线</li>
<li>有多少条线</li>
<li>有哪些点是属于线的</li>
</ol>
<p>霍夫变换：一种投票技术，可以解决上面的问题</p>
<ul>
<li>每个边缘点都会投票给兼容的线</li>
<li>找票数最多线</li>
<li>追踪票，可以找到属于线的点有哪些</li>
</ul>
<h4 id="霍夫空间Hough-parameter-space"><a href="#霍夫空间Hough-parameter-space" class="headerlink" title="霍夫空间Hough (parameter) space"></a>霍夫空间Hough (parameter) space</h4><img src="/2024/04/27/09-07-10/QQ20240428-135111@2x.png" class>
<p>对于一个点$(x,y)$，穿过这个点的直线为:$y_0=mx_0+b$，$m$,$b$为任意值。<br>所以对应霍夫空间的函数为：$b^2=-x_0m^2+y_0$</p>
<blockquote>
<p>将空间中的一点，对应到霍夫空间中的一条直线</p>
</blockquote>
<img src="/2024/04/27/09-07-10/QQ20240428-135421@2x.png" class>
<ul>
<li>霍夫空间中的交点，对应的参数，是过两点的直线</li>
<li>这就是从点中找线的方法</li>
</ul>
<p><strong>霍夫算法</strong></p>
<img src="/2024/04/27/09-07-10/QQ20240428-135710@2x.png" class>
<p>点对应于霍夫空间中的线：</p>
<ul>
<li>每个点都对自己经过的分区投票</li>
<li>票数最多的就是线<blockquote>
<p>具有偏差</p>
</blockquote>
</li>
</ul>
<p>为了防止出现垂直直线的表示，采用极坐标法表示图像</p>
<img src="/2024/04/27/09-07-10/QQ20240428-140007@2x.png" class>
<ul>
<li>$d$:原点到点距离</li>
<li>$\theta$: 表示到$x$轴的角度</li>
<li>$\quad x\cos\theta+y\sin\theta=d$</li>
</ul>
<blockquote>
<p>可以表示任何的直线<br>图像空间中的点是霍夫空间中的正弦曲线</p>
</blockquote>
<h4 id="基本霍夫变换算法"><a href="#基本霍夫变换算法" class="headerlink" title="基本霍夫变换算法"></a>基本霍夫变换算法</h4><p>霍夫累加器数组（收集投票的数组）：<br><img src="/2024/04/27/09-07-10/QQ20240428-140657@2x.png" class></p>
<p>霍夫算法：<br><img src="/2024/04/27/09-07-10/QQ20240428-140911@2x.png" class></p>
<p>霍夫变化的复杂性：<br>空间复杂性和时间复杂性都很大</p>
<p>直线的霍夫空间：<br>无噪音的直线<br><img src="/2024/04/27/09-07-10/QQ20240428-141342@2x.png" class><br>最亮的点：是像素最多的直线</p>
<p>正方形的霍夫空间：<br><img src="/2024/04/27/09-07-10/QQ20240428-141150@2x.png" class></p>
<h4 id="噪音对霍夫变化的影响"><a href="#噪音对霍夫变化的影响" class="headerlink" title="噪音对霍夫变化的影响"></a>噪音对霍夫变化的影响</h4><img src="/2024/04/27/09-07-10/QQ20240428-141725@2x.png" class>
<p>峰值不明确了</p>
<p>更多的噪音：<br><img src="/2024/04/27/09-07-10/QQ20240428-141839@2x.png" class></p>
<h4 id="霍夫变化的扩展"><a href="#霍夫变化的扩展" class="headerlink" title="霍夫变化的扩展"></a>霍夫变化的扩展</h4><p>使用<strong>梯度</strong>优化霍夫变换算法<br><img src="/2024/04/27/09-07-10/QQ20240428-142259@2x.png" class></p>
<blockquote>
<p>优化的霍夫变换的地方？</p>
</blockquote>
<p>扩展二：<br>改变阀值<br>扩展三：<br>改变投票箱的大小<br>扩展四：<br>相同的操作可以用的其他形状</p>
<blockquote>
<p>课上的算法对现实是不起作用的<br>论文中的算法也是不起作用，要把故事讲得好听<br>关键是理解原理</p>
</blockquote>
<h2 id="霍夫变换（Hough-transform）-圆"><a href="#霍夫变换（Hough-transform）-圆" class="headerlink" title="霍夫变换（Hough transform）:圆"></a>霍夫变换（Hough transform）:圆</h2><p>圆的方程：$\left(x_i-a\right)^2+\left(y_i-b\right)^2=r^2$</p>
<p>圆的霍夫空间：<br><img src="/2024/04/27/09-07-10/QQ20240429-091353@2x.png" class></p>
<p>使用更大的投票箱：<br><img src="/2024/04/27/09-07-10/QQ20240429-091756@2x.png" class></p>
<h4 id="圆的霍夫变换"><a href="#圆的霍夫变换" class="headerlink" title="圆的霍夫变换"></a>圆的霍夫变换</h4><p>投票箱在3D空间中：<br><img src="/2024/04/27/09-07-10/QQ20240429-091605@2x.png" class></p>
<p>梯度优化：<br><img src="/2024/04/27/09-07-10/QQ20240429-092109@2x.png" class></p>
<ul>
<li>过这点的圆心只可能在：点和圆心的连线，即梯度垂线上</li>
<li>这样就过滤掉其他位置的圆心投票</li>
</ul>
<p>算法：<br><img src="/2024/04/27/09-07-10/QQ20240429-091847@2x.png" class></p>
<h4 id="投票的实用技巧"><a href="#投票的实用技巧" class="headerlink" title="投票的实用技巧"></a>投票的实用技巧</h4><ul>
<li>剪枝，不要投没用得票</li>
<li>选一个合理的投票网格<ul>
<li>太大，投的错误太多</li>
<li>太小，噪音会影响</li>
</ul>
</li>
<li>投票给临近的投票箱，类似累加器平滑</li>
<li>使用梯度优化投票</li>
</ul>
<h4 id="优点缺点"><a href="#优点缺点" class="headerlink" title="优点缺点"></a>优点缺点</h4><p>优点：</p>
<ul>
<li>每个像素投票都是独立的，不受遮挡影响</li>
<li>噪音也不影响</li>
<li>可以在单图像找多形状</li>
</ul>
<p>缺点：</p>
<ul>
<li>参数的复杂性</li>
<li>非常规形状，投票很复杂</li>
</ul>
<h2 id="广义霍夫变换"><a href="#广义霍夫变换" class="headerlink" title="广义霍夫变换"></a>广义霍夫变换</h2><h4 id="非分析模型"><a href="#非分析模型" class="headerlink" title="非分析模型"></a>非分析模型</h4><p>霍夫表：<br>用于给非规则形状投票</p>
<p>建表：<br><img src="/2024/04/27/09-07-10/QQ20240429-093857@2x.png" class></p>
<ul>
<li>$c$：是一个定位点</li>
<li>$r$：位移矢量</li>
<li>$\theta_1$： 梯度</li>
<li>把$r$放入由$\theta$索引的表</li>
</ul>
<p>识别：</p>
<img src="/2024/04/27/09-07-10/QQ20240429-093933@2x.png" class>
<ul>
<li>计算边界点的梯度方向$\theta$</li>
<li>在表格中找出所有该方向的位移向量</li>
<li>给位移向量的终点投票？</li>
</ul>
<p>样例：</p>
<img src="/2024/04/27/09-07-10/QQ20240429-101040@2x.png" class>
<p>底部的边有相同的$\theta$，但是不一样的位移，对所有的位移投票。</p>
<img src="/2024/04/27/09-07-10/QQ20240429-101252@2x.png" class>
<p>当下这个像素点的位移图，来源于它相同$\theta$的投票，做了平移，他们公用一个索引点，最终底部的所有像素点投票得出了一条直线。</p>
<img src="/2024/04/27/09-07-10/QQ20240429-101605@2x.png" class>
<p>这条直线中，中心的投票数是最多的，通过对另一条边做相同操作，交点为中心点。</p>
<p>算法：默认不知道方向</p>
<img src="/2024/04/27/09-07-10/QQ20240429-102147@2x.png" class>
<p>不知道比例：<br><img src="/2024/04/27/09-07-10/QQ20240429-102238@2x.png" class></p>
<p><strong>识别中的应用</strong><br>基于视觉代码的索引：<br><img src="/2024/04/27/09-07-10/QQ20240429-102508@2x.png" class></p>
<p>生成代码块：<br><img src="/2024/04/27/09-07-10/QQ20240429-102615@2x.png" class><br>像素按蔟分类</p>
<p>生成特征：<br><img src="/2024/04/27/09-07-10/QQ20240429-102705@2x.png" class></p>
<p>生成位移投票：<br><img src="/2024/04/27/09-07-10/QQ20240429-102750@2x.png" class><br>在投票箱中，相同特征的投票数量就是特征的个数。<br>看轮胎投了几票</p>
<h2 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h2><p>计算视觉将图像视为数据，而不是信号，但频率分析的思想很有用。</p>
<p>basis sets：标准基(线代的定义)</p>
<p>应用到图像的标准基：<br>把图像视为非常大的空间中的点，例如一个N*N的图像，可以认为是一个一维的向量。<br>另一种做法：<br><img src="/2024/04/27/09-07-10/QQ20240429-140527@2x.png" class></p>
<ul>
<li>同一位置的图像：类似正弦余弦</li>
</ul>
<p>上面就是<strong>傅里叶基</strong>，递增的是频率</p>
<h4 id="正弦和"><a href="#正弦和" class="headerlink" title="正弦和"></a>正弦和</h4><p>公式：$A\sin(\omega x^2+\varphi^2)$<br>共有三个自由度：</p>
<ul>
<li>$A$：幅度</li>
<li>$\omega$：频率</li>
<li>$\varphi$：相位</li>
</ul>
<img src="/2024/04/27/09-07-10/QQ20240429-141002@2x.png" class>
<p>频率是最重要的，频率越高，摆动速度越快</p>
<h4 id="时间和频率"><a href="#时间和频率" class="headerlink" title="时间和频率"></a>时间和频率</h4><p>$g(t)=\sin(2\pi ft)+\frac13\sin(2\pi(3f)t)$<br><img src="/2024/04/27/09-07-10/QQ20240429-141307@2x.png" class></p>
<p>一种绘制光谱的方式</p>
<img src="/2024/04/27/09-07-10/QQ20240429-141409@2x.png" class>
<p>f越大，越接近方波</p>
<p>方波的正弦公式：$A\sum\limits_{k=1}^{\infty}\frac{1}{k}\sin\left(2\pi kt\right)$<br>图像：<br><img src="/2024/04/27/09-07-10/QQ20240429-141517@2x.png" class><br>不考虑相位</p>
<h4 id="傅里叶变换-1"><a href="#傅里叶变换-1" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h4><p>$f(x)\longrightarrow\boxed{\begin{array}{c}\text{Fourier}\\\text{Transform}\end{array}}\longrightarrow F(\omega)$</p>
<p>复数：$\begin{aligned}F\left(\omega\right)&amp;=R\left(\omega\right)+iI\left(\omega\right)\end{aligned}$<br>性质：</p>
<ul>
<li>$A = \pm\sqrt{R \left( \omega \right)^2 + I \left( \omega \right)^2}$</li>
<li>$\varphi^2=\tan^{-1}\frac{I\left(\omega\right)}{R\left(\omega\right)}$</li>
</ul>
<p>虚部是奇函数-正弦，实部是偶函数-余弦。</p>
<h4 id="计算傅里叶变换"><a href="#计算傅里叶变换" class="headerlink" title="计算傅里叶变换"></a>计算傅里叶变换</h4><p>基本性质：<br>$\int_{-\infty}^\infty\sin(ax+\phi)\sin(bx+\varphi)dx=0,\mathrm{~if~}a\neq b$</p>
<p>$\int_{-\infty}^\infty\sin(\alpha x+\phi)\sin(\alpha x+\varphi)dx=\pm\infty$</p>
<p>例子：<br>假设一个展开为余弦的函数：<br>$f\left(x\right)=\cos\left(2\pi\omega x\right)$</p>
<p>$C\left(u\right)=\int_{-\infty}^{\infty}f\left(x\right)\cos\left(2\pi ux\right)dx$</p>
<ul>
<li>如果$u == \omega$：积分为无穷</li>
<li>如果$u \neq \omega$：积分为0 </li>
</ul>
<p>得到脉冲图：<br><img src="/2024/04/27/09-07-10/QQ20240429-143042@2x.png" class></p>
<p>被称作与余弦对应的脉冲</p>
<p>如果是正弦，左边将会是负的脉冲：$\sin(-x) = -\sin(x)$</p>
<h4 id="傅里叶变换通用定义"><a href="#傅里叶变换通用定义" class="headerlink" title="傅里叶变换通用定义"></a>傅里叶变换通用定义</h4><p>定义：$F\left(u^2\right)=\int_{-\infty}^{\infty}f\left(x^2\right)e^{-i2\pi ux}dx$<br>其中：$e^{ik}=\text{ cos }k+i\sin k\quad i=\sqrt{-1}$</p>
<p>作用：从空间域转换到频域</p>
<p>傅里叶逆变换：$f\left(x\right)=\int_{-\infty}^\infty F\left(u\right)e^{i2\pi ux}du$<br>可以恢复信号</p>
<h4 id="频谱"><a href="#频谱" class="headerlink" title="频谱"></a>频谱</h4><p>常用频谱：<br><img src="/2024/04/27/09-07-10/QQ20240429-144050@2x.png" class><br>最后一个是幂频谱</p>
<p>频谱图：<br><img src="/2024/04/27/09-07-10/QQ20240429-144135@2x.png" class></p>
<p>局限性：<br>傅里叶级数积分有界</p>
<h4 id="傅里叶变换到傅里叶级数"><a href="#傅里叶变换到傅里叶级数" class="headerlink" title="傅里叶变换到傅里叶级数"></a>傅里叶变换到傅里叶级数</h4><p>级数：$F\left(k\right)=\frac1N\sum_{x=0}^{x=N-1}f\left(x\right)e^{-i\frac{2\pi kx}N}$</p>
<p>积分的另一种写法：离散化</p>
<h4 id="二维的傅里叶"><a href="#二维的傅里叶" class="headerlink" title="二维的傅里叶"></a>二维的傅里叶</h4><p>$F\left(u,\nu\right)=\int_{-\infty}^\infty\int_{-\infty}^\infty f\left(x,y\right)e^{-i2\pi\left(ux+\nu y\right)}dxdy\frac12$</p>
<p>离散：$F\left(k_x,k_y\right)=\frac1N\sum_{x=0}^{x=N-1}\sum_{y=0}^{y=N-1}f\left(x,y\right)e^{-i\frac{2\pi\left(k_xx+k_yy\right)}N}$</p>
<p>例子：<br>一个正弦曲线，处于特定的频率， 仅仅有垂直线组成：<br><img src="/2024/04/27/09-07-10/QQ20240429-144821@2x.png" class></p>
<p>右图是它的傅里叶频谱和功能谱。<br>亮点就是频率的尖峰</p>
<p>一个余弦曲线，频率更快：<br><img src="/2024/04/27/09-07-10/QQ20240429-145050@2x.png" class></p>
<blockquote>
<p>频率分量更高，峰值靠外</p>
</blockquote>
<p>线性：傅里叶变换是一个线性变换<br><img src="/2024/04/27/09-07-10/QQ20240429-145222@2x.png" class></p>
<h4 id="真实图像的光谱"><a href="#真实图像的光谱" class="headerlink" title="真实图像的光谱"></a>真实图像的光谱</h4><img src="/2024/04/27/09-07-10/QQ20240429-145348@2x.png" class>
<blockquote>
<p>自然图像有相同的光谱<br>重建图像才需要相位<br>用部分光谱重建图像，图像的变化如右图<br>高频率：告诉边缘在哪里，高频越亮，越清晰<br>明亮线垂直于轮廓线</p>
</blockquote>
<img src="/2024/04/27/09-07-10/QQ20240429-145542@2x.png" class>
<p>人造场景：</p>
<img src="/2024/04/27/09-07-10/QQ20240429-145613@2x.png" class>
<p>思考：</p>
<ul>
<li>如果不是周期函数，光谱会有倾斜</li>
<li></li>
</ul>
<h2 id="频率分析中的卷积"><a href="#频率分析中的卷积" class="headerlink" title="频率分析中的卷积"></a>频率分析中的卷积</h2><h4 id="傅里叶变换与卷积"><a href="#傅里叶变换与卷积" class="headerlink" title="傅里叶变换与卷积"></a>傅里叶变换与卷积</h4><p>卷积：$g = f * h$<br>傅里叶变换：<br>\begin{split}<br>G\left(u\right)&amp;=\int_{-\infty}^{\infty}g\left(x\right)e^{-i2\pi ux}dx \\<br>&amp;=\int_{-\infty}^\infty\int_{-\infty}^\infty f\left(\tau\right)h\left(x-\tau\right)e^{-i2\pi ux}d\tau dx \\<br>&amp;=\int_{-\infty}^\infty\int_{-\infty}^\infty\left[f\left(\tau\right)e^{-i2\pi u\tau}d\tau\right]\left[h\left(x-\tau\right)e^{-i2\pi u\left(x-\tau\right)}dx\right] \\<br>&amp;=\int_{-\infty}^{\infty}\left[f\left(\tau\right)e^{-i2\pi u\tau}d\tau\right]\int_{-\infty}^{\infty}\left[h\left(x^{\prime}\right)e^{-i2\pi ux^{\prime}}dx^{\prime}\right] \\<br>&amp;=F\left(\begin{array}{c}u\\\end{array}\right)H\left(\begin{array}{c}u\\\end{array}\right)<br>\end{split}</p>
<img src="/2024/04/27/09-07-10/QQ20240429-152239@2x.png" class>
<p><strong>空间中乘积$\Leftrightarrow$频率空间中卷积</strong></p>
<blockquote>
<p>大掩码的空间域卷积很复杂，用快速傅里叶变换可以转换为频率域乘法，避免卷积。</p>
</blockquote>
<h4 id="平滑和模糊中的应用"><a href="#平滑和模糊中的应用" class="headerlink" title="平滑和模糊中的应用"></a>平滑和模糊中的应用</h4><img src="/2024/04/27/09-07-10/QQ20240429-152734@2x.png" class>
<img src="/2024/04/27/09-07-10/QQ20240429-152812@2x.png" class>
<p><strong>瘦高斯的傅里叶是胖的</strong><br>原因：<br>如果高斯很瘦，就希望保留所有的频率，傅里叶就很胖。<br>高斯很胖，模糊了一切，就只保留一点点低频率，几乎没有高频率。<br>作用：<br>保存低频率，降低高频率。</p>
<blockquote>
<p>空间采样频率越低，傅里叶频率越高.<br>傅里叶的放缩原理</p>
</blockquote>
<p>效果图；<br><img src="/2024/04/27/09-07-10/QQ20240429-153249@2x.png" class></p>
<h4 id="傅里叶变换的性质"><a href="#傅里叶变换的性质" class="headerlink" title="傅里叶变换的性质"></a>傅里叶变换的性质</h4><img src="/2024/04/27/09-07-10/QQ20240429-153642@2x.png" class>
<p>傅里叶对：<br><img src="/2024/04/27/09-07-10/QQ20240429-153804@2x.png" class></p>
<h2 id="混叠-Aliasing"><a href="#混叠-Aliasing" class="headerlink" title="混叠 Aliasing"></a>混叠 Aliasing</h2><p>傅里叶基是如何混叠的？</p>
<h4 id="脉冲串的概念"><a href="#脉冲串的概念" class="headerlink" title="脉冲串的概念"></a>脉冲串的概念</h4><p>脉冲串的傅里叶变换是另一个脉冲串<br><img src="/2024/04/27/09-07-10/QQ20240429-154529@2x.png" class></p>
<blockquote>
<p>空间中脉冲距离越远，频率中脉冲越接近</p>
</blockquote>
<h4 id="采样和重构"><a href="#采样和重构" class="headerlink" title="采样和重构"></a>采样和重构</h4><img src="/2024/04/27/09-07-10/QQ20240429-154812@2x.png" class>
<p>采样是计算机如何存储连续信号提出的,如何重建原始信号？<br><img src="/2024/04/27/09-07-10/QQ20240429-154933@2x.png" class></p>
<p>在离散位置如何将信号连续起来。</p>
<p>样例：<br><img src="/2024/04/27/09-07-10/QQ20240429-155039@2x.png" class></p>
<p>采样密度不够，无法恢复图像。</p>
<p>如何防止锯齿出现？<br>过滤高频率，降低采样量。</p>
<h4 id="脉冲"><a href="#脉冲" class="headerlink" title="脉冲"></a>脉冲</h4><p>一维脉冲函数：$comb_M[x]=\sum_{k=-\infty}^{\infty}\delta[x-kM]$<br>图像：<br><img src="/2024/04/27/09-07-10/QQ20240429-155942@2x.png" class></p>
<p>二维脉冲函数：$comb_{M,N}(x,y)\equiv\sum_{k=-\infty}^\infty\sum_{l=-\infty}^\infty\delta\left(x-kM,y-lN\right)$<br>傅里叶变换：<br>$\sum_{k=-\infty}^n\sum_{l=-\infty}^n\delta\left(x-kM,y-lN\right)\Leftrightarrow\frac1{MN}\sum_{k=-\infty}^\infty\sum_{l=-\infty}^\infty\delta\left(u-\frac kM,\nu-\frac lN\right)$</p>
<h4 id="采样低频信号"><a href="#采样低频信号" class="headerlink" title="采样低频信号"></a>采样低频信号</h4><img src="/2024/04/27/09-07-10/QQ20240429-160402@2x.png" class>
<p>采样：连续信号乘离散梳函数</p>
<p>如果功能频率$W$满足：$W&lt;\frac1{2M}$，就可以恢复。</p>
<blockquote>
<p>这里有一些采样定理的内容</p>
</blockquote>
<h4 id="采样高频信号"><a href="#采样高频信号" class="headerlink" title="采样高频信号"></a>采样高频信号</h4><img src="/2024/04/27/09-07-10/QQ20240429-160831@2x.png" class>
<p>高频信号采样重叠了，采样之前，必须去处高频，以防重叠。</p>
<p>如何去处高频？<br><strong>梳状滤波器</strong><br><img src="/2024/04/27/09-07-10/QQ20240429-161033@2x.png" class></p>
<h4 id="图像中的重叠"><a href="#图像中的重叠" class="headerlink" title="图像中的重叠"></a>图像中的重叠</h4><p>图像缩小，如果直接丢掉行列，图像会变小。放大图像后，图像不像是缩小的图像，很模糊。</p>
<p>正确的做法是：用高斯滤波。<br><img src="/2024/04/27/09-07-10/QQ20240429-161449@2x.png" class><br>高斯滤波做了抗锯齿，所以效果更好。</p>
<h4 id="对比度敏感"><a href="#对比度敏感" class="headerlink" title="对比度敏感"></a>对比度敏感</h4><img src="/2024/04/27/09-07-10/QQ20240429-161728@2x.png" class>
<p>人类的视觉对高频不敏感。</p>
<h4 id="JPEG"><a href="#JPEG" class="headerlink" title="JPEG"></a>JPEG</h4><p>DCT：离散余弦变换<br>不保留高频信息，降低图像质量时，只保存低频率信息。</p>
]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>计算机视觉, 图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>Ud810 Intro-to-cv 笔记汇总</title>
    <url>/2024/04/27/08-42-03/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.04.27：初稿</li>
<li>24.05.06：暂停</li>
</ul>
<h2 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h2><ul>
<li><a href="/2024/04/27/08-38-57/" title="计算机视觉概论 什么是计算机视觉">计算机视觉概论笔记-第一章 什么是计算机视觉</a></li>
<li><a href="/2024/04/27/09-07-10/" title="计算机视觉概论 计算机视觉的图像处理">计算机视觉概论笔记-第二章 计算机视觉的图像处理</a></li>
<li><a href="/2024/04/29/16-24-21/" title="计算机视觉概论 相机和图像">计算机视觉概论笔记-第三章 相机和图像</a></li>
<li><a href="/2024/05/02/13-20-59/" title="计算机视觉概论 图像特征">计算机视觉概论笔记-第四章 图像特征</a></li>
<li><a href="/2024/05/03/12-11-15/" title="计算机视觉概论 光反射成像，亮度，阴影">计算机视觉概论笔记-第五章 图像</a></li>
<li></li>
</ul>
<h2 id="课程简介"><a href="#课程简介" class="headerlink" title="课程简介"></a>课程简介</h2><ol>
<li>介绍</li>
<li>计算机视觉的图像处理</li>
<li>相机和相机模型的几何结构以及多视角</li>
<li>图像特征与匹配</li>
<li>图像如何形成，光与纹理，传感器如何形成图像</li>
<li>图像运动序列</li>
<li>图像运动跟踪</li>
<li>分类和识别</li>
<li>计算机视觉简单的模式识别 </li>
<li>人类视觉系统-生物方向</li>
</ol>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://docs.google.com/spreadsheets/d/1ecUGIyhYOfQPi3HPXb-7NndrLgpX_zgkwsqzfqHPaus/pubhtml">课程PPT，作业</a><br><a href="https://learn.udacity.com/courses/ud810">课程视频</a></p>
]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>计算机视觉, 图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机视觉概论 什么是计算机视觉</title>
    <url>/2024/04/27/08-38-57/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.04.27：初稿</li>
</ul>
<h2 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h2><ul>
<li><a href="/2024/04/27/08-42-03/" title="Ud810 Intro-to-cv 笔记汇总">计算机视觉概率-笔记汇总</a>
</li>
</ul>
<h2 id="计算机视觉不是图像处理"><a href="#计算机视觉不是图像处理" class="headerlink" title="计算机视觉不是图像处理"></a>计算机视觉不是图像处理</h2><h3 id="大脑进行构造图像"><a href="#大脑进行构造图像" class="headerlink" title="大脑进行构造图像"></a>大脑进行构造图像</h3><p><strong>球的运动</strong></p>
<img src="/2024/04/27/08-38-57/QQ20240427-084559@2x.png" class>
<p>小球做了相同的运动，只有阴影移动不同，我们认为小球飞起来了</p>
<img src="/2024/04/27/08-38-57/QQ20240427-084850@2x.png" class>
<p>大脑在描述看到的视觉</p>
<h3 id="计算机视觉是什么"><a href="#计算机视觉是什么" class="headerlink" title="计算机视觉是什么"></a>计算机视觉是什么</h3><img src="/2024/04/27/08-38-57/QQ20240427-085557@2x.png" class>
<p>计算机视觉: 计算模型，算法，真实图像的三种思考方式三角形</p>
<h3 id="课程简介"><a href="#课程简介" class="headerlink" title="课程简介"></a>课程简介</h3><ol>
<li>介绍</li>
<li>计算机视觉的图像处理</li>
<li>相机和相机模型的几何结构以及多视角</li>
<li>图像特征与匹配</li>
<li>图像如何形成，光与纹理，传感器如何形成图像</li>
<li>图像运动序列</li>
<li>图像运动跟踪</li>
<li>分类和识别</li>
<li>计算机视觉简单的模式识别 </li>
<li>人类视觉系统-生物方向</li>
</ol>
<h3 id="课程作业"><a href="#课程作业" class="headerlink" title="课程作业"></a>课程作业</h3><p>一共8次作业，PS1是简单的图像处理，PS2-8是课程设计作业。</p>
<p>使用Python-OpenCV，不需要matlab</p>
<ul>
<li>代码必须自己写，要理解相关代码</li>
<li>为什么要写书中存在的代码？<br>“当代码不起作用的时候，才会知道为什么”<br>书中的代码通常不起作用或效果不佳。</li>
</ul>
<h3 id="软件相关"><a href="#软件相关" class="headerlink" title="软件相关"></a>软件相关</h3><p>计算机视觉相关图像处理<br>使用Python和OpenCV，完成课程作业。</p>
]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>计算机视觉, 图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>人体姿态估计算法演变历史</title>
    <url>/2024/04/26/13-54-29/</url>
    <content><![CDATA[<h1 id="人体姿态估计算法演变过程"><a href="#人体姿态估计算法演变过程" class="headerlink" title="人体姿态估计算法演变过程"></a>人体姿态估计算法演变过程</h1><h2 id="传统视觉算法"><a href="#传统视觉算法" class="headerlink" title="传统视觉算法"></a>传统视觉算法</h2><p>基于两种，一种采用电磁标记坐标，另一种采用基于视觉的无标记分析<sup><a href="#fn_1" id="reffn_1">1</a></sup>。<br>研究可以分为两大类：基于模型（或生成）和无模型（或判别）方法。基于模型的方法采用先验的人体。姿态估计过程包括建模和估计。建模是似然函数的构造，考虑了相机模型、图像描述符、人体模型和匹配函数以及（物理）约束。</p>
<h3 id="基于生成模型方法"><a href="#基于生成模型方法" class="headerlink" title="基于生成模型方法"></a>基于生成模型方法</h3><p><strong>建模</strong><br>建模阶段的目标是在给定一组参数的情况下构建给出图像可能性的函数,参数包括，身体配置，体型和外观参数以及相机视角。</p>
<p>基于模型的方法使用人体模型，其中包括运动学结构和身体尺寸。此外，还使用一个函数描述了给定模型参数的人体如何在图像域中出现。图像通常不是使用原始的视觉输入，而是用边缘、颜色区域或轮廓来描述。需要视觉输入和人体模型生成外观之间的匹配函数来评估模型实例化对视觉输入的解释程度。</p>
<p><strong>运动学模型</strong></p>
<ul>
<li>运动学模型有关节组成，关节包含多个自由度(DOF),指示关节可以在多少个方向上移动。</li>
</ul>
<h3 id="基于无模型判别方法"><a href="#基于无模型判别方法" class="headerlink" title="基于无模型判别方法"></a>基于无模型判别方法</h3><h1 id="人体姿态估计算法"><a href="#人体姿态估计算法" class="headerlink" title="人体姿态估计算法"></a>人体姿态估计算法</h1><h2 id="传统计算机视觉方法-1990-2000"><a href="#传统计算机视觉方法-1990-2000" class="headerlink" title="传统计算机视觉方法 1990-2000"></a>传统计算机视觉方法 1990-2000</h2><h3 id="直接线性变换算法DLT-Direct-Linear-Transform"><a href="#直接线性变换算法DLT-Direct-Linear-Transform" class="headerlink" title="直接线性变换算法DLT(Direct Linear Transform)"></a>直接线性变换算法DLT(Direct Linear Transform)</h3><p>&gt;</p>
<blockquote>
<p>d</p>
</blockquote>
<h3 id="透视n点-PnP-算法-Perspective-n-Point"><a href="#透视n点-PnP-算法-Perspective-n-Point" class="headerlink" title="透视n点(PnP) 算法(Perspective-n-Point)"></a>透视n点(PnP) 算法(Perspective-n-Point)</h3><h2 id><a href="#" class="headerlink" title=" "></a> </h2><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1].Pope, R. 《Vision-based human motion analysis: An overview》. Computer Vision and Image Understanding 108, 期 1–2 (2007年): 4–18. <a href="https://doi.org/10.1016/J.CVIU.2006.10.016">https://doi.org/10.1016/J.CVIU.2006.10.016</a>.</p>
]]></content>
      <categories>
        <category>人体姿态估计</category>
      </categories>
      <tags>
        <tag>人体姿态估计, 论文</tag>
      </tags>
  </entry>
  <entry>
    <title>人体姿态估计相关链接</title>
    <url>/2024/04/26/12-29-38/</url>
    <content><![CDATA[<h1 id="人体姿态估计"><a href="#人体姿态估计" class="headerlink" title="人体姿态估计"></a>人体姿态估计</h1><h2 id="github仓库"><a href="#github仓库" class="headerlink" title="github仓库"></a>github仓库</h2><h2 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h2><ul>
<li><a href="https://2d3d.ai">2030AI-Peter</a><ul>
<li><a href="https://2d3d.ai/index.php/2020/06/14/human-pose-estimation-hrnet/">HPE沙漏模型 HRNet + HigherHRNet</a></li>
</ul>
</li>
</ul>
<h2 id="知乎"><a href="#知乎" class="headerlink" title="知乎"></a>知乎</h2><h2 id="网页"><a href="#网页" class="headerlink" title="网页"></a>网页</h2><ul>
<li><a href="https://blog.roboflow.com/pose-estimation-algorithms-history/">姿态估计算法：历史与演变</a><blockquote>
<p>从传统算法到深度学习算法</p>
</blockquote>
</li>
</ul>
<h2 id="youtube"><a href="#youtube" class="headerlink" title="youtube"></a>youtube</h2><ul>
<li><a href="https://www.youtube.com/playlist?list=PLoEMreTa9CNmPGaVQYDWydc2ZmEt6zdrV">Pose Estimation | Applied Deep Learning</a><blockquote>
<p>解读深度学习算法的相关论文</p>
</blockquote>
</li>
</ul>
<h2 id="课题组"><a href="#课题组" class="headerlink" title="课题组"></a>课题组</h2><h3 id="北京大学王亦洲"><a href="#北京大学王亦洲" class="headerlink" title="北京大学王亦洲"></a>北京大学王亦洲</h3><blockquote>
<p>三维人体姿态估计</p>
</blockquote>
<h3 id="北京大学刘宏"><a href="#北京大学刘宏" class="headerlink" title="北京大学刘宏"></a>北京大学刘宏</h3><ul>
<li>课题组 <a href="https://robotics.pkusz.edu.cn/">网页</a></li>
</ul>
<h4 id="李文豪-博士生"><a href="#李文豪-博士生" class="headerlink" title="李文豪-博士生"></a>李文豪-博士生</h4><ul>
<li>个人简介<a href="https://vegetebird.github.io/">主页</a><blockquote>
<p>3D人体姿态估计</p>
</blockquote>
</li>
</ul>
<h3 id="哈工大张盛平"><a href="#哈工大张盛平" class="headerlink" title="哈工大张盛平"></a>哈工大张盛平</h3><ul>
<li>课题组 <a href="https://homepage.hit.edu.cn/zhangshengping">网页</a><blockquote>
<p>3D人体姿态估计</p>
</blockquote>
</li>
</ul>
<h3 id="厦门大学曾鸣"><a href="#厦门大学曾鸣" class="headerlink" title="厦门大学曾鸣"></a>厦门大学曾鸣</h3><ul>
<li>课题组<a href="https://vcg.xmu.edu.cn/">网页</a></li>
</ul>
<h4 id="郑英林-博士生MSRA"><a href="#郑英林-博士生MSRA" class="headerlink" title="郑英林-博士生MSRA"></a>郑英林-博士生MSRA</h4><ul>
<li>个人简介<a href="https://yinglinzheng.netlify.app/">主页</a><blockquote>
<p>多人人体姿态估计，人脸识别</p>
</blockquote>
</li>
</ul>
<h1 id="相关工具"><a href="#相关工具" class="headerlink" title="相关工具"></a>相关工具</h1><h2 id="论文可视化探索"><a href="#论文可视化探索" class="headerlink" title="论文可视化探索"></a>论文可视化探索</h2><p><a href="https://www.connectedpapers.com/">connectedpapers</a></p>
]]></content>
      <categories>
        <category>人体姿态估计</category>
      </categories>
      <tags>
        <tag>人体姿态估计, HPE, 工具, 论文</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习笔记五 神经网络的学习</title>
    <url>/2024/04/23/12-43-40/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.04.23：初稿</li>
</ul>
<h1 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h1><ul>
<li><a href="/2024/04/18/15-40-33/" title="机器笔记汇总">吴恩达机器学习 - 笔记汇总</a>
</li>
</ul>
<h1 id="9-神经网络-学习（Neural-Networks-Learning）"><a href="#9-神经网络-学习（Neural-Networks-Learning）" class="headerlink" title="9 神经网络: 学习（Neural Networks: Learning）"></a>9 神经网络: 学习（Neural Networks: Learning）</h1><h2 id="9-1-代价函数（Cost-Function）"><a href="#9-1-代价函数（Cost-Function）" class="headerlink" title="9.1 代价函数（Cost Function）"></a>9.1 代价函数（Cost Function）</h2><p>神经网络的分类问题有两种：</p>
<ul>
<li><p>二元分类问题（0/1分类）</p>
<p>只有一个输出单元（$K=1$）</p>
</li>
<li><p>多元（$K$）分类问题</p>
<p>输出单元不止一个（$K\gt1$）</p>
</li>
</ul>
<p>神经网络的代价函数公式：</p>
<p>$h_\Theta(x) = a^{(L)} = g(\Theta^{(L-1)}a^{(L-1)}) = g(z^{(L)})$</p>
<p>$$ \begin{split} J(\Theta) = - \frac{1}{m} \sum_{i=1}^m \sum_{k=1}^K \left[y^{(i)}_k \log ((h_\Theta (x^{(i)}))_k) + (1 - y^{(i)}_k)\log (1 - (h_\Theta(x^{(i)}))_k)\right] + \frac{\lambda}{2m}\sum_{l=1}^{L-1} \sum_{i=1}^{s_l} \sum_{j=1}^{s_{l+1} } ( \Theta_{j,i}^{(l)})^2\end{split}$$</p>
<blockquote>
<p>$L$: 神经网络的总层数</p>
<p>$s_l$: 第 $l$ 层激活单元的数量（不包含偏置单元）</p>
<p>$h_\Theta(x)_k$: 分为第 $k$ 个分类($k^{th}$)的概率 $P(y=k | x ; \Theta) $</p>
<p>$K$: 输出层的输出单元数量，即类数 - 1</p>
<p>$y_k^{(i)}$: 第 $i$ 个训练样本的第 $k$ 个分量值</p>
<p>$y$: $K$ 维向量</p>
</blockquote>
<p>对照下逻辑回归中的代价函数：</p>
<p>$$<br>J(\theta) = - \frac{1}{m} \sum_{i=1}^m [ y^{(i)}\ \log (h_\theta (x^{(i)})) + (1 - y^{(i)})\ \log (1 - h_\theta(x^{(i)}))] + \frac{\lambda}{2m}\sum_{j=1}^n \theta_j^2<br>$$</p>
<p>在神经网络的代价函数中，</p>
<ul>
<li>左边的变化实际上是为了求解 $K$ 分类问题，即公式会对每个样本特征都运行 $K$ 次，并依次给出分为第 $k$ 类的概率，$h_\Theta(x)\in \mathbb{R}^{K}, y \in \mathbb{R}^{K}$。</li>
<li>右边的正则化项比较容易理解，每一层有多维矩阵 $\Theta^{(l)}\in \mathbb{R}^{(s_l + 1)\times s_{l+1} }$，从左到右看这个三次求和式 $\sum\limits_{l=1}^{L-1}\sum\limits_{i=1}^{s_l}\sum\limits_{j=1}^{s_{l+1} }$ ，就是对每一层间的多维矩权重 $\Theta^{(l)}$ ，依次平方后求取其除了偏置权重部分的和值，并循环累加即得结果。</li>
</ul>
<blockquote>
<p>$\mathbb{R}^{m}$: 即 $m$ 维向量</p>
<p>$\mathbb{R}^{m\times n}$: 即 $m \times n$ 维矩阵</p>
</blockquote>
<p>再次可见，神经网络背后的思想是和逻辑回归一样的，但由于计算复杂，实际上神经网络的代价函数 $J(\Theta)$ 是一个非凸（non-convex）函数。</p>
<h2 id="9-2-反向传播算法（Backpropagation-Algorithm）"><a href="#9-2-反向传播算法（Backpropagation-Algorithm）" class="headerlink" title="9.2 反向传播算法（Backpropagation Algorithm）"></a>9.2 反向传播算法（Backpropagation Algorithm）</h2><p>类似于回归模型中的梯度下降算法，为了求解神经网络最优化问题，我们也要计算 $\frac{\partial}{\partial\Theta}J(\Theta)$，以此 $\underset{\Theta}{\text{minimize} }J(\Theta)$ 。</p>
<p>在神经网络中，代价函数看上去虽然不复杂，但要注意到其中 $h_\Theta(x)$ 的求取实际上是由前向传播算法求得，即需从输入层开始，根据每层间的权重矩阵 $\Theta$ 依次计算激活单元的值 $a$。 在最优化代价函数时，我们必然也需要最优化每一层的权重矩阵，再次强调一下，<strong>算法最优化的是权重，而不是输入</strong>。</p>

<p><strong>反向传播算法</strong>用于计算每一层权重矩阵的偏导 $\frac{\partial}{\partial\Theta}J(\Theta)$，算法实际上是对代价函数求导的拆解。</p>
<ol>
<li><p>对于给定训练集 $\lbrace (x^{(1)}, y^{(1)}) \cdots (x^{(m)}, y^{(m)})\rbrace$ ，初始化每层间的误差和矩阵 $\Delta$，即令所有的 $\Delta^{(l)}_{i,j}=0$，使得每个 $\Delta^{(l)}$ 为一个全零矩阵。</p>
</li>
<li><p>接下来遍历所有样本实例，对于每一个样本实例，有下列步骤：</p>
<ol>
<li><p>运行前向传播算法，得到初始预测 $a^{(L)}=h_\Theta(x)$ 。</p>
</li>
<li><p>运行反向传播算法，从输出层开始计算每一层预测的<strong>误差（error）</strong>，以此来求取偏导。</p>

<p>输出层的误差即为预测与训练集结果的之间的差值：$\delta^{(L)} = a^{(L)} - y$，</p>
<p>对于隐藏层中每一层的误差，都通过上一层的误差来计算：</p>
<p>$\delta^{(l)} = (\Theta^{(l)})^T\delta^{(l+1)} .*\ \frac{\partial a^{(l)} }{\partial z^{(l)} }\; \; \; \; \;  \text{for }l := L-1, L-2,\dots,2.$</p>
<p>隐藏层中，$a^{(l)}$ 即为增加偏置单元后的 $g(z^{(l)})$，$a^{(l)}$ 与 $\Theta^{(l)}$ 维度匹配，得以完成矩阵运算。</p>
<p>即对于隐藏层，有 $a^{(l)} = (g(z^{(l)})$ 添加偏置单元 $a^{(l)}_0 = 1)$</p>
<p>解得 $\frac{\partial}{\partial z^{(l)} }g(z^{(l)})=g’(z^{(l)})=g(z^{(l)}) .* \ (1-g(z^{(l)}))$，</p>
<p>则有 $\delta^{(l)} = (\Theta^{(l)})^T\delta^{(l+1)} .<em>\ a^{(l)} .</em>\ (1-a^{(l)}), \ \ a^{(l)}_0 = 1$。</p>
<blockquote>
<p>$\delta^{(l)}$ 求导前的公式不同于视频内容，经核实为视频内容错误。推导请阅下节。</p>
</blockquote>
<p>根据以上公式计算依次每一层的误差 $\delta^{(L)}, \delta^{(L-1)},\dots,\delta^{(2)}$。</p>
</li>
<li><p>依次求解并累加误差 $\Delta^{(l)}_{i,j} := \Delta^{(l)}_{i,j} + a_j^{(l)} \delta_i^{(l+1)}$，向量化实现即 $\Delta^{(l)} := \Delta^{(l)} + \delta^{(l+1)}(a^{(l)})^T$</p>
</li>
</ol>
</li>
<li><p>遍历全部样本实例，求解完 $\Delta$ 后，最后则求得偏导 $\frac \partial {\partial \Theta_{i,j}^{(l)} } J(\Theta)=D_{i,j}^{(l)}$</p>
<ul>
<li>$D^{(l)}_{i,j} := \dfrac{1}{m}\left(\Delta^{(l)}_{i,j} + \lambda\Theta^{(l)}_{i,j}\right)$, if $j\neq0$,</li>
<li>$D^{(l)}_{i,j} := \dfrac{1}{m}\Delta^{(l)}_{i,j}$, if $j=0$.（对应于偏置单元）</li>
</ul>
</li>
</ol>
<blockquote>
<p>$\delta^{(l)}$: 第 $l$ 层的误差向量</p>
<p>$\delta^{(l)}_i$: 第 $l$ 层的第 $i$ 个激活单元的误差</p>
<p>$\Delta^{(l)}_{i,j}$: 从第 $l$ 层的第 $j$ 个单元映射到第 $l+1$ 层的第 $i$ 个单元的权重代价的偏导（所有样本实例之和）</p>
<p>$D^{(l)}_{i,j}$: $\Delta^{(l)}_{i,j}$ 的样本均值与正则化项之和</p>
<p>注：无需计算 $\delta^{(1)}$，因为输入没有误差。</p>
</blockquote>
<p>这就是反向传播算法，即从输出层开始不断<strong>向前迭代</strong>，根据<strong>上一层</strong>的误差依次计算当前层的误差，以求得代价函数的偏导。</p>
<blockquote>
<p>应用反向传播（BP）算法的神经网络被称为 BP 网络，也称前馈网络（向前反馈）。</p>
</blockquote>
<p>《机器学习》一书中提到的 BP 网络强大之处：</p>
<blockquote>
<p>任何布尔函数都可由两层神经网络准确表达，但所需的中间单元的数量随输入呈指数级增长;</p>
<p>任何连续函数都可由两层神经网络以任意精度逼近;</p>
<p>任何函数都可由三层神经网络以任意程度逼近。</p>
</blockquote>
<h2 id="9-3-直观理解反向传播（Backpropagation-Intuition）"><a href="#9-3-直观理解反向传播（Backpropagation-Intuition）" class="headerlink" title="9.3 直观理解反向传播（Backpropagation Intuition）"></a>9.3 直观理解反向传播（Backpropagation Intuition）</h2><p>这节给出了反向传播算法中误差的数学意义：</p>
<p>$cost(t) =y^{(t)} \ \log (h_\Theta (x^{(t)})) + (1 - y^{(t)})\ \log (1 - h_\Theta(x^{(t)}))$</p>
<p>$\delta_j^{(l)} = \dfrac{\partial}{\partial z_j^{(l)} } cost(t)$</p>
<p>视频内容实际在上文都涉及到了，上节也做了解释：</p>
<blockquote>
<p>反向传播算法，即从输出层开始不断<strong>向前迭代</strong>，根据<strong>上一层</strong>的误差依次计算当前层的误差，以求得代价函数的偏导。</p>
</blockquote>
<p>前文提到输入层没有偏差，所以没有 $\delta^{(1)}$，同样的，偏置单元的值始终为 1，也没有误差，故一般会选择<strong>忽略偏置单元项的误差</strong>。</p>
<p><strong>神经网络中代价函数求导的推导过程</strong>：</p>
<p>代价函数无正则化项时：</p>
<p>$\begin{split} J(\Theta) = - \frac{1}{m} \sum_{i=1}^m \left[y^{(i)} \log ((h_\Theta (x^{(i)}))) + (1 - y^{(i)})\log (1 - (h_\Theta(x^{(i)})))\right] \end{split}$</p>
<p>再次的，为了方便起见，这里假设样本只有一个，则有：</p>
<p>$\begin{split} J(\Theta) = -\left[y \log ((h_\Theta (x))) + (1 - y)\log (1 - (h_\Theta(x)))\right] \end{split}$</p>
<p>忆及 $h_\Theta(x) = a^{(L)} = g(z^{(L)})$，$g(z) = \frac{1}{1+e^{(-z)} }$，代入后整理后可得：</p>
<p>$J(\Theta) ={y}\log \left( 1+{ {e}^{-z^{(L)} }} \right)+\left( 1-{y} \right)\log \left( 1+{ {e}^{z^{(L)} }} \right)$</p>

<p>再次为了便于计算，我们用到如上图这个三层（输入层一般不计数）神经网络。</p>
<p>忆及 $z^{(l)} = \Theta^{(l-1)}a^{(l-1)}$，我们有 $h_\Theta(x)=a^{(4)}= g(z^{(4)})=g(\Theta^{(3)}a^{(3)})$</p>
<p>观察考虑各变量与 $\Theta^{(3)}$ 之间的关系，有 $J(\Theta) \rightarrow  a^{(4)}\rightarrow z^{(4)}\rightarrow \Theta^{(3)}$</p>
<p>要计算 $J(\Theta)$ 的偏导，就要按照关系不断往前看，每一次回头看，就称为一次反向传播。</p>
<p>把回头看的关系说的“微积分一点”，那就是 $\Theta^{(3)}$ 的微小改变会引起 $z^{(4)}$ 的改变， $z^{(4)}$ 的微小改变会引起 $a^{(4)}$ 的改变，$a^{(4)}$ 的微小改变又会引起 $ J(\Theta)$ 的改变，关系方向也可以反过来写：$\Theta^{(3)} \rightarrow z^{(4)} \rightarrow a^{(4)} \rightarrow J(\Theta) $。</p>
<p>令 $\delta^{(l)} = \frac{\partial}{\partial z^{(l)} } J(\Theta)$，则有 $J(\Theta)$ 关于 $\Theta^{(3)}$ 的偏导：</p>
<p>$\frac{\partial}{\partial\Theta^{(3)} } J(\Theta) = \frac{\partial J(\Theta)}{\partial z^{(4)} }   \frac{\partial z^{(4)} }{\partial\Theta^{(3)} } = \delta^{(4)}\frac{\partial z^{(4)} }{\partial\Theta^{(3)} }$</p>
<p>再次忆及 $z^{(l)} = \Theta^{(l-1)}a^{(l-1)}$，则 $\frac{\partial z^{(4)} }{\partial\Theta^{(3)} } = a^{(3)}$</p>
<p>则对于输出层，我们证得 $\frac{\partial}{\partial\Theta^{(3)} } J(\Theta) =  a^{(3)}\delta^{(4)}$。</p>
<p>再次忆及 $g(z) = \frac{1}{1+e^{-z} }$，$a^{(L)}=g(z^{(L)})$</p>
<p>$\delta^{(4)}=\frac{\partial}{\partial z^{(4)} }J(\Theta)={ {y} }\frac{-e^{-z^{(4)} }}{1+e^{-z^{(4)} }}+\left( 1-{ {y} } \right)\frac{ {e^{z^{(4)} }} }{1+e^{z^{(4)} }} = g(z^{(4)}) - y = a^{(4)}-y$</p>
<p>即证得 $\delta^{(4)} = a^{(4)}-y$</p>
<p>对于任意的输出层 $L$ 及 $\Theta^{(L-1)}$，有 $J(\Theta) \rightarrow  a^{(L)}\rightarrow z^{(L)}\rightarrow \Theta^{(L-1)}$ 关系不变，故证得：<br>$$<br>\frac{\partial}{\partial\Theta^{(L-1)} } J(\Theta) =  a^{(L-1)}\delta^{(L)}, \ \ \delta^{(L)} = a^{(L)}-y<br>$$<br>好了，接下来来看一下 $J(\Theta)$ 关于 $\Theta^{(2)}$ 的偏导</p>
<p>仍然观察考虑各变量与 $\Theta^{(2)}$ 之间的关系，有 $J(\Theta)\rightarrow a^{(4)} \rightarrow z^{(4)} \rightarrow    a^{(3)} \rightarrow z^{(3)} \rightarrow\Theta^{(2)}$ </p>
<p>$\frac{\partial}{\partial \Theta^{(2)} }J(\Theta) = \frac{\partial J(\Theta)}{\partial z^{(3)} } \frac{\partial z^{(3)} }{\partial \Theta^{(2)} }=\delta^{(3)} \frac{\partial z^{(3)} }{\partial \Theta^{(2)} }=  a^{(2)}\delta^{(3)}$</p>
<p>$\delta^{(3)} = \frac{\partial}{\partial z^{(3)} }J(\Theta) =\frac{\partial J(\Theta)}{\partial z^{(4)} } \frac{\partial z^{(4)} }{\partial a^{(3)} }\frac{\partial a^{(3)} }{\partial z^{(3)} } = \delta^{(4)}\frac{\partial z^{(4)} }{\partial a^{(3)} }\frac{\partial a^{(3)} }{\partial z^{(3)} }$</p>
<p>易求得 $\frac{\partial z^{(4)} }{\partial a^{(3)} }=\Theta^{(3)}$</p>
<p>$g’(z) =\frac{e^{-z} }{(1+e^{-z})^2}=\frac{(1+e^{-z})-1}{(1+e^{-z})^2}=\frac{1}{1+e^{-z} }-\frac{1}{(1+e^{-z})^2}=g(z)(1-g(z))$</p>
<p>即 $g’(z^{(l)})=g(z^{(l)}) .* \ (1-g(z^{(l)}))$</p>
<p>有 $a^{(l)} = (g(z^{(l)})$ 添加偏置单元 $a^{(l)}_0 = 1)$，则 $\frac{\partial a^{(3)} }{\partial z^{(3)} }=a^{(3)} .*\ (1-a^{(3)})$，</p>
<blockquote>
<p>证明时为先求导后添加偏置单元，与前向传播算法顺序一致，实际实现时，求导和添加偏置单元的顺序可作调换，由于一般选择忽略偏置单元的误差，所以并不影响结果。</p>
</blockquote>
<p>即证得 $\delta^{(3)}=(\Theta^{(3)})^T\delta^{(4)}.*(a^{(3)})’=(\Theta^{(3)})^T\delta^{(4)}.*\ a^{(3)} .*\ (1-a^{(3)})$</p>
<p>对于任意的隐藏层 $l + 1$ 及权重矩阵 $\Theta^{(l)}$，有 $J(\Theta)\rightarrow a^{(L)} \rightarrow z^{(L)} \rightarrow \dots \rightarrow a^{(l+1)} \rightarrow z^{(l+1)} \rightarrow\Theta^{(l)}$ 关系不变，故证得：</p>
<p>$$<br>\frac{\partial}{\partial\Theta^{(l)} } J(\Theta) =  a^{(l)}\delta^{(l+1)}, \ \ \delta^{(l)} = (\Theta^{(l)})^T\delta^{(l+1)}.*\ a^{(l)} .*\ (1-a^{(l)})\; \; \; \; \;  \text{for }l := L-1, L-2,\dots,2.<br>$$</p>
<p>再添回为了计算方便去掉的 $\frac{1}{m}$ 和正则化项（时刻记住偏置单元不正则化）等，即可得上节中 $J(\Theta)$ 的偏导。</p>
<h2 id="9-4-实现注意点-参数展开（Implementation-Note-Unrolling-Parameters）"><a href="#9-4-实现注意点-参数展开（Implementation-Note-Unrolling-Parameters）" class="headerlink" title="9.4 实现注意点: 参数展开（Implementation Note: Unrolling Parameters）"></a>9.4 实现注意点: 参数展开（Implementation Note: Unrolling Parameters）</h2><p>在 Octave/Matlab 中，如果要使用类似于 <code>fminunc</code> 等高级最优化函数，其函数参数、函数返回值等都为且只为向量，而由于神经网络中的权重是多维矩阵，所以需要用到参数展开这个技巧。</p>
<p>说白了，这个技巧就是把多个矩阵转换为一个长长的向量，便于传入函数，之后再根据矩阵维度，转回矩阵即可。</p>
<p>Octave 代码：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 多个矩阵展开为一个向量</span></span><br><span class="line">Theta1 = <span class="built_in">ones</span>(<span class="number">11</span>, <span class="number">10</span>);    <span class="comment">% 创建维度为 11 * 10 的矩阵</span></span><br><span class="line">Theta2 = <span class="built_in">ones</span>(<span class="number">2</span>, <span class="number">4</span>) * <span class="number">2</span>;  <span class="comment">% 创建维度为 2 * 4 的矩阵</span></span><br><span class="line">ThetaVec = [Theta1(:); Theta2(:)]; <span class="comment">% 将上面两个矩阵展开为向量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 从一个向量重构还原回多个矩阵</span></span><br><span class="line">Theta1 = <span class="built_in">reshape</span>(ThetaVec(<span class="number">1</span>:<span class="number">110</span>), <span class="number">11</span>, <span class="number">10</span>)</span><br><span class="line">Theta2 = <span class="built_in">reshape</span>(ThetaVec(<span class="number">111</span>:<span class="number">118</span>), <span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment">% Theta2 = reshape(ThetaVec(111:(111 + 2 * 4) - 1), 2, 4)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>reshape(A,m,n)</code>: 将向量 A 重构为 m * n 维矩阵。</p>
</blockquote>
<h2 id="9-5-梯度检验（Gradient-Checking）"><a href="#9-5-梯度检验（Gradient-Checking）" class="headerlink" title="9.5 梯度检验（Gradient Checking）"></a>9.5 梯度检验（Gradient Checking）</h2><p>由于神经网络模型中的反向传播算法较为复杂，在小细节非常容易出错，从而无法得到最优解，故引入梯度检验。</p>
<p>梯度检验采用数值估算（Numerical estimation）梯度的方法，被用于验证反向传播算法的正确性。</p>

<p>把视 $\Theta$ 为一个实数，数值估算梯度的原理如上图所示，即有 $\dfrac{\partial}{\partial\Theta}J(\Theta) \approx \dfrac{J(\Theta + \epsilon) - J(\Theta - \epsilon)}{2\epsilon}$</p>
<p>其中，$\epsilon$ 为极小值，由于太小时容易出现数值运算问题，一般取 $10^{-4}$。</p>
<p>对于矩阵 $\Theta$，有 $\dfrac{\partial}{\partial\Theta_j}J(\Theta) \approx \dfrac{J(\Theta_1, \dots, \Theta_j + \epsilon, \dots, \Theta_n) - J(\Theta_1, \dots, \Theta_j - \epsilon, \dots, \Theta_n)}{2\epsilon}$</p>
<p>Octave 代码：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">epsilon = <span class="number">1e-4</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:n,</span><br><span class="line">  thetaPlus = theta;</span><br><span class="line">  thetaPlus(<span class="built_in">i</span>) += epsilon;</span><br><span class="line">  thetaMinus = theta;</span><br><span class="line">  thetaMinus(<span class="built_in">i</span>) -= epsilon;</span><br><span class="line">  gradApprox(<span class="built_in">i</span>) = (J(thetaPlus) - J(thetaMinus))/(<span class="number">2</span>*epsilon);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>在得出 gradApprox 梯度向量后，将其同之前计算的偏导 $D$ 比较，如果相等或很接近，即说明算法没有问题。</p>
<p>在确认算法<strong>没有问题后</strong>（一般只需运行一次），由于数值估计的梯度检验效率很低，所以一定要<strong>禁用它</strong>。</p>
<h2 id="9-6-随机初始化（Random-Initialization）"><a href="#9-6-随机初始化（Random-Initialization）" class="headerlink" title="9.6 随机初始化（Random Initialization）"></a>9.6 随机初始化（Random Initialization）</h2><p>逻辑回归中，初始参数向量全为 0 没什么问题，在神经网络中，情况就不一样了。</p>
<p>初始权重如果全为 0，忆及 $z^{(l)} = \Theta^{(l-1)}a^{(l-1)}$，则隐藏层除了偏置单元，都为 0，而每个单元求导的值也都一样，这就相当于是在不断<strong>重复计算同一结果</strong>，也就是算着算着，一堆特征在每一层都变成只有一个特征（虽然有很多单元，但值都相等），这样，神经网络的性能和效果都会大打折扣，故需要随机初始化初始权重。</p>
<p>随机初始化权重矩阵也为实现细节之一，用于打破对称性（Symmetry Breaking），使得 $\Theta^{(l)}_{ij} \in [-\epsilon,\epsilon]$ 。</p>
<p>Octave 代码：</p>
<p>当然，初始权重的波动也不能太大，一般限定在极小值 $\epsilon$ 范围内，即 $\Theta^{(l)}_{i,j} \in [-\epsilon, \epsilon]$。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">If the dimensions of Theta1 is <span class="number">10</span>x11, Theta2 is <span class="number">10</span>x11 and Theta3 is <span class="number">1</span>x11.</span><br><span class="line"></span><br><span class="line">Theta1 = <span class="built_in">rand</span>(<span class="number">10</span>,<span class="number">11</span>) * (<span class="number">2</span> * INIT_EPSILON) - INIT_EPSILON;</span><br><span class="line">Theta2 = <span class="built_in">rand</span>(<span class="number">10</span>,<span class="number">11</span>) * (<span class="number">2</span> * INIT_EPSILON) - INIT_EPSILON;</span><br><span class="line">Theta3 = <span class="built_in">rand</span>(<span class="number">1</span>,<span class="number">11</span>) * (<span class="number">2</span> * INIT_EPSILON) - INIT_EPSILON;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>rand(m,n)</code>: 返回一个在区间 $(0,1)$ 内均匀分布的随机矩阵。</p>
<p>$\epsilon$: 和梯度下降中的 $\epsilon$ 没有联系，这里只是一个任意实数，给定了权重矩阵初始化值的范围。</p>
</blockquote>
<h2 id="9-7-综合起来（Putting-It-Together）"><a href="#9-7-综合起来（Putting-It-Together）" class="headerlink" title="9.7 综合起来（Putting It Together）"></a>9.7 综合起来（Putting It Together）</h2><p>一般来说，应用神经网络有如下步骤：</p>
<ol>
<li><p>神经网络的建模（后续补充）</p>
<ul>
<li>选取特征，确定特征向量 $x$ 的维度，即输入单元的数量。</li>
<li>鉴别分类，确定预测向量 $h_\Theta(x)$ 的维度，即输出单元的数量。</li>
<li>确定隐藏层有几层以及每层隐藏层有多少个隐藏单元。</li>
</ul>
<blockquote>
<p>默认情况下，隐藏层至少要有一层，也可以有多层，层数越多一般意味着效果越好，计算量越大。</p>
</blockquote>
</li>
<li><p>训练神经网络</p>
<ol>
<li><p>随机初始化初始权重矩阵</p>
</li>
<li><p>应用前向传播算法计算初始预测</p>
</li>
<li><p>计算代价函数 $J(\Theta)$ 的值</p>
</li>
<li><p>应用后向传播宣发计算 $J(\Theta)$ 的偏导数</p>
</li>
<li><p>使用梯度检验检查算法的正确性，别忘了用完就禁用它</p>
</li>
<li><p>丢给最优化函数最小化代价函数</p>
<blockquote>
<p>由于神经网络的代价函数非凸，最优化时不一定会收敛在全局最小值处，高级最优化函数能确保收敛在某个<strong>局部</strong>最小值处。</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<h2 id="9-8-自主驾驶（Autonomous-Driving）"><a href="#9-8-自主驾驶（Autonomous-Driving）" class="headerlink" title="9.8 自主驾驶（Autonomous Driving）"></a>9.8 自主驾驶（Autonomous Driving）</h2>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习, 深度学习, 吴恩达</tag>
      </tags>
  </entry>
  <entry>
    <title>72-优化算法</title>
    <url>/2024/04/23/11-06-12/</url>
    <content><![CDATA[<h2 id="72-优化算法"><a href="#72-优化算法" class="headerlink" title="72.优化算法"></a>72.优化算法</h2><h3 id="1-优化问题"><a href="#1-优化问题" class="headerlink" title="1.优化问题"></a>1.优化问题</h3><img src="/2024/04/23/11-06-12/72-01.png" class>
<h3 id="2-局部最小-vs-全局最小"><a href="#2-局部最小-vs-全局最小" class="headerlink" title="2.局部最小 vs 全局最小"></a>2.局部最小 vs 全局最小</h3><img src="/2024/04/23/11-06-12/72-02.png" class>
<h3 id="3-凸集和凸函数"><a href="#3-凸集和凸函数" class="headerlink" title="3.凸集和凸函数"></a>3.凸集和凸函数</h3><ul>
<li>凸集：形象化来说，就是这个集合上任意两个点连一条线，这个线在集合里面</li>
<li>凸函数：形象上来说函数上任取两个点连线，函数都在该线下面</li>
<li>凸优化问题：局部最小一定是全局最小。严格凸优化问题有唯一的全局最小。<ul>
<li>凸：线性回归，softmax回归</li>
<li>非凸：其他（MLP,CNN,RNN,attention）</li>
</ul>
</li>
</ul>
<h3 id="4-梯度下降"><a href="#4-梯度下降" class="headerlink" title="4.梯度下降"></a>4.梯度下降</h3><ul>
<li>梯度下降——最简单的迭代求解算法</li>
<li>随机梯度下降<ul>
<li>求导数需要求所有样本导数，样本多的情况下代价太大</li>
<li>理论依据：所用样本，和随机选取一个样本得到的数学期望是一样的。</li>
</ul>
</li>
<li>小批量随机梯度下降（实际应用的）<ul>
<li>计算原因：计算单样本的梯度难以完全利用硬件资源</li>
<li>采集一个随机子集</li>
<li>理论依据：无偏近，但降低了方差</li>
</ul>
</li>
</ul>
<h3 id="5-冲量法"><a href="#5-冲量法" class="headerlink" title="5.冲量法"></a>5.冲量法</h3><ul>
<li>使用平滑过的梯度对权重更新，不容易震荡</li>
<li>momentum</li>
</ul>
<img src="/2024/04/23/11-06-12/72-03.png" class>
<h3 id="6-Adam"><a href="#6-Adam" class="headerlink" title="6.Adam"></a>6.Adam</h3><ul>
<li>非常平滑，对于学习率不敏感</li>
<li>对于t比较小的时候，由于$v_0=0$,所以会导致一开始值比较小，做了一个修正。</li>
</ul>
<img src="/2024/04/23/11-06-12/72-04.png" class>
<ul>
<li>为什么除以$\sqrt{\widehat{s}_t}+\epsilon$？<ul>
<li>在nlp里面常用，起到正则化的作用，控制每个维度的值在合适的大小。</li>
</ul>
</li>
</ul>
<img src="/2024/04/23/11-06-12/72-05.png" class>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>深度学习模型大部分是非凸的</li>
<li>小批量随机梯度下降是最常见的优化算法</li>
<li>冲量是对梯度做平滑</li>
<li>Adam是对梯度做平滑，且对梯度各个维度值做重新调整，对于学习率不敏感</li>
</ul>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>70-BERT微调</title>
    <url>/2024/04/23/11-06-10/</url>
    <content><![CDATA[<h2 id="70-BERT微调"><a href="#70-BERT微调" class="headerlink" title="70 BERT微调"></a>70 BERT微调</h2><h3 id="1-intro"><a href="#1-intro" class="headerlink" title="1.intro"></a>1.intro</h3><p>与图片分类不同，BERT预训练时使用的两个任务没有什么实际应用场景，所以使用BERT时多需要进行微调。</p>
<p>BERT对每一个token都返回一个特定长度的特征向量（课堂演示为128，bert-base是768，bert-large是1024），这些特征向量抽取了上下文信息。不同的任务使用不同的特征。</p>
<h3 id="2-具体应用"><a href="#2-具体应用" class="headerlink" title="2.具体应用"></a>2.具体应用</h3><h4 id="2-1句子分类"><a href="#2-1句子分类" class="headerlink" title="2.1句子分类"></a>2.1句子分类</h4><p>将句首的\<CLS\>token对应的向量输入到全连接层分类。对于一对句子也是同理，句子中间用\<SEP\>分开但仍只用第一个\<CLS\>对应的向量。</CLS\></SEP\></CLS\></p>
<p>关于为什么要使用\<CLS\>是因为预训练中判断句子是否连续任务中使用的是\<CLS\>，因此模型会“知道”\<CLS\>是句子级别分类用的向量，表示的信息应与句子整体有关。当然我们也可以不使用\<CLS\>选定自己想要的token，之后在微调中更新bert的权重即可。</CLS\></CLS\></CLS\></CLS\></p>
<h4 id="2-2命名实体识别"><a href="#2-2命名实体识别" class="headerlink" title="2.2命名实体识别"></a>2.2命名实体识别</h4><p>命名实体识别即识别一个词元是不是命名实体，例如人名、机构、位置。其方法是将每一个非特殊词元的向量放进全连接层分类（二分类多分类均可）。</p>
<h4 id="2-3问题回答"><a href="#2-3问题回答" class="headerlink" title="2.3问题回答"></a>2.3问题回答</h4><p>给定一个问题和描述文字，找出一个判断作为回答，微调方法为对片段中的每个词元预测它是不是回答的开头或结束。</p>
<p>总体而言，无论是句子级别还是词级别的分类任务，都只需要在bert的基础上加全连接层，bert中的权重是可以直接从预训练模型得到的，真正需要自己从头训练的只有全连接层的权重。</p>
<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h3><ul>
<li>即使下游任务各有不同，使用BERT微调时均只需要增加输出层</li>
<li>但根据任务的不同，输入的表示，和使用的BERT特征也会不一样</li>
</ul>
<p>在BERT的基础上微调使得多数任务都变的简单许多且效果相比从零开始训练要好很多，至此自然语言处理也向计算机视觉一样转向微调路线。</p>
<h3 id="4-QA"><a href="#4-QA" class="headerlink" title="4.QA"></a>4.QA</h3><p>Q1: BERT微调的时候固定预训练模型的参数吗？</p>
<blockquote>
<p>一般不固定，所有权重都进行训练。也可以固定住底部一些层来加速训练，但通常来说不固定效果更好。可以自行尝试固定哪几层在训练速度更快的前提下效果更好</p>
</blockquote>
<p>Q2: 为什么没讲YOLO？</p>
<blockquote>
<p>YOLO的较新版本已经跟之前版本很不一样了，且里面的技术细节很杂多。纯Python实现的yolo效果不见得比其他算法好，之所以表现出众是因为加入了大量的技术细节。只给大家实现一个本身大家可能不会太感兴趣。</p>
</blockquote>
<p>Q3: BERT在实际应用中怎样部署？用C++写代码吗？</p>
<blockquote>
<p>一般不需要用C++，可以将模型编译到C++（框架通常有支持）。但搬到C++也不能解决速度问题，BERT本身比resnet之类慢很多。</p>
</blockquote>
<p>Q4: 如果设备性能不高是不是不建议用BERT？</p>
<blockquote>
<p>可以用简化版本的BERT，如蒸馏版的BERT大约只有原模型十分之一大小。</p>
</blockquote>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>69-BERT预训练</title>
    <url>/2024/04/23/11-06-09/</url>
    <content><![CDATA[<h2 id="BERT预训练"><a href="#BERT预训练" class="headerlink" title="BERT预训练"></a>BERT预训练</h2><h3 id="2-BERT"><a href="#2-BERT" class="headerlink" title="2.BERT:"></a>2.BERT:</h3><h4 id="2-1-NLP里的迁移学习"><a href="#2-1-NLP里的迁移学习" class="headerlink" title="2.1 NLP里的迁移学习"></a>2.1 NLP里的迁移学习</h4><ul>
<li><p>使用预训练好的模型来抽取词，句子的特征</p>
<ul>
<li>例如word2vec或语言模型</li>
</ul>
</li>
<li><p>不更新预训练好的模型</p>
</li>
<li>需要构建新的网络来抓取任务需要的信息<ul>
<li>Word2vec忽略了时序信息</li>
<li>语言模型只看了一个方向</li>
</ul>
</li>
</ul>
<h4 id="2-2-BERT的动机"><a href="#2-2-BERT的动机" class="headerlink" title="2.2 BERT的动机"></a>2.2 BERT的动机</h4><ul>
<li>基于微调的NLP模型</li>
<li>预训练的模型抽取了足够多的信息</li>
<li>新的任务只需要增加一个简单地输出层</li>
</ul>
<img src="/2024/04/23/11-06-09/69-1.png" class>
<h4 id="2-3-BERT架构"><a href="#2-3-BERT架构" class="headerlink" title="2.3 BERT架构"></a>2.3 BERT架构</h4><ul>
<li>只有编码器的Transformer</li>
<li><p>两个版本：</p>
<ul>
<li>Base:#blocks=12,hidden size=768,#heads=12,#parameters=110M</li>
<li>Large:#blocks=24,hidden size=1024,#heads=16,#paramerter=340M</li>
</ul>
</li>
<li><p>在大规模数据上训练&gt;3B词</p>
</li>
</ul>
<h4 id="2-4-对输入的修改"><a href="#2-4-对输入的修改" class="headerlink" title="2.4 对输入的修改"></a>2.4 对输入的修改</h4><ul>
<li>每个样本是一个句子对</li>
<li>加入额外的片段嵌入</li>
<li>位置编码可学习</li>
</ul>
<img src="/2024/04/23/11-06-09/69-2.png" class>
<h4 id="2-5-预训练任务"><a href="#2-5-预训练任务" class="headerlink" title="2.5 预训练任务"></a>2.5 预训练任务</h4><h5 id="2-5-1-带掩码的语言模型"><a href="#2-5-1-带掩码的语言模型" class="headerlink" title="2.5.1 带掩码的语言模型"></a>2.5.1 带掩码的语言模型</h5><ul>
<li>Transformer的编码器是双向的，标准语言模型要求单向</li>
<li>带掩码的语言模型每次随机（15%概率）将一些词元换成<mask>
</mask></li>
</ul>
<h5 id="2-5-2-下一个句子预测"><a href="#2-5-2-下一个句子预测" class="headerlink" title="2.5.2 下一个句子预测"></a>2.5.2 下一个句子预测</h5><ul>
<li>预测一个句子对中两个句子是不是相邻</li>
<li><p>训练样本中：</p>
<ul>
<li>50%概率选择相邻句子对：<cls>this movie is great <sep> i like it <sep></sep></sep></cls></li>
<li>50%概率选择随机句子对：<cls>this movie is great<sep> hello world<sep></sep></sep></cls></li>
</ul>
</li>
<li><p>将<cls>对应的输出放到一个全连接层来预测</cls></p>
</li>
</ul>
<h4 id="2-6-总结"><a href="#2-6-总结" class="headerlink" title="2.6 总结"></a>2.6 总结</h4><ul>
<li>BERT针对微调设计</li>
<li>基于Transformer的编码器做了如下修改<ul>
<li>模型更大，训练数据更多</li>
<li>输入句子对，片段嵌入，可学习的位置编码</li>
<li>训练时使用两个任务：<ul>
<li>带掩码的语言模型</li>
<li>下一个句子预测</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3.代码实现"></a>3.代码实现</h3><h4 id="3-1-获取输入："><a href="#3-1-获取输入：" class="headerlink" title="3.1 获取输入："></a>3.1 获取输入：</h4><p>在自然语言处理中，有些任务（如情感分析）以单个文本作为输入，而有些任务（如自然语言推断）以一对文本序列作为输入。BERT输入序列明确地表示单个文本和文本对。当输入为单个文本时，BERT输入序列是特殊类别词元“<cls>”、文本序列的标记、以及特殊分隔词元“<sep>”的连结。当输入为文本对时，BERT输入序列是“<cls>”、第一个文本序列的标记、“<sep>”、第二个文本序列标记、以及“<sep>”的连结。我们将始终如一地将术语“BERT输入序列”与其他类型的“序列”区分开来。例如，一个<em>BERT输入序列</em>可以包括一个<em>文本序列</em>或两个<em>文本序列</em>。</sep></sep></cls></sep></cls></p>
<p>为了区分文本对，根据输入序列学到的片段嵌入eA和eB分别被添加到第一序列和第二序列的词元嵌入中。对于单文本输入，仅使用eA。</p>
<p>下面的<code>get_tokens_and_segments</code>将一个句子或两个句子作为输入，然后返回BERT输入序列的标记及其相应的片段索引。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_tokens_and_segments</span>(<span class="params">tokens_a, tokens_b=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;获取输入序列的词元及其片段索引&quot;&quot;&quot;</span></span><br><span class="line">    tokens = [<span class="string">&#x27;&lt;cls&gt;&#x27;</span>] + tokens_a + [<span class="string">&#x27;&lt;sep&gt;&#x27;</span>]</span><br><span class="line">    <span class="comment"># 0和1分别标记片段A和B</span></span><br><span class="line">    segments = [<span class="number">0</span>] * (<span class="built_in">len</span>(tokens_a) + <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> tokens_b <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        tokens += tokens_b + [<span class="string">&#x27;&lt;sep&gt;&#x27;</span>]</span><br><span class="line">        segments += [<span class="number">1</span>] * (<span class="built_in">len</span>(tokens_b) + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> tokens, segments</span><br></pre></td></tr></table></figure>
<p>BERT选择Transformer编码器作为其双向架构。在Transformer编码器中常见是，位置嵌入被加入到输入序列的每个位置。然而，与原始的Transformer编码器不同，BERT使用<em>可学习的</em>位置嵌入。总之， 下图表明BERT输入序列的嵌入是词元嵌入、片段嵌入和位置嵌入的和。</p>
<img src="/2024/04/23/11-06-09/69-3.png" class>
<h4 id="3-2-BERT实现"><a href="#3-2-BERT实现" class="headerlink" title="3.2 BERT实现"></a>3.2 BERT实现</h4><p>下面的<code>BERTEncoder</code>类类似于 <a href="https://zh-v2.d2l.ai/chapter_attention-mechanisms/transformer.html#sec-transformer">10.7节</a>中实现的<code>TransformerEncoder</code>类。与<code>TransformerEncoder</code>不同，<code>BERTEncoder</code>使用片段嵌入和可学习的位置嵌入。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BERTEncoder</span>(nn.Module):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;BERT编码器&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, vocab_size, num_hiddens, norm_shape, ffn_num_input,</span></span><br><span class="line"><span class="params">                 ffn_num_hiddens, num_heads, num_layers, dropout,</span></span><br><span class="line"><span class="params">                 max_len=<span class="number">1000</span>, key_size=<span class="number">768</span>, query_size=<span class="number">768</span>, value_size=<span class="number">768</span>,</span></span><br><span class="line"><span class="params">                 **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>(BERTEncoder, self).__init__(**kwargs)</span><br><span class="line">        self.token_embedding = nn.Embedding(vocab_size, num_hiddens)</span><br><span class="line">        self.segment_embedding = nn.Embedding(<span class="number">2</span>, num_hiddens)</span><br><span class="line">        self.blks = nn.Sequential()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_layers):</span><br><span class="line">            self.blks.add_module(<span class="string">f&quot;<span class="subst">&#123;i&#125;</span>&quot;</span>, d2l.EncoderBlock(</span><br><span class="line">                key_size, query_size, value_size, num_hiddens, norm_shape,</span><br><span class="line">                ffn_num_input, ffn_num_hiddens, num_heads, dropout, <span class="literal">True</span>))</span><br><span class="line">        <span class="comment"># 在BERT中，位置嵌入是可学习的，因此我们创建一个足够长的位置嵌入参数</span></span><br><span class="line">        self.pos_embedding = nn.Parameter(torch.randn(<span class="number">1</span>, max_len,</span><br><span class="line">                                                      num_hiddens))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, tokens, segments, valid_lens</span>):</span><br><span class="line">        <span class="comment"># 在以下代码段中，X的形状保持不变：（批量大小，最大序列长度，num_hiddens）</span></span><br><span class="line">        X = self.token_embedding(tokens) + self.segment_embedding(segments)</span><br><span class="line">        X = X + self.pos_embedding.data[:, :X.shape[<span class="number">1</span>], :]</span><br><span class="line">        <span class="keyword">for</span> blk <span class="keyword">in</span> self.blks:</span><br><span class="line">            X = blk(X, valid_lens)</span><br><span class="line">        <span class="keyword">return</span> X</span><br></pre></td></tr></table></figure>
<p>假设词表大小为10000，为了演示<code>BERTEncoder</code>的前向推断，让我们创建一个实例并初始化它的参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">vocab_size, num_hiddens, ffn_num_hiddens, num_heads = <span class="number">10000</span>, <span class="number">768</span>, <span class="number">1024</span>, <span class="number">4</span></span><br><span class="line">norm_shape, ffn_num_input, num_layers, dropout = [<span class="number">768</span>], <span class="number">768</span>, <span class="number">2</span>, <span class="number">0.2</span></span><br><span class="line">encoder = BERTEncoder(vocab_size, num_hiddens, norm_shape, ffn_num_input,</span><br><span class="line">                      ffn_num_hiddens, num_heads, num_layers, dropout)</span><br></pre></td></tr></table></figure>
<p>我们将<code>tokens</code>定义为长度为8的2个输入序列，其中每个词元是词表的索引。使用输入<code>tokens</code>的<code>BERTEncoder</code>的前向推断返回编码结果，其中每个词元由向量表示，其长度由超参数<code>num_hiddens</code>定义。此超参数通常称为Transformer编码器的<em>隐藏大小</em>（隐藏单元数）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tokens = torch.randint(<span class="number">0</span>, vocab_size, (<span class="number">2</span>, <span class="number">8</span>))</span><br><span class="line">segments = torch.tensor([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]])</span><br><span class="line">encoded_X = encoder(tokens, segments, <span class="literal">None</span>)</span><br><span class="line">encoded_X.shape</span><br></pre></td></tr></table></figure>
<h4 id="3-3-预训练任务"><a href="#3-3-预训练任务" class="headerlink" title="3.3 预训练任务"></a>3.3 预训练任务</h4><h5 id="3-3-1-遮掩语言模型"><a href="#3-3-1-遮掩语言模型" class="headerlink" title="3.3.1 遮掩语言模型"></a>3.3.1 遮掩语言模型</h5><p>我们实现了下面的<code>MaskLM</code>类来预测BERT预训练的掩蔽语言模型任务中的掩蔽标记。预测使用单隐藏层的多层感知机（<code>self.mlp</code>）。在前向推断中，它需要两个输入：<code>BERTEncoder</code>的编码结果和用于预测的词元位置。输出是这些位置的预测结果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MaskLM</span>(nn.Module):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;BERT的掩蔽语言模型任务&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, vocab_size, num_hiddens, num_inputs=<span class="number">768</span>, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>(MaskLM, self).__init__(**kwargs)</span><br><span class="line">        self.mlp = nn.Sequential(nn.Linear(num_inputs, num_hiddens),</span><br><span class="line">                                 nn.ReLU(),</span><br><span class="line">                                 nn.LayerNorm(num_hiddens),</span><br><span class="line">                                 nn.Linear(num_hiddens, vocab_size))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, X, pred_positions</span>):</span><br><span class="line">        num_pred_positions = pred_positions.shape[<span class="number">1</span>]</span><br><span class="line">        pred_positions = pred_positions.reshape(-<span class="number">1</span>)</span><br><span class="line">        batch_size = X.shape[<span class="number">0</span>]</span><br><span class="line">        batch_idx = torch.arange(<span class="number">0</span>, batch_size)</span><br><span class="line">        <span class="comment"># 假设batch_size=2，num_pred_positions=3</span></span><br><span class="line">        <span class="comment"># 那么batch_idx是np.array（[0,0,0,1,1]）</span></span><br><span class="line">        batch_idx = torch.repeat_interleave(batch_idx, num_pred_positions)</span><br><span class="line">        masked_X = X[batch_idx, pred_positions]</span><br><span class="line">        masked_X = masked_X.reshape((batch_size, num_pred_positions, -<span class="number">1</span>))</span><br><span class="line">        mlm_Y_hat = self.mlp(masked_X)</span><br><span class="line">        <span class="keyword">return</span> mlm_Y_hat</span><br></pre></td></tr></table></figure>
<p>为了演示<code>MaskLM</code>的前向推断，我们创建了其实例<code>mlm</code>并对其进行了初始化。回想一下，来自<code>BERTEncoder</code>的正向推断<code>encoded_X</code>表示2个BERT输入序列。我们将<code>mlm_positions</code>定义为在<code>encoded_X</code>的任一输入序列中预测的3个指示。<code>mlm</code>的前向推断返回<code>encoded_X</code>的所有掩蔽位置<code>mlm_positions</code>处的预测结果<code>mlm_Y_hat</code>。对于每个预测，结果的大小等于词表的大小。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mlm = MaskLM(vocab_size, num_hiddens)</span><br><span class="line">mlm_positions = torch.tensor([[<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>], [<span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>]])</span><br><span class="line">mlm_Y_hat = mlm(encoded_X, mlm_positions)</span><br><span class="line">mlm_Y_hat.shape</span><br></pre></td></tr></table></figure>
<p>通过掩码下的预测词元<code>mlm_Y</code>的真实标签<code>mlm_Y_hat</code>，我们可以计算在BERT预训练中的遮蔽语言模型任务的交叉熵损失。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mlm_Y = torch.tensor([[<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]])</span><br><span class="line">loss = nn.CrossEntropyLoss(reduction=<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">mlm_l = loss(mlm_Y_hat.reshape((-<span class="number">1</span>, vocab_size)), mlm_Y.reshape(-<span class="number">1</span>))</span><br><span class="line">mlm_l.shape</span><br></pre></td></tr></table></figure>
<h5 id="3-3-2-下一句预测"><a href="#3-3-2-下一句预测" class="headerlink" title="3.3.2 下一句预测"></a>3.3.2 下一句预测</h5><p>下面的<code>NextSentencePred</code>类使用单隐藏层的多层感知机来预测第二个句子是否是BERT输入序列中第一个句子的下一个句子。由于Transformer编码器中的自注意力，特殊词元“<cls>”的BERT表示已经对输入的两个句子进行了编码。因此，多层感知机分类器的输出层（<code>self.output</code>）以<code>X</code>作为输入，其中<code>X</code>是多层感知机隐藏层的输出，而MLP隐藏层的输入是编码后的“<cls>”词元。</cls></cls></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NextSentencePred</span>(nn.Module):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;BERT的下一句预测任务&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, num_inputs, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>(NextSentencePred, self).__init__(**kwargs)</span><br><span class="line">        self.output = nn.Linear(num_inputs, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, X</span>):</span><br><span class="line">        <span class="comment"># X的形状：(batchsize,num_hiddens)</span></span><br><span class="line">        <span class="keyword">return</span> self.output(X)</span><br></pre></td></tr></table></figure>
<p>我们可以看到，<code>NextSentencePred</code>实例的前向推断返回每个BERT输入序列的二分类预测。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">encoded_X = torch.flatten(encoded_X, start_dim=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># NSP的输入形状:(batchsize，num_hiddens)</span></span><br><span class="line">nsp = NextSentencePred(encoded_X.shape[-<span class="number">1</span>])</span><br><span class="line">nsp_Y_hat = nsp(encoded_X)</span><br><span class="line">nsp_Y_hat.shape</span><br></pre></td></tr></table></figure>
<h4 id="3-4-整合代码"><a href="#3-4-整合代码" class="headerlink" title="3.4 整合代码"></a>3.4 整合代码</h4><p>在预训练BERT时，最终的损失函数是掩蔽语言模型损失函数和下一句预测损失函数的线性组合。现在我们可以通过实例化三个类<code>BERTEncoder</code>、<code>MaskLM</code>和<code>NextSentencePred</code>来定义<code>BERTModel</code>类。前向推断返回编码后的BERT表示<code>encoded_X</code>、掩蔽语言模型预测<code>mlm_Y_hat</code>和下一句预测<code>nsp_Y_hat</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BERTModel</span>(nn.Module):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;BERT模型&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, vocab_size, num_hiddens, norm_shape, ffn_num_input,</span></span><br><span class="line"><span class="params">                 ffn_num_hiddens, num_heads, num_layers, dropout,</span></span><br><span class="line"><span class="params">                 max_len=<span class="number">1000</span>, key_size=<span class="number">768</span>, query_size=<span class="number">768</span>, value_size=<span class="number">768</span>,</span></span><br><span class="line"><span class="params">                 hid_in_features=<span class="number">768</span>, mlm_in_features=<span class="number">768</span>,</span></span><br><span class="line"><span class="params">                 nsp_in_features=<span class="number">768</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(BERTModel, self).__init__()</span><br><span class="line">        self.encoder = BERTEncoder(vocab_size, num_hiddens, norm_shape,</span><br><span class="line">                    ffn_num_input, ffn_num_hiddens, num_heads, num_layers,</span><br><span class="line">                    dropout, max_len=max_len, key_size=key_size,</span><br><span class="line">                    query_size=query_size, value_size=value_size)</span><br><span class="line">        self.hidden = nn.Sequential(nn.Linear(hid_in_features, num_hiddens),</span><br><span class="line">                                    nn.Tanh())</span><br><span class="line">        self.mlm = MaskLM(vocab_size, num_hiddens, mlm_in_features)</span><br><span class="line">        self.nsp = NextSentencePred(nsp_in_features)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, tokens, segments, valid_lens=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">                pred_positions=<span class="literal">None</span></span>):</span><br><span class="line">        encoded_X = self.encoder(tokens, segments, valid_lens)</span><br><span class="line">        <span class="keyword">if</span> pred_positions <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            mlm_Y_hat = self.mlm(encoded_X, pred_positions)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            mlm_Y_hat = <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 用于下一句预测的多层感知机分类器的隐藏层，0是“&lt;cls&gt;”标记的索引</span></span><br><span class="line">        nsp_Y_hat = self.nsp(self.hidden(encoded_X[:, <span class="number">0</span>, :]))</span><br><span class="line">        <span class="keyword">return</span> encoded_X, mlm_Y_hat, nsp_Y_hat</span><br></pre></td></tr></table></figure>
<h4 id="3-5-小结"><a href="#3-5-小结" class="headerlink" title="3.5 小结"></a>3.5 小结</h4><ul>
<li>word2vec和GloVe等词嵌入模型与上下文无关。它们将相同的预训练向量赋给同一个词，而不考虑词的上下文（如果有的话）。它们很难处理好自然语言中的一词多义或复杂语义。</li>
<li>对于上下文敏感的词表示，如ELMo和GPT，词的表示依赖于它们的上下文。</li>
<li>ELMo对上下文进行双向编码，但使用特定于任务的架构（然而，为每个自然语言处理任务设计一个特定的体系架构实际上并不容易）；而GPT是任务无关的，但是从左到右编码上下文。</li>
<li>BERT结合了这两个方面的优点：它对上下文进行双向编码，并且需要对大量自然语言处理任务进行最小的架构更改。</li>
<li>BERT输入序列的嵌入是词元嵌入、片段嵌入和位置嵌入的和。</li>
<li>预训练包括两个任务：掩蔽语言模型和下一句预测。前者能够编码双向上下文来表示单词，而后者则显式地建模文本对之间的逻辑关系。</li>
</ul>
<h3 id="Q-amp-A："><a href="#Q-amp-A：" class="headerlink" title="Q&amp;A："></a>Q&amp;A：</h3><h5 id="Q1-BERT是不是很少用在CV上？"><a href="#Q1-BERT是不是很少用在CV上？" class="headerlink" title="Q1:BERT是不是很少用在CV上？"></a>Q1:BERT是不是很少用在CV上？</h5><blockquote>
<p>transformer架构这几年在大量的用于CV上</p>
</blockquote>
<h5 id="Q2-展示一下10W-batch-训练结果？"><a href="#Q2-展示一下10W-batch-训练结果？" class="headerlink" title="Q2:展示一下10W batch 训练结果？"></a>Q2:展示一下10W batch 训练结果？</h5><blockquote>
<p>微调时会用到</p>
</blockquote>
<h5 id="Q3：使用BERT-large时显存不足，有什么方法吗？"><a href="#Q3：使用BERT-large时显存不足，有什么方法吗？" class="headerlink" title="Q3：使用BERT large时显存不足，有什么方法吗？"></a>Q3：使用BERT large时显存不足，有什么方法吗？</h5><blockquote>
<p>单机多卡，模型并行，或改用小模型</p>
</blockquote>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>68-transformer架构</title>
    <url>/2024/04/23/11-06-08/</url>
    <content><![CDATA[<h3 id="1-transformer架构"><a href="#1-transformer架构" class="headerlink" title="1.transformer架构"></a>1.transformer架构</h3><ul>
<li>基于encoder-decoder架构来处理序列对</li>
<li>跟使用注意力的seq2seq不同，transformer是纯基于注意力</li>
</ul>
<p>&lt;</p>
<h3 id="2-多头注意力"><a href="#2-多头注意力" class="headerlink" title="2.多头注意力"></a>2.多头注意力</h3><ul>
<li><p>对同一key，value，query，希望抽取不同的信息</p>
<ul>
<li>例如短距离关系和长距离关系</li>
</ul>
</li>
<li><p>多头注意力使用h个独立的注意力池化</p>
<ul>
<li><p>合并各个头（head）输出得到最终输出</p>
</li>
<li><img src="/2024/04/23/11-06-08/68-02.png" class>
</li>
</ul>
</li>
<li><p>数学表达式</p>
<img src="/2024/04/23/11-06-08/68-02.png" class>
</li>
</ul>
<h3 id="3-有掩码的多头注意力"><a href="#3-有掩码的多头注意力" class="headerlink" title="3.有掩码的多头注意力"></a>3.有掩码的多头注意力</h3><ul>
<li>解码器对序列中一个元素输出的时候，不应该考虑该元素之后的元素</li>
<li>可以用掩码来实现<ul>
<li>也就是计算$x_i$输出的时候，假装当前序列长度为i</li>
</ul>
</li>
</ul>
<h3 id="4-基于位置的前馈网络"><a href="#4-基于位置的前馈网络" class="headerlink" title="4.基于位置的前馈网络"></a>4.基于位置的前馈网络</h3><ul>
<li>将输入形状变化（b,n,d）变换成（bn，d）；输出形状由（bn，d）变成（b，n，d）</li>
<li>作用两个全连接层</li>
<li>等价于两层核窗口为1的一维卷积层（全连接）</li>
</ul>
<h3 id="5-层归一化"><a href="#5-层归一化" class="headerlink" title="5.层归一化"></a>5.层归一化</h3><ul>
<li>批量归一化对每个特征/通道里元素进行归一化<ul>
<li>不适合序列长度会变的nlp应用</li>
</ul>
</li>
<li>层归一化对每个样本里面的元素进行归一化（ layer norm ）</li>
</ul>
<h3 id="6-信息传递"><a href="#6-信息传递" class="headerlink" title="6.信息传递"></a>6.信息传递</h3><ul>
<li>将编码器输出作为解码中第i个transformer块中多头注意力的key和value<ul>
<li>query来自目标序列</li>
</ul>
</li>
<li>意味着编码器和解码器中块的个数，输出维度都是一样的</li>
</ul>
<h3 id="7-预测"><a href="#7-预测" class="headerlink" title="7.预测"></a>7.预测</h3><ul>
<li>预测第t+1个输出时</li>
<li>解码器中输入前t个预测值（顺序）<ul>
<li>在自注意力中，前t个预测值作为key和value，第t个预测值还作为query</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>transformer是一个纯使用注意力的encoder-decoder</li>
<li>编码器和解码器都有n个transformer块</li>
<li>每个块里面使用多头注意力，基于位置的前馈网络，层归一化</li>
</ul>
<h3 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h3><ul>
<li>多头注意力，concat和相加取平均怎么选择？<ul>
<li>老师认为concat保留的信息更全面，更好</li>
</ul>
</li>
<li>为什么在获取词向量之后，需要对词向量进行缩放（乘以embedding size的开方之后再加上PE）<ul>
<li>embedding之后，向量长度变长，元素值变小，乘以之后可以保证在-1，1之间，和position大小差不多</li>
</ul>
</li>
<li>num of head是什么？<ul>
<li>类似卷积的多通道，多个attention关注的是不同的特征</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>65-注意力分数</title>
    <url>/2024/04/23/11-06-05/</url>
    <content><![CDATA[<h3 id="65-注意力分数"><a href="#65-注意力分数" class="headerlink" title="65 注意力分数"></a>65 注意力分数</h3><ul>
<li>在上一节中，我们使用高斯核来对查询和键之间的关系建模。我们可以将上一节中的高斯核函数部分视为注意力评分函数，简称评分函数，然后把这个函数的输出结果输入到softmax函数中进行运算。 通过上述步骤，我们将得到与键对应的值的概率分布（即注意力权重）。 最后，注意力汇聚的输出就是基于这些注意力权重的值的加权和。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br></pre></td></tr></table></figure>
<h4 id="掩蔽softmax操作"><a href="#掩蔽softmax操作" class="headerlink" title="掩蔽softmax操作"></a>掩蔽softmax操作</h4><ul>
<li>正如上面提到的，softmax操作用于输出一个概率分布作为注意力权重。 在某些情况下，并非所有的值都应该被纳入到注意力汇聚中。 例如，为了在 <a href="https://zh-v2.d2l.ai/chapter_recurrent-modern/machine-translation-and-dataset.html#sec-machine-translation">9.5节</a>中高效处理小批量数据集， 某些文本序列被填充了没有意义的特殊词元。 为了仅将有意义的词元作为值来获取注意力汇聚， 我们可以指定一个有效序列长度（即词元的个数）， 以便在计算softmax时过滤掉超出指定范围的位置。 通过这种方式，我们可以在下面的<code>masked_softmax</code>函数中 实现这样的<em>掩蔽softmax操作</em>（masked softmax operation）， 其中任何超出有效长度的位置都被掩蔽并置为0。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">masked_softmax</span>(<span class="params">X, valid_lens</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;通过在最后一个轴上掩蔽元素来执行softmax操作&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># X:3D张量，valid_lens:1D或2D张量</span></span><br><span class="line">    <span class="keyword">if</span> valid_lens <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> nn.functional.softmax(X, dim=-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        shape = X.shape</span><br><span class="line">        <span class="keyword">if</span> valid_lens.dim() == <span class="number">1</span>:</span><br><span class="line">            valid_lens = torch.repeat_interleave(valid_lens, shape[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            valid_lens = valid_lens.reshape(-<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 最后一轴上被掩蔽的元素使用一个非常大的负值替换，从而其softmax输出为0</span></span><br><span class="line">        X = d2l.sequence_mask(X.reshape(-<span class="number">1</span>, shape[-<span class="number">1</span>]), valid_lens,</span><br><span class="line">                              value=-<span class="number">1e6</span>)</span><br><span class="line">        <span class="keyword">return</span> nn.functional.softmax(X.reshape(shape), dim=-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h4 id="加性注意力"><a href="#加性注意力" class="headerlink" title="加性注意力"></a>加性注意力</h4><ul>
<li>一般来说，当查询和键是不同长度的矢量时， 我们可以使用加性注意力作为评分函数。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AdditiveAttention</span>(nn.Module):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;加性注意力&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, key_size, query_size, num_hiddens, dropout, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>(AdditiveAttention, self).__init__(**kwargs)</span><br><span class="line">        self.W_k = nn.Linear(key_size, num_hiddens, bias=<span class="literal">False</span>)</span><br><span class="line">        self.W_q = nn.Linear(query_size, num_hiddens, bias=<span class="literal">False</span>)</span><br><span class="line">        self.w_v = nn.Linear(num_hiddens, <span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">        self.dropout = nn.Dropout(dropout)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, queries, keys, values, valid_lens</span>):</span><br><span class="line">        queries, keys = self.W_q(queries), self.W_k(keys)</span><br><span class="line">        <span class="comment"># 在维度扩展后，</span></span><br><span class="line">        <span class="comment"># queries的形状：(batch_size，查询的个数，1，num_hidden)</span></span><br><span class="line">        <span class="comment"># key的形状：(batch_size，1，“键－值”对的个数，num_hiddens)</span></span><br><span class="line">        <span class="comment"># 使用广播方式进行求和</span></span><br><span class="line">        features = queries.unsqueeze(<span class="number">2</span>) + keys.unsqueeze(<span class="number">1</span>)</span><br><span class="line">        features = torch.tanh(features)</span><br><span class="line">        <span class="comment"># self.w_v仅有一个输出，因此从形状中移除最后那个维度。</span></span><br><span class="line">        <span class="comment"># scores的形状：(batch_size，查询的个数，“键-值”对的个数)</span></span><br><span class="line">        scores = self.w_v(features).squeeze(-<span class="number">1</span>)</span><br><span class="line">        self.attention_weights = masked_softmax(scores, valid_lens)</span><br><span class="line">        <span class="comment"># values的形状：(batch_size，“键－值”对的个数，值的维度)</span></span><br><span class="line">        <span class="keyword">return</span> torch.bmm(self.dropout(self.attention_weights), values)</span><br></pre></td></tr></table></figure>
<h4 id="缩放点积注意力"><a href="#缩放点积注意力" class="headerlink" title="缩放点积注意力"></a>缩放点积注意力</h4><ul>
<li>使用点积可以得到计算效率更高的评分函数， 但是点积操作要求查询和键具有相同的长度<em>d</em>。 假设查询和键的所有元素都是独立的随机变量， 并且都满足零均值和单位方差， 那么两个向量的点积的均值为0，方差为<em>d</em>。 为确保无论向量长度如何， 点积的方差在不考虑向量长度的情况下仍然是1， 我们将点积除以√d,在下面的缩放点积注意力的实现中，我们使用了暂退法进行模型正则化。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DotProductAttention</span>(nn.Module):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;缩放点积注意力&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, dropout, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>(DotProductAttention, self).__init__(**kwargs)</span><br><span class="line">        self.dropout = nn.Dropout(dropout)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># queries的形状：(batch_size，查询的个数，d)</span></span><br><span class="line">    <span class="comment"># keys的形状：(batch_size，“键－值”对的个数，d)</span></span><br><span class="line">    <span class="comment"># values的形状：(batch_size，“键－值”对的个数，值的维度)</span></span><br><span class="line">    <span class="comment"># valid_lens的形状:(batch_size，)或者(batch_size，查询的个数)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, queries, keys, values, valid_lens=<span class="literal">None</span></span>):</span><br><span class="line">        d = queries.shape[-<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># 设置transpose_b=True为了交换keys的最后两个维度</span></span><br><span class="line">        scores = torch.bmm(queries, keys.transpose(<span class="number">1</span>,<span class="number">2</span>)) / math.sqrt(d)</span><br><span class="line">        self.attention_weights = masked_softmax(scores, valid_lens)</span><br><span class="line">        <span class="keyword">return</span> torch.bmm(self.dropout(self.attention_weights), values)</span><br></pre></td></tr></table></figure>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>将注意力汇聚的输出计算可以作为值的加权平均，选择不同的注意力评分函数会带来不同的注意力汇聚操作。</li>
<li>当查询和键是不同长度的矢量时，可以使用可加性注意力评分函数。当它们的长度相同时，使用缩放的“点－积”注意力评分函数的计算效率更高。</li>
</ul>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>63-束搜索</title>
    <url>/2024/04/23/11-06-03/</url>
    <content><![CDATA[<h2 id="束搜索"><a href="#束搜索" class="headerlink" title="束搜索"></a>束搜索</h2><p>在序列生成问题中，常用的方法是一个个词元地进行生成，但是先前步生成的词元会影响之后词元的概率分布，为此，我们需要使用搜索算法来得到一个较好的序列</p>
<h3 id="贪心搜索"><a href="#贪心搜索" class="headerlink" title="贪心搜索"></a>贪心搜索</h3><p>贪心搜索即每个时间步都选择具有最高条件概率的词元。</p>
<script type="math/tex; mode=display">
y_{t'} = \operatorname*{argmax}_{y \in \mathcal{Y}} P(y \mid y_1, \ldots, y_{t'-1}, \mathbf{c})</script><p>我们的目标是找到一个最有序列，他的联合概率，也就是每步之间的条件概率的乘积，最大。</p>
<script type="math/tex; mode=display">
\prod_{t'=1}^{T'} P(y_{t'} \mid y_1, \ldots, y_{t'-1}, \mathbf{c})</script><p>然而，贪心搜索很可能搜索到的不是最优解，例如：<img src="/2024/04/23/11-06-03/Greedy_or_not.png" class></p>
<p>左侧的搜索方式为贪心搜索，每次找到当前条件概率最大的选项进行预测，但是这样可能会导致之后的条件概率较小，从而导致最终的联合概率较小，生成的序列不优。</p>
<p>而右侧的选择方式虽然在第二步选择了较小的选项，但之后在第三步时有了条件概率为0.6选项，最终结果反而更好。</p>
<h3 id="穷举搜索"><a href="#穷举搜索" class="headerlink" title="穷举搜索"></a>穷举搜索</h3><p>穷举搜索枚举所有可能的输出序列及其概率，然后选择概率最大的作为最终的输出，枚举搜索可以保证得到最优解，但是计算复杂度很高，难以实现</p>
<h3 id="束搜索（beam-search）"><a href="#束搜索（beam-search）" class="headerlink" title="束搜索（beam search）"></a>束搜索（beam search）</h3><p>束搜索综合了贪心搜索和穷举搜索，在能接受的计算成本下得到比贪心搜索更好的结果。</p>
<p>束搜索有一个超参数，名为<strong>束宽（beam size）</strong>$k$，束搜索的具体流程如下：</p>
<ul>
<li>1：在第一时间步选择条件概率最高的k个选项</li>
<li><p>2：对随后的每个时间步，基于上一时间步的k个候选输出序列预测这一时间步的所有可能选项的条件概率，从中取k个最大的</p>
</li>
<li><p>3：最后基于每步得到的序列，删去截止符和其后元素，获得最终候选序列集合，取出加权条件概率最大的</p>
</li>
</ul>
<p>加权条件概率公式如下：</p>
<script type="math/tex; mode=display">
\frac{1}{L^\alpha} \log P(y_1, \ldots, y_{L}\mid \mathbf{c}) = \frac{1}{L^\alpha} \sum_{t'=1}^L \log P(y_{t'} \mid y_1, \ldots, y_{t'-1}, \mathbf{c}),</script><p>式中$\frac{1}{L^\alpha}$用于调整长序列的评估值使得长短序列间的比较公平</p>
<p>束宽k的选择：</p>
<ul>
<li>k=1时实际为贪心搜索</li>
<li>k越小搜索速度越快，但结果越差，k越大则搜索速度越慢，但结果越好</li>
</ul>
<p>束搜索只在测试时使用</p>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>62-序列到序列学习</title>
    <url>/2024/04/23/11-06-02/</url>
    <content><![CDATA[<h2 id="62-序列到序列学习"><a href="#62-序列到序列学习" class="headerlink" title="62-序列到序列学习"></a>62-序列到序列学习</h2><h3 id="1-应用举例：机器翻译"><a href="#1-应用举例：机器翻译" class="headerlink" title="1. 应用举例：机器翻译"></a>1. 应用举例：机器翻译</h3><ul>
<li>给定一个源语言的句子，自动翻译成目标语言</li>
<li>这两个句子可以有不同的长度</li>
</ul>
<h3 id="2-模型架构：Seq2seq"><a href="#2-模型架构：Seq2seq" class="headerlink" title="2. 模型架构：Seq2seq"></a>2. 模型架构：Seq2seq</h3><img src="/2024/04/23/11-06-02/62-01.png" class>
<ul>
<li><p>序列到序列模型由<strong>编码器-解码器</strong>构成。</p>
</li>
<li><p><strong>编码器</strong>RNN可以是<strong>双向</strong>，由于输入的句子是完整地，可以正着看，也可以反着看；而<strong>解码器</strong>只能是<strong>单向</strong>，由于预测时，只能正着去预测。</p>
</li>
<li>编码器，解码器采用<strong>不同的RNN</strong>，此RNN也可以是GRU，LSTM等。</li>
</ul>
<h3 id="3-编码器-解码器细节"><a href="#3-编码器-解码器细节" class="headerlink" title="3. 编码器-解码器细节"></a>3. 编码器-解码器细节</h3><img src="/2024/04/23/11-06-02/62-02.png" class>
<ul>
<li><p>编码器的RNN<strong>没有</strong>连接<strong>输出层</strong></p>
</li>
<li><p><strong>编码器</strong>的<strong>最后时间步的隐状态</strong>用作<strong>解码器</strong>的<strong>初始隐状态</strong>（图中箭头的传递）</p>
</li>
</ul>
<h3 id="4-训练和推理"><a href="#4-训练和推理" class="headerlink" title="4. 训练和推理"></a>4. 训练和推理</h3><img src="/2024/04/23/11-06-02/62-03.png" class>
<ul>
<li>第3节中提到编码器没有输出层，只有解码器有，于是损失函数的计算只关注解码器的输出层。</li>
<li>训练和预测（推理）有区别的，训练时解码器使用目标句子（真值）作为输入，以指导模型训练；而推理时无法提前得知真值，需要一步一步进行预测。</li>
</ul>
<h3 id="5-衡量生成序列的好坏：BLEU"><a href="#5-衡量生成序列的好坏：BLEU" class="headerlink" title="5. 衡量生成序列的好坏：BLEU"></a>5. 衡量生成序列的好坏：BLEU</h3><h4 id="5-1-BLUE值定义："><a href="#5-1-BLUE值定义：" class="headerlink" title="5.1 BLUE值定义："></a>5.1 BLUE值定义：</h4><img src="/2024/04/23/11-06-02/62-04.png" class>
<p>宗成庆老师《统计自然语言处理》（第二版）一书中关于BLEU的定义：</p>
<img src="/2024/04/23/11-06-02/62-05.png" class>
<p>同时，吴恩达深度学习课程中也是使用这一方式定义。但观察两种方式，BP惩罚因子的计算是一致的，pn也是使用了几何平均的方式，只是对于wn这一加权值的选择有所不同。</p>
<h4 id="5-2-定义式解析"><a href="#5-2-定义式解析" class="headerlink" title="5.2 定义式解析"></a>5.2 定义式解析</h4><img src="/2024/04/23/11-06-02/62-06.png" class>
<p>BLEU值衡量的是精确率，而且对不同n-gram进行集成打分。</p>
<ul>
<li><p>BP惩罚因子：为了惩罚过短的句子，由于过短的句子基数小，精确率容易提升，所以加上一个BP乘子，当预测句子长度&lt;参考句子长度，则BP&lt;1。</p>
</li>
<li><p>wn的选择：李沐老师课程中是采用了$\frac{1}{2^n}$​作为加权因子，n越大，加权因子越小，但由于pn&lt;1，赋予的权重越大，即长匹配具有更高的权重。而宗老师的书中所述：在BLEU的基线系统中取N＝4，wn＝1/N，也可以参考。</p>
</li>
</ul>
<h3 id="6-QA"><a href="#6-QA" class="headerlink" title="6. QA"></a>6. QA</h3><p>问题：LSTM、GRU、Seq2Seq的区别是什么？</p>
<blockquote>
<p>Seq2Seq是一种由编码器和解码器组成的框架，而LSTM、GRU是组成编码器和解码器的一种单元。</p>
</blockquote>
<p>问题：encoder的输出和decoder的输入，拼接和按位相加起来有什么区别么？</p>
<blockquote>
<p>不能够按位加，由于encoder的输出最后维度是hidden_size，而decoder的输入最后维度是embedding_size，可能不一样，所以用拼接。</p>
</blockquote>
<p>问题：embedding层是做word2vec吗？</p>
<blockquote>
<p>这里不是，这里是从头开始训练。现在用的比较多得都是预训练，BERT等。</p>
</blockquote>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>61-编码器-解码器架构</title>
    <url>/2024/04/23/11-06-01/</url>
    <content><![CDATA[<h2 id="编码器-解码器架构"><a href="#编码器-解码器架构" class="headerlink" title="编码器-解码器架构"></a>编码器-解码器架构</h2><h3 id="CNN中的解释"><a href="#CNN中的解释" class="headerlink" title="CNN中的解释"></a>CNN中的解释</h3><p>考虑一个CNN模型：</p>
<img src="/2024/04/23/11-06-01/CNN.png" class>
<p>整个CNN实际上可以看作一个编码器，解码器两部分。</p>
<ul>
<li>底层的神经网络，也就是编码器将输入编码成能被模型识别的中间表达形式，也就是特征</li>
<li>解码器将中间结果解码为输出</li>
</ul>
<h3 id="RNN中的解释"><a href="#RNN中的解释" class="headerlink" title="RNN中的解释"></a>RNN中的解释</h3><p>对于RNN而言，同样有着类似的划分</p>
<img src="/2024/04/23/11-06-01/RNN.png" class>
<ul>
<li>编码器将输入文本表示为向量</li>
<li>解码器将向量表示为输出</li>
</ul>
<h3 id="抽象的编码器-解码器架构"><a href="#抽象的编码器-解码器架构" class="headerlink" title="抽象的编码器-解码器架构"></a>抽象的编码器-解码器架构</h3><p>指一个模型被分为两块：</p>
<ul>
<li>一块是编码器，也叫encoder，用于将输入处理为一个中间状态</li>
<li>一块是解码器，也叫decoder，用于将中间状态表示为输出</li>
<li>解码器也可以有额外的输入提供信息</li>
</ul>
<img src="/2024/04/23/11-06-01/encoder-decoder.png" class>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>58-深层循环神经网络</title>
    <url>/2024/04/23/11-01-58/</url>
    <content><![CDATA[<h2 id="58-深层循环神经网络"><a href="#58-深层循环神经网络" class="headerlink" title="58 深层循环神经网络"></a>58 深层循环神经网络</h2><p>x</p>
<h3 id="1-深层循环神经网络"><a href="#1-深层循环神经网络" class="headerlink" title="1.深层循环神经网络"></a>1.深层循环神经网络</h3><p>之前讲的RNN都只有一个隐藏层（序列变长不算是深度），而一个隐藏层的RNN一旦做的很宽就容易出现过拟合。因此我们考虑将网络做的更深而非更宽，每层都只做一点非线性，靠层数叠加得到更加非线性的模型。</p>
<p>浅RNN：输入-隐层-输出</p>
<p>深RNN：输入-隐层-隐层-…-输出</p>
<img src="/2024/04/23/11-01-58/58-01.png" class>
<p>（课程视频中的图片有错误，最后输出层后一时间步是不受前一步影响的，即没有箭头）</p>
<h3 id="2-公式"><a href="#2-公式" class="headerlink" title="2.公式"></a>2.公式</h3><div align="center">

![](http://latex.codecogs.com/svg.latex?\mathbf{H}_t^1=f_1(\mathbf{H_{t-1}^1},\mathbf{X_t}))

</div>

<p><em>第一层的第t步状态是关于第一层第t-1步状态和第t步输入的函数</em></p>
<div align="center">

<p><img src="http://latex.codecogs.com/svg.latex?\mathbf{H}_t^j=f_j(\mathbf{H_{t-1}^j},\mathbf{H_{t}^{j-1}" alt>})</p>
<p>&lt;/div&gt;<br><em>第j层的第t步状态是关于当前层上一步步状态和上一层当前步的函数</em></p>
<div align="center">

<p><img src="http://latex.codecogs.com/svg.latex?\mathbf{O}_t=g(\mathbf{H}_t^L" alt>)</p>
<p>&lt;/div&gt;<br><em>由最后一个隐藏层得到输出</em></p>
<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h3><ul>
<li>深度循环神经网络使用多个隐藏层来获得更多的非线性性</li>
</ul>
<p>将RNN/GRU/LSTM做深都是一个道理，三者只是使用的函数f不同。</p>
<h3 id="4-QA"><a href="#4-QA" class="headerlink" title="4.QA"></a>4.QA</h3><p>Q1: NLP那个方向好找工作？文本翻译是不是现在只在学术研究中才需要自己实现？（2021-7-27）</p>
<blockquote>
<p>文本翻译已经是一个很成熟的领域，NLP挺好找工作，人产生的文本远多于图片。</p>
</blockquote>
<p>Q2: 关于BPTT</p>
<blockquote>
<p>课上不讲，书上有讲原理</p>
</blockquote>
<p>Q3: 深层RNN是不是每层都需要一个初始hidenstate?</p>
<blockquote>
<p>是的</p>
</blockquote>
<p>Q4: 可不可以手动实现hidden_size不一样的多层RNN？</p>
<blockquote>
<p>应该没问题，但通常大家不会去调hidden_size，因为网络不会做的很深，最后还有全连接层。</p>
</blockquote>
<p>Q5: 关于课上提到的classifier</p>
<blockquote>
<p>分类的任务在最后的全连接层完成</p>
</blockquote>
</div></div>]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>57-长短期记忆网络(LSTM)</title>
    <url>/2024/04/23/11-01-57/</url>
    <content><![CDATA[<h1 id="长短期记忆网络"><a href="#长短期记忆网络" class="headerlink" title="长短期记忆网络"></a>长短期记忆网络</h1><h3 id="2-长短期记忆网络："><a href="#2-长短期记忆网络：" class="headerlink" title="2.长短期记忆网络："></a>2.长短期记忆网络：</h3><ul>
<li>忘记门：将值朝0减少</li>
<li>输入门：决定是不是忽略掉输入数据</li>
<li>输出门：决定是不是使用隐状态</li>
</ul>
<p>可以说，长短期记忆网络的设计灵感来自于计算机的逻辑门。 长短期记忆网络引入了<em>记忆元</em>（memory cell），或简称为<em>单元</em>（cell）。 有些文献认为记忆元是隐状态的一种特殊类型， 它们与隐状态具有相同的形状，其设计目的是用于记录附加的信息。 为了控制记忆元，我们需要许多门。 其中一个门用来从单元中输出条目，我们将其称为<em>输出门</em>（output gate）。 另外一个门用来决定何时将数据读入单元，我们将其称为<em>输入门</em>（input gate）。 我们还需要一种机制来重置单元的内容，由<em>遗忘门</em>（forget gate）来管理， 这种设计的动机与门控循环单元相同， 能够通过专用机制决定什么时候记忆或忽略隐状态中的输入。 让我们看看这在实践中是如何运作的。</p>
<h4 id="2-1-门："><a href="#2-1-门：" class="headerlink" title="2.1 门："></a>2.1 门：</h4><p>输入门：<img src="https://latex.codecogs.com/svg.image?I_{t}=\sigma&space;(X_{t}W_{xi}&plus;H_{t-1}W_{hi}&plus;b_{i})" title="I_{t}=\sigma (X_{t}W_{xi}+H_{t-1}W_{hi}+b_{i})"></p>
<p>忘记门：<img src="https://latex.codecogs.com/svg.image?F_{t}=\sigma&space;(X_{t}W_{xf}&plus;H_{t-1}W_{hf}&plus;b_{f})" title="F_{t}=\sigma (X_{t}W_{xf}+H_{t-1}W_{hf}+b_{f})"></p>
<p>输出门：<img src="https://latex.codecogs.com/svg.image?O_{t}=\sigma&space;(X_{t}W_{xo}&plus;H_{t-1}W_{ho}&plus;b_{o})" title="O_{t}=\sigma (X_{t}W_{xo}+H_{t-1}W_{ho}+b_{o})"></p>
<p>这三个门的算式和普通RNN计算Ht算式相同。</p>
<img src="/2024/04/23/11-01-57/57-1.png" class>
<h4 id="2-2候选记忆单元"><a href="#2-2候选记忆单元" class="headerlink" title="2.2候选记忆单元"></a>2.2候选记忆单元</h4><p><img src="https://latex.codecogs.com/svg.image?\widetilde{C_{t}}=tanh(X_{t}W_{xc}&plus;H_{t-1}W_{hc}&plus;b_{c})" title="\widetilde{C_{t}}=tanh(X_{t}W_{xc}+H_{t-1}W_{hc}+b_{c})"></p>
<p>相当于在ht-1到ht的预测中又加了一层隐藏单元</p>
<img src="/2024/04/23/11-01-57/57-2.png" class>
<h4 id="2-2记忆单元"><a href="#2-2记忆单元" class="headerlink" title="2.2记忆单元"></a>2.2记忆单元</h4><p><img src="https://latex.codecogs.com/svg.image?C_{t}=F_{t}\odot&space;C_{t-1}&plus;I_{t}\odot&space;\widetilde{C_{t}}" title="C_{t}=F_{t}\odot C_{t-1}+I_{t}\odot \widetilde{C_{t}}"></p>
<p>如果遗忘门始终为(1)且输入门始终为(0)， 则过去的记忆元 将随时间被保存并传递到当前时间步。 引入这种设计是为了缓解梯度消失问题， 并更好地捕获序列中的长距离依赖关系。</p>
<img src="/2024/04/23/11-01-57/57-3.png" class>
<h4 id="2-3隐状态"><a href="#2-3隐状态" class="headerlink" title="2.3隐状态"></a>2.3隐状态</h4><p><img src="https://latex.codecogs.com/svg.image?H_{t}=O_{t}\odot&space;tanh(C_{t})" title="H_{t}=O_{t}\odot tanh(C_{t})"></p>
<p>最后，我们需要定义如何计算隐状态， 这就是输出门发挥作用的地方。 在长短期记忆网络中，它仅仅是记忆元的的门控版本。 这就确保了Ht的值始终在区间((-1, 1))内.</p>
<p>只要输出门接近1，我们就能够有效地将所有记忆信息传递给预测部分， 而对于输出门接近(0)，我们只保留记忆元内的所有信息，而不需要更新隐状态。</p>
<img src="/2024/04/23/11-01-57/57-4.png" class>
<h4 id="2-4总结"><a href="#2-4总结" class="headerlink" title="2.4总结"></a>2.4总结</h4><p>LSTM的计算流程：</p>
<p><img src="https://latex.codecogs.com/svg.image?I_{t}=\sigma&space;(X_{t}W_{xi}&plus;H_{t-1}W_{hi}&plus;b_{i})" title="I_{t}=\sigma (X_{t}W_{xi}+H_{t-1}W_{hi}+b_{i})"></p>
<p><img src="https://latex.codecogs.com/svg.image?F_{t}=\sigma&space;(X_{t}W_{xf}&plus;H_{t-1}W_{hf}&plus;b_{f})" title="F_{t}=\sigma (X_{t}W_{xf}+H_{t-1}W_{hf}+b_{f})"></p>
<p><img src="https://latex.codecogs.com/svg.image?O_{t}=\sigma&space;(X_{t}W_{xo}&plus;H_{t-1}W_{ho}&plus;b_{o})" title="O_{t}=\sigma (X_{t}W_{xo}+H_{t-1}W_{ho}+b_{o})"></p>
<p><img src="https://latex.codecogs.com/svg.image?\widetilde{C_{t}}=tanh(X_{t}W_{xc}&plus;H_{t-1}W_{hc}&plus;b_{c})" title="\widetilde{C_{t}}=tanh(X_{t}W_{xc}+H_{t-1}W_{hc}+b_{c})"></p>
<p><img src="https://latex.codecogs.com/svg.image?C_{t}=F_{t}\odot&space;C_{t-1}&plus;I_{t}\odot&space;\widetilde{C_{t}}" title="C_{t}=F_{t}\odot C_{t-1}+I_{t}\odot \widetilde{C_{t}}"></p>
<p><img src="https://latex.codecogs.com/svg.image?H_{t}=O_{t}\odot&space;tanh(C_{t})" title="H_{t}=O_{t}\odot tanh(C_{t})"></p>
<h3 id="3-从零实现"><a href="#3-从零实现" class="headerlink" title="3.从零实现"></a>3.从零实现</h3><p>加载时光机器数据集</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line">batch_size, num_steps = <span class="number">32</span>, <span class="number">35</span></span><br><span class="line">train_iter, vocab = d2l.load_data_time_machine(batch_size, num_steps)</span><br></pre></td></tr></table></figure>
<h4 id="3-1初始化模型参数"><a href="#3-1初始化模型参数" class="headerlink" title="3.1初始化模型参数"></a>3.1初始化模型参数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_lstm_params</span>(<span class="params">vocab_size, num_hiddens, device</span>):</span><br><span class="line">    num_inputs = num_outputs = vocab_size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">normal</span>(<span class="params">shape</span>):</span><br><span class="line">        <span class="keyword">return</span> torch.randn(size=shape, device=device)*<span class="number">0.01</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">three</span>():</span><br><span class="line">        <span class="keyword">return</span> (normal((num_inputs, num_hiddens)),</span><br><span class="line">                normal((num_hiddens, num_hiddens)),</span><br><span class="line">                torch.zeros(num_hiddens, device=device))</span><br><span class="line"></span><br><span class="line">    W_xi, W_hi, b_i = three()  <span class="comment"># 输入门参数</span></span><br><span class="line">    W_xf, W_hf, b_f = three()  <span class="comment"># 遗忘门参数</span></span><br><span class="line">    W_xo, W_ho, b_o = three()  <span class="comment"># 输出门参数</span></span><br><span class="line">    W_xc, W_hc, b_c = three()  <span class="comment"># 候选记忆元参数</span></span><br><span class="line">    <span class="comment"># 输出层参数</span></span><br><span class="line">    W_hq = normal((num_hiddens, num_outputs))</span><br><span class="line">    b_q = torch.zeros(num_outputs, device=device)</span><br><span class="line">    <span class="comment"># 附加梯度</span></span><br><span class="line">    params = [W_xi, W_hi, b_i, W_xf, W_hf, b_f, W_xo, W_ho, b_o, W_xc, W_hc,</span><br><span class="line">              b_c, W_hq, b_q]</span><br><span class="line">    <span class="keyword">for</span> param <span class="keyword">in</span> params:</span><br><span class="line">        param.requires_grad_(<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> params</span><br></pre></td></tr></table></figure>
<h4 id="3-2定义模型"><a href="#3-2定义模型" class="headerlink" title="3.2定义模型"></a>3.2定义模型</h4><p>在初始化函数中， 长短期记忆网络的隐状态需要返回一个<em>额外</em>的记忆元， 单元的值为0，形状为（批量大小，隐藏单元数）。 因此，我们得到以下的状态初始化。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">init_lstm_state</span>(<span class="params">batch_size, num_hiddens, device</span>):</span><br><span class="line">    <span class="keyword">return</span> (torch.zeros((batch_size, num_hiddens), device=device),</span><br><span class="line">            torch.zeros((batch_size, num_hiddens), device=device))</span><br></pre></td></tr></table></figure>
<p>实际模型的定义与我们前面讨论的一样： 提供三个门和一个额外的记忆元。 请注意，只有隐状态才会传递到输出层， 而记忆元(\mathbf{C}_t)不直接参与输出计算。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lstm</span>(<span class="params">inputs, state, params</span>):</span><br><span class="line">    [W_xi, W_hi, b_i, W_xf, W_hf, b_f, W_xo, W_ho, b_o, W_xc, W_hc, b_c,</span><br><span class="line">     W_hq, b_q] = params</span><br><span class="line">    (H, C) = state</span><br><span class="line">    outputs = []</span><br><span class="line">    <span class="keyword">for</span> X <span class="keyword">in</span> inputs:</span><br><span class="line">        I = torch.sigmoid((X @ W_xi) + (H @ W_hi) + b_i)</span><br><span class="line">        F = torch.sigmoid((X @ W_xf) + (H @ W_hf) + b_f)</span><br><span class="line">        O = torch.sigmoid((X @ W_xo) + (H @ W_ho) + b_o)</span><br><span class="line">        C_tilda = torch.tanh((X @ W_xc) + (H @ W_hc) + b_c)</span><br><span class="line">        C = F * C + I * C_tilda</span><br><span class="line">        H = O * torch.tanh(C)</span><br><span class="line">        Y = (H @ W_hq) + b_q</span><br><span class="line">        outputs.append(Y)</span><br><span class="line">    <span class="keyword">return</span> torch.cat(outputs, dim=<span class="number">0</span>), (H, C)</span><br></pre></td></tr></table></figure>
<h4 id="3-3训练和预测"><a href="#3-3训练和预测" class="headerlink" title="3.3训练和预测"></a>3.3训练和预测</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">vocab_size, num_hiddens, device = <span class="built_in">len</span>(vocab), <span class="number">256</span>, d2l.try_gpu()</span><br><span class="line">num_epochs, lr = <span class="number">500</span>, <span class="number">1</span></span><br><span class="line">model = d2l.RNNModelScratch(<span class="built_in">len</span>(vocab), num_hiddens, device, get_lstm_params,</span><br><span class="line">                            init_lstm_state, lstm)</span><br><span class="line">d2l.train_ch8(model, train_iter, vocab, lr, num_epochs, device)</span><br></pre></td></tr></table></figure>
<img src="/2024/04/23/11-01-57/57-5.png" class>
<h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><h5 id="Q1：请问LSTM如果不要C-把公式里的换成，好像可以实现隐藏状态往下传递？"><a href="#Q1：请问LSTM如果不要C-把公式里的换成，好像可以实现隐藏状态往下传递？" class="headerlink" title="Q1：请问LSTM如果不要C,把公式里的换成，好像可以实现隐藏状态往下传递？"></a>Q1：请问LSTM如果不要C,把公式里的<img src="https://latex.codecogs.com/svg.image?&space;C_{t-1}" title=" C_{t-1}">换成<img src="https://latex.codecogs.com/svg.image?&space;H_{t-1}" title=" H_{t-1}">，好像可以实现隐藏状态往下传递？</h5><blockquote>
<p><img src="https://latex.codecogs.com/svg.image?&space;C_{t-1}" title=" C_{t-1}">的可以约束<img src="https://latex.codecogs.com/svg.image?&space;H_{t-1}" title=" H_{t-1}">的大小在0-1之间，避免梯度爆炸，而且使算式更加自然，c换成h复杂度降低。</p>
</blockquote>
<h5 id="Q2：I-F-O-C-tilda的初始化为零？"><a href="#Q2：I-F-O-C-tilda的初始化为零？" class="headerlink" title="Q2：I,F,O,C_tilda的初始化为零？"></a>Q2：I,F,O,C_tilda的初始化为零？</h5><blockquote>
<p>这些是计算的中间变量，不需要初始化</p>
</blockquote>
<h5 id="Q3：如何计算模型占用显存，batch占用的显存？"><a href="#Q3：如何计算模型占用显存，batch占用的显存？" class="headerlink" title="Q3：如何计算模型占用显存，batch占用的显存？"></a>Q3：如何计算模型占用显存，batch占用的显存？</h5><blockquote>
<p>取决于框架和库，没法具体算</p>
</blockquote>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>56-门控循环单元(GRU)</title>
    <url>/2024/04/23/11-01-56/</url>
    <content><![CDATA[<h2 id="56-门控循环单元-GRU"><a href="#56-门控循环单元-GRU" class="headerlink" title="56-门控循环单元(GRU)"></a>56-门控循环单元(GRU)</h2><h3 id="1-动机：如何关注一个序列"><a href="#1-动机：如何关注一个序列" class="headerlink" title="1. 动机：如何关注一个序列"></a>1. 动机：如何关注一个序列</h3><ul>
<li>不是每个观察值都是同等重要</li>
</ul>
<img src="/2024/04/23/11-01-56/56-01.png" class>
<p>比如上图中的序列，若干个猫中出现了一个鼠，那么我们应该重点关注这个鼠，而中间重复出现的猫则减少关注。文本序列同理，通常长文本我们需要关注的是几个关键词，关键句。</p>
<ul>
<li>想只记住相关的观察需要：<ul>
<li>能<strong>关注</strong>的机制（<strong>更新门</strong>）：顾名思义，是否需要根据我的输入，更新隐藏状态</li>
<li>能<strong>遗忘</strong>的机制（<strong>重置门</strong>）：更新候选项时，是否要考虑前一隐藏状态。</li>
</ul>
</li>
</ul>
<h3 id="2-门的概念"><a href="#2-门的概念" class="headerlink" title="2. 门的概念"></a>2. 门的概念</h3><ul>
<li><p>更新门Zt，重置门Rt的公式大体相同，唯一不同的是学习到的参数。</p>
</li>
<li><p>需要注意的是，计算门的方式和原来RNN的实现中计算新的隐状态相似，只是激活函数改成了sigmoid。</p>
</li>
<li>门本来是电路中的一个概念，0,1代表不同的电平，可以用于控制电路的通断。此处sigmoid将门的数值归一化到0到1之间，是一种”软更新”方式。而从后面的公式上可以看出，本讲课程采用的是低电平有效（越靠近0，门的作用越明显）的方式控制。</li>
</ul>
<img src="/2024/04/23/11-01-56/56-02.png" class>
<h3 id="3-候选隐状态"><a href="#3-候选隐状态" class="headerlink" title="3. 候选隐状态"></a>3. 候选隐状态</h3><img src="/2024/04/23/11-01-56/56-03.png" class>
<ul>
<li><p>候选隐状态，如果抛开公式中的$R_{t}$遗忘门来说，这个和之前RNN中计算当前步的隐状态没有差别。</p>
</li>
<li><p>但是这里引入了遗忘门，如果$R_{t}$无限接近于0，那么此时候选隐状态将不再考虑前一隐状态的影响，也就是和MLP没有区别，起到“遗忘”的作用；</p>
</li>
<li>反之，如果$R_{t}$无限接近于1，那么与RNN计算隐状态的过程没有差别，不进行遗忘。</li>
<li>公式中的⊙表示逐元素乘积。</li>
</ul>
<blockquote>
<p>为什么叫候选隐状态？</p>
<p>在RNN中，这个所谓的候选隐状态就是当前步的隐状态（$R_{t}$无限接近1时）。但是由于引入了更新门，我们需要考虑是直接沿用上一步的隐藏状态，还是像RNN一样使用当前步计算的隐状态。所以这个结合了当前输入计算的隐状态，不能立马变成当前的$H_{t}$，而是需要用更新门和前一隐状态$H_{t-1}$做一个加权，所以它是一个候选项。</p>
</blockquote>
<h3 id="4-隐状态"><a href="#4-隐状态" class="headerlink" title="4. 隐状态"></a>4. 隐状态</h3><img src="/2024/04/23/11-01-56/56-04.png" class>
<p>用更新门对<strong>候选隐状态</strong>和<strong>前一隐状态</strong>做加权，得到当前步<strong>隐状态</strong>的值。</p>
<p>如果$Z_{t}$无限接近于0，更新起作用，候选隐状态“转正”，变为当前隐状态。</p>
<p>如果$Z_{t}$无限接近于1，更新不起作用，当前隐状态还是沿用前一隐状态。</p>
<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><img src="/2024/04/23/11-01-56/56-05.png" class>
<p>上图四行公式概括了GRU模型。在RNN的基础上，最重要的是引入了<strong>更新门和重置门</strong>，来决定前一隐状态对当前隐状态的影响。以最开始的猫鼠序列的例子来说，如果我的模型一直看到猫，模型可以学习到隐状态不怎么去更新，于是隐状态一直保留了猫的信息，而看到老鼠，隐状态才进行更新。</p>
<ul>
<li>对于一个更具体的例子而言(语言模型)：</li>
</ul>
<p>“The cat, which already ate ……, __(is/ was) full.”，假设我的句子很长，预测完前面的词后需要预测下一个词is还是was，如果引入这种更新/重置的机制，那我们的模型可以在was这个词之前尽可能去保持隐状态的信息，从而即使阅读了一个很长的定语从句，但我们还是保留了cat这个词的单数信息，从而模型预测下一个词为’was’。</p>
<ul>
<li>一个与RNN的联动在于：</li>
</ul>
<p>如果更新门完全发挥作用（无限接近于0），重置门不起作用（无限接近于1），此时GRU模型退化为RNN模型。</p>
<h3 id="6-QA"><a href="#6-QA" class="headerlink" title="6. QA"></a>6. QA</h3><p>问题：GRU为什么需要两个门？</p>
<blockquote>
<p>重置门和更新门各司其职。重置门单方面控制自某个节点开始，之前的记忆（隐状态）不在乎了，直接清空影响，同时也需要更新门帮助它实现记忆的更新。更新门更多是用于处理梯度消失问题，可以选择一定程度地保留记忆，防止梯度消失。</p>
<p>重置门影响的是当前步新的候选隐状态的计算，更新门影响的是当前步隐状态的更新程度。</p>
</blockquote>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>54-循环神经网络RNN</title>
    <url>/2024/04/23/11-01-54/</url>
    <content><![CDATA[<h3 id="使用潜变量"><a href="#使用潜变量" class="headerlink" title="使用潜变量"></a>使用潜变量</h3><ul>
<li>RNN使用了隐藏层来记录过去发生的所有事件的信息，从而引入时许的特性，并且避免常规序列模型每次都要重新计算前面所有已发生的事件而带来的巨大计算量。<img src="https://github.com/kinza99/DeepLearning-MuLi-Notes/blob/main/imgs/54/54-01.png" alt="截屏2022-02-12 下午2.17.32"></li>
</ul>
<h3 id="RNN"><a href="#RNN" class="headerlink" title="RNN"></a>RNN</h3><ul>
<li>流程如下，首先有一个输入序列，对于时刻t，我们用t-1时刻的输入x~t-1~和潜变量h~t-1~来计算新的潜变量h~t~。同时，对于t时刻的输出o~t~，则直接使用h~t~来计算得到。注意，计算第一个潜变量只需要输入即可（因为前面并不存在以往的潜变量）。<img src="https://github.com/kinza99/DeepLearning-MuLi-Notes/blob/main/imgs/54/54-02.png" alt="截屏2022-02-12 下午2.34.14"> </li>
<li>值得注意的是，RNN本质也是一种MLP，尤其是将h~t-1~这一项去掉时就完全退化成了MLP。RNN的核心其实也就是h~t-1~这一项，它使得模型可以和前面的信息联系起来，将时序信息储存起来，可以把RNN理解为是包含时序信息的MLP。</li>
</ul>
<h3 id="困惑度"><a href="#困惑度" class="headerlink" title="困惑度"></a>困惑度</h3><ul>
<li>为了衡量一个语言模型的好坏，例如分类模型，可以使用平均交叉熵来衡量，就是将预测概率的负对数值求和之后再去平均，即常用的交叉熵损失。但是由于某些历史原因，NLP往往不是用这种方式，而是在这种方式的基础上最后再取指数，即exp，这样得到的结果如果是1，说明完美；如果是无穷大，说明结果很差。</li>
</ul>
<h3 id="梯度裁剪"><a href="#梯度裁剪" class="headerlink" title="梯度裁剪"></a>梯度裁剪</h3><ul>
<li>在T个时间步中进行反向传播，会由于产生O(T)长度的梯度乘法链，导致导数数值不稳定，这里使用一个限制θ，通常为5到10，来控制梯度乘法链的长度。使用如下的公式<img src="https://github.com/kinza99/DeepLearning-MuLi-Notes/blob/main/imgs/54/54-03.png" alt="截屏2022-02-12 下午3.10.38">在这个公式中，如果梯度长度大于θ，梯度g会变为<script type="math/tex; mode=display">
\frac{\theta}{\Vert g \Vert} g</script>这样再对g求2范式就变成了θ，所以可以把梯度限制在θ以下。</li>
</ul>
<h3 id="更多的应用RNNs"><a href="#更多的应用RNNs" class="headerlink" title="更多的应用RNNs"></a>更多的应用RNNs</h3><ul>
<li>基本的应用如下图<img src="https://github.com/kinza99/DeepLearning-MuLi-Notes/blob/main/imgs/54/54-04.png" alt="截屏2022-02-12 下午3.36.29"></li>
</ul>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>53-语言模型</title>
    <url>/2024/04/23/11-01-53/</url>
    <content><![CDATA[<h3 id="53-语言模型"><a href="#53-语言模型" class="headerlink" title="53 语言模型"></a>53 语言模型</h3><ul>
<li><p>语言模型的目标：</p>
<p>假设长度为<em>T</em>的文本序列中的词元依次为<em>x</em>~1~,<em>x</em>~2~,…,<em>x~T~</em>。 于是，<em>x~t~</em>（1≤<em>t</em>≤<em>T</em>） 可以被认为是文本序列在时间步<em>t</em>处的观测或标签。 在给定这样的文本序列时目标是估计序列的联合概率<em>P</em>(<em>x</em>~1~,<em>x~2~</em>,…,<em>x~T~</em>)</p>
</li>
</ul>
<h4 id="学习语言模型"><a href="#学习语言模型" class="headerlink" title="学习语言模型"></a>学习语言模型</h4><ul>
<li><p>基本想法：</p>
<p><em>P</em>(<em>x</em>~1~,<em>x~2~</em>,…,<em>x~T~</em>) = <em>P</em>(<em>x~t~</em>∣<em>x</em>~1~,…,<em>x~t−1~</em>). (1 &lt;= t &lt;= T) 共T个结果相乘</p>
<p>例如，包含了四个单词的一个文本序列的概率是：</p>
<p><em>P</em>(deep,learning,is,fun)=<em>P</em>(deep)<em>P</em>(learning∣deep)<em>P</em>(is∣deep,learning)<em>P</em>(fun∣deep,learning,is) </p>
<p>为了训练语言模型，我们需要计算单词的概率， 以及给定前面几个单词后出现某个单词的条件概率。 这些概率本质上就是语言模型的参数。训练数据集中词的概率可以根据给定词的相对词频来计算。 例如，可以将估计值<em>P</em>^(deep) 计算为任何以单词“deep”开头的句子的概率。 一种（稍稍不太精确的）方法是统计单词“deep”在数据集中的出现次数， 然后将其除以整个语料库中的单词总数。 这种方法效果不错，特别是对于频繁出现的单词。</p>
</li>
<li><p>基本想法的问题：</p>
<p>由于连续单词对“deep learning”的出现频率要低得多， 所以估计这类单词正确的概率要困难得多。 特别是对于一些不常见的单词组合，要想找到足够的出现次数来获得准确的估计可能都不容易。 而对于三个或者更多的单词组合，情况会变得更糟。 许多合理的三个单词组合可能是存在的，但是在数据集中却找不到。 除非我们提供某种解决方案，来将这些单词组合指定为非零计数， 否则将无法在语言模型中使用它们。 如果数据集很小，或者单词非常罕见，那么这类单词出现一次的机会可能都找不到。</p>
</li>
</ul>
<h4 id="马尔可夫模型与n元语法"><a href="#马尔可夫模型与n元语法" class="headerlink" title="马尔可夫模型与n元语法"></a>马尔可夫模型与n元语法</h4><ul>
<li>如果<em>P</em>(x~t+1~∣<em>x~t~</em>,…,<em>x</em>~1~)=<em>P</em>(x~t+1~∣<em>x~t~</em>)， 则序列上的分布满足一阶马尔可夫性质。 阶数越高，对应的依赖关系就越长。 这种性质推导出了许多可以应用于序列建模的近似公式：<ul>
<li>P(x~1~,x~2~,x~3~,x~4~) = P(x~1~)P(x~2~)P(x~3~)P(x~4~)</li>
<li>P(x~1~,x~2~,x~3~,x~4~) = P(x~1~)P(x~2~ |x~1~)P(x~3~|x~2~)P(x~4~|x~3~)</li>
<li>P(x~1~,x~2~,x~3~,x~4~) = P(x~1~)P(x~2~ |x~1~)P(x~3~|x~1~,x~2~)P(x~4~|x~2~,x~3~)</li>
</ul>
</li>
</ul>
<h4 id="自然语言统计"><a href="#自然语言统计" class="headerlink" title="自然语言统计"></a>自然语言统计</h4><ul>
<li>在真实数据上如果进行自然语言统计：</li>
</ul>
<p>根据前几节介绍的时光机器数据集构建词表，并打印前10个最常用的单词</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line">tokens = d2l.tokenize(d2l.read_time_machine())</span><br><span class="line"><span class="comment"># 因为每个文本行不一定是一个句子或一个段落，因此我们把所有文本行拼接到一起</span></span><br><span class="line">corpus = [token <span class="keyword">for</span> line <span class="keyword">in</span> tokens <span class="keyword">for</span> token <span class="keyword">in</span> line]</span><br><span class="line">vocab = d2l.Vocab(corpus)</span><br><span class="line">vocab.token_freqs[:<span class="number">10</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[(<span class="string">&#x27;the&#x27;</span>, <span class="number">2261</span>),</span><br><span class="line"> (<span class="string">&#x27;i&#x27;</span>, <span class="number">1267</span>),</span><br><span class="line"> (<span class="string">&#x27;and&#x27;</span>, <span class="number">1245</span>),</span><br><span class="line"> (<span class="string">&#x27;of&#x27;</span>, <span class="number">1155</span>),</span><br><span class="line"> (<span class="string">&#x27;a&#x27;</span>, <span class="number">816</span>),</span><br><span class="line"> (<span class="string">&#x27;to&#x27;</span>, <span class="number">695</span>),</span><br><span class="line"> (<span class="string">&#x27;was&#x27;</span>, <span class="number">552</span>),</span><br><span class="line"> (<span class="string">&#x27;in&#x27;</span>, <span class="number">541</span>),</span><br><span class="line"> (<span class="string">&#x27;that&#x27;</span>, <span class="number">443</span>),</span><br><span class="line"> (<span class="string">&#x27;my&#x27;</span>, <span class="number">440</span>)]</span><br></pre></td></tr></table></figure>
<ul>
<li>正如我们所看到的，最流行的词看起来很无聊， 这些词通常被称为<em>停用词</em>（stop words），因此可以被过滤掉。 尽管如此，它们本身仍然是有意义的，我们仍然会在模型中使用它们。 此外，还有个明显的问题是词频衰减的速度相当地快。 例如，最常用单词的词频对比，第10个还不到第1个的1/5。 为了更好地理解，我们可以画出的词频图：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">freqs = [freq <span class="keyword">for</span> token, freq <span class="keyword">in</span> vocab.token_freqs]</span><br><span class="line">d2l.plot(freqs, xlabel=<span class="string">&#x27;token: x&#x27;</span>, ylabel=<span class="string">&#x27;frequency: n(x)&#x27;</span>,</span><br><span class="line">         xscale=<span class="string">&#x27;log&#x27;</span>, yscale=<span class="string">&#x27;log&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>我们可以发现：词频以一种明确的方式迅速衰减。 将前几个单词作为例外消除后，剩余的所有单词大致遵循双对数坐标图上的一条直线。</p>
<ul>
<li>我们来看看二元语法的频率是否与一元语法的频率表现出相同的行为方式。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bigram_tokens = [pair <span class="keyword">for</span> pair <span class="keyword">in</span> <span class="built_in">zip</span>(corpus[:-<span class="number">1</span>], corpus[<span class="number">1</span>:])]</span><br><span class="line">bigram_vocab = d2l.Vocab(bigram_tokens)</span><br><span class="line">bigram_vocab.token_freqs[:<span class="number">10</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[((<span class="string">&#x27;of&#x27;</span>, <span class="string">&#x27;the&#x27;</span>), <span class="number">309</span>),</span><br><span class="line"> ((<span class="string">&#x27;in&#x27;</span>, <span class="string">&#x27;the&#x27;</span>), <span class="number">169</span>),</span><br><span class="line"> ((<span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;had&#x27;</span>), <span class="number">130</span>),</span><br><span class="line"> ((<span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;was&#x27;</span>), <span class="number">112</span>),</span><br><span class="line"> ((<span class="string">&#x27;and&#x27;</span>, <span class="string">&#x27;the&#x27;</span>), <span class="number">109</span>),</span><br><span class="line"> ((<span class="string">&#x27;the&#x27;</span>, <span class="string">&#x27;time&#x27;</span>), <span class="number">102</span>),</span><br><span class="line"> ((<span class="string">&#x27;it&#x27;</span>, <span class="string">&#x27;was&#x27;</span>), <span class="number">99</span>),</span><br><span class="line"> ((<span class="string">&#x27;to&#x27;</span>, <span class="string">&#x27;the&#x27;</span>), <span class="number">85</span>),</span><br><span class="line"> ((<span class="string">&#x27;as&#x27;</span>, <span class="string">&#x27;i&#x27;</span>), <span class="number">78</span>),</span><br><span class="line"> ((<span class="string">&#x27;of&#x27;</span>, <span class="string">&#x27;a&#x27;</span>), <span class="number">73</span>)]</span><br></pre></td></tr></table></figure>
<p>这里值得注意：在十个最频繁的词对中，有九个是由两个停用词组成的， 只有一个与“the time”有关。 我们再进一步看看三元语法的频率是否表现出相同的行为方式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">trigram_tokens = [triple <span class="keyword">for</span> triple <span class="keyword">in</span> <span class="built_in">zip</span>(</span><br><span class="line">    corpus[:-<span class="number">2</span>], corpus[<span class="number">1</span>:-<span class="number">1</span>], corpus[<span class="number">2</span>:])]</span><br><span class="line">trigram_vocab = d2l.Vocab(trigram_tokens)</span><br><span class="line">trigram_vocab.token_freqs[:<span class="number">10</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[((<span class="string">&#x27;the&#x27;</span>, <span class="string">&#x27;time&#x27;</span>, <span class="string">&#x27;traveller&#x27;</span>), <span class="number">59</span>),</span><br><span class="line"> ((<span class="string">&#x27;the&#x27;</span>, <span class="string">&#x27;time&#x27;</span>, <span class="string">&#x27;machine&#x27;</span>), <span class="number">30</span>),</span><br><span class="line"> ((<span class="string">&#x27;the&#x27;</span>, <span class="string">&#x27;medical&#x27;</span>, <span class="string">&#x27;man&#x27;</span>), <span class="number">24</span>),</span><br><span class="line"> ((<span class="string">&#x27;it&#x27;</span>, <span class="string">&#x27;seemed&#x27;</span>, <span class="string">&#x27;to&#x27;</span>), <span class="number">16</span>),</span><br><span class="line"> ((<span class="string">&#x27;it&#x27;</span>, <span class="string">&#x27;was&#x27;</span>, <span class="string">&#x27;a&#x27;</span>), <span class="number">15</span>),</span><br><span class="line"> ((<span class="string">&#x27;here&#x27;</span>, <span class="string">&#x27;and&#x27;</span>, <span class="string">&#x27;there&#x27;</span>), <span class="number">15</span>),</span><br><span class="line"> ((<span class="string">&#x27;seemed&#x27;</span>, <span class="string">&#x27;to&#x27;</span>, <span class="string">&#x27;me&#x27;</span>), <span class="number">14</span>),</span><br><span class="line"> ((<span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;did&#x27;</span>, <span class="string">&#x27;not&#x27;</span>), <span class="number">14</span>),</span><br><span class="line"> ((<span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;saw&#x27;</span>, <span class="string">&#x27;the&#x27;</span>), <span class="number">13</span>),</span><br><span class="line"> ((<span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;began&#x27;</span>, <span class="string">&#x27;to&#x27;</span>), <span class="number">13</span>)]</span><br></pre></td></tr></table></figure>
<ul>
<li>最后，我们直观地对比三种模型中的词元频率：一元语法、二元语法和三元语法。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bigram_freqs = [freq <span class="keyword">for</span> token, freq <span class="keyword">in</span> bigram_vocab.token_freqs]</span><br><span class="line">trigram_freqs = [freq <span class="keyword">for</span> token, freq <span class="keyword">in</span> trigram_vocab.token_freqs]</span><br><span class="line">d2l.plot([freqs, bigram_freqs, trigram_freqs], xlabel=<span class="string">&#x27;token: x&#x27;</span>,</span><br><span class="line">         ylabel=<span class="string">&#x27;frequency: n(x)&#x27;</span>, xscale=<span class="string">&#x27;log&#x27;</span>, yscale=<span class="string">&#x27;log&#x27;</span>,</span><br><span class="line">         legend=[<span class="string">&#x27;unigram&#x27;</span>, <span class="string">&#x27;bigram&#x27;</span>, <span class="string">&#x27;trigram&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p><img src="https://zh-v2.d2l.ai/_images/output_language-models-and-dataset_789d14_54_0.svg" alt="../_images/output_language-models-and-dataset_789d14_54_0.svg"></p>
<h4 id="读取长序列数据"><a href="#读取长序列数据" class="headerlink" title="读取长序列数据"></a>读取长序列数据</h4><ul>
<li><p>由于序列数据本质上是连续的，因此我们在处理数据时需要解决这个问题。在前几节中我们以一种相当特别的方式做到了这一点： 当序列变得太长而不能被模型一次性全部处理时， 我们可能希望拆分这样的序列方便模型读取。</p>
</li>
<li><p>在介绍该模型之前，我们看一下总体策略。 假设我们将使用神经网络来训练语言模型， 模型中的网络一次处理具有预定义长度 （例如<em>n</em>个时间步）的一个小批量序列。 现在的问题是如何随机生成一个小批量数据的特征和标签以供读取。首先，由于文本序列可以是任意长的， 例如整本《时光机器》（<em>The Time Machine</em>）， 于是任意长的序列可以被我们划分为具有相同时间步数的子序列。 当训练我们的神经网络时，这样的小批量子序列将被输入到模型中。 假设网络一次只处理具有<em>n</em>个时间步的子序列。下画出了从原始文本序列获得子序列的所有不同的方式， 其中<em>n</em>=5，并且每个时间步的词元对应于一个字符。 请注意，因为我们可以选择任意偏移量来指示初始位置，所以我们有相当大的自由度。</p>
<p><img src="https://zh-v2.d2l.ai/_images/timemachine-5gram.svg" alt="../_images/timemachine-5gram.svg"></p>
</li>
</ul>
<p>因此，我们应该从中选择哪一个呢？ 事实上，他们都一样的好。 然而，如果我们只选择一个偏移量， 那么用于训练网络的、所有可能的子序列的覆盖范围将是有限的。 因此，我们可以从随机偏移量开始划分序列， 以同时获得<em>覆盖性</em>（coverage）和<em>随机性</em>（randomness）。 下面，我们将描述如何实现<em>随机采样</em>（random sampling）和 <em>顺序分区</em>（sequential partitioning）策略。</p>
<h4 id="随机采样"><a href="#随机采样" class="headerlink" title="随机采样"></a>随机采样</h4><ul>
<li>在随机采样中，每个样本都是在原始的长序列上任意捕获的子序列。 在迭代过程中，来自两个相邻的、随机的、小批量中的子序列不一定在原始序列上相邻。 对于语言建模，目标是基于到目前为止我们看到的词元来预测下一个词元， 因此标签是移位了一个词元的原始序列。下面的代码每次可以从数据中随机生成一个小批量。 在这里，参数<code>batch_size</code>指定了每个小批量中子序列样本的数目， 参数<code>num_steps</code>是每个子序列中预定义的时间步数。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">seq_data_iter_random</span>(<span class="params">corpus, batch_size, num_steps</span>):  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用随机抽样生成一个小批量子序列&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 从随机偏移量开始对序列进行分区，随机范围包括num_steps-1</span></span><br><span class="line">    corpus = corpus[random.randint(<span class="number">0</span>, num_steps - <span class="number">1</span>):]</span><br><span class="line">    <span class="comment"># 减去1，是因为我们需要考虑标签</span></span><br><span class="line">    num_subseqs = (<span class="built_in">len</span>(corpus) - <span class="number">1</span>) // num_steps</span><br><span class="line">    <span class="comment"># 长度为num_steps的子序列的起始索引</span></span><br><span class="line">    initial_indices = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">0</span>, num_subseqs * num_steps, num_steps))</span><br><span class="line">    <span class="comment"># 在随机抽样的迭代过程中，</span></span><br><span class="line">    <span class="comment"># 来自两个相邻的、随机的、小批量中的子序列不一定在原始序列上相邻</span></span><br><span class="line">    random.shuffle(initial_indices)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">data</span>(<span class="params">pos</span>):</span><br><span class="line">        <span class="comment"># 返回从pos位置开始的长度为num_steps的序列</span></span><br><span class="line">        <span class="keyword">return</span> corpus[pos: pos + num_steps]</span><br><span class="line"></span><br><span class="line">    num_batches = num_subseqs // batch_size</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, batch_size * num_batches, batch_size):</span><br><span class="line">        <span class="comment"># 在这里，initial_indices包含子序列的随机起始索引</span></span><br><span class="line">        initial_indices_per_batch = initial_indices[i: i + batch_size]</span><br><span class="line">        X = [data(j) <span class="keyword">for</span> j <span class="keyword">in</span> initial_indices_per_batch]</span><br><span class="line">        Y = [data(j + <span class="number">1</span>) <span class="keyword">for</span> j <span class="keyword">in</span> initial_indices_per_batch]</span><br><span class="line">        <span class="keyword">yield</span> torch.tensor(X), torch.tensor(Y)</span><br></pre></td></tr></table></figure>
<ul>
<li>下面我们生成一个从0到34的序列。 假设批量大小为2，时间步数为5，这意味着可以生成 ⌊(35−1)/5⌋=6个“特征－标签”子序列对。 如果设置小批量大小为2，我们只能得到3个小批量。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_seq = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">35</span>))</span><br><span class="line"><span class="keyword">for</span> X, Y <span class="keyword">in</span> seq_data_iter_random(my_seq, batch_size=<span class="number">2</span>, num_steps=<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;X: &#x27;</span>, X, <span class="string">&#x27;\nY:&#x27;</span>, Y)</span><br></pre></td></tr></table></figure>
<h4 id="顺序分区"><a href="#顺序分区" class="headerlink" title="顺序分区"></a>顺序分区</h4><ul>
<li>在迭代过程中，除了对原始序列可以随机抽样外， 我们还可以保证两个相邻的小批量中的子序列在原始序列上也是相邻的。 这种策略在基于小批量的迭代过程中保留了拆分的子序列的顺序，因此称为顺序分区。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">seq_data_iter_sequential</span>(<span class="params">corpus, batch_size, num_steps</span>):  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用顺序分区生成一个小批量子序列&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 从随机偏移量开始划分序列</span></span><br><span class="line">    offset = random.randint(<span class="number">0</span>, num_steps)</span><br><span class="line">    num_tokens = ((<span class="built_in">len</span>(corpus) - offset - <span class="number">1</span>) // batch_size) * batch_size</span><br><span class="line">    Xs = torch.tensor(corpus[offset: offset + num_tokens])</span><br><span class="line">    Ys = torch.tensor(corpus[offset + <span class="number">1</span>: offset + <span class="number">1</span> + num_tokens])</span><br><span class="line">    Xs, Ys = Xs.reshape(batch_size, -<span class="number">1</span>), Ys.reshape(batch_size, -<span class="number">1</span>)</span><br><span class="line">    num_batches = Xs.shape[<span class="number">1</span>] // num_steps</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, num_steps * num_batches, num_steps):</span><br><span class="line">        X = Xs[:, i: i + num_steps]</span><br><span class="line">        Y = Ys[:, i: i + num_steps]</span><br><span class="line">        <span class="keyword">yield</span> X, Y</span><br></pre></td></tr></table></figure>
<ul>
<li>基于相同的设置，通过顺序分区读取每个小批量的子序列的特征<code>X</code>和标签<code>Y</code>。 通过将它们打印出来可以发现： 迭代期间来自两个相邻的小批量中的子序列在原始序列中确实是相邻的。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> X, Y <span class="keyword">in</span> seq_data_iter_sequential(my_seq, batch_size=<span class="number">2</span>, num_steps=<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;X: &#x27;</span>, X, <span class="string">&#x27;\nY:&#x27;</span>, Y)</span><br></pre></td></tr></table></figure>
<ul>
<li>现在，我们将上面的两个采样函数包装到一个类中， 以便稍后可以将其用作数据迭代器。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SeqDataLoader</span>:  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;加载序列数据的迭代器&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, batch_size, num_steps, use_random_iter, max_tokens</span>):</span><br><span class="line">        <span class="keyword">if</span> use_random_iter:</span><br><span class="line">            self.data_iter_fn = d2l.seq_data_iter_random</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.data_iter_fn = d2l.seq_data_iter_sequential</span><br><span class="line">        self.corpus, self.vocab = d2l.load_corpus_time_machine(max_tokens)</span><br><span class="line">        self.batch_size, self.num_steps = batch_size, num_steps</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.data_iter_fn(self.corpus, self.batch_size, self.num_steps)</span><br></pre></td></tr></table></figure>
<ul>
<li>最后，我们定义了一个函数<code>load_data_time_machine</code>， 它同时返回数据迭代器和词表， 因此可以与其他带有<code>load_data</code>前缀的函数类似地使用。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_data_time_machine</span>(<span class="params">batch_size, num_steps,  <span class="comment">#@save</span></span></span><br><span class="line"><span class="params">                           use_random_iter=<span class="literal">False</span>, max_tokens=<span class="number">10000</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;返回时光机器数据集的迭代器和词表&quot;&quot;&quot;</span></span><br><span class="line">    data_iter = SeqDataLoader(</span><br><span class="line">        batch_size, num_steps, use_random_iter, max_tokens)</span><br><span class="line">    <span class="keyword">return</span> data_iter, data_iter.vocab</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>51-序列模型</title>
    <url>/2024/04/23/11-01-51/</url>
    <content><![CDATA[<h1 id="序列模型"><a href="#序列模型" class="headerlink" title="序列模型"></a>序列模型</h1><h3 id="2-序列数据"><a href="#2-序列数据" class="headerlink" title="2.序列数据"></a>2.序列数据</h3><ul>
<li>实际中很多数据是有时序的</li>
<li>电影的评价随时间变化而变化<ul>
<li>拿了奖后评分上升，直到奖项被遗忘</li>
<li>看了很多好电影后，人们的期望变高</li>
<li>季节性：贺岁片，暑期档</li>
<li>导演、演员的负面报道导致评分变低</li>
</ul>
</li>
</ul>
<h4 id="2-1-更多例子"><a href="#2-1-更多例子" class="headerlink" title="2.1 更多例子"></a>2.1 更多例子</h4><ul>
<li><p>音乐、文本、语言和视频都是连续的</p>
<ul>
<li>标题“狗咬人”远没有“人咬狗”那么令人惊讶</li>
</ul>
</li>
<li><p>大地震发生后，很有可能会有几次较小的余震</p>
</li>
<li>人的互动是连续的，从网上吵架可以看出</li>
<li>预测明天的股价要比填补昨天遗失的股价更困难</li>
</ul>
<h3 id="3-统计工具"><a href="#3-统计工具" class="headerlink" title="3.统计工具"></a>3.统计工具</h3><ul>
<li><p>在时间t观察到<img src="https://latex.codecogs.com/svg.image?X_{t}" title="X_{t}">，那么得到T个不独立的随机变量<img src="https://latex.codecogs.com/svg.image?(X_{1},...X_{t})\sim&space;p(X)" title="(X_{1},...X_{t})\sim p(X)"></p>
</li>
<li><p>使用条件概率展开</p>
<p><img src="https://latex.codecogs.com/svg.image?p(a,b)=p(a)p(b|a)=p(b)p(a|b)" title="p(a,b)=p(a)p(b|a)=p(b)p(a|b)"></p>
</li>
</ul>
<img src="/2024/04/23/11-01-51/51-01.png" class>
<h3 id="4-序列模型"><a href="#4-序列模型" class="headerlink" title="4.序列模型"></a>4.序列模型</h3><img src="/2024/04/23/11-01-51/51-02.png" class>
<ul>
<li>对条件概率建模</li>
</ul>
<img src="/2024/04/23/11-01-51/51-03.png" class>
<h4 id="4-1-方案A-马尔科夫假设"><a href="#4-1-方案A-马尔科夫假设" class="headerlink" title="4.1 方案A:马尔科夫假设"></a>4.1 方案A:马尔科夫假设</h4><img src="/2024/04/23/11-01-51/51-04.png" class>
<ul>
<li>假设当前数据只跟τ个过去数据点相关</li>
</ul>
<img src="/2024/04/23/11-01-51/51-05.png" class>
<h4 id="4-2-方案B-潜变量模型"><a href="#4-2-方案B-潜变量模型" class="headerlink" title="4.2 方案B:潜变量模型"></a>4.2 方案B:潜变量模型</h4><img src="/2024/04/23/11-01-51/51-06.png" class>
<ul>
<li>引入潜变量<img src="https://latex.codecogs.com/svg.image?h_{t}" title="h_{t}">来表示过去信息<img src="https://latex.codecogs.com/svg.image?h_{t}=f(x_{1},...x_{t-1})" title="h_{t}=f(x_{1},...x_{t-1})"><ul>
<li>这样<img src="https://latex.codecogs.com/svg.image?x_{t}=p(x_{t}|h_{t})" title="x_{t}=p(x_{t}|h_{t})"></li>
</ul>
</li>
</ul>
<img src="/2024/04/23/11-01-51/51-07.png" class>
<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h3><ul>
<li>时序模型中，当前数据跟之前观察到的数据相关</li>
<li>自回归模型使用自身过去数据来预测未来</li>
<li>马尔科夫模型假设当前只跟最近少数数据相关，从而简化模型</li>
<li>潜变量模型使用潜变量来概括历史信息</li>
</ul>
<h3 id="6-Q-amp-A："><a href="#6-Q-amp-A：" class="headerlink" title="6.Q&amp;A："></a>6.Q&amp;A：</h3><h5 id="Q1-在常规范围内tau是不是越大越好。刚才例子tau-5是不是比4好？"><a href="#Q1-在常规范围内tau是不是越大越好。刚才例子tau-5是不是比4好？" class="headerlink" title="Q1:在常规范围内tau是不是越大越好。刚才例子tau=5是不是比4好？"></a>Q1:在常规范围内tau是不是越大越好。刚才例子tau=5是不是比4好？</h5><blockquote>
<p>当然比4好，也有局限性，tau特别大，训练样本变小，模型变复杂</p>
</blockquote>
<h5 id="Q2：潜变量模型和隐马尔科夫模型有什么区别？"><a href="#Q2：潜变量模型和隐马尔科夫模型有什么区别？" class="headerlink" title="Q2：潜变量模型和隐马尔科夫模型有什么区别？"></a>Q2：潜变量模型和隐马尔科夫模型有什么区别？</h5><blockquote>
<p>没有太多联系，两个不同的观点，但是潜变量模型可以使用隐马尔科夫假设。潜变量-怎么建模，隐马尔科夫-这个数据和之前多少个数据有关。</p>
</blockquote>
<h5 id="Q3：若预测一个月，tau-30-预测7天，tau-7，是否有这样的关系？"><a href="#Q3：若预测一个月，tau-30-预测7天，tau-7，是否有这样的关系？" class="headerlink" title="Q3：若预测一个月，tau=30,预测7天，tau=7，是否有这样的关系？"></a>Q3：若预测一个月，tau=30,预测7天，tau=7，是否有这样的关系？</h5><blockquote>
<p>tau取决于对数据的理解，没有固定的规则</p>
</blockquote>
<h5 id="Q4：在预测未来方面，现在的sota模型能做到多好？"><a href="#Q4：在预测未来方面，现在的sota模型能做到多好？" class="headerlink" title="Q4：在预测未来方面，现在的sota模型能做到多好？"></a>Q4：在预测未来方面，现在的sota模型能做到多好？</h5><blockquote>
<p>具体问题具体分析，在有些领域做得好比如写作，写代码，在一些领域做的不好，比如预测股票。</p>
</blockquote>
<h5 id="Q5-tau能够随着xt的变化而变化吗？这样感觉更符合实际情况"><a href="#Q5-tau能够随着xt的变化而变化吗？这样感觉更符合实际情况" class="headerlink" title="Q5:tau能够随着xt的变化而变化吗？这样感觉更符合实际情况"></a>Q5:tau能够随着xt的变化而变化吗？这样感觉更符合实际情况</h5><blockquote>
<p>当然可以，有计算量的增加，也不一定更好</p>
</blockquote>
<h5 id="Q6-预测电池之类很多参数的未来变化趋势时怎么长步预测？"><a href="#Q6-预测电池之类很多参数的未来变化趋势时怎么长步预测？" class="headerlink" title="Q6:预测电池之类很多参数的未来变化趋势时怎么长步预测？"></a>Q6:预测电池之类很多参数的未来变化趋势时怎么长步预测？</h5><blockquote>
<p>与数据关系比较大，负类样本较少，所以比较难训练</p>
</blockquote>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>50-课程竞赛：牛仔行头检测</title>
    <url>/2024/04/23/11-01-50/</url>
    <content><![CDATA[<h2 id="课程竞赛：牛仔行头检测"><a href="#课程竞赛：牛仔行头检测" class="headerlink" title="课程竞赛：牛仔行头检测"></a>课程竞赛：牛仔行头检测</h2><h3 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h3><p>图像中的目标检测，检测牛仔的装备，主要包括：夹克，墨镜，靴子，牛仔帽，腰带</p>
<p>有6937张训练图片，12660个标注框，数据集使用MS-COCO格式，可以调用pycocotools库，评测使用mAP（评测对每个类预测的框的好坏）</p>
<p>挑战：五个类别出现次数不同，墨镜、夹克次数多，牛仔帽、靴子其次，腰带很少</p>
<img src="/2024/04/23/11-01-50/%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1.png" class>
<h3 id="安排"><a href="#安排" class="headerlink" title="安排"></a>安排</h3><p>Kaggle不支持mAP，提交结果csv文件时网址不同</p>
<p>公私榜分配和之前不同，之前kaggle从所有数据中选出一部分作为私榜，本次限定了时间公榜结束后12小时内拿到私榜数据并提交结果，至多提交三次</p>
<p>提供了一个示例程序</p>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>49-样式迁移</title>
    <url>/2024/04/23/11-01-49/</url>
    <content><![CDATA[<h2 id="样式迁移"><a href="#样式迁移" class="headerlink" title="样式迁移"></a>样式迁移</h2><p>样式迁移类似于手机相机中的滤镜，指的是给定内容图片和风格图片，合成一张新的图片，使得他的内容与内容图片相似，而风格却是风格图片的样子，如下例：</p>
<img src="/2024/04/23/11-01-49/%E6%A0%B7%E5%BC%8F%E8%BF%81%E7%A7%BB%E7%A4%BA%E4%BE%8B.png" class>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>如下图所示，可以用一个预训练好的神经网络来实现样式迁移：</p>
<ul>
<li>1：复制内容图片来初始化一张图片，之后将这张图片中的像素作为参数进行更新，最终得到合成的图片</li>
<li>2：将内容图片，当前的合成图片，样式图片分别输入一个相同的预训练好的神经网络</li>
<li>3：假设该神经网络的不同层分别提取与内容和风格相关的信息，可以据此得到一个损失：<ul>
<li>将合成图片与<strong>内容</strong>相关的层的输出与<strong>内容</strong>图片对应层的输出进行处理，得到<strong>内容损失</strong></li>
<li>将合成图片与<strong>风格</strong>相关的层的输出与<strong>风格</strong>图片对应层的输出进行处理，得到<strong>风格损失</strong></li>
<li>对合成图片本身，统计图片中的高频噪点（即过明或过暗像素点），得到<strong>全变分损失</strong></li>
<li>将三部分损失加起来得到总的样式迁移的<strong>损失函数</strong></li>
</ul>
</li>
<li>4：利用3定义的损失函数，以合成图片的每个像素点为参数进行梯度下降，得到最终合成的图片</li>
</ul>
<img src="/2024/04/23/11-01-49/CNN%E5%AE%9E%E7%8E%B0.png" class>
<h3 id="内容损失"><a href="#内容损失" class="headerlink" title="内容损失"></a>内容损失</h3><p>神经网络内容相关层的输出的相似度可以直接反应两张图片在内容上的相似度，因此内容损失可以直接将对应层的输出视为内容直接求平方差损失。</p>
<h3 id="风格损失：格拉姆矩阵"><a href="#风格损失：格拉姆矩阵" class="headerlink" title="风格损失：格拉姆矩阵"></a>风格损失：格拉姆矩阵</h3><p>对于内容层，可以直接将对应层的输出求平方差损失，但是对于风格则略有不同</p>
<p>一般认为，风格层对应的输出的多个通道分别对应着不同类型的信息，如果将输出的形状从$[batch_size=1,channels,h,w]$转化为$[channels,h*w]$就能得到通道数个向量，以$x_1,x_2…x_c$表示，代表不同通道所提取出的不同信息，而风格可以视作这些信息之间的关联，即相似度。</p>
<p>定义格拉姆矩阵$\bold X * \bold X^T \in R^{c \cdot c}$，矩阵的第i行第j列即向量$x_i$与$x_j$的内积，这个矩阵就代表了一张图片的风格。</p>
<p>对于生成图片和风格图片的格拉姆矩阵求平方差损失就能得到所需的风格损失</p>
<p>此外，为了让风格损失不受格拉姆矩阵及向量的大小影响，实际将格拉姆矩阵除以这些大小$channnels<em>h</em>w$。</p>
<h3 id="全变分损失"><a href="#全变分损失" class="headerlink" title="全变分损失"></a>全变分损失</h3><p>用于去除高频噪点（过明过暗像素点）</p>
<script type="math/tex; mode=display">
\sum_{i, j} \left|x_{i, j} - x_{i+1, j}\right| + \left|x_{i, j} - x_{i, j+1}\right|</script>]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>48-全连接卷积神经网络（FCN）</title>
    <url>/2024/04/23/11-01-48/</url>
    <content><![CDATA[<h2 id="48-全连接卷积神经网络（FCN）"><a href="#48-全连接卷积神经网络（FCN）" class="headerlink" title="48.全连接卷积神经网络（FCN）"></a>48.全连接卷积神经网络（FCN）</h2><img src="/2024/04/23/11-01-48/48-01.png" class>
<ul>
<li><p>代码</p>
<ul>
<li>见code</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>47-转置卷积</title>
    <url>/2024/04/23/11-01-47/</url>
    <content><![CDATA[<h3 id="47-转置卷积"><a href="#47-转置卷积" class="headerlink" title="47-转置卷积"></a>47-转置卷积</h3><h3 id="1-转置卷积"><a href="#1-转置卷积" class="headerlink" title="1.转置卷积"></a>1.转置卷积</h3><ul>
<li>转置卷积和卷积的区别：<ul>
<li>卷积不会增大输入的高宽，通常要么不变、要么减半</li>
<li>转置卷积则可以用来增大输入高宽</li>
</ul>
</li>
<li>转置卷积的具体实现：</li>
</ul>
<img src="/2024/04/23/11-01-47/47-01.png" class>
<p>如图所示，input里的每个元素和kernel相乘，最后把对应位置相加，相当于卷积的逆变换</p>
<ul>
<li>为什么称之为“转置：<ul>
<li>对于卷积Y=X*W<ul>
<li>可以对W构造一个V，使得卷积等价于矩阵乘法Y’=VX’</li>
<li>这里Y’,X’是Y,X对应的向量版本</li>
</ul>
</li>
<li>转置卷积等价于Y’=VTX’</li>
<li>如果卷积将输入从（h，w）变成了（h‘，w’）<ul>
<li>同样超参数的转置卷积则从（h‘，w’）变成为（h，w）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-转置卷积是一种卷积"><a href="#2-转置卷积是一种卷积" class="headerlink" title="2.转置卷积是一种卷积"></a>2.转置卷积是一种卷积</h3><ul>
<li><p>重新排列输入和核</p>
<ul>
<li>当填充为0步幅为1时：<ul>
<li>将输入填充k-1（k时核窗口）</li>
<li>将核矩阵上下、左右翻转</li>
<li>然后做正常卷积（填充0、步幅1）</li>
</ul>
</li>
</ul>
<img src="/2024/04/23/11-01-47/47-02.png" class>
<ul>
<li>当填充为p步幅为1时：<ul>
<li>将输如填充k-p-1（k是核窗口）</li>
<li>将核矩阵上下、左右翻转</li>
<li>然后做正常卷积（填充0、步幅1）</li>
</ul>
</li>
</ul>
<img src="/2024/04/23/11-01-47/47-03.png" class>
<ul>
<li><p>当填充为p步幅为s时：</p>
<ul>
<li><p>在行和列之间插入s-1行或列</p>
</li>
<li><p>将输如填充k-p-1（k是核窗口）</p>
</li>
<li>将核矩阵上下、左右翻转</li>
<li>然后做正常卷积（填充0、步幅1）</li>
</ul>
</li>
</ul>
<img src="/2024/04/23/11-01-47/47-04.png" class>
</li>
<li><p>形状换算</p>
<ul>
<li><p>输入高（宽）为n，核k，填充p，步幅s：</p>
<ul>
<li><p>转置卷积：n‘=sn+k-2p-s</p>
</li>
<li><p>卷积：n’=[(n-k-2p+s)/s]向下取整</p>
</li>
</ul>
</li>
<li><p>如果让高宽成倍增加，那么k=2p+s</p>
</li>
</ul>
</li>
<li><p>同反卷积的关系</p>
<ul>
<li>数学上的反卷积是指卷积的逆运算<ul>
<li>若Y=conv（X,K），那么X=deconv（Y,K）</li>
</ul>
</li>
<li>反卷积很少用在深度学习中<ul>
<li>我们说的反卷积神经网络指用了转置卷积的神经网络</li>
</ul>
</li>
</ul>
</li>
<li><p>总结</p>
<ul>
<li>转置卷积是一种变化了输入和核的卷积，来得到上采用的目的</li>
<li>不等同于数学上的反卷积操作</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>46.语义分割</title>
    <url>/2024/04/23/11-01-46/</url>
    <content><![CDATA[<h2 id="46-语义分割"><a href="#46-语义分割" class="headerlink" title="46 语义分割"></a>46 语义分割</h2><h3 id="1-语义分割"><a href="#1-语义分割" class="headerlink" title="1.语义分割"></a>1.语义分割</h3><p>有时只能实现框选的目标检测还是太粗糙了，无法得到更精细的信息。语义分割将图片中的每个像素分类到对应的类别。</p>
<p>分割这一概念在计算机视觉中由来已久。最早的图片分割对给定图片使用聚类等方法把语义上比较像的像素放在一起，但通常不会告诉我们这些像素到底是什么。而语义分割可以告诉我们每个像素对应的label是什么。</p>
<p>这也意味着我们需要对图片的每一个像素都做label，使得语义分割成为了一个比较精细且大的任务。语义分割的数据集成本也较高，往往规模小像素高。常用的数据集之一是Pascal VOC2012。</p>
<img src="/2024/04/23/11-01-46/46-01.jpg" class>
<h3 id="2-应用"><a href="#2-应用" class="headerlink" title="2.应用"></a>2.应用</h3><p>背景虚化：传统的背景替换往往采用绿幕。在没有绿幕的情况下传统相机可以通过光圈来实现背景虚化，对于手机等设备而言背景虚化通常使用的都是语义分割或结合图像景深信息。</p>
<p>路面分割：如无人驾驶时用于实时识别周围物体，实现找路的功能。</p>
<h3 id="3-实例分割"><a href="#3-实例分割" class="headerlink" title="3.实例分割"></a>3.实例分割</h3><p>语义分割只关心像素属于哪一类，而实例分割则更进一步，如图片里有两只狗，则需要得出哪个像素属于哪一只狗。可以将其理解为目标检测的进化版本。</p>
<img src="/2024/04/23/11-01-46/46-02.png" class>
<h3 id="4-QA"><a href="#4-QA" class="headerlink" title="4.QA"></a>4.QA</h3><p>Q1: 能否做更细的语义分割如狗的头/身/腿？</p>
<blockquote>
<p>可以，有标注数据即可，不过可能会出现不同标注者对身体部位分界不同之类的问题。针对狗头这一例子可以考虑使用姿态识别得到关节点。</p>
</blockquote>
<p>Q2: 目标检测里做图像增广，目标框做对应变换后不再是矩形怎么办？</p>
<blockquote>
<p>如果很关心角度信息可以给框加入一个表示旋转角度的feature，也可以考虑在旋转后的原框外面画一个大框把它圈起来，这个大框是可以计算出来的。</p>
</blockquote>
<p>Q3: 把人像语义分割做到slides中的效果大概需要多少训练集？</p>
<blockquote>
<p>人像这块技术相对比较成熟，应该能找到很好的预训练模型在其基础上调整即可。人像的形状是比较容易做的，难点主要在于光照不同（可能使背景与人像/衣服模糊）</p>
</blockquote>
<p>Q4: 三维语义分割标注怎么做？</p>
<blockquote>
<p>（这里把三维理解成有景深的图片）一个简单的做法是把图片压缩成2维，也可以使用三维卷积。三维的分割实际上是好做的，因为一个物体的像素景深往往是连续的且与背景差距较大。</p>
</blockquote>
<p>Q5: 自动驾驶用语义分割，实例分割还是目标检测更合适？</p>
<blockquote>
<p>自动驾驶需要用到大量不同的模型，语义分割主要用于路面分割，目标检测用于检测前车/行人及其距离/速度。</p>
</blockquote>
<p>Q6: 语义分割有什么标注工具？</p>
<blockquote>
<p>国内外的数据标注公司会有这方面的平台，可以自己找找，老师认为这个比较简单，工具大同小异。</p>
<p>（弹幕提及较多：labelme）</p>
</blockquote>
<p>Q7: 摄像头怕过曝，逆光相关</p>
<blockquote>
<p>过曝不常见，但欠曝在光线不足时很常见，一种方法是做大量数据增广。逆光更难做一点，不过photoshop可以模拟出逆光效果用于数据增强，也可以在采集数据时采集一些逆光照片，检查低置信度的照片确认是否为逆光，之后加以标注对模型重新训练。这样的方法可能会涉及到数据隐私问题。</p>
</blockquote>
<p>Q8: 自动驾驶用纯视觉方案能不能做到很可靠？</p>
<blockquote>
<p>tesla做的就是纯视觉，国内/Google用激光雷达（贵但精准），此外大家都会用摄像头和雷达。老师的广电是使用纯摄像头方案一方面是因为技术团队在这方面有积累，另一个可能的原因是摄像头便宜，第三个原因是tesla的算力很大能很好处理大量摄像头信息，最后是Tesla有大量的数据积累，大量的数据可以弥补传感器方面的劣势。</p>
<p>理论上纯视觉自动驾驶是可行的，但目前只有Tesla做的还算可靠。</p>
</blockquote>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>44.物体检测算法：R-CNN,SSD,YOLO</title>
    <url>/2024/04/23/11-01-44/</url>
    <content><![CDATA[<h2 id="44-物体检测算法：R-CNN-SSD-YOLO"><a href="#44-物体检测算法：R-CNN-SSD-YOLO" class="headerlink" title="44.物体检测算法：R-CNN,SSD,YOLO"></a>44.物体检测算法：R-CNN,SSD,YOLO</h2><h3 id="1-区域卷积神经网络"><a href="#1-区域卷积神经网络" class="headerlink" title="1.区域卷积神经网络"></a>1.区域卷积神经网络</h3><h4 id="1-1-R-CNN"><a href="#1-1-R-CNN" class="headerlink" title="1.1.R-CNN"></a>1.1.R-CNN</h4><ul>
<li>使用启发式搜索算法来选择锚框</li>
<li>使用预训练模型来对每个锚框抽取特征（每个锚框当作一个图片，用CNN）</li>
<li>训练一个SVM来类别分类（神经网络之前，category prediction）</li>
<li>训练一个线性回归模型来预测边缘框偏移（bounding box prediction）</li>
<li>兴趣区域（Rol）池化层<ul>
<li>给定一个锚框，均匀分割（如果没法均匀分割，取整）成 n x m 块，输出每块的最大值（max pooling）</li>
<li>不管锚框多大，总是输出nm个值</li>
<li>目的：每个锚框都可以变成想要的形状</li>
</ul>
</li>
</ul>
<h4 id="1-2-Fast-RCNN"><a href="#1-2-Fast-RCNN" class="headerlink" title="1.2 Fast RCNN"></a>1.2 Fast RCNN</h4><ul>
<li><p>RCNN需要对每个锚框进行CNN运算，这些特征抽取计算有重复，并且锚框数量大，特征抽取的计算量也大。Fast RCNN改进了这种计算量大的问题</p>
</li>
<li><p>使用CNN对整张图片抽取特征（快的关键）</p>
</li>
<li><p>使用Rol池化层对每个锚框（将在原图片中搜索到的锚框，映射到CNN得到的结果上），生成固定长度的特征</p>
</li>
</ul>
<img src="/2024/04/23/11-01-44/44-01.png" class>
<h4 id="1-3-Faster-RCNN"><a href="#1-3-Faster-RCNN" class="headerlink" title="1.3 Faster RCNN"></a>1.3 Faster RCNN</h4><ul>
<li>在Fast RCNN基础上变得更快</li>
<li>使用一个 <strong>区域提议网络来替代启发式搜索获得更好的锚框</strong></li>
<li>如下图所示，将CNN结果输入到卷积层，然后用锚框去圈区域，这些锚框很多有好有坏，然后进行预测，binary 预测是预测这个锚框的好坏，即有没有有效的圈住物体，bounding box prediction预测是对锚框进行一些改进，最后用NMS（非极大值抑制）对锚框进行合并。</li>
<li>具体来说，区域提议网络的计算步骤如下：<ol>
<li>使用填充为1的3×3的卷积层变换卷积神经网络的输出，并将输出通道数记为c。这样，卷积神经网络为图像抽取的特征图中的每个单元均得到一个长度为c的新特征。</li>
<li>以特征图的每个像素为中心，生成多个不同大小和宽高比的锚框并标注它们。</li>
<li>使用锚框中心单元长度为c的特征，分别预测该锚框的二元类别（含目标还是背景）和边界框。</li>
<li>使用非极大值抑制，从预测类别为目标的预测边界框中移除相似的结果。最终输出的预测边界框即是兴趣区域汇聚层所需的提议区域。</li>
</ol>
</li>
</ul>
<img src="/2024/04/23/11-01-44/44-02.png" class>
<h4 id="1-4-Mask-RCNN"><a href="#1-4-Mask-RCNN" class="headerlink" title="1.4 Mask RCNN"></a>1.4 Mask RCNN</h4><ul>
<li>如果有<strong>像素级别的标号</strong>，使用FCN（fully convolutional network）利用这些信息。可以提升CNN的性能</li>
<li><strong>Rol align</strong>。之前的Rol进行池化的时候，如果没法整除，可以直接取整。但是像素级别的标号预测的时候，会造成偏差的累积，导致边界预测不准确。未来避免这种情况，使用Rol align，也就是当没法整除，对每个像素值进行按比例分配。</li>
<li>具体来说，Mask R-CNN将兴趣区域汇聚层替换为了<em>兴趣区域对齐</em>层，使用<em>双线性插值</em>（bilinear interpolation）来保留特征图上的空间信息，从而更适于像素级预测。 兴趣区域对齐层的输出包含了所有与兴趣区域的形状相同的特征图。 它们不仅被用于预测每个兴趣区域的类别和边界框，还通过额外的全卷积网络预测目标的像素级位置。</li>
</ul>
<img src="/2024/04/23/11-01-44/44-03.png" class>
<h4 id="1-5-总结"><a href="#1-5-总结" class="headerlink" title="1.5 总结"></a>1.5 总结</h4><ul>
<li>R-CNN是最早也是最有名的一类基于锚框和CNN的目标检测算法</li>
<li>Fast/Faster RCNN 持续提升性能</li>
<li>Faster RCNN和Mask RCNN是在要求高精度场景下常用的算法（但是速度是最慢的）</li>
</ul>
<h3 id="2-单发多框检测（SSD-single-shot-detection）"><a href="#2-单发多框检测（SSD-single-shot-detection）" class="headerlink" title="2. 单发多框检测（SSD single shot detection）"></a>2. 单发多框检测（SSD single shot detection）</h3><ul>
<li>生成锚框<ul>
<li>对每个像素，生成多个以它为中心的锚框</li>
<li>给定 n 个大小$s_1,…,s_n$和m个高宽比，生成n+m-1个锚框，其大小和高宽比分别为：$(s_1,r_1),(s_2,r_1)…,(s_n,r_1),(s_1,r_2),…,(s_1,r_m)$</li>
</ul>
</li>
<li>SSD模型<ul>
<li>对多个分辨率下的卷积特征，生成锚框，预测</li>
<li>一个基础网络，抽取特征，然后用多个卷积层来减半高宽</li>
<li>在每段都生成锚框<ul>
<li>底部段拟合小物体</li>
<li>顶部段拟合大物体</li>
</ul>
</li>
<li>对每个锚框预测类别和边缘框</li>
</ul>
</li>
</ul>
<img src="/2024/04/23/11-01-44/44-04.png" class>
<ul>
<li>总结<ul>
<li>速度快，精度很低。这么多年，作者没有持续的提升，但是启发了后面的一系列工作，实现上相对比较简单。</li>
<li>SSD通过单神经网络来检测模型（single shot）</li>
<li>以像素为中心的产生多个锚框</li>
<li>在多个段的输出上进行多尺度的检测</li>
</ul>
</li>
</ul>
<h3 id="3-YOLO（you-only-look-once）"><a href="#3-YOLO（you-only-look-once）" class="headerlink" title="3. YOLO（you only look once）"></a>3. YOLO（you only look once）</h3><ul>
<li>SSD中锚框大量重复，因此浪费了很多计算资源</li>
<li>YOLO将图片均分为 S X S 个锚框</li>
<li>每个锚框预测 B 个边缘框（防止多个物体出现在一个锚框里面）</li>
<li>后续版本 v2 v3 v4 有持续改进</li>
<li>非锚框算法</li>
</ul>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>43-树叶分类竞赛技术总结</title>
    <url>/2024/04/23/11-01-43/</url>
    <content><![CDATA[<h2 id="43-树叶分类竞赛技术总结"><a href="#43-树叶分类竞赛技术总结" class="headerlink" title="43-树叶分类竞赛技术总结"></a>43-树叶分类竞赛技术总结</h2><h3 id="1-比赛结果"><a href="#1-比赛结果" class="headerlink" title="1. 比赛结果"></a>1. 比赛结果</h3><ul>
<li>176类，18353训练样本</li>
</ul>
<img src="/2024/04/23/11-01-43/43-01.png" class>
<ul>
<li>165只队伍参加<ul>
<li>41只队伍精度 &gt; 98% (非常好)</li>
<li>83只队伍精度 &gt; 95% (够用)</li>
</ul>
</li>
</ul>
<h3 id="2-结果分析"><a href="#2-结果分析" class="headerlink" title="2. 结果分析"></a>2. 结果分析</h3><ul>
<li><p>16只队伍提供了代码：</p>
<ul>
<li><a href="https://www.kaggle.com/c/classify-leaves/code">Classify Leaves | Kaggle</a></li>
</ul>
</li>
<li><p>额外加上Neko Kiku</p>
<ul>
<li>很多人参考了此代码 <a href="https://www.kaggle.com/nekokiku/simple-resnet-baseline">simple resnet baseline | Kaggle</a></li>
</ul>
</li>
</ul>
<h3 id="3-技术分析"><a href="#3-技术分析" class="headerlink" title="3. 技术分析"></a>3. 技术分析</h3><p>相比于课程介绍的代码，同学们主要做了下面这些加强：</p>
<ul>
<li><p><strong>数据增强</strong>，在测试时多次使用稍弱的增强然后取平均</p>
</li>
<li><p>使用<strong>多个模型</strong>预测，最后结果加权平均</p>
<ul>
<li>有使用10种模型的，也有使用单一模型的</li>
</ul>
</li>
<li><strong>训练算法</strong>和<strong>学习率</strong></li>
<li><strong>清理数据</strong></li>
</ul>
<h3 id="4-模型方面"><a href="#4-模型方面" class="headerlink" title="4. 模型方面"></a>4. 模型方面</h3><ul>
<li><p>模型多为ResNet变种</p>
<ul>
<li>DenseNet，ResNeXt，ResNeSt,  …</li>
<li>EfficientNet</li>
</ul>
</li>
<li><p>优化算法多为Adam或其变种</p>
</li>
<li>学习率一般是Cosine或者训练不动时往下调</li>
</ul>
<h3 id="5-AutoGluon"><a href="#5-AutoGluon" class="headerlink" title="5. AutoGluon"></a>5. AutoGluon</h3><ul>
<li>15行代码， 安装加训练耗时100分钟<ul>
<li><a href="https://www.kaggle.com/zhreshold/autogluon-vision-0-96-with-15-lines">AutoGluon.vision: 0.96+ with 15 lines | Kaggle</a></li>
</ul>
</li>
<li>精度96%<ul>
<li>可以通过定制化提升精度</li>
<li>下一个版本将搜索更多的模型超参数</li>
<li>AG目前主要仍是关注工业界应用上，而非比赛</li>
</ul>
</li>
</ul>
<h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h3><ul>
<li>提升精度思路：根据数据挑选增强，使用新模型、新优化算法，多个模型融合，测试时使用增强</li>
<li>数据相对简单，排名有相对随机性</li>
<li>在工业界应用中：<ul>
<li>少使用模型融合和测试时增强，计算代价过高</li>
<li>通常固定模型超参数，而将精力主要花在提升数据质量</li>
</ul>
</li>
</ul>
<p>比赛/学术界：固定数据，调模型</p>
<p>工业界：固定模型，调数据</p>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>41-物体检测和数据集</title>
    <url>/2024/04/23/11-01-41/</url>
    <content><![CDATA[<h3 id="41-物体检测和数据集"><a href="#41-物体检测和数据集" class="headerlink" title="41 物体检测和数据集"></a>41 物体检测和数据集</h3><h4 id="物体检测"><a href="#物体检测" class="headerlink" title="物体检测"></a>物体检测</h4><ol>
<li>图片分类和目标检测在任务上的区别：图片分类已知有一个确定目标，任务是识别该目标属于何种分类，而目标检测不仅需要检测出图片中所有感兴趣的目标类别，并确定其位置，所以目标检测要比图片分类更复杂应用场景更广。</li>
<li>图片分类和目标检测在数据集上的区别：由于目标检测中每一张图片可能存在多个目标，每个目标我们不仅需要分类，还需要确定边缘框以给出目标位置信息，因此目标检测数据集的标注成本要显著高于图片分类，也就导致了目标检测数据集较小。</li>
<li>边缘框：用一个尽量小矩形框将目标物体大体框起来，边框的位置信息就可以表示目标位置在图片中的位置信息，常见的边缘框有两种表示方法：</li>
</ol>
<ul>
<li>（左上x，左上y，右下x，右下y）</li>
<li>（左上x，左上y，宽，高）</li>
</ul>
<ol>
<li>目标检测数据集的常见表示：每一行表示一个物体，对于每一个物体而言，用“图片文件名，物体类别，边缘框”表示，由于边缘框用4个数值表示，因此对于每一行的那一个物体而言，需要用6个数值表示。</li>
<li>目标检测领域常用数据集：COCO（80类物体，330K图片，所有图片共标注1.5M物体）</li>
</ol>
<h4 id="边缘框实现"><a href="#边缘框实现" class="headerlink" title="边缘框实现"></a>边缘框实现</h4><ol>
<li>目标的位置</li>
</ol>
<p>在图像分类任务中，我们假设图像中只有一个主要物体对象，我们只关注如何识别其类别。 然而，很多时候图像里有多个我们感兴趣的目标，我们不仅想知道它们的类别，还想得到它们在图像中的具体位置。 在计算机视觉里，我们将这类任务称为<em>目标检测</em>（object detection）或<em>目标识别</em>（object recognition）。目标检测在多个领域中被广泛使用。 例如，在无人驾驶里，我们需要通过识别拍摄到的视频图像里的车辆、行人、道路和障碍物的位置来规划行进线路。 机器人也常通过该任务来检测感兴趣的目标。安防领域则需要检测异常目标，如歹徒或者炸弹。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面加载本节将使用的示例图像。可以看到图像左边是一只狗，右边是一只猫。 它们是这张图像里的两个主要目标。</span></span><br><span class="line"></span><br><span class="line">d2l.set_figsize()</span><br><span class="line">img = d2l.plt.imread(<span class="string">&#x27;../img/catdog.jpg&#x27;</span>)</span><br><span class="line">d2l.plt.imshow(img);</span><br></pre></td></tr></table></figure>
<ol>
<li>边界框</li>
</ol>
<ul>
<li><p>在目标检测中，我们通常使用<em>边界框</em>（bounding box）来描述对象的空间位置。 边界框是矩形的，由矩形左上角的以及右下角的<em>x</em>和<em>y</em>坐标决定。 另一种常用的边界框表示方法是边界框中心的(<em>x</em>,<em>y</em>)轴坐标以及框的宽度和高度。</p>
</li>
<li><p>在这里，我们定义在这两种表示法之间进行转换的函数：<code>box_corner_to_center</code>从两角表示法转换为中心宽度表示法，而<code>box_center_to_corner</code>反之亦然。 输入参数<code>boxes</code>可以是长度为4的张量，也可以是形状为（<em>n</em>，4）的二维张量，其中<em>n</em>是边界框的数量。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">box_corner_to_center</span>(<span class="params">boxes</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;从（左上，右下）转换到（中间，宽度，高度）&quot;&quot;&quot;</span></span><br><span class="line">    x1, y1, x2, y2 = boxes[:, <span class="number">0</span>], boxes[:, <span class="number">1</span>], boxes[:, <span class="number">2</span>], boxes[:, <span class="number">3</span>]</span><br><span class="line">    cx = (x1 + x2) / <span class="number">2</span></span><br><span class="line">    cy = (y1 + y2) / <span class="number">2</span></span><br><span class="line">    w = x2 - x1</span><br><span class="line">    h = y2 - y1</span><br><span class="line">    boxes = torch.stack((cx, cy, w, h), axis=-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> boxes</span><br><span class="line"></span><br><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">box_center_to_corner</span>(<span class="params">boxes</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;从（中间，宽度，高度）转换到（左上，右下）&quot;&quot;&quot;</span></span><br><span class="line">    cx, cy, w, h = boxes[:, <span class="number">0</span>], boxes[:, <span class="number">1</span>], boxes[:, <span class="number">2</span>], boxes[:, <span class="number">3</span>]</span><br><span class="line">    x1 = cx - <span class="number">0.5</span> * w</span><br><span class="line">    y1 = cy - <span class="number">0.5</span> * h</span><br><span class="line">    x2 = cx + <span class="number">0.5</span> * w</span><br><span class="line">    y2 = cy + <span class="number">0.5</span> * h</span><br><span class="line">    boxes = torch.stack((x1, y1, x2, y2), axis=-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> boxes</span><br></pre></td></tr></table></figure>
<ul>
<li>我们将根据坐标信息定义图像中狗和猫的边界框。 图像中坐标的原点是图像的左上角，向右的方向为<em>x</em>轴的正方向，向下的方向为<em>y</em>轴的正方向。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># bbox是边界框的英文缩写</span></span><br><span class="line">dog_bbox, cat_bbox = [<span class="number">60.0</span>, <span class="number">45.0</span>, <span class="number">378.0</span>, <span class="number">516.0</span>], [<span class="number">400.0</span>, <span class="number">112.0</span>, <span class="number">655.0</span>, <span class="number">493.0</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>我们可以将边界框在图中画出，以检查其是否准确。 画之前，我们定义一个辅助函数<code>bbox_to_rect</code>。 它将边界框表示成<code>matplotlib</code>的边界框格式。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bbox_to_rect</span>(<span class="params">bbox, color</span>):</span><br><span class="line">    <span class="comment"># 将边界框(左上x,左上y,右下x,右下y)格式转换成matplotlib格式：</span></span><br><span class="line">    <span class="comment"># ((左上x,左上y),宽,高)</span></span><br><span class="line">    <span class="keyword">return</span> d2l.plt.Rectangle(</span><br><span class="line">        xy=(bbox[<span class="number">0</span>], bbox[<span class="number">1</span>]), width=bbox[<span class="number">2</span>]-bbox[<span class="number">0</span>], height=bbox[<span class="number">3</span>]-bbox[<span class="number">1</span>],</span><br><span class="line">        fill=<span class="literal">False</span>, edgecolor=color, linewidth=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>在图像上添加边界框之后，我们可以看到两个物体的主要轮廓基本上在两个框内。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig = d2l.plt.imshow(img)</span><br><span class="line">fig.axes.add_patch(bbox_to_rect(dog_bbox, <span class="string">&#x27;blue&#x27;</span>))</span><br><span class="line">fig.axes.add_patch(bbox_to_rect(cat_bbox, <span class="string">&#x27;red&#x27;</span>));</span><br></pre></td></tr></table></figure>
<ol>
<li>小结</li>
</ol>
<ul>
<li>目标检测不仅可以识别图像中所有感兴趣的物体，还能识别它们的位置，该位置通常由矩形边界框表示。</li>
<li>我们可以在两种常用的边界框表示（中间，宽度，高度）和（左上，右下）坐标之间进行转换。</li>
</ul>
<h4 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h4><p>目标检测领域没有像MNIST和Fashion-MNIST那样的小数据集。 为了快速测试目标检测模型，我们收集并标记了一个小型数据集。 首先，我们拍摄了一组香蕉的照片，并生成了1000张不同角度和大小的香蕉图像。 然后，我们在一些背景图片的随机位置上放一张香蕉的图像。 最后，我们在图片上为这些香蕉标记了边界框。</p>
<ol>
<li>下载数据集</li>
</ol>
<ul>
<li>包含所有图像和CSV标签文件的香蕉检测数据集可以直接从互联网下载。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> mxnet <span class="keyword">import</span> gluon, image, np, npx</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> mxnet <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line">npx.set_np()</span><br><span class="line"></span><br><span class="line"><span class="comment">#@save</span></span><br><span class="line">d2l.DATA_HUB[<span class="string">&#x27;banana-detection&#x27;</span>] = (</span><br><span class="line">    d2l.DATA_URL + <span class="string">&#x27;banana-detection.zip&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;5de26c8fce5ccdea9f91267273464dc968d20d72&#x27;</span>)</span><br></pre></td></tr></table></figure>
<ol>
<li>读取数据集</li>
</ol>
<ul>
<li>通过<code>read_data_bananas</code>函数，我们读取香蕉检测数据集。 该数据集包括一个的CSV文件，内含目标类别标签和位于左上角和右下角的真实边界框坐标。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_data_bananas</span>(<span class="params">is_train=<span class="literal">True</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;读取香蕉检测数据集中的图像和标签&quot;&quot;&quot;</span></span><br><span class="line">    data_dir = d2l.download_extract(<span class="string">&#x27;banana-detection&#x27;</span>)</span><br><span class="line">    csv_fname = os.path.join(data_dir, <span class="string">&#x27;bananas_train&#x27;</span> <span class="keyword">if</span> is_train</span><br><span class="line">                             <span class="keyword">else</span> <span class="string">&#x27;bananas_val&#x27;</span>, <span class="string">&#x27;label.csv&#x27;</span>)</span><br><span class="line">    csv_data = pd.read_csv(csv_fname)</span><br><span class="line">    csv_data = csv_data.set_index(<span class="string">&#x27;img_name&#x27;</span>)</span><br><span class="line">    images, targets = [], []</span><br><span class="line">    <span class="keyword">for</span> img_name, target <span class="keyword">in</span> csv_data.iterrows():</span><br><span class="line">        images.append(torchvision.io.read_image(</span><br><span class="line">            os.path.join(data_dir, <span class="string">&#x27;bananas_train&#x27;</span> <span class="keyword">if</span> is_train <span class="keyword">else</span></span><br><span class="line">                         <span class="string">&#x27;bananas_val&#x27;</span>, <span class="string">&#x27;images&#x27;</span>, <span class="string">f&#x27;<span class="subst">&#123;img_name&#125;</span>&#x27;</span>)))</span><br><span class="line">        <span class="comment"># 这里的target包含（类别，左上角x，左上角y，右下角x，右下角y），</span></span><br><span class="line">        <span class="comment"># 其中所有图像都具有相同的香蕉类（索引为0）</span></span><br><span class="line">        targets.append(<span class="built_in">list</span>(target))</span><br><span class="line">    <span class="keyword">return</span> images, torch.tensor(targets).unsqueeze(<span class="number">1</span>) / <span class="number">256</span></span><br></pre></td></tr></table></figure>
<ul>
<li>通过使用<code>read_data_bananas</code>函数读取图像和标签，以下<code>BananasDataset</code>类别将允许我们创建一个自定义<code>Dataset</code>实例来加载香蕉检测数据集。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BananasDataset</span>(torch.utils.data.Dataset):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;一个用于加载香蕉检测数据集的自定义数据集&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, is_train</span>):</span><br><span class="line">        self.features, self.labels = read_data_bananas(is_train)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;read &#x27;</span> + <span class="built_in">str</span>(<span class="built_in">len</span>(self.features)) + (<span class="string">f&#x27; training examples&#x27;</span> <span class="keyword">if</span></span><br><span class="line">              is_train <span class="keyword">else</span> <span class="string">f&#x27; validation examples&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, idx</span>):</span><br><span class="line">        <span class="keyword">return</span> (self.features[idx].<span class="built_in">float</span>(), self.labels[idx])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.features)</span><br></pre></td></tr></table></figure>
<ul>
<li>最后，我们定义<code>load_data_bananas</code>函数，来为训练集和测试集返回两个数据加载器实例。对于测试集，无须按随机顺序读取它。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_data_bananas</span>(<span class="params">batch_size</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;加载香蕉检测数据集&quot;&quot;&quot;</span></span><br><span class="line">    train_iter = torch.utils.data.DataLoader(BananasDataset(is_train=<span class="literal">True</span>),</span><br><span class="line">                                             batch_size, shuffle=<span class="literal">True</span>)</span><br><span class="line">    val_iter = torch.utils.data.DataLoader(BananasDataset(is_train=<span class="literal">False</span>),</span><br><span class="line">                                           batch_size)</span><br><span class="line">    <span class="keyword">return</span> train_iter, val_iter</span><br></pre></td></tr></table></figure>
<ul>
<li>让我们读取一个小批量，并打印其中的图像和标签的形状。 图像的小批量的形状为（批量大小、通道数、高度、宽度），看起来很眼熟：它与我们之前图像分类任务中的相同。 标签的小批量的形状为（批量大小，<em>m</em>，5），其中<em>m</em>是数据集的任何图像中边界框可能出现的最大数量。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">batch_size, edge_size = <span class="number">32</span>, <span class="number">256</span></span><br><span class="line">train_iter, _ = load_data_bananas(batch_size)</span><br><span class="line">batch = <span class="built_in">next</span>(<span class="built_in">iter</span>(train_iter))</span><br><span class="line">batch[<span class="number">0</span>].shape, batch[<span class="number">1</span>].shape</span><br></pre></td></tr></table></figure>
<ol>
<li>小结</li>
</ol>
<ul>
<li>我们收集的香蕉检测数据集可用于演示目标检测模型。</li>
<li>用于目标检测的数据加载与图像分类的数据加载类似。但是，在目标检测中，标签还包含真实边界框的信息，它不出现在图像分类中。</li>
</ul>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>39-实战kaggle竞赛：CIFAR-10</title>
    <url>/2024/04/23/11-01-39/</url>
    <content><![CDATA[<h1 id="CIFAR-10"><a href="#CIFAR-10" class="headerlink" title="CIFAR-10"></a>CIFAR-10</h1><p>首先，导入竞赛所需要的包和模块：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br></pre></td></tr></table></figure>
<h4 id="2-1-下载数据集："><a href="#2-1-下载数据集：" class="headerlink" title="2.1 下载数据集："></a>2.1 下载数据集：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#@save</span></span><br><span class="line">d2l.DATA_HUB[<span class="string">&#x27;cifar10_tiny&#x27;</span>] = (d2l.DATA_URL + <span class="string">&#x27;kaggle_cifar10_tiny.zip&#x27;</span>,</span><br><span class="line">                                <span class="string">&#x27;2068874e4b9a9f0fb07ebe0ad2b29754449ccacd&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果你使用完整的Kaggle竞赛的数据集，设置demo为False</span></span><br><span class="line">demo = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> demo:</span><br><span class="line">    data_dir = d2l.download_extract(<span class="string">&#x27;cifar10_tiny&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    data_dir = <span class="string">&#x27;../data/cifar-10/&#x27;</span></span><br></pre></td></tr></table></figure>
<p>为了便于入门，我们提供包含前1000个训练图像和5个随机测试图像的数据集的小规模样本，如果要获取完整数据集，你需要将一下demo变量设置为False</p>
<h4 id="2-2-整理数据集"><a href="#2-2-整理数据集" class="headerlink" title="2.2 整理数据集"></a>2.2 整理数据集</h4><p>首先我们用以下函数读取CSV文件中的标签，它返回一个字典，该字典将文件名中不带拓展名德部分映射到其标签。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">read_csv_labels</span>(<span class="params">fname</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;读取fname来给标签字典返回一个文件名&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(fname, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="comment"># 跳过文件头行(列名)</span></span><br><span class="line">        lines = f.readlines()[<span class="number">1</span>:]</span><br><span class="line">    tokens = [</span><br><span class="line">        <span class="comment"># 训练样本 : 1000l.rstrip().split(&#x27;,&#x27;) for l in lines]</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dict</span>(((name, label) <span class="keyword">for</span> name, label <span class="keyword">in</span> tokens))</span><br><span class="line"></span><br><span class="line">labels = read_csv_labels(os.path.join(data_dir, <span class="string">&#x27;trainLabels.csv&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;# 训练样本 :&#x27;</span>, <span class="built_in">len</span>(labels))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;# 类别 :&#x27;</span>, <span class="built_in">len</span>(<span class="built_in">set</span>(labels.values())))</span><br><span class="line"><span class="comment"># 训练样本 : 1000</span></span><br><span class="line"><span class="comment"># 类别 : 10</span></span><br></pre></td></tr></table></figure>
<p>接下来，我们定义reorg_train_valid函数来将验证集从原始的训练集中拆分出来。此函数中的参数valid_ratio是验证集中的样本数与原始训练集中的样本数之比。更具体的说，令n等于样本最少的类别中的图像数量，而r是比率。验证集将为每个类别拆分出max([nr],1)张图像。让我们以valid_ratio=0.1为例，由于原始的训练集有50000张图像，因此trian_valid_test/train路径中将有45000张图像用于训练，而剩下5000张图像将作为路径train_valid_test/valid中的验证集。组织数据集后，同类别的图像将被放置在同一文件夹下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">copyfile</span>(<span class="params">filename, target_dir</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;将文件复制到目标目录&quot;&quot;&quot;</span></span><br><span class="line">    os.makedirs(target_dir, exist_ok=<span class="literal">True</span>)</span><br><span class="line">    shutil.copy(filename, target_dir)</span><br><span class="line"></span><br><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reorg_train_valid</span>(<span class="params">data_dir, labels, valid_ratio</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;将验证集从原始的训练集中拆分出来&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 训练数据集中样本最少的类别中的样本数</span></span><br><span class="line">    n = collections.Counter(labels.values()).most_common()[-<span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line">    <span class="comment"># 验证集中每个类别的样本数</span></span><br><span class="line">    n_valid_per_label = <span class="built_in">max</span>(<span class="number">1</span>, math.floor(n * valid_ratio))</span><br><span class="line">    label_count = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> train_file <span class="keyword">in</span> os.listdir(os.path.join(data_dir, <span class="string">&#x27;train&#x27;</span>)):</span><br><span class="line">        label = labels[train_file.split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">0</span>]]</span><br><span class="line">        fname = os.path.join(data_dir, <span class="string">&#x27;train&#x27;</span>, train_file)</span><br><span class="line">        copyfile(fname, os.path.join(data_dir, <span class="string">&#x27;train_valid_test&#x27;</span>,</span><br><span class="line">                                     <span class="string">&#x27;train_valid&#x27;</span>, label))</span><br><span class="line">        <span class="keyword">if</span> label <span class="keyword">not</span> <span class="keyword">in</span> label_count <span class="keyword">or</span> label_count[label] &lt; n_valid_per_label:</span><br><span class="line">            copyfile(fname, os.path.join(data_dir, <span class="string">&#x27;train_valid_test&#x27;</span>,</span><br><span class="line">                                         <span class="string">&#x27;valid&#x27;</span>, label))</span><br><span class="line">            label_count[label] = label_count.get(label, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            copyfile(fname, os.path.join(data_dir, <span class="string">&#x27;train_valid_test&#x27;</span>,</span><br><span class="line">                                         <span class="string">&#x27;train&#x27;</span>, label))</span><br><span class="line">    <span class="keyword">return</span> n_valid_per_label</span><br></pre></td></tr></table></figure>
<p>其中os.listdir显示指定路径下的文件和文件夹列表</p>
<p>下面的reorg_test函数用来预测期间整理测试集，以方便读取。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reorg_test</span>(<span class="params">data_dir</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;在预测期间整理测试集，以方便读取&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> test_file <span class="keyword">in</span> os.listdir(os.path.join(data_dir, <span class="string">&#x27;test&#x27;</span>)):</span><br><span class="line">        copyfile(os.path.join(data_dir, <span class="string">&#x27;test&#x27;</span>, test_file),</span><br><span class="line">                 os.path.join(data_dir, <span class="string">&#x27;train_valid_test&#x27;</span>, <span class="string">&#x27;test&#x27;</span>,</span><br><span class="line">                              <span class="string">&#x27;unknown&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>最后我们使用一个函数来调用前面定义的函数read_csv_labels，reorg_train_valid和reorg_test。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reorg_cifar10_data</span>(<span class="params">data_dir, valid_ratio</span>):</span><br><span class="line">    labels = read_csv_labels(os.path.join(data_dir, <span class="string">&#x27;trainLabels.csv&#x27;</span>))</span><br><span class="line">    reorg_train_valid(data_dir, labels, valid_ratio)</span><br><span class="line">    reorg_test(data_dir)</span><br></pre></td></tr></table></figure>
<p>在这里，我们只将样本数据集的批量大小设置为32.在实际训练和测试中，应该使用Kaggle竞赛的完整数据集，并将batch_size设置为更大的整数，例如128.我们将10%的训练样本作为调整超参数的验证集。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">batch_size = <span class="number">32</span> <span class="keyword">if</span> demo <span class="keyword">else</span> <span class="number">128</span></span><br><span class="line">valid_ratio = <span class="number">0.1</span></span><br><span class="line">reorg_cifar10_data(data_dir, valid_ratio)</span><br></pre></td></tr></table></figure>
<h3 id="3-图像增广"><a href="#3-图像增广" class="headerlink" title="3.图像增广"></a>3.图像增广</h3><p>使用图像增广来解决过拟合问题。在训练中，我们可以随机水平翻转图像。我们可以对彩色图像的三个RGB通道执行标准化。下面为一些可以调整的操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">transform_train = torchvision.transforms.Compose([</span><br><span class="line">    <span class="comment"># 在高度和宽度上将图像放大到40像素的正方形</span></span><br><span class="line">    torchvision.transforms.Resize(<span class="number">40</span>),</span><br><span class="line">    <span class="comment"># 随机裁剪出一个高度和宽度均为40像素的正方形图像，</span></span><br><span class="line">    <span class="comment"># 生成一个面积为原始图像面积0.64到1倍的小正方形，</span></span><br><span class="line">    <span class="comment"># 然后将其缩放为高度和宽度均为32像素的正方形</span></span><br><span class="line">    torchvision.transforms.RandomResizedCrop(<span class="number">32</span>, scale=(<span class="number">0.64</span>, <span class="number">1.0</span>),</span><br><span class="line">                                                   ratio=(<span class="number">1.0</span>, <span class="number">1.0</span>)),</span><br><span class="line">    torchvision.transforms.RandomHorizontalFlip(),</span><br><span class="line">    torchvision.transforms.ToTensor(),</span><br><span class="line">    <span class="comment"># 标准化图像的每个通道</span></span><br><span class="line">    torchvision.transforms.Normalize([<span class="number">0.4914</span>, <span class="number">0.4822</span>, <span class="number">0.4465</span>],</span><br><span class="line">                                     [<span class="number">0.2023</span>, <span class="number">0.1994</span>, <span class="number">0.2010</span>])])</span><br></pre></td></tr></table></figure>
<p>在测试期间，我们只对图像执行标准化，以消除评估结果中的随机性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">transform_test = torchvision.transforms.Compose([</span><br><span class="line">    torchvision.transforms.ToTensor(),</span><br><span class="line">    torchvision.transforms.Normalize([<span class="number">0.4914</span>, <span class="number">0.4822</span>, <span class="number">0.4465</span>],</span><br><span class="line">                                     [<span class="number">0.2023</span>, <span class="number">0.1994</span>, <span class="number">0.2010</span>])])</span><br></pre></td></tr></table></figure>
<h3 id="4-读取数据集"><a href="#4-读取数据集" class="headerlink" title="4.读取数据集"></a>4.读取数据集</h3><p>读取由原始图像组成的数据集，每个样本都包括一张图片和一个标签。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_ds, train_valid_ds = [torchvision.datasets.ImageFolder(</span><br><span class="line">    os.path.join(data_dir, <span class="string">&#x27;train_valid_test&#x27;</span>, folder),</span><br><span class="line">    transform=transform_train) <span class="keyword">for</span> folder <span class="keyword">in</span> [<span class="string">&#x27;train&#x27;</span>, <span class="string">&#x27;train_valid&#x27;</span>]]</span><br><span class="line"></span><br><span class="line">valid_ds, test_ds = [torchvision.datasets.ImageFolder(</span><br><span class="line">    os.path.join(data_dir, <span class="string">&#x27;train_valid_test&#x27;</span>, folder),</span><br><span class="line">    transform=transform_test) <span class="keyword">for</span> folder <span class="keyword">in</span> [<span class="string">&#x27;valid&#x27;</span>, <span class="string">&#x27;test&#x27;</span>]]</span><br></pre></td></tr></table></figure>
<p>当验证集在超参数调整过程中用于模型评估中，不应引入图像增广的随机性。在最终预测之前，我们根据训练集合验证集组合而成的训练模型进行训练，以充分利用所有标记的数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_iter, train_valid_iter = [torch.utils.data.DataLoader(</span><br><span class="line">    dataset, batch_size, shuffle=<span class="literal">True</span>, drop_last=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">for</span> dataset <span class="keyword">in</span> (train_ds, train_valid_ds)]</span><br><span class="line"></span><br><span class="line">valid_iter = torch.utils.data.DataLoader(valid_ds, batch_size, shuffle=<span class="literal">False</span>,</span><br><span class="line">                                         drop_last=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">test_iter = torch.utils.data.DataLoader(test_ds, batch_size, shuffle=<span class="literal">False</span>,</span><br><span class="line">                                        drop_last=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<h3 id="5-定义模型"><a href="#5-定义模型" class="headerlink" title="5.定义模型"></a>5.定义模型</h3><p>直接使用Resnet-18模型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_net</span>():</span><br><span class="line">    num_classes = <span class="number">10</span></span><br><span class="line">    net = d2l.resnet18(num_classes, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> net</span><br><span class="line"></span><br><span class="line">loss = nn.CrossEntropyLoss(reduction=<span class="string">&quot;none&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="6-定义训练函数"><a href="#6-定义训练函数" class="headerlink" title="6.定义训练函数"></a>6.定义训练函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">net, train_iter, valid_iter, num_epochs, lr, wd, devices, lr_period,</span></span><br><span class="line"><span class="params">          lr_decay</span>):</span><br><span class="line">    trainer = torch.optim.SGD(net.parameters(), lr=lr, momentum=<span class="number">0.9</span>,</span><br><span class="line">                              weight_decay=wd)</span><br><span class="line">    scheduler = torch.optim.lr_scheduler.StepLR(trainer, lr_period, lr_decay)</span><br><span class="line">    num_batches, timer = <span class="built_in">len</span>(train_iter), d2l.Timer()</span><br><span class="line">    legend = [<span class="string">&#x27;train loss&#x27;</span>, <span class="string">&#x27;train acc&#x27;</span>]</span><br><span class="line">    <span class="keyword">if</span> valid_iter <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        legend.append(<span class="string">&#x27;valid acc&#x27;</span>)</span><br><span class="line">    animator = d2l.Animator(xlabel=<span class="string">&#x27;epoch&#x27;</span>, xlim=[<span class="number">1</span>, num_epochs],</span><br><span class="line">                            legend=legend)</span><br><span class="line">    net = nn.DataParallel(net, device_ids=devices).to(devices[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">        net.train()</span><br><span class="line">        metric = d2l.Accumulator(<span class="number">3</span>)</span><br><span class="line">        <span class="keyword">for</span> i, (features, labels) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_iter):</span><br><span class="line">            timer.start()</span><br><span class="line">            l, acc = d2l.train_batch_ch13(net, features, labels,</span><br><span class="line">                                          loss, trainer, devices)</span><br><span class="line">            metric.add(l, acc, labels.shape[<span class="number">0</span>])</span><br><span class="line">            timer.stop()</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span>) % (num_batches // <span class="number">5</span>) == <span class="number">0</span> <span class="keyword">or</span> i == num_batches - <span class="number">1</span>:</span><br><span class="line">                animator.add(epoch + (i + <span class="number">1</span>) / num_batches,</span><br><span class="line">                             (metric[<span class="number">0</span>] / metric[<span class="number">2</span>], metric[<span class="number">1</span>] / metric[<span class="number">2</span>],</span><br><span class="line">                              <span class="literal">None</span>))</span><br><span class="line">        <span class="keyword">if</span> valid_iter <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            valid_acc = d2l.evaluate_accuracy_gpu(net, valid_iter)</span><br><span class="line">            animator.add(epoch + <span class="number">1</span>, (<span class="literal">None</span>, <span class="literal">None</span>, valid_acc))</span><br><span class="line">        scheduler.step()</span><br><span class="line">    measures = (<span class="string">f&#x27;train loss <span class="subst">&#123;metric[<span class="number">0</span>] / metric[<span class="number">2</span>]:<span class="number">.3</span>f&#125;</span>, &#x27;</span></span><br><span class="line">                <span class="string">f&#x27;train acc <span class="subst">&#123;metric[<span class="number">1</span>] / metric[<span class="number">2</span>]:<span class="number">.3</span>f&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> valid_iter <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        measures += <span class="string">f&#x27;, valid acc <span class="subst">&#123;valid_acc:<span class="number">.3</span>f&#125;</span>&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(measures + <span class="string">f&#x27;\n<span class="subst">&#123;metric[<span class="number">2</span>] * num_epochs / timer.<span class="built_in">sum</span>():<span class="number">.1</span>f&#125;</span>&#x27;</span></span><br><span class="line">          <span class="string">f&#x27; examples/sec on <span class="subst">&#123;<span class="built_in">str</span>(devices)&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>使用随机梯度下降和学习率规划来训练模型，以更快达到收敛。</p>
<h3 id="7-训练和验证模型"><a href="#7-训练和验证模型" class="headerlink" title="7.训练和验证模型"></a>7.训练和验证模型</h3><p>以下所有超参数都可以调节</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">devices, num_epochs, lr, wd = d2l.try_all_gpus(), <span class="number">20</span>, <span class="number">2e-4</span>, <span class="number">5e-4</span></span><br><span class="line">lr_period, lr_decay, net = <span class="number">4</span>, <span class="number">0.9</span>, get_net()</span><br><span class="line">train(net, train_iter, valid_iter, num_epochs, lr, wd, devices, lr_period,</span><br><span class="line">      lr_decay)</span><br></pre></td></tr></table></figure>
<img src="/2024/04/23/11-01-39/39-01.png" class>
<h3 id="8-Q-amp-A"><a href="#8-Q-amp-A" class="headerlink" title="8.Q&amp;A"></a>8.Q&amp;A</h3><h5 id="Q1-深度学习的损失函数一般是非凸的吗？"><a href="#Q1-深度学习的损失函数一般是非凸的吗？" class="headerlink" title="Q1:深度学习的损失函数一般是非凸的吗？"></a>Q1:深度学习的损失函数一般是非凸的吗？</h5><blockquote>
<p>损失函数一般是凸的，但是神经网络是非凸的(非单层)。凸函数表示能力有限。</p>
</blockquote>
<h5 id="Q2-训练时的训练集交叉熵loss大于验证集，但是训练集acc也是大于验证集的？"><a href="#Q2-训练时的训练集交叉熵loss大于验证集，但是训练集acc也是大于验证集的？" class="headerlink" title="Q2:训练时的训练集交叉熵loss大于验证集，但是训练集acc也是大于验证集的？"></a>Q2:训练时的训练集交叉熵loss大于验证集，但是训练集acc也是大于验证集的？</h5><blockquote>
<p>应该是因为在训练集上加了数据增广</p>
</blockquote>
<h5 id="Q3-normalize参数怎么来的？"><a href="#Q3-normalize参数怎么来的？" class="headerlink" title="Q3:normalize参数怎么来的？"></a>Q3:normalize参数怎么来的？</h5><blockquote>
<p>由imagenet数据集上RGB的均值和方差</p>
</blockquote>
<h5 id="Q4：weight-decay和lr-decay的作用有什么区别吗？"><a href="#Q4：weight-decay和lr-decay的作用有什么区别吗？" class="headerlink" title="Q4：weight decay和lr decay的作用有什么区别吗？"></a>Q4：weight decay和lr decay的作用有什么区别吗？</h5><blockquote>
<p>weight decay是对权重更新的操作——正则化（统计），lr decay 是作用在学习率上——为了收敛（优化模型）</p>
</blockquote>
<h5 id="Q5-scheduler怎么设置是最好的最优的，怎么选择？"><a href="#Q5-scheduler怎么设置是最好的最优的，怎么选择？" class="headerlink" title="Q5:scheduler怎么设置是最好的最优的，怎么选择？"></a>Q5:scheduler怎么设置是最好的最优的，怎么选择？</h5><blockquote>
<p>现在一般选用cosine函数，参数设置较少   。最好在前期保证比较大的lr，后期lr可以变小一点。具体流行什么说不准</p>
</blockquote>
<h5 id="Q6-lr-decay和weight-decay的效果？"><a href="#Q6-lr-decay和weight-decay的效果？" class="headerlink" title="Q6:lr decay和weight decay的效果？"></a>Q6:lr decay和weight decay的效果？</h5><blockquote>
<p>效果类似，但是本质不同。</p>
</blockquote>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>38-第二次竞赛树叶分类结果</title>
    <url>/2024/04/23/11-01-38/</url>
    <content><![CDATA[<h2 id="第二次竞赛树叶分类结果"><a href="#第二次竞赛树叶分类结果" class="headerlink" title="第二次竞赛树叶分类结果"></a>第二次竞赛树叶分类结果</h2><h3 id="任务简介"><a href="#任务简介" class="headerlink" title="任务简介"></a>任务简介</h3><p>对176种叶子进行分类，每类叶子的数据大约有100张图片，数据较干净，没有复杂背景且颜色并不关键，模型只要能识别出形状即可</p>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>165个队伍参加，1800次提交，私榜排名第一的同学正确率有0.99272，李沐老师私下使用AutoML训练大约0.98，由于结果较好，6-20名的队伍如果分享代码也可获得签名书</p>
<h3 id="方法总结"><a href="#方法总结" class="headerlink" title="方法总结"></a>方法总结</h3><p>待参加比赛的同学分享代码后下周课程上讲解，但B站视频并未上传此部分。</p>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>37-微调</title>
    <url>/2024/04/23/11-01-37/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul>
<li>很多时候，例如我们想对家具进行分类，但是往往在努力收集数据得到的数据集也比较小假如我们想识别图片中不同类型的椅子，然后向用户推荐购买链接。 一种可能的方法是首先识别100把普通椅子，为每把椅子拍摄1000张不同角度的图像，然后在收集的图像数据集上训练一个分类模型。 尽管这个椅子数据集可能大于Fashion-MNIST数据集，但实例数量仍然不到ImageNet中的十分之一。 适合ImageNet的复杂模型可能会在这个椅子数据集上过拟合。 此外，由于训练样本数量有限，训练模型的准确性可能无法满足实际要求。为了避免这种情况，我们可以有两种方法：<ul>
<li>显然的想法就是收集更多的数据，但是，收集和标记数据可能需要大量的时间和金钱。 例如，为了收集ImageNet数据集，研究人员花费了数百万美元的研究资金。 尽管目前的数据收集成本已大幅降低，但这一成本仍不能忽视。</li>
<li>我们可以考虑迁移学习将从<em>源数据集</em>学到的知识迁移到<em>目标数据集</em>。 例如，尽管ImageNet数据集中的大多数图像与椅子无关，但在此数据集上训练的模型可能会提取更通用的图像特征，这有助于识别边缘、纹理、形状和对象组合。 这些类似的特征也可能有效地识别椅子。</li>
</ul>
</li>
</ul>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ul>
<li>如图所示，微调包括以下四个步骤：<ol>
<li>在源数据集（例如ImageNet数据集）上预训练神经网络模型，即<strong><em>源模型</em></strong>。</li>
<li>创建一个新的神经网络模型，即<strong><em>目标模型</em></strong>。这将复制源模型上的所有模型设计及其参数（输出层除外）。我们假定这些模型参数包含从源数据集中学到的知识，这些知识也将适用于目标数据集。我们还假设源模型的输出层与源数据集的标签密切相关；因此不在目标模型中使用该层。</li>
<li>向目标模型添加输出层，其输出数是目标数据集中的类别数。然后随机初始化该层的模型参数。</li>
<li>在目标数据集（如椅子数据集）上训练目标模型。输出层将从头开始进行训练，而所有其他层的参数将根据源模型的参数进行微调。</li>
</ol>
</li>
</ul>
<img src="/2024/04/23/11-01-37/37-01.png" class>
<ol>
<li>通常来讲，微调速度更快，并且具有较强的正则性，一般学习率比较小，也不需要很多轮的数据迭代，对于不同的任务往往只需要改变最后输出层，这一层随机初始化即可。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>迁移学习将从源数据集中学到的知识“迁移”到目标数据集，微调是迁移学习的常见技巧。</li>
<li>除输出层外，目标模型从源模型中复制所有模型设计及其参数，并根据目标数据集对这些参数进行微调。但是，目标模型的输出层需要从头开始训练。</li>
<li>通常，微调参数使用较小的学习率，而从头开始训练输出层可以使用更大的学习率。</li>
</ul>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>36-数据增广</title>
    <url>/2024/04/23/11-01-36/</url>
    <content><![CDATA[<h2 id="36-数据增广"><a href="#36-数据增广" class="headerlink" title="36 数据增广"></a>36 数据增广</h2><p>数据增广不仅用于处理图片，也可用于文本和语音，这里只涉及到图片。</p>
<h3 id="1-使用增强数据训练"><a href="#1-使用增强数据训练" class="headerlink" title="1. 使用增强数据训练"></a>1. 使用增强数据训练</h3><p>采集数据得到的训练场景与实际部署场景不同是常见的问题，这种变化有时会显著影响模型表现。在训练集中尽可能模拟部署时可能遇到的场景对模型的泛化性十分重要。</p>
<p>数据增强是指在一个已有数据集上操作使其有更多的多样性。对语音来说可以加入不同的背景噪音，对图片而言可以改变其颜色，形状等。</p>
<p>一般来说不会先将数据集做增广后存下来再用于训练；而是直接在线生成，从原始数据中读图片并随机做数据增强，再进入模型训练。通常只在训练时做数据增强而测试时不用。可以将数据增强理解为一个正则项。</p>
<h3 id="2-增强手段"><a href="#2-增强手段" class="headerlink" title="2. 增强手段"></a>2. 增强手段</h3><h4 id="2-1-翻转"><a href="#2-1-翻转" class="headerlink" title="2.1 翻转"></a>2.1 翻转</h4><p>一些例子：左右翻转，上下翻转</p>
<p>要注意不是所有增强策略都总是可行，如建筑图片上下翻转就不太合适，而之前的树叶分类竞赛中的树叶图片就没关系。</p>
<img src="/2024/04/23/11-01-36/36-01.png" class>
<h4 id="2-2-切割"><a href="#2-2-切割" class="headerlink" title="2.2 切割"></a>2.2 切割</h4><p>从图片中切割一块然后变形到固定形状。一般做法是随机取一个高宽比，随机取图片大小（切下部分占原图的百分数），随机取位置。</p>
<img src="/2024/04/23/11-01-36/36-02.png" class>
<h4 id="2-3-颜色"><a href="#2-3-颜色" class="headerlink" title="2.3 颜色"></a>2.3 颜色</h4><p>改变色调，饱和度，明亮度。</p>
<img src="/2024/04/23/11-01-36/36-03.png" class>
<h4 id="2-4-其他"><a href="#2-4-其他" class="headerlink" title="2.4 其他"></a>2.4 其他</h4><p>还可以有很多种不同的方法，如高斯模糊，部分像素变黑，图片变形，锐化等等。理论上讲Photoshop能做到的都可以用作图片数据增强，但效果好坏另当别论。如果测试集中有类似的效果那么相应的数据增广手段会更有效。</p>
<img src="/2024/04/23/11-01-36/36-04.png" class>
<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><ul>
<li>数据增广通过变形数据来获取多样性从而使得模型泛化性能更好</li>
<li>常见图片增广包括翻转，切割，变色</li>
</ul>
<h3 id="4-QA"><a href="#4-QA" class="headerlink" title="4. QA"></a>4. QA</h3><p>Q1: 理论上是不是原始样本足够多就不需要做增广？</p>
<blockquote>
<p>是的，但实际情况中很难有足够多样性的图片能覆盖测试的所有情况。</p>
<p>数据量大也不一定意味着足够多样，可能简单情况已经很充分，但对于很难的情况覆盖率不够。</p>
</blockquote>
<p>Q2: （代码实现中的）num_worker值是不是根据GPU性能而定？</p>
<blockquote>
<p>是。</p>
<p>这里老师还提到虽然深度学习主要用GPU，但CPU也不能太差，否则可能数据预处理跟不上，CPU的内存带宽和到显卡的带宽不够。具体决定num_worker可以自己定一个值然后跑一个epoch看看耗时。</p>
</blockquote>
<p>Q3: 金融风控领域经常面临极度偏斜数据（欺诈样本极少），是否可对正样本做数据增广？</p>
<blockquote>
<p>可以，类似地震预测等等正样本少的情况都可以尝试对正样本做增广，负样本可以不用。</p>
</blockquote>
<p>Q4: 测试一般做什么样的增广？如何理解对测试集增广能提高精度？</p>
<blockquote>
<p>一般不对测试集做增广。也可以对一张测试图像做增广，将每个增广出的图片都做一次预测最后取平均，会一定程度改善精度。但这样会使得对每张图片预测计算量成倍增长，所以使用较少。</p>
</blockquote>
<p>Q5: 课件里提到的对比实验固定了所有随机种子吗？昨晚增广后训练精度下降是不是意味着还可以继续训练减少gap？</p>
<blockquote>
<p>没有。</p>
<p>是的，课堂演示时往往跑的epoch较少，另外训练到后期gap一般不会减少。</p>
</blockquote>
<p>Q6: 图片增广后需要人工一张张确认效果吗？</p>
<blockquote>
<p>不用全看，大概看看效果即可。</p>
</blockquote>
<p>Q7: 图片增广后训练数据与测试数据分布可能不同，会对模型最终精度有影响吗？</p>
<blockquote>
<p>首先多数图片增广手段不改变数据分布，因为亮度变化等是随机的，数据的均值不变，翻转不影响分布，crop可能会有改变但影响不大。</p>
<p>后面还有问题提到对增广不改变数据分布的理解，可理解成增广不改变均值但稍微增大方差。很多时候讨论训练集和测试集分布是否相同不是看原始的像素分布而是看各label比例或图片色调等是否差不多。</p>
</blockquote>
<p>Q8: 关于图神经网络</p>
<blockquote>
<p>图神经网络很强大但不好训练，目前落地还太早了</p>
</blockquote>
<p>Q9: 关于mosaic和crop</p>
<blockquote>
<p>把多张图片拼起来训练。这里老师理解错了问题，提到了加马赛克和本节代码中一次展示八张图片只是一起显示而不是使用了crop方法。</p>
</blockquote>
<p>Q10: 用对一个事物的视频描述做数据集是不是会比增广更有效？</p>
<blockquote>
<p>可以这么认为，但拍视频是很贵的事情，获取视频往往划不来。</p>
</blockquote>
<p>Q11: 多张图片叠加是否也是有效的增广方式？</p>
<blockquote>
<p>是的，这种方法叫mix-up，非常有用。</p>
<p>后面有问到为什么mix-up有用，老师也不清楚。</p>
<p>lable的叠加是对两张图片label按特定分布随机取权重加权求和</p>
</blockquote>
<p>Q12: 做车辆位置识别如果实际应用场景摄像头高度角度清晰度都和训练集不一样，是不是只能针对场景单独采集数据重新打标训练？</p>
<blockquote>
<p>是，可以考虑将实际部署时识别错误的数据加入训练集使得训练集测试集分布趋同</p>
</blockquote>
<p>Q13: 是否会出现图像增广减小类间差异，混淆不同类别的情况？</p>
<blockquote>
<p>那倒不会。可以考虑不要crop太小的区域。</p>
</blockquote>
<p>Q14: 实际操作用torchvision还是albumentation?</p>
<blockquote>
<p>都差不多</p>
</blockquote>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>35-分布式训练</title>
    <url>/2024/04/23/11-01-35/</url>
    <content><![CDATA[<h2 id="35-分布式训练"><a href="#35-分布式训练" class="headerlink" title="35-分布式训练"></a>35-分布式训练</h2><h3 id="1-分布式计算"><a href="#1-分布式计算" class="headerlink" title="1.分布式计算"></a>1.分布式计算</h3><ul>
<li>本质上来说和之前讲的单机多卡并行没有区别。二者之间的区别是分布式计算是通过网络把数据从一台机器搬到另一台机器</li>
</ul>
<img src="/2024/04/23/11-01-35/35-01.png" class>
<h3 id="2-GPU机器架构"><a href="#2-GPU机器架构" class="headerlink" title="2. GPU机器架构"></a>2. GPU机器架构</h3><ul>
<li>总的来说，gpu到gpu的通讯是很快的，gpu到cpu慢一点。机器到机器更慢。因而总体性能的关键就是尽量在本地做通讯而少在机器之间做通讯</li>
</ul>
<h5 id="2-1-样例：计算一个小批量"><a href="#2-1-样例：计算一个小批量" class="headerlink" title="2.1 样例：计算一个小批量"></a>2.1 样例：计算一个小批量</h5><ul>
<li>每个worker从参数服务器那里获取模型参数：首先把样本复制到机器的内存，然后把样本分到每个gpu上</li>
<li>复制参数到每个gpu上：同样，先把每一次的参数放到内存里，然后再复制到每个gpu上</li>
<li>每个gpu计算梯度</li>
<li>再主内存上把所有gpu上的梯度加起来</li>
<li>梯度从主内存传回服务器</li>
<li>每个服务器对梯度求和，并更新参数</li>
</ul>
<h5 id="2-2-总结"><a href="#2-2-总结" class="headerlink" title="2.2 总结"></a>2.2 总结</h5><ul>
<li>由于gpu到gpu和gpu到内存的通讯速度还不错，因此我们尽量再本地做聚合（如梯度相加），并减少再网络上的多次通讯</li>
</ul>
<h3 id="3-关于性能"><a href="#3-关于性能" class="headerlink" title="3.  关于性能"></a>3.  关于性能</h3><h5 id="3-1-对于同步SGD："><a href="#3-1-对于同步SGD：" class="headerlink" title="3.1 对于同步SGD："></a>3.1 对于<strong>同步SGD</strong>：</h5><ul>
<li>这里每个worker都是同步计算一个批量，称为同步SGD</li>
<li>假设有n个ggpu，每个gpu每次处理b个样本，那么同步SGD等价于再单gpu运行批量大小为nb的SGD</li>
<li>再理想情况下，n个gpu可以得到相对单gpu的n倍加速</li>
</ul>
<h5 id="3-2-性能："><a href="#3-2-性能：" class="headerlink" title="3.2 性能："></a>3.2 <strong>性能</strong>：</h5><ul>
<li>t1 = 在单gpu上计算b个样本梯度时间</li>
<li>假设有m个参数，一个worker每次发送和接受m个参数、梯度<ul>
<li>t2 = 发送和接受所用时间</li>
</ul>
</li>
<li>每个批量的计算时间为max（t1，t2）<ul>
<li>选取足够大的b使t1&gt;t2</li>
<li>增加b或n导致更大的批量 大小，当值需要更多计算来得到给定的模型精度</li>
</ul>
</li>
</ul>
<h5 id="3-3-性能的权衡"><a href="#3-3-性能的权衡" class="headerlink" title="3.3 性能的权衡"></a>3.3 性能的权衡</h5><img src="/2024/04/23/11-01-35/35-02.png" class>
<h3 id="4-实践时的建议"><a href="#4-实践时的建议" class="headerlink" title="4. 实践时的建议"></a>4. 实践时的建议</h3><ul>
<li>使用一个大数据集</li>
<li>需要好的gpu-gpu和机器-机器带宽</li>
<li>高效的数据读取和预处理</li>
<li>模型需要有好的计算和通讯比<ul>
<li>Inception&gt;ResNet&gt;AlexNet</li>
</ul>
</li>
<li>使用足够大的批量大小来得到更好的系统性能</li>
<li>使用高效的优化算法对应大批量大小</li>
</ul>
<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><ul>
<li>分布式同步数据并行是多gpu数据并行在多机器上的拓展</li>
<li>网络通讯通常是瓶颈</li>
<li>需要注意使用特别大的批量大小时的收敛效率</li>
<li>更复杂的分布式有异步、模型并行（这里没有介绍）</li>
</ul>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>33-单机多卡并行</title>
    <url>/2024/04/23/11-01-34/</url>
    <content><![CDATA[<h2 id="单机多卡并行"><a href="#单机多卡并行" class="headerlink" title="单机多卡并行"></a>单机多卡并行</h2><p>一台机器可以安装多个GPU（一般为1-16个），在训练和预测时可以将一个小批量计算切分到多个GPU上来达到加速目的，常用的切分方案有数据并行，模型并行，通道并行。</p>
<h3 id="数据并行"><a href="#数据并行" class="headerlink" title="数据并行"></a>数据并行</h3><p>将小批量的数据分为n块，每个GPU拿到完整的参数，对这一块的数据进行前向传播与反向传播，计算梯度。</p>
<p>数据并行通常性能比模型并行更好，因为对数据进行划分使得各个GPU的计算内容更加均匀。</p>
<h4 id="数据并行的大致流程"><a href="#数据并行的大致流程" class="headerlink" title="数据并行的大致流程"></a>数据并行的大致流程</h4><img src="/2024/04/23/11-01-34/DataParallel.png" class>
<p>主要分为五部</p>
<ul>
<li>1：每个GPU读取一个数据块（灰色部分）</li>
<li>2：每个GPU读取当前模型的参数（橙色部分）</li>
<li>3：每个GPU计算自己拿到数据块的梯度（绿色部分）</li>
<li>4：GPU将计算得到的梯度传给内存（CPU）（绿色箭头）</li>
<li>5：利用梯度对模型参数进行更新（橙色箭头）</li>
</ul>
<p>数据并行并行性较好，主要因为当每个GPU拿到的数据量相同时计算量也相似，各个GPU的运算时间相近，幸能较好</p>
<h3 id="模型并行"><a href="#模型并行" class="headerlink" title="模型并行"></a>模型并行</h3><p>将整个模型分为n个部分，每个GPU拿到这个部分的参数和负责上一个部分的GPU的输出作为输入来进行计算，反向传播同理。</p>
<p>模型并行通常用于模型十分巨大，参数众多，即使在每个mini-batch只有一个样本的情况下单个GPU的显存仍然不够的情况，但并行性较差，可能有时会有GPU处于等待状态。</p>
<h3 id="通道并行"><a href="#通道并行" class="headerlink" title="通道并行"></a>通道并行</h3><p>通道并行是数据并行和模型并行同时进行</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>当一个模型能用单卡计算时，通常使用数据并行扩展到多卡</li>
<li>模型并行则用在超大模型上</li>
</ul>
<h3 id="Q-amp-A（部分有价值的）"><a href="#Q-amp-A（部分有价值的）" class="headerlink" title="Q&amp;A（部分有价值的）"></a>Q&amp;A（部分有价值的）</h3><ul>
<li>问1：若有4块GPU，两块显存大两块显存小怎么办？</li>
<li>答1：<br>若GPU运算性能相同，则训练取决于小显存的GPU的显存大小，更大的显存相当于浪费掉<br>若GPU运算性能不同，一般即为显存大的GPU性能更好，可以在分配数据时多分配一点</li>
<li></li>
<li>问2：数据拆分后，需存储的数据量会变大吗？会降低性能吗？</li>
<li>答2：每个GPU都单独存储了一份模型，这部分的数据量变大了，但如果只考虑运算时的中间变量，则中间变量的大小与数据量呈线性关系，每个GPU的数据小了，中间变量也会变小，所有GPU的中间变量加起来大小是不变的。<br>数据拆分后性能会变低，在下节课讲解（数据通讯的开销，每个GPU的batch-size变小可能无法跑满GPU，总batch-size变大则相同计算量下训练次数变少）</li>
</ul>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>34-多GPU训练实现</title>
    <url>/2024/04/23/11-01-34/</url>
    <content><![CDATA[<h2 id="34-多GPU训练实现"><a href="#34-多GPU训练实现" class="headerlink" title="34 多GPU训练实现"></a>34 多GPU训练实现</h2><p>本讲内容为代码实现，这里整理QA，其余内容参考代码部分。</p>
<p>Q1: keras从tf分离，书籍会不会需要重新整理？</p>
<blockquote>
<p>暂时不会有影响</p>
</blockquote>
<p>Q2: 是否可以通过把resnet中的卷积层全替换成mlp来实现一个很深的网络？</p>
<blockquote>
<p>可以，有这样做的paper，但是通过一维卷积（等价于全连接层）做的，如果直接换成全连接层很可能会过拟合。</p>
</blockquote>
<p>Q3: 为什么batch norm是一种正则但只加快训练不提升精度？</p>
<blockquote>
<p>老师也不太清楚并认为这是很好的问题，可以去查阅论文。</p>
</blockquote>
<p>Q4: all_reduce, all_gather主要起什么作用？实际使用时发现pytorch的类似分布式op不能传导梯度，会破坏计算图不能自动求导，如何解决？</p>
<blockquote>
<p>all_reduce是把n个东西加在一起再把所有东西复制回去，all_gather则只是把来自不同地方东西合并但不相加。使用分布式的东西会破坏自动求导，跨GPU的自动求导并不好做，老师不确定pytorch能不能做到这一功能，如果不能就只能手写。</p>
</blockquote>
<p>Q5: 两个GPU训练时最后的梯度是把两个GPU上的梯度相加吗？</p>
<blockquote>
<p>是的。mini-batch的梯度就是每个样本的梯度求和，多GPU时同理，每个GPU向将自己算的那部分样本梯度求和，最后再将两个GPU的计算得的梯度求和。</p>
</blockquote>
<p>Q6: 为什么参数大的模型不一定慢？flop数多的模型性能更好是什么原理？</p>
<blockquote>
<p>性能取决于每算一个乘法需要访问多少个bit，计算量与内存访问的比值越高越好。通常CPU/GPU不会被卡在频率上而是访问数据/内存上，所以参数量小，算力高的模型性能较好（如卷积，矩阵乘法）。</p>
</blockquote>
<p>Q7: 为什么分布到多GPU上测试精度会比单GPU抖动大？</p>
<blockquote>
<p>抖动是因为学习率变大了，使用GPU数对测试精度没有影响，只会影响性能。但为了得到更好的速度需要把batchsize调大，使得收敛情况发生变化，把学习率上调就使得精度更抖。</p>
</blockquote>
<p>Q8: batchsize太大会导致loss nan吗？</p>
<blockquote>
<p>不会，batchsize中的loss是求均值的，理论上batchsize更大数值稳定性会更好，出现数值不稳定问题可能是学习率没有调好。</p>
</blockquote>
<p>Q9: GPU显存如何优化？</p>
<blockquote>
<p>显存手动优化很难，靠的是框架，pytorch的优化做的还不错。除非特别懂框架相关技术不然建议把batchsize调小或是把模型做简单一点。</p>
</blockquote>
<p>Q10: 对于精度来说batchsize=1是一种最好的情况吗？</p>
<blockquote>
<p>可能是。</p>
</blockquote>
<p>Q11: parameter server可以和pytorch结合吗，具体如何实现？</p>
<blockquote>
<p>pytorch没有实现parameter server，但mxnet和tensorflow有。但是有第三方实现如byteps支持pytorch。</p>
</blockquote>
<p>Q12: 用了nn.DataParallel()，是不是数据集也被自动分配到了多个GPU上？</p>
<blockquote>
<p>是的。在算net.forward()的时候会分开。</p>
</blockquote>
<p>Q13: 验证集准确率震荡大那个参数影响最大？</p>
<blockquote>
<p>学习率。</p>
</blockquote>
<p>Q14: 为了让网络前几层能够训练能否采用不同stage采用不同学习率的方法？</p>
<blockquote>
<p>可以，主要的问题是麻烦，不好确定各部分学习率相差多少。</p>
</blockquote>
<p>Q15: 在用torch的数据并行中将inputs和labels放到GPU0是否会导致性能问题，因为这些数据最终回被挪一次到其他GPU上。</p>
<blockquote>
<p>数据相比梯度来说很少，不会对性能有太大影响。但这个操作看上去的确很多余，老师认为不需要做，但不这样做会报错。</p>
</blockquote>
<p>Q16: 为什么batchsize较小精度会不怎么变化？</p>
<blockquote>
<p>学习率太大了，batchsize小学习率就不能太大。</p>
</blockquote>
<p>Q17: 使用两块不同型号GPU影响深度学习性能吗？</p>
<blockquote>
<p>需要算好两块GPU的性能差。如一块GPU的性能是另一块的2倍，那么在分配任务时也应该分得2倍的任务量。保证各GPU在同样时间内算完同一部分。</p>
</blockquote>
<p>Q18: 课内竞赛直接用教材的VGG11但不收敛，同样的dataloader用resnet可以收敛，如何解决这一问题？</p>
<blockquote>
<p>可能是学习率太大，也可考虑加入batch normalization。</p>
</blockquote>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>32-深度学习硬件</title>
    <url>/2024/04/23/11-01-32/</url>
    <content><![CDATA[<h2 id="32-深度学习硬件"><a href="#32-深度学习硬件" class="headerlink" title="32-深度学习硬件"></a>32-深度学习硬件</h2><h3 id="1-DSP-数字信号处理"><a href="#1-DSP-数字信号处理" class="headerlink" title="1.DSP:数字信号处理"></a>1.DSP:数字信号处理</h3><ul>
<li><p>为数字信号处理算法设计：点积、卷积、FFT</p>
</li>
<li><p>低功耗，高性能</p>
<ul>
<li>比移动GPU快5倍，功耗更低</li>
</ul>
</li>
<li>VLIW：very long instruction word<ul>
<li>频率低，核少，但是一条指令可以进行上百次的累加，便于重复</li>
</ul>
</li>
<li>缺点：编程和调试困难，编译器良莠不齐（做的人少，工具不是很好用）</li>
</ul>
<h3 id="2-可编程阵列（FPGA）"><a href="#2-可编程阵列（FPGA）" class="headerlink" title="2.可编程阵列（FPGA）"></a>2.可编程阵列（FPGA）</h3><ul>
<li>有大量的可以用来编程的逻辑单元和可配置链接</li>
<li>可以配置成计算复杂函数<ul>
<li>编程语言：VHDL Verilog</li>
</ul>
</li>
<li>通常比通用硬件更高效，但是体积更大不方便</li>
<li>缺点：工具链质量良莠不齐，一次编译需要数个小时（烧一次板子，物理上的改变）</li>
<li>用途：主要用来模拟，看看效果好不好，如果好可以进一步造芯片</li>
</ul>
<h3 id="3-AI-ASIC"><a href="#3-AI-ASIC" class="headerlink" title="3.AI ASIC"></a>3.AI ASIC</h3><ul>
<li>深度学习热门领域（针对特定领域）<ul>
<li>大公司都在造自己的芯片（Intel Qualcomm Google Amazon Facebook）</li>
</ul>
</li>
<li>Google TPU 是标志性芯片（听说在Google内部已经盛行 取代GPU了）<ul>
<li>能够媲美 Nvidia GPU性能</li>
<li>在Google 大量部署</li>
<li>核心是 systolic array（时间快 容易造）</li>
</ul>
</li>
<li>systolic array<ul>
<li>计算单元（PE）阵列</li>
<li>特别适合做矩阵乘法</li>
<li>设计和制造相对简单（核少）</li>
<li>矩阵乘法例子：见PPT<ul>
<li>对于一般的矩阵乘法：通过切开、填充来匹配SA大小</li>
<li>批量输入来降低延迟（避免空等，先出的硬件空闲）</li>
<li>通常有其他硬件单元来处理别的NN操作子，例如激活层</li>
</ul>
</li>
<li>缺点：只针对深度学习这方面有用，别的方面效果不大</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>灵活性、易用性：Intel(CPU) &gt; GPU &gt; DSP &gt; FPGA &gt; ASIC</li>
<li>性能功耗：Intel(CPU) &lt; GPU &lt; DSP &lt; FPGA &lt; ASIC</li>
</ul>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>31-CPU和GPU</title>
    <url>/2024/04/23/11-01-31/</url>
    <content><![CDATA[<h1 id="CPU和GPU"><a href="#CPU和GPU" class="headerlink" title="CPU和GPU"></a>CPU和GPU</h1><h3 id="1-CPU："><a href="#1-CPU：" class="headerlink" title="1.CPU："></a>1.CPU：</h3><h4 id="1-1-提升CPU利用率一："><a href="#1-1-提升CPU利用率一：" class="headerlink" title="1.1 提升CPU利用率一："></a>1.1 提升CPU利用率一：</h4><ul>
<li>在计算a+b之前，需要准备数据</li>
<li><p>主内存-&gt;L3-&gt;L2-&gt;L1-&gt;寄存器</p>
<ul>
<li>L1访问延时：0.5ms</li>
<li>L2访问延时：7ns（14XL1）</li>
<li>主内存访问延时：100ns(200XL1)</li>
</ul>
</li>
<li><p>提升空间和时间的内存本地性</p>
<ul>
<li>时间：重用数据使它们在缓存里</li>
<li>空间：按序读写数据是的可以预读取</li>
</ul>
</li>
</ul>
<h4 id="1-2-样例分析："><a href="#1-2-样例分析：" class="headerlink" title="1.2 样例分析："></a>1.2 样例分析：</h4><ul>
<li>如果一个矩阵是按行存储，访问一行比访问一列要快<ul>
<li>CPU一次读取64字节（缓存线）</li>
<li>CPU会“聪明的”提前读取下一个（缓存线）</li>
</ul>
</li>
</ul>
<img src="/2024/04/23/11-01-31/31-01.png" class>
<h4 id="1-3-提升CPU利用率二："><a href="#1-3-提升CPU利用率二：" class="headerlink" title="1.3 提升CPU利用率二："></a>1.3 提升CPU利用率二：</h4><ul>
<li><p>高端CPU有几十个核</p>
<ul>
<li>EC2 P3.16xlarge:2 Intel Xeon CPUs,32物理核</li>
</ul>
</li>
<li><p>并行来利用所用核</p>
<ul>
<li>超线程不一定提升性能，因为他们共享寄存器</li>
</ul>
</li>
</ul>
<h4 id="1-4-样例分析："><a href="#1-4-样例分析：" class="headerlink" title="1.4 样例分析："></a>1.4 样例分析：</h4><ul>
<li>左边比右边慢（python）</li>
</ul>
<img src="/2024/04/23/11-01-31/31-02.png" class>
<ul>
<li>左边调用n次函数，每次调用有开销</li>
<li>右边很容易被并行（例如下面的C++实现）</li>
</ul>
<img src="/2024/04/23/11-01-31/31-03.png" class>
<h3 id="2-CPU-vs-GPU"><a href="#2-CPU-vs-GPU" class="headerlink" title="2.CPU vs GPU:"></a>2.CPU vs GPU:</h3><img src="/2024/04/23/11-01-31/31-04.png" class>
<h4 id="2-1-提升GPU利用率"><a href="#2-1-提升GPU利用率" class="headerlink" title="2.1 提升GPU利用率"></a>2.1 提升GPU利用率</h4><ul>
<li><p>并行</p>
<ul>
<li>使用数千个线程</li>
</ul>
</li>
<li><p>内存本地性</p>
<ul>
<li>缓存更小，架构更简单</li>
</ul>
</li>
<li><p>少用控制语句</p>
<ul>
<li>支持有限</li>
<li>同步开销大</li>
</ul>
</li>
</ul>
<h4 id="2-2-CPU-GPU-带宽"><a href="#2-2-CPU-GPU-带宽" class="headerlink" title="2.2 CPU/GPU 带宽"></a>2.2 CPU/GPU 带宽</h4><img src="/2024/04/23/11-01-31/31-05.png" class>
<h4 id="2-3-更多的CPUs和GPUs"><a href="#2-3-更多的CPUs和GPUs" class="headerlink" title="2.3 更多的CPUs和GPUs"></a>2.3 更多的CPUs和GPUs</h4><ul>
<li>CPU:AMD,ARM</li>
<li>GPU:AMD,Intel,ARM,Qualcomm…</li>
</ul>
<h4 id="2-4-CPU-GPU高性能计算编程"><a href="#2-4-CPU-GPU高性能计算编程" class="headerlink" title="2.4 CPU/GPU高性能计算编程"></a>2.4 CPU/GPU高性能计算编程</h4><ul>
<li>CPU：C++或者任何高性能语言<ul>
<li>编译器成熟</li>
</ul>
</li>
<li>GPU<ul>
<li>Nvida上用CUDA<ul>
<li>编译器和驱动成熟</li>
</ul>
</li>
<li>其他用OpenCL<ul>
<li>质量取决于硬件厂商</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h3><ul>
<li>CPU:可以处理通用计算。性能优化考虑数据读写效率和多线程</li>
<li>GPU：使用更多的小核和更好的内存带宽，适合能大规模并行的计算任务</li>
</ul>
<h3 id="4-Q-amp-A"><a href="#4-Q-amp-A" class="headerlink" title="4.Q&amp;A"></a>4.Q&amp;A</h3><h5 id="Q1-如果要提高泛化性，就要增加数据？调参的意思是不是最大？"><a href="#Q1-如果要提高泛化性，就要增加数据？调参的意思是不是最大？" class="headerlink" title="Q1:  如果要提高泛化性，就要增加数据？调参的意思是不是最大？"></a>Q1:  如果要提高泛化性，就要增加数据？调参的意思是不是最大？</h5><blockquote>
<p>提高泛化性的有效手段是增加数据，但是数据的质量很重要，少量高质量数据和大量低质量数据可能有1:10或者1:100的换算关系。实际应用场景对调参要求不高，因为有不断增加的数据。</p>
</blockquote>
<h5 id="Q2-alexnet模型比resnet要大，为什么计算上resnet比alexnet运算量大？"><a href="#Q2-alexnet模型比resnet要大，为什么计算上resnet比alexnet运算量大？" class="headerlink" title="Q2:alexnet模型比resnet要大，为什么计算上resnet比alexnet运算量大？"></a>Q2:alexnet模型比resnet要大，为什么计算上resnet比alexnet运算量大？</h5><blockquote>
<p>alexnet后面用到的几个连续的全连接层使模型变大，但是resnet使用的卷积层在少量参数下更消耗计算资源。模型大小和计算复杂度不能直接换算。</p>
</blockquote>
<h5 id="Q3-训练时为什么使用w-lr-w-grad-而不写做w-w-lr-w-grad"><a href="#Q3-训练时为什么使用w-lr-w-grad-而不写做w-w-lr-w-grad" class="headerlink" title="Q3:训练时为什么使用w-=lr*w.grad,而不写做w=w-lr*w.grad?"></a>Q3:训练时为什么使用w-=lr*w.grad,而不写做w=w-lr*w.grad?</h5><blockquote>
<p>因为第二种写法定义了一个新的tensor，梯度参数会成为false</p>
</blockquote>
<h5 id="Q4-llc是显存还是缓存，是l1-l2-还是l3"><a href="#Q4-llc是显存还是缓存，是l1-l2-还是l3" class="headerlink" title="Q4:llc是显存还是缓存，是l1,l2,还是l3?"></a>Q4:llc是显存还是缓存，是l1,l2,还是l3?</h5><blockquote>
<p>llc是缓存，last level cash,是最后一层缓存，具体是ln取决于一共有几层缓存。</p>
</blockquote>
<h5 id="Q5-做计算时把for-lopps运算尽可能向量化？"><a href="#Q5-做计算时把for-lopps运算尽可能向量化？" class="headerlink" title="Q5:做计算时把for_lopps运算尽可能向量化？"></a>Q5:做计算时把for_lopps运算尽可能向量化？</h5><blockquote>
<p>是的，尽量不要用python写for-loop</p>
</blockquote>
<h5 id="Q6-可视化时，需要把数据在cpu和GPU之间切换，如何避免频繁传输？常见的错误操作有哪些？怎么看到和排查这种错误？"><a href="#Q6-可视化时，需要把数据在cpu和GPU之间切换，如何避免频繁传输？常见的错误操作有哪些？怎么看到和排查这种错误？" class="headerlink" title="Q6:可视化时，需要把数据在cpu和GPU之间切换，如何避免频繁传输？常见的错误操作有哪些？怎么看到和排查这种错误？"></a>Q6:可视化时，需要把数据在cpu和GPU之间切换，如何避免频繁传输？常见的错误操作有哪些？怎么看到和排查这种错误？</h5><blockquote>
<p>可视化操作不需要太担心，只要不是计算中来回传递就好。深度学习框架会有限制，只能在一个设备上做。框架没报错一般不会有太多问题</p>
</blockquote>
<h5 id="Q7-go怎么样？"><a href="#Q7-go怎么样？" class="headerlink" title="Q7:go怎么样？"></a>Q7:go怎么样？</h5><blockquote>
<p>go分布式系统做的很好，和深度学习的分布式不太一样</p>
</blockquote>
<h5 id="Q8-怎样复现论文？"><a href="#Q8-怎样复现论文？" class="headerlink" title="Q8:怎样复现论文？"></a>Q8:怎样复现论文？</h5><blockquote>
<p>80%的论文无法复现，要读懂每一句话，和明白作者实现的细节。</p>
</blockquote>
<h5 id="Q9：分布式和高性能的区别？"><a href="#Q9：分布式和高性能的区别？" class="headerlink" title="Q9：分布式和高性能的区别？"></a>Q9：分布式和高性能的区别？</h5><blockquote>
<p>没有本质区别，分布式更多考虑容错。高性能是分布式的一个应用</p>
</blockquote>
<h5 id="Q10-自动驾驶烧钱，短时间难以落地是不是和nas一样？"><a href="#Q10-自动驾驶烧钱，短时间难以落地是不是和nas一样？" class="headerlink" title="Q10:自动驾驶烧钱，短时间难以落地是不是和nas一样？"></a>Q10:自动驾驶烧钱，短时间难以落地是不是和nas一样？</h5><blockquote>
<p>不是，自动驾驶有很好的商业前景。nas没有太多意义。</p>
</blockquote>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>30 第二部分完结竞赛：图片分类</title>
    <url>/2024/04/23/11-01-30/</url>
    <content><![CDATA[<h2 id="30-第二部分完结竞赛：图片分类"><a href="#30-第二部分完结竞赛：图片分类" class="headerlink" title="30 第二部分完结竞赛：图片分类"></a>30 第二部分完结竞赛：图片分类</h2><p>竞赛地址：<a href="https://www.kaggle.com/c/classify-leaves">https://www.kaggle.com/c/classify-leaves</a></p>
<p>任务：给出叶子图片预测树种，共20000张图，176类，每类至少50张图。训练样本18353张，测试样本8800张。</p>
<p>这次公榜私榜是随机分的，正常来说两榜的名次差别不会太大。</p>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>29-残差网络（ResNet）</title>
    <url>/2024/04/23/11-01-29/</url>
    <content><![CDATA[<h3 id="残差网络（ResNet）"><a href="#残差网络（ResNet）" class="headerlink" title="残差网络（ResNet）"></a>残差网络（ResNet）</h3><p>随着我们设计越来越深的网络，深刻理解“新添加的层如何提升神经网络的性能”变得至关重要。更重要的是设计网络的能力，在ResNet这种网络中，添加层会使网络更具表现力</p>
<h4 id="函数类"><a href="#函数类" class="headerlink" title="函数类"></a>函数类</h4><ul>
<li>假设有一类特定的神经网络架构F，它包括学习速率和其他超参数设置。 对于所有<em>f</em>∈F，存在一些参数集（例如权重和偏置），这些参数可以通过在合适的数据集上进行训练而获得。 现在假设<em>f</em>∗是我们真正想要找到的函数，如果是<em>f</em>∗∈F，那我们可以轻而易举的训练得到它，但通常我们不会那么幸运。 相反，我们将尝试找到一个函数<em>f</em>∗，这是我们在F中的最佳选择。</li>
<li>为了得到更近似真正<em>f</em>∗的函数我们需要设计一个更强大的架构F’，但是如果先前的框架F不包含于新框架F‘中就可能导致如下图中左侧的最优函数离实际预测函数误差反而随框架边强而增大，这不是我们期望的结果，所以我们选择使用下图中右侧的嵌套函数类以解决这个问题</li>
<li>引入方法：对于深度神经网络，如果我们能将新添加的层训练成<em>恒等映射</em>（identity function）<em>f</em>(<strong>x</strong>)=<strong>x</strong>，新模型和原模型将同样有效。 同时，由于新模型可能得出更优的解来拟合训练数据集，因此添加层似乎更容易降低训练误差。</li>
</ul>
<img src="/2024/04/23/11-01-29/29-01.png" class>
<img src="/2024/04/23/11-01-29/29-02.png" class>
<h4 id="残差块"><a href="#残差块" class="headerlink" title="残差块"></a>残差块</h4><ul>
<li><p>神经网络中的具体实现：假设我们的原始输入为<em>x</em>，而希望学出的理想映射为<em>f</em>(<strong>x</strong>)，左图虚线框中的部分需要直接拟合出该映射<em>f</em>(<strong>x</strong>)，而右图虚线框中的部分则需要拟合出残差映射<em>f</em>(<strong>x</strong>)−<strong>x</strong>。而右图正是ResNet的基础架构–<em>残差块</em>（residual block）</p>
</li>
<li><p>残差块的代码实现：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Residual</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, input_channels, num_channels,</span></span><br><span class="line"><span class="params">                 use_1x1conv=<span class="literal">False</span>, strides=<span class="number">1</span></span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="comment"># 第一个卷积层</span></span><br><span class="line">        self.conv1 = nn.Conv2d(input_channels, num_channels,</span><br><span class="line">                               kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>, stride=strides)</span><br><span class="line">        <span class="comment"># 第二个卷积层</span></span><br><span class="line">        self.conv2 = nn.Conv2d(num_channels, num_channels,</span><br><span class="line">                               kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 如果使用1 x 1卷积以使得输入变换成需要的形状</span></span><br><span class="line">        <span class="keyword">if</span> use_1x1conv:</span><br><span class="line">            self.conv3 = nn.Conv2d(input_channels, num_channels,</span><br><span class="line">                                   kernel_size=<span class="number">1</span>, stride=strides)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.conv3 = <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 对应第一个卷积层的批量规范化层</span></span><br><span class="line">        self.bn1 = nn.BatchNorm2d(num_channels)</span><br><span class="line">        <span class="comment"># 对应第二个卷积层的批量规范化层</span></span><br><span class="line">        self.bn2 = nn.BatchNorm2d(num_channels)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, X</span>):</span><br><span class="line">        <span class="comment"># 第一层：卷积 -&gt; 规范化 -&gt; relu激活</span></span><br><span class="line">        Y = F.relu(self.bn1(self.conv1(X)))</span><br><span class="line">        <span class="comment"># 第二层：卷积 -&gt; 规范化</span></span><br><span class="line">        Y = self.bn2(self.conv2(Y))</span><br><span class="line">        <span class="comment"># 如果要让输入变换成需要的形状</span></span><br><span class="line">        <span class="keyword">if</span> self.conv3:</span><br><span class="line">            <span class="comment"># 对X使用1 x 1卷积，以使输出成为需要的形状</span></span><br><span class="line">            X = self.conv3(X)</span><br><span class="line">        <span class="comment"># 嵌套模型的实现，即对上一次训练后的模型进行嵌套</span></span><br><span class="line">        Y += X</span><br><span class="line">        <span class="comment"># relu激活并输出</span></span><br><span class="line">        <span class="keyword">return</span> F.relu(Y)</span><br></pre></td></tr></table></figure>
<img src="/2024/04/23/11-01-29/29-03.png" class>
<h4 id="ResNet模型"><a href="#ResNet模型" class="headerlink" title="ResNet模型"></a>ResNet模型</h4><ul>
<li>ResNet的前两层跟之前介绍的GoogLeNet中的一样： 在输出通道数为64、步幅为2的7×7卷积层后，接步幅为2的3×3的最大汇聚层。 不同之处在于ResNet每个卷积层后增加了批量规范化层。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b1 = nn.Sequential(nn.Conv2d(<span class="number">1</span>, <span class="number">64</span>, kernel_size=<span class="number">7</span>, stride=<span class="number">2</span>, padding=<span class="number">3</span>),</span><br><span class="line">                   nn.BatchNorm2d(<span class="number">64</span>), nn.ReLU(),</span><br><span class="line">                   nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>, padding=<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<ul>
<li>GoogLeNet在后面接了4个由Inception块组成的模块。 ResNet则使用4个由残差块组成的模块，每个模块使用若干个同样输出通道数的残差块。 第一个模块的通道数同输入通道数一致。 由于之前已经使用了步幅为2的最大汇聚层，所以无须减小高和宽。 之后的每个模块在第一个残差块里将上一个模块的通道数翻倍，并将高和宽减半。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">resnet_block</span>(<span class="params">input_channels, num_channels, num_residuals,</span></span><br><span class="line"><span class="params">                 first_block=<span class="literal">False</span></span>):</span><br><span class="line">    blk = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_residuals):</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> first_block:</span><br><span class="line">            blk.append(Residual(input_channels, num_channels,</span><br><span class="line">                                use_1x1conv=<span class="literal">True</span>, strides=<span class="number">2</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            blk.append(Residual(num_channels, num_channels))</span><br><span class="line">    <span class="keyword">return</span> blk</span><br></pre></td></tr></table></figure>
<ul>
<li>接着在ResNet加入所有残差块，这里每个模块使用2个残差块。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b2 = nn.Sequential(*resnet_block(<span class="number">64</span>, <span class="number">64</span>, <span class="number">2</span>, first_block=<span class="literal">True</span>))</span><br><span class="line">b3 = nn.Sequential(*resnet_block(<span class="number">64</span>, <span class="number">128</span>, <span class="number">2</span>))</span><br><span class="line">b4 = nn.Sequential(*resnet_block(<span class="number">128</span>, <span class="number">256</span>, <span class="number">2</span>))</span><br><span class="line">b5 = nn.Sequential(*resnet_block(<span class="number">256</span>, <span class="number">512</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<ul>
<li>最后，与GoogLeNet一样，在ResNet中加入全局平均汇聚层，以及全连接层输出。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">net = nn.Sequential(b1, b2, b3, b4, b5,</span><br><span class="line">                    nn.AdaptiveAvgPool2d((<span class="number">1</span>,<span class="number">1</span>)),</span><br><span class="line">                    nn.Flatten(), nn.Linear(<span class="number">512</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure>
<ul>
<li>每个模块有4个卷积层（不包括恒等映射的1×1卷积层）。 加上第一个7×7卷积层和最后一个全连接层，共有18层。 因此，这种模型通常被称为ResNet-18。 通过配置不同的通道数和模块里的残差块数可以得到不同的ResNet模型，例如更深的含152层的ResNet-152。 虽然ResNet的主体架构跟GoogLeNet类似，但ResNet架构更简单，修改也更方便。这些因素都导致了ResNet迅速被广泛使用。</li>
</ul>
<img src="/2024/04/23/11-01-29/29-04.png" class>
<h4 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h4><ul>
<li>我们在Fashion-MNIST数据集上训练ResNet</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lr, num_epochs, batch_size = <span class="number">0.05</span>, <span class="number">10</span>, <span class="number">256</span></span><br><span class="line">train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size, resize=<span class="number">96</span>)</span><br><span class="line">d2l.train_ch6(net, train_iter, test_iter, num_epochs, lr, d2l.try_gpu())</span><br></pre></td></tr></table></figure>
<img src="/2024/04/23/11-01-29/29-05.png" class>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>学习嵌套函数（nested function）是训练神经网络的理想情况。在深层神经网络中，学习另一层作为恒等映射（identity function）较容易（尽管这是一个极端情况）。</li>
<li>残差映射可以更容易地学习同一函数，例如将权重层中的参数近似为零。</li>
<li>利用残差块（residual blocks）可以训练出一个有效的深层神经网络：输入可以通过层间的残余连接更快地向前传播。</li>
<li>残差网络（ResNet）对随后的深层神经网络设计产生了深远影响。</li>
</ul>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>28-批量归一化</title>
    <url>/2024/04/23/11-01-28/</url>
    <content><![CDATA[<h2 id="批量归一化"><a href="#批量归一化" class="headerlink" title="批量归一化"></a>批量归一化</h2><p>深层神经网络的训练，尤其是使网络在较短时间内收敛是十分困难的，<strong>批量归一化[batch normalization]</strong>是一种流行且有效的技术，能加速深层网络的收敛速度，目前仍被广泛使用。</p>
<h3 id="训练深层网络时的问题"><a href="#训练深层网络时的问题" class="headerlink" title="训练深层网络时的问题"></a>训练深层网络时的问题</h3><img src="/2024/04/23/11-01-28/deep_model.png" class>
<p>深度神经网络在训练时会遇到一些问题：</p>
<ul>
<li>收敛速度慢：<ul>
<li>由于训练时先正向传播后反向传播，且每层的梯度一般较小，若网络较深，则反向传播时会出现类似于梯度消失的现象，导致距离数据更近的层梯度较小，收敛慢，而距离输出更近的层梯度较大，收敛快。然而底部的层一般都用于提取较基础的特征信息，上方的层收敛后，由于底部提取基础特征的层仍在变化，上方的层一直在不停的重新训练，导致整个网络难以收敛，训练较慢。</li>
</ul>
</li>
<li>内部协变量转移：<ul>
<li>分布偏移：偏移在视频课程中并未出现，但在《动手学深度学习》这本书中有提到过，在<a href="https://zh-v2.d2l.ai/chapter_multilayer-perceptrons/environment.html">4.9. 环境和分布偏移</a>部分。偏移指的是训练数据可能和测试数据的分布不同，比如利用来自真实的猫和狗的照片的训练数据训练模型，然后让模型去预测动画中的猫和狗的图片。<img src="/2024/04/23/11-01-28/cat-dog-train.svg" alt="cat-dog-train"><img src="/2024/04/23/11-01-28/cat-dog-test.svg" alt="cat-dog-test">这显然会降低正确率也会对模型的进一步优化带来干扰。一般情况下对于分布偏移我们毫无办法，然而，在一些特定场景中，如果假定一些训练数据和测试数据分布的前提条件，就能对分布偏移进行处理，其中之一就是协变量偏移。</li>
<li>协变量偏移：协变量偏移假设输入的分布可能随时间变化，但标签函数（条件分布$P(y|\bold x)$）没有改变。统计学家称这为<em>协变量偏移</em>（covariate shift）并给出了一些解决方案</li>
<li><strong>内部协变量偏移(Internal Covariate Shift)</strong>：每一层的参数在更新过程中，会改变下一层输入的分布，导致网络参数变幻莫测，难以收敛，神经网络层数越多，表现得越明显。</li>
<li><font color="red">注意：</font>
* <font color="red">1：内部协变量偏移这个词与标准的协变量偏移所有区别。</font>
* <font color="red">2：能缓解内部协变量偏移仅仅是批量归一化的作者提出的假想，后续论文证实批量归一化实际对内部协变量偏移的缓解帮助不大</font>
* <font color="red">3：批量归一化一般只影响模型的收敛速度，不影响精度</font></li>
</ul>
</li>
<li>过拟合：<ul>
<li>由于网络深度加深，变得更为复杂，使得网络容易过拟合。</li>
</ul>
</li>
</ul>
<h3 id="批量归一化-1"><a href="#批量归一化-1" class="headerlink" title="批量归一化"></a>批量归一化</h3><p><strong>批量归一化(batch normalization)</strong>在 <a href="https://zh-v2.d2l.ai/chapter_references/zreferences.html#ioffe-szegedy-2015">[Ioffe &amp; Szegedy, 2015]</a>中被提出，用于解决上述训练深度网络时的这些问题，然而这只是人们的感性理解，关于批量归一化具体是怎样帮助训练这个问题目前仍待进一步研究。</p>
<p>批量归一化尝试将每个训练中的mini-batch小批量数据（即会导致参数更新的数据）在每一层的结果进行归一化，使其更稳定，归一化指的是对于当前小批量中的所有样本，求出期望和方差，然后将每个样本减去期望再除以标准差。</p>
<h3 id="形式化表达"><a href="#形式化表达" class="headerlink" title="形式化表达"></a>形式化表达</h3><p>下面的运算均为向量运算，向量中的每个维度代表一个特征，对于每个特征分别进行计算再拼接在一起即为向量运算。</p>
<p>设$ \bold x \in \mathcal{B}$为来自一个小批量$\mathcal{B}$的输入，批量规范化BN根据下式进行转换</p>
<script type="math/tex; mode=display">
\mathrm{BN}(\mathbf{x}) = \boldsymbol{\gamma} \odot \frac{\mathbf{x} - \hat{\boldsymbol{\mu}}_\mathcal{B}}{\hat{\boldsymbol{\sigma}}_\mathcal{B}} + \boldsymbol{\beta}.</script><p>式中$\hat{\boldsymbol{\mu}}_\mathcal{B}$为小批量$\mathcal{B}$样本均值，$\hat{\boldsymbol{\sigma}}_\mathcal{B}$为样本标准差：</p>
<script type="math/tex; mode=display">
\begin{split}\begin{aligned} \hat{\boldsymbol{\mu}}_\mathcal{B} &= \frac{1}{|\mathcal{B}|} \sum_{\mathbf{x} \in \mathcal{B}} \mathbf{x},\\
\hat{\boldsymbol{\sigma}}_\mathcal{B}^2 &= \frac{1}{|\mathcal{B}|} \sum_{\mathbf{x} \in \mathcal{B}} (\mathbf{x} - \hat{\boldsymbol{\mu}}_{\mathcal{B}})^2 + \epsilon\end{aligned}\end{split}</script><p>其中$\epsilon$用于防止分母为0，经过减期望与除以标准差后得到期望为1方差为0的小批量数据。然而，期望和方差为了使小批量有更自由的选择，再将其乘拉伸参数$\boldsymbol {\gamma}$，加偏移参数$\boldsymbol \beta$，这两个参数与$\bold x$同样大小，是模型中的可学习参数，与其他参数一同更新。</p>
<p>由于$\hat{\boldsymbol{\mu}}_\mathcal{B}$和$\hat{\boldsymbol{\sigma}}_\mathcal{B}$为由当前小批量计算的值，实际上是整个分布对应的期望与标准差的估计值，由于小批量的随机选择，$\hat{\boldsymbol{\mu}}_\mathcal{B}$和$\hat{\boldsymbol{\sigma}}_\mathcal{B}$会给模型带来一定的与输入数据有关的噪音，而这些噪音也能对模型进行正则化，防止过拟合。为何这种噪音能加快训练并带来正则化还有待研究，不过已有理论说明了为什么批量规范化最适应$50∼100$范围中的中等批量大小的问题。</p>
<p>训练时不能使用整个数据集，只能一步步的训练和更新；而预测时模型已然固定，可以根据整个数据集精确计算均值和方差。因此，批量归一化对于训练和预测时有两种不同模式。</p>
<h3 id="批量归一化层"><a href="#批量归一化层" class="headerlink" title="批量归一化层"></a>批量归一化层</h3><p>批量归一化不再单独的考虑单个样本，需要对整个mini-batch进行，因此需要考虑多种情况。</p>
<h4 id="全连接层"><a href="#全连接层" class="headerlink" title="全连接层"></a>全连接层</h4><p>通常，我们将批量规范化层置于全连接层中的仿射变换和激活函数之间。如下：</p>
<script type="math/tex; mode=display">
\mathbf{h} = \phi(\mathrm{BN}(\mathbf{W}\mathbf{x} + \mathbf{b}))</script><h4 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h4><p>在卷积层中，我们将通道视作每个位置的特征，将每个样本中的每个位置视作一个样本进行计算。每个通道都有着自己的拉伸参数${\gamma}$和偏移参数$\beta$，所有通道加在一起组成了拉伸参数向量$\boldsymbol {\gamma}$和偏移参数向量$\boldsymbol \beta$，若样本数为m，卷积输出为p*q，计算时对m*p*q个向量进行批量归一化运算（即视作有m*p*q个样本）</p>
<h4 id="预测过程中的批量归一化"><a href="#预测过程中的批量归一化" class="headerlink" title="预测过程中的批量归一化"></a>预测过程中的批量归一化</h4><p>在训练过程中，我们需要不断地更新模型，方差和均值也就在不断地变化，就必须计算当前小批量数据对应的方差和均值，然而预测时我们的模型已经确定下来，可以用在整个训练数据集上得到的均值和方差来对预测时的结果进行归一化。</p>
<h4 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h4><ul>
<li><p>在实际实现时，一般使用指数加权平均来更新小批量的均值和方差，指数加权平均将旧值和当前计算结果不断进行加权平均，最终做到平滑的向更新值靠拢，公式如下：</p>
</li>
<li><script type="math/tex; mode=display">
S_t = 
\begin{cases} 
Y_1, &t = 1 \\\\ 
\beta S_{t-1} + (1-\beta)Y_t, &t > 1 
\end{cases}</script></li>
<li><p>批量归一化的参数可以通过动量梯度下降，RMSProp，Adam等多种优化方法进行训练。</p>
</li>
</ul>
<h3 id="吴恩达老师深度学习课程中的批量归一化"><a href="#吴恩达老师深度学习课程中的批量归一化" class="headerlink" title="吴恩达老师深度学习课程中的批量归一化"></a>吴恩达老师深度学习课程中的批量归一化</h3><p>吴恩达老师深度学习课程中的批量归一化中的部分内容与本课程有所出入，考虑到批量归一化这部分内容还没有精确的理论解释，目前的认识仅限于直觉，故将两课程中的区别即补充罗列在此作为参考：</p>
<ul>
<li>关于dropout：<ul>
<li>本课中提到批量归一化有正则化效果，无需再进行dropout</li>
<li>吴恩达老师课程中提到批量归一化正则化效果较差，不能作为正则化的手段，必要时需要dropout</li>
</ul>
</li>
<li>对于线性层（包括其他带有偏置项的层）后的批量归一化，由于归一化时减去了均值，偏置项被消掉，可以省略归一化层之前的偏置项</li>
<li>标准化的输入能使梯度下降加快，批归一化能使得每层的输入都被归一化，这也是训练更快的原因之一</li>
<li>批量归一化可以使得不同层之间互相的影响减少，从而应对数据偏移，增强鲁棒性。</li>
</ul>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>26-网络中的网络（NiN）</title>
    <url>/2024/04/23/11-01-26/</url>
    <content><![CDATA[<h2 id="26-网络中的网络（NiN）"><a href="#26-网络中的网络（NiN）" class="headerlink" title="26-网络中的网络（NiN）"></a>26-网络中的网络（NiN）</h2><h3 id="1-动机"><a href="#1-动机" class="headerlink" title="1. 动机"></a>1. 动机</h3><p><strong>全连接层的问题</strong></p>
<ul>
<li><strong>卷积层</strong>需要的<strong>参数较少</strong></li>
<li>而卷积层后的第一个<strong>全连接层</strong>的<strong>参数较多</strong></li>
</ul>
<img src="/2024/04/23/11-01-26/26-01.png" class>
<p>以VGG为例(图示)，全连接层需要先Flatten，输入维度为512x7x7，输出维度为4096，则需要参数个数为512x7x7x4096=102M。</p>
<h3 id="2-NiN块"><a href="#2-NiN块" class="headerlink" title="2. NiN块"></a>2. NiN块</h3><ul>
<li>核心思想：一个卷积层后面跟两个1x1的卷积层，后两层起到全连接层的作用。</li>
</ul>
<img src="/2024/04/23/11-01-26/26-02.png" class>
<h3 id="3-NiN架构"><a href="#3-NiN架构" class="headerlink" title="3. NiN架构"></a>3. NiN架构</h3><ul>
<li>无全连接层</li>
<li>交替使用NiN块和步幅为2的最大池化层<ul>
<li>逐步减小高宽和增大通道数</li>
</ul>
</li>
<li>最后使用全局平均池化得到输出<ul>
<li>其输入通道是类别数</li>
</ul>
</li>
</ul>
<h3 id="4-NiN-Networks"><a href="#4-NiN-Networks" class="headerlink" title="4. NiN Networks"></a>4. NiN Networks</h3><img src="/2024/04/23/11-01-26/26-03.png" class>
<p>NiN架构如上图右边所示，若干个NiN块(图示中为4个块)+池化层；前3个块后接最大池化层，最后一块连接一个全局平均池化层。</p>
<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><ul>
<li>NiN块结构：使用卷积层加两个1x1卷积层<ul>
<li>后者对每个像素增加了非线性性</li>
</ul>
</li>
<li>NiN使用全局平均池化层来替代VGG和AlexNet中的全连接层<ul>
<li>不容易过拟合，更少的参数个数</li>
</ul>
</li>
</ul>
<h3 id="6-代码"><a href="#6-代码" class="headerlink" title="6.代码"></a>6.代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果在Colab上跑, 或没有安装过d2l包, 需要最开始pip install d2l</span></span><br><span class="line">!pip install git+https://github.com/d2l-ai/d2l-zh@release  <span class="comment"># installing d2l</span></span><br></pre></td></tr></table></figure>
<p><strong>NiN块</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义NiN块</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nin_block</span>(<span class="params">in_channels, out_channels, kernel_size, strides, padding</span>):</span><br><span class="line">    <span class="keyword">return</span> nn.Sequential(</span><br><span class="line">        nn.Conv2d(in_channels, out_channels, kernel_size, strides, padding),</span><br><span class="line">        nn.ReLU(), nn.Conv2d(out_channels, out_channels, kernel_size=<span class="number">1</span>),</span><br><span class="line">        nn.ReLU(), nn.Conv2d(out_channels, out_channels, kernel_size=<span class="number">1</span>),</span><br><span class="line">        nn.ReLU())</span><br></pre></td></tr></table></figure>
<p><strong>NiN模型</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">net = nn.Sequential(</span><br><span class="line">    nin_block(<span class="number">1</span>, <span class="number">96</span>, kernel_size=<span class="number">11</span>, strides=<span class="number">4</span>, padding=<span class="number">0</span>),</span><br><span class="line">    nn.MaxPool2d(<span class="number">3</span>, stride=<span class="number">2</span>),</span><br><span class="line">    nin_block(<span class="number">96</span>, <span class="number">256</span>, kernel_size=<span class="number">5</span>, strides=<span class="number">1</span>, padding=<span class="number">2</span>),</span><br><span class="line">    nn.MaxPool2d(<span class="number">3</span>, stride=<span class="number">2</span>),</span><br><span class="line">    nin_block(<span class="number">256</span>, <span class="number">384</span>, kernel_size=<span class="number">3</span>, strides=<span class="number">1</span>, padding=<span class="number">1</span>),</span><br><span class="line">    nn.MaxPool2d(<span class="number">3</span>, stride=<span class="number">2</span>), nn.Dropout(<span class="number">0.5</span>),</span><br><span class="line">    <span class="comment"># 标签类别数是10</span></span><br><span class="line">    nin_block(<span class="number">384</span>, <span class="number">10</span>, kernel_size=<span class="number">3</span>, strides=<span class="number">1</span>, padding=<span class="number">1</span>),</span><br><span class="line">    nn.AdaptiveAvgPool2d((<span class="number">1</span>, <span class="number">1</span>)),          <span class="comment">#全局平均池化，高宽都变成1</span></span><br><span class="line">    nn.Flatten())             <span class="comment">#消掉最后两个维度, 变成(batch_size, 10)</span></span><br></pre></td></tr></table></figure>
<p><strong>demo测试，查看每个块的输出情况</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = torch.rand(size=(<span class="number">1</span>, <span class="number">1</span>, <span class="number">224</span>, <span class="number">224</span>))</span><br><span class="line"><span class="keyword">for</span> layer <span class="keyword">in</span> net:</span><br><span class="line">    X = layer(X)</span><br><span class="line">    <span class="built_in">print</span>(layer.__class__.__name__, <span class="string">&#x27;output shape:\t&#x27;</span>, X.shape)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;</span><br><span class="line">Sequential output shape:	 torch.Size([<span class="number">1</span>, <span class="number">96</span>, <span class="number">54</span>, <span class="number">54</span>])</span><br><span class="line">MaxPool2d output shape:		 torch.Size([<span class="number">1</span>, <span class="number">96</span>, <span class="number">26</span>, <span class="number">26</span>])</span><br><span class="line">Sequential output shape:	 torch.Size([<span class="number">1</span>, <span class="number">256</span>, <span class="number">26</span>, <span class="number">26</span>])</span><br><span class="line">MaxPool2d output shape:		 torch.Size([<span class="number">1</span>, <span class="number">256</span>, <span class="number">12</span>, <span class="number">12</span>])</span><br><span class="line">Sequential output shape:	 torch.Size([<span class="number">1</span>, <span class="number">384</span>, <span class="number">12</span>, <span class="number">12</span>])</span><br><span class="line">MaxPool2d output shape:		 torch.Size([<span class="number">1</span>, <span class="number">384</span>, <span class="number">5</span>, <span class="number">5</span>])</span><br><span class="line">Dropout output shape:		 torch.Size([<span class="number">1</span>, <span class="number">384</span>, <span class="number">5</span>, <span class="number">5</span>])</span><br><span class="line">Sequential output shape:	 torch.Size([<span class="number">1</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">5</span>])</span><br><span class="line">AdaptiveAvgPool2d output shape:	 torch.Size([<span class="number">1</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line">Flatten output shape:		 torch.Size([<span class="number">1</span>, <span class="number">10</span>])</span><br></pre></td></tr></table></figure>
<p><strong>训练模型</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lr, num_epochs, batch_size = <span class="number">0.1</span>, <span class="number">10</span>, <span class="number">128</span></span><br><span class="line">train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size, resize=<span class="number">224</span>)</span><br><span class="line">d2l.train_ch6(net, train_iter, test_iter, num_epochs, lr, d2l.try_gpu())</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>&lt;Figure size 252x180 <span class="keyword">with</span> <span class="number">1</span> Axes&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>25 使用块的网络 VGG</title>
    <url>/2024/04/23/11-01-25/</url>
    <content><![CDATA[<h2 id="25-使用块的网络-VGG"><a href="#25-使用块的网络-VGG" class="headerlink" title="25 使用块的网络 VGG"></a>25 使用块的网络 VGG</h2><p>Alexnet最大的问题在于长得不规则，结构不甚清晰，也不便于调整。想要把网络做的更深更大需要更好的设计思想和标准框架。</p>
<h3 id="1-VGG块"><a href="#1-VGG块" class="headerlink" title="1. VGG块"></a>1. VGG块</h3><p>直到现在更深更大的模型也是我们努力的方向，在当时AlexNet比LeNet更深更大得到了更好的精度，大家也希望把网络做的更深更大。选择之一是使用更多的全连接层，但全连接层的成本很高；第二个选择是使用更多的卷积层，但缺乏好的指导思想来说明在哪加，加多少。最终VGG采取了将卷积层组合成块，再把卷积块组合到一起的思路。</p>
<p>VGG块可以看作是AlexNet思路的拓展，AlexNet中将三个相同的卷积层放在一起再加上一个池化层，而VGG将其拓展成可以使用任意个3x3，不改变输入大小的的卷积层，最后加上一个2x2的最大池化层。</p>
<img src="/2024/04/23/11-01-25/25-01.PNG" class>
<p>为什么选择3x3卷积呢？在计算量相同的情况下选用更大的卷积核涉及对网络会越浅，VGG作者经过实验发现用3x3卷积的效果要比5x5好，也就是说神经网络库深且窄的效果会更好。</p>
<h3 id="2-VGG架构"><a href="#2-VGG架构" class="headerlink" title="2. VGG架构"></a>2. VGG架构</h3><p>多个VGG块后接全连接层，不同次数的重复块得到不同的架构，如VGG-16, VGG-19等，后面的数字取决于网络层数。</p>
<p>可以讲VGG看作是将AlexNet中连续卷积的部分取出加以推广和复制，并删去了AlexNet中不那么规整的前几层。</p>
<img src="/2024/04/23/11-01-25/25-02.PNG" class>
<p>VGG较AlexNet相比性能有很大的提升，而代价是处理样本速度的降低和内存占用的增加。</p>
<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><ul>
<li><p>VGG使用可重复使用的卷积块来构建深度卷积网络</p>
</li>
<li><p>不同卷积块个数和超参数可以得到不同复杂度的变种</p>
</li>
</ul>
<p>这些思想影响了后面神经网络的设计，在之后的模型中被广泛使用。</p>
<h3 id="4-QA"><a href="#4-QA" class="headerlink" title="4. QA"></a>4. QA</h3><p>Q1: 视觉领域人工特征的研究还有无进展？</p>
<blockquote>
<p>现在在计算机视觉做人工特征是一种“政治不正确”的事，可能会因被认为没有novelty而发不出paper ;-)</p>
<p>老师认为人工特征提取确实应该被取代掉，随着技术进步可以把这部分工作交给机器，人去做更高级的事。</p>
</blockquote>
<p>Q2: 需要学习特征值/特征向量/奇异值分解的知识吗？</p>
<blockquote>
<p>这门课中不一定会讲，但很多深度学习模型用到矩阵分解的思想，但是用的不多，想学可以学。</p>
</blockquote>
<p>Q3: Colab限时12小时与验证码的解决方法</p>
<blockquote>
<p>充钱</p>
</blockquote>
<p>Q4: 训练loss一直下降，测试loss一只不降的原因</p>
<blockquote>
<p>代码写错了/过拟合(训练集和测试集很不一样)</p>
</blockquote>
<p>Q5: 为什么VGG（1，1，224，224）输入高宽减半后通道数是64？</p>
<blockquote>
<p>第一个卷积层的输出通道选的是64。(通道数变化是自定的，和高宽变化没有关系)</p>
</blockquote>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>24-AlexNet</title>
    <url>/2024/04/23/11-01-24/</url>
    <content><![CDATA[<h2 id="AlexNet"><a href="#AlexNet" class="headerlink" title="AlexNet"></a>AlexNet</h2><h3 id="1-历史"><a href="#1-历史" class="headerlink" title="1.历史"></a>1.历史</h3><h4 id="1-1-2000-流行的机器学习方法——SVM，核方法"><a href="#1-1-2000-流行的机器学习方法——SVM，核方法" class="headerlink" title="1.1 2000 流行的机器学习方法——SVM，核方法"></a>1.1 2000 流行的机器学习方法——SVM，核方法</h4><ul>
<li>核方法替代了之前的神经网络网络方法，SVM对于调参不敏感，现在也有一些应用</li>
<li>本质上是特征提取，具体的方法是选择核函数来计算，把特征映射到高纬空间，使得他们线性可分</li>
<li>经过核函数计算之后，原问题可以转化为凸优化问题，这是2006年左右的研究热点</li>
<li><p>核方法有很多漂亮的定理，有很好的数学解释性</p>
</li>
<li><p>2010年左右，深度学习才兴起</p>
</li>
</ul>
<h4 id="1-2-2000计算机视觉主要方法——几何学"><a href="#1-2-2000计算机视觉主要方法——几何学" class="headerlink" title="1.2 2000计算机视觉主要方法——几何学"></a>1.2 2000计算机视觉主要方法——几何学</h4><ul>
<li>首先还是对图片进行特征抽取</li>
<li>希望把计算机视觉问题描述成几何问题，建立（非）凸优化模型，可以得到很多漂亮的定理。</li>
<li>可以假设这是一个几何问题，假设这个假设被满足了，可以推出很好的效果</li>
</ul>
<h4 id="1-3-2010计算机视觉的热点问题——特征工程"><a href="#1-3-2010计算机视觉的热点问题——特征工程" class="headerlink" title="1.3 2010计算机视觉的热点问题——特征工程"></a>1.3 2010计算机视觉的热点问题——特征工程</h4><ul>
<li>特征工程就是怎么抽取一张图片的特征，因为直接输入一张图片效果非常的差</li>
<li>特征描述子：SIFT,SURF</li>
</ul>
<h4 id="1-4-硬件的发展奠定了深度学习的兴起"><a href="#1-4-硬件的发展奠定了深度学习的兴起" class="headerlink" title="1.4 硬件的发展奠定了深度学习的兴起"></a>1.4 硬件的发展奠定了深度学习的兴起</h4><ul>
<li>数据的增长，硬件的计算能力奠定了人们对于方法的选择</li>
</ul>
<img src="/2024/04/23/11-01-24/24-01.png" class>
<h4 id="1-5-ImageNet（2010）"><a href="#1-5-ImageNet（2010）" class="headerlink" title="1.5 ImageNet（2010）"></a>1.5 ImageNet（2010）</h4><img src="/2024/04/23/11-01-24/24-02.png" class>
<ul>
<li><p>AlexNet赢得了2012年ImageNet竞赛冠军</p>
</li>
<li><p>本质上是一个加强版的LeNet，更深更大</p>
</li>
<li><p>AlexNet主要改进措施：</p>
<ul>
<li>dropout（正则）</li>
<li>ReLu（梯度更大）</li>
<li>MaxPooling（取最大值，梯度相对增大）</li>
</ul>
</li>
<li><p>影响：计算机视觉方法论的改变，从人工提取特征过渡到CNN学习特征</p>
</li>
</ul>
<img src="/2024/04/23/11-01-24/24-03.png" class>
<h3 id="2-AlexNet架构"><a href="#2-AlexNet架构" class="headerlink" title="2.AlexNet架构"></a>2.AlexNet架构</h3><img src="/2024/04/23/11-01-24/24-04.png" class>
<img src="/2024/04/23/11-01-24/24-05.png" class>
<img src="/2024/04/23/11-01-24/24-06.png" class>
<ul>
<li>网络代码</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">net = nn.Sequential(</span><br><span class="line">这里，我们使用一个<span class="number">11</span>*<span class="number">11</span>的更大窗口来捕捉对象。</span><br><span class="line">    <span class="comment"># 同时，步幅为4，以减少输出的高度和宽度。</span></span><br><span class="line">    <span class="comment"># 另外，输出通道的数目远大于LeNet</span></span><br><span class="line">    nn.Conv2d(<span class="number">1</span>, <span class="number">96</span>, kernel_size=<span class="number">11</span>, stride=<span class="number">4</span>, padding=<span class="number">1</span>), nn.ReLU(),</span><br><span class="line">    nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>),</span><br><span class="line">    <span class="comment"># 减小卷积窗口，使用填充为2来使得输入与输出的高和宽一致，且增大输出通道数</span></span><br><span class="line">    nn.Conv2d(<span class="number">96</span>, <span class="number">256</span>, kernel_size=<span class="number">5</span>, padding=<span class="number">2</span>), nn.ReLU(),</span><br><span class="line">    nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>),</span><br><span class="line">    <span class="comment"># 使用三个连续的卷积层和较小的卷积窗口。</span></span><br><span class="line">    <span class="comment"># 除了最后的卷积层，输出通道的数量进一步增加。</span></span><br><span class="line">    <span class="comment"># 在前两个卷积层之后，汇聚层不用于减少输入的高度和宽度</span></span><br><span class="line">    nn.Conv2d(<span class="number">256</span>, <span class="number">384</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>), nn.ReLU(),</span><br><span class="line">    nn.Conv2d(<span class="number">384</span>, <span class="number">384</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>), nn.ReLU(),</span><br><span class="line">    nn.Conv2d(<span class="number">384</span>, <span class="number">256</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>), nn.ReLU(),</span><br><span class="line">    nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>),</span><br><span class="line">    nn.Flatten(),</span><br><span class="line">    <span class="comment"># 这里，全连接层的输出数量是LeNet中的好几倍。使用dropout层来减轻过拟合</span></span><br><span class="line">    nn.Linear(<span class="number">6400</span>, <span class="number">4096</span>), nn.ReLU(),</span><br><span class="line">    nn.Dropout(p=<span class="number">0.5</span>),</span><br><span class="line">    nn.Linear(<span class="number">4096</span>, <span class="number">4096</span>), nn.ReLU(),</span><br><span class="line">    nn.Dropout(p=<span class="number">0.5</span>),</span><br><span class="line">    <span class="comment"># 最后是输出层。由于这里使用Fashion-MNIST，所以用类别数为10，而非论文中的1000</span></span><br><span class="line">    nn.Linear(<span class="number">4096</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure>
<ul>
<li>更多细节<ul>
<li>激活函数从sigmoid变成Relu，减缓梯度消失</li>
<li>隐藏全连接层后加入了丢弃层（2个4096之后加入了dropout）</li>
<li>数据增强，将一张图片进行变化，选取多个位置、光照之类的。</li>
</ul>
</li>
</ul>
<img src="/2024/04/23/11-01-24/24-07.png" class>
<ul>
<li>复杂度对比<ul>
<li>参数个数增加，每次更新数据增加</li>
</ul>
</li>
</ul>
<img src="/2024/04/23/11-01-24/24-08.png" class>
<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h3><ul>
<li>AlexNet 是更大更深的LeNet，10x参数个数，260x计算复杂度</li>
<li>新加入了dropout，relu，maxpooling，数据增强</li>
<li>标志着新一轮神经网络热潮开始了</li>
</ul>
<h3 id="4-QA"><a href="#4-QA" class="headerlink" title="4.QA"></a>4.QA</h3><ul>
<li>问题大部分都在问如何炼丹，炼丹的理论，为啥炼丹的步骤要这样不哪有？<ul>
<li>老师说这个确实不好理解，只能从自己的角度去尝试解释</li>
</ul>
</li>
<li>数据增强了，但是效果还不如之前的，为啥？<ul>
<li>太正常了，属于超参数没调好</li>
</ul>
</li>
<li>为啥LeNet不属于深度卷积神经网络？<ul>
<li>为了包装现在的产品，更好卖（确实是这么回答的），这个我们研究者需要学习，好好宣传自己的产品</li>
</ul>
</li>
<li>网络要求输入的size是固定的，实际使用的时候图片不一定是要求的size，怎么处理？<ul>
<li>如果是大的图片，在保持长宽比的情况下，把短边压成输入的size，然后在新的图片中随机抠出来几张图片（要求和网络输入一致）进行预测。效果上不会有太大的影响</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>23-经典卷积神经网络LeNet</title>
    <url>/2024/04/23/11-01-23/</url>
    <content><![CDATA[<h3 id="1-LeNet卷积神经网络"><a href="#1-LeNet卷积神经网络" class="headerlink" title="1.LeNet卷积神经网络"></a>1.LeNet卷积神经网络</h3><h4 id="1-1-手写数字识别"><a href="#1-1-手写数字识别" class="headerlink" title="1.1 手写数字识别"></a>1.1 手写数字识别</h4><ul>
<li>LeNet网络最早是为了应用于手写数字的识别应用。</li>
<li>应用背景：<ul>
<li>邮政局希望可以自动读出信件上的邮政编码</li>
<li>人们希望可以用支票自动取钱</li>
</ul>
</li>
<li>该模型在80年代末的银行被真正的部署</li>
</ul>
<img src="/2024/04/23/11-01-23/23-01.png" class>
<h4 id="1-2-MNIST"><a href="#1-2-MNIST" class="headerlink" title="1.2 MNIST"></a>1.2 MNIST</h4><ul>
<li>LeNet所使用的数据集</li>
<li>50，000个训练数据</li>
<li>10，000个测试数据</li>
<li>图像大小为28*28</li>
<li>10类</li>
</ul>
<img src="/2024/04/23/11-01-23/23-02.png" class>
<h4 id="1-3-LeNet的具体模型"><a href="#1-3-LeNet的具体模型" class="headerlink" title="1.3 LeNet的具体模型"></a>1.3 LeNet的具体模型</h4><img src="/2024/04/23/11-01-23/23-03.png" class>
<h4 id="1-4-总结"><a href="#1-4-总结" class="headerlink" title="1.4 总结"></a>1.4 总结</h4><ul>
<li>LeNet是早期成功的神经网络</li>
<li>先使用卷积层来学习图片空间信息</li>
<li>然后使用全连接层来转换到类别空间</li>
</ul>
<h3 id="2-代码部分"><a href="#2-代码部分" class="headerlink" title="2.代码部分"></a>2.代码部分</h3><h4 id="2-1-定义网络结构和准备工作"><a href="#2-1-定义网络结构和准备工作" class="headerlink" title="2.1 定义网络结构和准备工作"></a>2.1 定义网络结构和准备工作</h4><ul>
<li>导入所需的库</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#导入所需的库</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br></pre></td></tr></table></figure>
<ul>
<li>定义网络结构（具体可参考上文“具体模型”的图）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定义网络结构</span></span><br><span class="line">net = nn.Sequential(</span><br><span class="line">    nn.Conv2d(<span class="number">1</span>, <span class="number">6</span>, kernel_size=<span class="number">5</span>, padding=<span class="number">2</span>), nn.Sigmoid(),</span><br><span class="line">    nn.AvgPool2d(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>),</span><br><span class="line">    nn.Conv2d(<span class="number">6</span>, <span class="number">16</span>, kernel_size=<span class="number">5</span>), nn.Sigmoid(),</span><br><span class="line">    nn.AvgPool2d(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>),</span><br><span class="line">    nn.Flatten(),</span><br><span class="line">    nn.Linear(<span class="number">16</span> * <span class="number">5</span> * <span class="number">5</span>, <span class="number">120</span>), nn.Sigmoid(),</span><br><span class="line">    nn.Linear(<span class="number">120</span>, <span class="number">84</span>), nn.Sigmoid(),</span><br><span class="line">    nn.Linear(<span class="number">84</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure>
<ul>
<li>查看每一层数据的变化情况</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#把每一层数据的shape给打印出来</span></span><br><span class="line">X = torch.rand(size=(<span class="number">1</span>, <span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>), dtype=torch.float32)<span class="comment">#创建符合要求的张量</span></span><br><span class="line"><span class="keyword">for</span> layer <span class="keyword">in</span> net:</span><br><span class="line">    X = layer(X)<span class="comment">#通过每一层</span></span><br><span class="line">    <span class="built_in">print</span>(layer.__class__.__name__,<span class="string">&#x27;output shape: \t&#x27;</span>,X.shape)<span class="comment">#打印</span></span><br></pre></td></tr></table></figure>
<h4 id="2-2-模型训练"><a href="#2-2-模型训练" class="headerlink" title="2.2 模型训练"></a>2.2 模型训练</h4><ul>
<li>下载数据集</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">batch_size = <span class="number">256</span><span class="comment">#批量大小</span></span><br><span class="line">train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size=batch_size)<span class="comment">#下载或加载数据集，得到训练和测试集的迭代对象</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用GPU计算模型在数据集上的精度</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">evaluate_accuracy_gpu</span>(<span class="params">net, data_iter, device=<span class="literal">None</span></span>): <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用GPU计算模型在数据集上的精度&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(net, nn.Module):</span><br><span class="line">        net.<span class="built_in">eval</span>()  <span class="comment"># 设置为评估模式</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> device:</span><br><span class="line">            device = <span class="built_in">next</span>(<span class="built_in">iter</span>(net.parameters())).device</span><br><span class="line">    <span class="comment"># 正确预测的数量，总预测的数量</span></span><br><span class="line">    metric = d2l.Accumulator(<span class="number">2</span>)<span class="comment">#创建一个累加器，包含2个要累加的元素</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> X, y <span class="keyword">in</span> data_iter:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(X, <span class="built_in">list</span>):</span><br><span class="line">                <span class="comment"># BERT微调所需的（之后将介绍）</span></span><br><span class="line">                X = [x.to(device) <span class="keyword">for</span> x <span class="keyword">in</span> X]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                X = X.to(device)</span><br><span class="line">            y = y.to(device)</span><br><span class="line">            metric.add(d2l.accuracy(net(X), y), y.numel())<span class="comment">#把每一组数据预测结果正确的个数和长度累加</span></span><br><span class="line">    <span class="keyword">return</span> metric[<span class="number">0</span>] / metric[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>训练函数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train_ch6</span>(<span class="params">net, train_iter, test_iter, num_epochs, lr, device</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;用GPU训练模型(在第六章定义)&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">init_weights</span>(<span class="params">m</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(m) == nn.Linear <span class="keyword">or</span> <span class="built_in">type</span>(m) == nn.Conv2d:</span><br><span class="line">            nn.init.xavier_uniform_(m.weight)<span class="comment">#对linear类型的层用xavier初始化</span></span><br><span class="line">    net.apply(init_weights)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;training on&#x27;</span>, device)</span><br><span class="line">    net.to(device)</span><br><span class="line">    optimizer = torch.optim.SGD(net.parameters(), lr=lr)</span><br><span class="line">    loss = nn.CrossEntropyLoss()</span><br><span class="line">    animator = d2l.Animator(xlabel=<span class="string">&#x27;epoch&#x27;</span>, xlim=[<span class="number">1</span>, num_epochs],</span><br><span class="line">                            legend=[<span class="string">&#x27;train loss&#x27;</span>, <span class="string">&#x27;train acc&#x27;</span>, <span class="string">&#x27;test acc&#x27;</span>])<span class="comment">#动画需要</span></span><br><span class="line">    timer, num_batches = d2l.Timer(), <span class="built_in">len</span>(train_iter)</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">        <span class="comment"># 训练损失之和，训练准确率之和，范例数</span></span><br><span class="line">        metric = d2l.Accumulator(<span class="number">3</span>)</span><br><span class="line">        net.train()</span><br><span class="line">        <span class="keyword">for</span> i, (X, y) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_iter):</span><br><span class="line">            timer.start()</span><br><span class="line">            optimizer.zero_grad()<span class="comment">#梯度清零</span></span><br><span class="line">            X, y = X.to(device), y.to(device)</span><br><span class="line">            y_hat = net(X)<span class="comment">#正向传播</span></span><br><span class="line">            l = loss(y_hat, y)<span class="comment">#计算损失</span></span><br><span class="line">            l.backward()<span class="comment">#反向传播</span></span><br><span class="line">            optimizer.step()<span class="comment">#梯度下降</span></span><br><span class="line">            <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">                metric.add(l * X.shape[<span class="number">0</span>], d2l.accuracy(y_hat, y), X.shape[<span class="number">0</span>])<span class="comment">#训练损失之和，训练准确率之和，范例数</span></span><br><span class="line">            timer.stop()</span><br><span class="line">            train_l = metric[<span class="number">0</span>] / metric[<span class="number">2</span>]</span><br><span class="line">            train_acc = metric[<span class="number">1</span>] / metric[<span class="number">2</span>]</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span>) % (num_batches // <span class="number">5</span>) == <span class="number">0</span> <span class="keyword">or</span> i == num_batches - <span class="number">1</span>:</span><br><span class="line">                animator.add(epoch + (i + <span class="number">1</span>) / num_batches,</span><br><span class="line">                             (train_l, train_acc, <span class="literal">None</span>))</span><br><span class="line">        test_acc = evaluate_accuracy_gpu(net, test_iter)<span class="comment">#评估测试集的精度</span></span><br><span class="line">        animator.add(epoch + <span class="number">1</span>, (<span class="literal">None</span>, <span class="literal">None</span>, test_acc))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;loss <span class="subst">&#123;train_l:<span class="number">.3</span>f&#125;</span>, train acc <span class="subst">&#123;train_acc:<span class="number">.3</span>f&#125;</span>, &#x27;</span></span><br><span class="line">          <span class="string">f&#x27;test acc <span class="subst">&#123;test_acc:<span class="number">.3</span>f&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;metric[<span class="number">2</span>] * num_epochs / timer.<span class="built_in">sum</span>():<span class="number">.1</span>f&#125;</span> examples/sec &#x27;</span></span><br><span class="line">          <span class="string">f&#x27;on <span class="subst">&#123;<span class="built_in">str</span>(device)&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>运行</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lr, num_epochs = <span class="number">0.9</span>, <span class="number">10</span></span><br><span class="line">train_ch6(net, train_iter, test_iter, num_epochs, lr, d2l.try_gpu())</span><br></pre></td></tr></table></figure>
<img src="/2024/04/23/11-01-23/23-04.png" class>
<h4 id="2-3-总结"><a href="#2-3-总结" class="headerlink" title="2.3 总结"></a>2.3 总结</h4><ul>
<li>卷积神经网络（CNN）是一类使用卷积层的网络。</li>
<li>在卷积神经网络中，我们组合使用卷积层、非线性激活函数和汇聚层。</li>
<li>为了构造高性能的卷积神经网络，我们通常对卷积层进行排列，逐渐降低其表示的空间分辨率，同时增加通道数。</li>
<li>在传统的卷积神经网络中，卷积块编码得到的表征在输出之前需由一个或多个全连接层进行处理。</li>
<li>LeNet是最早发布的卷积神经网络之一（80年代）</li>
</ul>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>22-池化层</title>
    <url>/2024/04/23/11-01-22/</url>
    <content><![CDATA[<h1 id="池化层"><a href="#池化层" class="headerlink" title="池化层"></a>池化层</h1><p>本节将介绍<em>池化</em>（pooling）层，它具有目的：类似于数据增强，降低卷积层对位置的敏感性；一定程度减少计算。</p>
<h2 id="最大池化层和平均池化层"><a href="#最大池化层和平均池化层" class="headerlink" title="最大池化层和平均池化层"></a>最大池化层和平均池化层</h2><p>与卷积层类似，池化层运算符由一个固定形状的窗口组成，该窗口根据其步幅大小在输入的所有区域上滑动，为固定形状窗口遍历的每个位置计算一个输出。<br>然而，不同于卷积层中的输入与卷积核之间的互相关计算，<strong>池化层不包含参数</strong>。<br>相反，池运算符是确定性的，我们通常计算池化窗口中所有元素的最大值或平均值。这些操作分别称为<em>最大池化层</em>（maximum pooling）和<em>平均池化层</em>（average pooling）。</p>
<p>在这两种情况下，与互相关运算符一样，池化窗口从输入张量的左上角开始，从左往右、从上往下的在输入张量内滑动。在池化窗口到达的每个位置，它计算该窗口中输入子张量的最大值或平均值。计算最大值或平均值是取决于使用了最大池化层还是平均池化层。</p>
<p><img src="http://d2l.ai/_images/pooling.svg" alt="池化窗口形状为 $2\times 2$ 的最大池化层。着色部分是第一个输出元素，以及用于计算这个输出的输入元素: $\max(0, 1, 3, 4)=4$."><br>上图中的输出张量的高度为$2$，宽度为$2$。这四个元素为每个池化窗口中的最大值：</p>
<script type="math/tex; mode=display">
\max(0, 1, 3, 4)=4,\\
\max(1, 2, 4, 5)=5,\\
\max(3, 4, 6, 7)=7,\\
\max(4, 5, 7, 8)=8.\\</script><p>池化窗口形状为$p \times q$的池化层称为$p \times q$池化层，池化操作称为$p \times q$池化。</p>
<p>回到本节开头提到的对象边缘检测示例，现在我们将使用卷积层的输出作为$2\times 2$最大池化的输入。<br>设置卷积层输入为<code>X</code>，池化层输出为<code>Y</code>。<br>无论<code>X[i, j]</code>和<code>X[i, j + 1]</code>的值是否不同，或<code>X[i, j + 1]</code>和<code>X[i, j + 2]</code>的值是否不同，池化层始终输出<code>Y[i, j] = 1</code>。<br>也就是说，使用$2\times 2$最大池化层，即使在高度或宽度上移动一个元素，卷积层仍然可以识别到模式。</p>
<p>在下面的代码中的<code>pool2d</code>函数，我们(<strong>实现池化层的前向传播</strong>)。然而，这里我们没有卷积核，输出为输入中每个区域的最大值或平均值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pool2d</span>(<span class="params">X, pool_size, mode=<span class="string">&#x27;max&#x27;</span></span>):</span><br><span class="line">    p_h, p_w = pool_size</span><br><span class="line">    Y = torch.zeros((X.shape[<span class="number">0</span>] - p_h + <span class="number">1</span>, X.shape[<span class="number">1</span>] - p_w + <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(Y.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(Y.shape[<span class="number">1</span>]):  <span class="comment"># 枚举输出的每个位置，[i,j]对应输入的位置[i至i+p_h,j至j+p_w]</span></span><br><span class="line">            <span class="keyword">if</span> mode == <span class="string">&#x27;max&#x27;</span>:  <span class="comment"># 最大池化</span></span><br><span class="line">                Y[i, j] = X[i: i + p_h, j: j + p_w].<span class="built_in">max</span>()  <span class="comment"># max函数返回最大值</span></span><br><span class="line">            <span class="keyword">elif</span> mode == <span class="string">&#x27;avg&#x27;</span>:  <span class="comment"># 平均池化</span></span><br><span class="line">                Y[i, j] = X[i: i + p_h, j: j + p_w].mean()  <span class="comment"># mean函数返回平均值</span></span><br><span class="line">    <span class="keyword">return</span> Y</span><br></pre></td></tr></table></figure>
<p>我们可以构建上图中的输入张量<code>X</code>，[<strong>验证二维最大池化层的输出</strong>]。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = torch.tensor([[<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>], [<span class="number">3.0</span>, <span class="number">4.0</span>, <span class="number">5.0</span>], [<span class="number">6.0</span>, <span class="number">7.0</span>, <span class="number">8.0</span>]])</span><br><span class="line">pool2d(X, (<span class="number">2</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[4., 5.],
        [7., 8.]])
</code></pre><p>此外，我们还可以(<strong>验证平均池化层</strong>)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pool2d(X, (<span class="number">2</span>, <span class="number">2</span>), <span class="string">&#x27;avg&#x27;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[2., 3.],
        [5., 6.]])
</code></pre><h2 id="填充和步幅"><a href="#填充和步幅" class="headerlink" title="填充和步幅"></a>填充和步幅</h2><p>与卷积层一样，池化层也可以改变输出形状。和以前一样，我们可以通过填充和步幅以获得所需的输出形状。<br>下面，我们用深度学习框架中内置的二维最大池化层，来演示池化层中填充和步幅的使用。<br>我们首先构造了一个输入张量<code>X</code>，它有四个维度，其中样本数和通道数都是1。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = torch.arange(<span class="number">16</span>, dtype=torch.float32).reshape(</span><br><span class="line">    (<span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>))  <span class="comment"># 维度[batch_size，通道数，H，W]</span></span><br><span class="line">X</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[[[ 0.,  1.,  2.,  3.],
          [ 4.,  5.,  6.,  7.],
          [ 8.,  9., 10., 11.],
          [12., 13., 14., 15.]]]])
</code></pre><p>默认情况下，(<strong>深度学习框架中的步幅与池化窗口的大小相同</strong>)。<br>因此，如果我们使用形状为<code>(3, 3)</code>的池化窗口，那么默认情况下，我们得到的步幅形状为<code>(3, 3)</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pool2d = nn.MaxPool2d(<span class="number">3</span>)</span><br><span class="line">pool2d(X)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[[[10.]]]])
</code></pre><p>[<strong>填充和步幅可以手动设定</strong>]。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pool2d = nn.MaxPool2d(<span class="number">3</span>, padding=<span class="number">1</span>, stride=<span class="number">2</span>)</span><br><span class="line">pool2d(X)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[[[ 5.,  7.],
          [13., 15.]]]])
</code></pre><p>当然，我们可以(<strong>设定一个任意大小的矩形池化窗口，并分别设定填充和步幅的高度和宽度</strong>)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pool2d = nn.MaxPool2d((<span class="number">2</span>, <span class="number">3</span>), stride=(<span class="number">2</span>, <span class="number">3</span>), padding=(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">pool2d(X)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[[[ 5.,  7.],
          [13., 15.]]]])
</code></pre><h2 id="多个通道"><a href="#多个通道" class="headerlink" title="多个通道"></a>多个通道</h2><p>在处理多通道输入数据时，[<strong>池化层在每个输入通道上单独运算</strong>]，而不是像卷积层一样在通道上对输入进行汇总。<br>这意味着池化层的输出通道数与输入通道数相同。<br>下面，我们将在通道维度上连结张量<code>X</code>和<code>X + 1</code>，以构建具有2个通道的输入。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = torch.cat((X, X + <span class="number">1</span>), <span class="number">1</span>)  <span class="comment"># 在第一个维度也就是通道维度拼接</span></span><br><span class="line">X</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[[[ 0.,  1.,  2.,  3.],
          [ 4.,  5.,  6.,  7.],
          [ 8.,  9., 10., 11.],
          [12., 13., 14., 15.]],

         [[ 1.,  2.,  3.,  4.],
          [ 5.,  6.,  7.,  8.],
          [ 9., 10., 11., 12.],
          [13., 14., 15., 16.]]]])
</code></pre><p>如下所示，池化后输出通道的数量仍然是2。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pool2d = nn.MaxPool2d(<span class="number">3</span>, padding=<span class="number">1</span>, stride=<span class="number">2</span>)</span><br><span class="line">pool2d(X)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[[[ 5.,  7.],
          [13., 15.]],

         [[ 6.,  8.],
          [14., 16.]]]])
</code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>对于给定输入元素，最大池化层会输出该窗口内的最大值，平均池化层会输出该窗口内的平均值。</li>
<li>池化层的主要优点之一是减轻卷积层对位置的过度敏感。</li>
<li>我们可以指定池化层的填充和步幅。</li>
<li>使用最大池化层以及大于1的步幅，可减少空间维度（如高度和宽度）。</li>
<li>池化层的输出通道数与输入通道数相同。</li>
</ul>
<h2 id="问题和练习"><a href="#问题和练习" class="headerlink" title="问题和练习"></a>问题和练习</h2><ol>
<li>你能将平均池化层作为卷积层的特殊情况实现吗？</li>
</ol>
<blockquote>
<p>设卷积层大小是$m\times n$，卷积层里面每个元素参数是$\dfrac{1} {m\times n}$，这样就是一个平均池化层作为卷积层的实现</p>
</blockquote>
<ol>
<li>假设池化层的输入大小为$c\times h\times w$，则汇聚窗口的形状为$p_h\times p_w$，填充为$(p_h, p_w)$，步幅为$(s_h, s_w)$。这个池化层的计算成本是多少？</li>
</ol>
<blockquote>
<p>$ c\times \left \lfloor \dfrac {h-p_h+s_h}{s_h}\right \rfloor \times \left \lfloor \dfrac {w-p_w+s_w}{s_w}\right \rfloor $</p>
</blockquote>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>21-多个输入和输出通道</title>
    <url>/2024/04/23/11-01-21/</url>
    <content><![CDATA[<h1 id="21-多个输入和输出通道"><a href="#21-多个输入和输出通道" class="headerlink" title="21-多个输入和输出通道"></a>21-多个输入和输出通道</h1><h3 id="1-多个输入通道："><a href="#1-多个输入通道：" class="headerlink" title="1.多个输入通道："></a>1.多个输入通道：</h3><ul>
<li><p>彩色图像可能有RGB三个通道</p>
</li>
<li><p>转换为灰度会丢失信息</p>
</li>
</ul>
<img src="/2024/04/23/11-01-21/21-01.png" class>
<ul>
<li>每个通道都有一个卷积和，结果是所有通道卷积结果的和</li>
</ul>
<img src="/2024/04/23/11-01-21/21-02.png" class>
<ul>
<li>输入<strong>X</strong>:<img src="https://latex.codecogs.com/svg.image?c_{i}\times&space;n_{h}\times&space;n_{w}" title="c_{i}\times n_{h}\times n_{w}"></li>
<li>核<strong>W</strong>：<img src="https://latex.codecogs.com/svg.image?c_{i}\times&space;k_{h}\times&space;k_{w}" title="c_{i}\times k_{h}\times k_{w}"></li>
<li>输出<strong>Y</strong>:<img src="https://latex.codecogs.com/svg.image?m_{h}\times&space;m_{w}" title="m_{h}\times m_{w}"></li>
</ul>
<p><img src="https://latex.codecogs.com/svg.image?Y=\sum&space;_{i=0}^{c_{i}}X_{i,:,:}\bigstar&space;W_{i,:,:}" title="Y=\sum _{i=0}^{c_{i}}X_{i,:,:}\bigstar W_{i,:,:}"></p>
<p>多个输入通道：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">corr2d_multi_in</span>(<span class="params">X, K</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(d2l.corr2d(x, k) <span class="keyword">for</span> x, k <span class="keyword">in</span> <span class="built_in">zip</span>(X, K))</span><br></pre></td></tr></table></figure>
<h3 id="2-多个输出通道"><a href="#2-多个输出通道" class="headerlink" title="2.多个输出通道"></a>2.多个输出通道</h3><ul>
<li>无论有多少输入通道，到目前位置我们植绒到单输出通道</li>
<li>我们可以有多个三维卷积核，每个核生成一个输出通道</li>
<li>输入<strong>X</strong>:<img src="https://latex.codecogs.com/svg.image?c_{i}\times&space;k_{h}\times&space;k_{w}" title="c_{i}\times k_{h}\times k_{w}"></li>
<li>核<strong>W</strong>：<img src="https://latex.codecogs.com/svg.image?c_{o}\times&space;c_{i}\times&space;k_{h}\times&space;k_{w}" title="c_{o}\times c_{i}\times k_{h}\times k_{w}"></li>
<li>输出<strong>Y</strong>：<img src="https://latex.codecogs.com/svg.image?c_{o}\times&space;m_{h}\times&space;m_{w}" title="c_{o}\times m_{h}\times m_{w}"></li>
</ul>
<p><img src="https://latex.codecogs.com/svg.image?Y_{i,:,:}=X\bigstar&space;W_{i,:,:}\qquad&space;for&space;\quad&space;i=1,...,c_{o}" title="Y_{i,:,:}=X\bigstar W_{i,:,:}\qquad for \quad i=1,...,c_{o}"></p>
<p>多个输出通道：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">corr2d_multi_in_out</span>(<span class="params">X, K</span>):</span><br><span class="line">    <span class="keyword">return</span> torch.stack([corr2d_multi_in(X, k) <span class="keyword">for</span> k <span class="keyword">in</span> K], <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h3 id="3-多个输入和输出通道"><a href="#3-多个输入和输出通道" class="headerlink" title="3.多个输入和输出通道"></a>3.多个输入和输出通道</h3><ul>
<li>每个通道可以识别特定的模式</li>
</ul>
<img src="/2024/04/23/11-01-21/21-03.png" class>
<ul>
<li>输入通道核识别并组合输入中的模式</li>
</ul>
<h3 id="4-1X1卷积层"><a href="#4-1X1卷积层" class="headerlink" title="4.1X1卷积层"></a>4.1X1卷积层</h3><img src="/2024/04/23/11-01-21/21-04.png" class>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">corr2d_multi_in_out_1x1</span>(<span class="params">X, K</span>):</span><br><span class="line">    c_i, h, w = X.shape</span><br><span class="line">    c_o = K.shape[<span class="number">0</span>]</span><br><span class="line">    X = X.reshape((c_i, h * w))</span><br><span class="line">    K = K.reshape((c_o, c_i))</span><br><span class="line">    Y = torch.matmul(K, X)</span><br><span class="line">    <span class="keyword">return</span> Y.reshape((c_o, h, w))</span><br></pre></td></tr></table></figure>
<h3 id="5-二维卷积层"><a href="#5-二维卷积层" class="headerlink" title="5.二维卷积层"></a>5.二维卷积层</h3><img src="/2024/04/23/11-01-21/21-05.png" class>
<h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h3><ul>
<li>输出通道数是卷积层的超参数</li>
<li>每个输入通道有独立的二维卷积和，所有通道结果相加得到一个输出通道结果</li>
<li>每个输出通道有独立的三维卷积核</li>
</ul>
<h3 id="7-Q-amp-A"><a href="#7-Q-amp-A" class="headerlink" title="7.Q&amp;A"></a>7.Q&amp;A</h3><h5 id="Q1-网络越深，Padding-0-越多，这里是否会影响性能？"><a href="#Q1-网络越深，Padding-0-越多，这里是否会影响性能？" class="headerlink" title="Q1:网络越深，Padding 0 越多，这里是否会影响性能？"></a>Q1:网络越深，Padding 0 越多，这里是否会影响性能？</h5><blockquote>
<p>这里性能分为计算性能和网络性能，Padding 0 不会影响网络精度，但会使计算复杂</p>
</blockquote>
<h5 id="Q2-计算卷积时，bias的有无对结果影响大吗？bias的作用怎么解释？"><a href="#Q2-计算卷积时，bias的有无对结果影响大吗？bias的作用怎么解释？" class="headerlink" title="Q2:计算卷积时，bias的有无对结果影响大吗？bias的作用怎么解释？"></a>Q2:计算卷积时，bias的有无对结果影响大吗？bias的作用怎么解释？</h5><blockquote>
<p>因为正则化的操作，bias对结果影响不大，但加入bias对计算性能基本无影响，故默认加入bias</p>
</blockquote>
<h5 id="Q3-如果是一个rgb图像，加上深度图，相当于是四个通道吗？"><a href="#Q3-如果是一个rgb图像，加上深度图，相当于是四个通道吗？" class="headerlink" title="Q3:如果是一个rgb图像，加上深度图，相当于是四个通道吗？"></a>Q3:如果是一个rgb图像，加上深度图，相当于是四个通道吗？</h5><blockquote>
<p>不是，输入输出通道单列，这里使用3d的卷积，输入变为4维，核是5维</p>
</blockquote>
<h5 id="Q4-怎么理解1x1卷积核不识别空间模式？"><a href="#Q4-怎么理解1x1卷积核不识别空间模式？" class="headerlink" title="Q4:怎么理解1x1卷积核不识别空间模式？"></a>Q4:怎么理解1x1卷积核不识别空间模式？</h5><blockquote>
<p>因为输出的一个像素只对应输入的一个像素，所以没有获取到空间信息</p>
</blockquote>
<h5 id="Q5-是不是可以3x3x3和1x1xN的卷积层叠加，来进行空间信息的检测和信息融合，以及输出通道的调整？"><a href="#Q5-是不是可以3x3x3和1x1xN的卷积层叠加，来进行空间信息的检测和信息融合，以及输出通道的调整？" class="headerlink" title="Q5:是不是可以3x3x3和1x1xN的卷积层叠加，来进行空间信息的检测和信息融合，以及输出通道的调整？"></a>Q5:是不是可以3x3x3和1x1xN的卷积层叠加，来进行空间信息的检测和信息融合，以及输出通道的调整？</h5><blockquote>
<p>是的，mobile net就是这种思想                                                                                                                                                                                                                                                                                 </p>
</blockquote>
<h5 id="Q6：3d卷积是处理视频问题的吧？也可以处理rgb加深度信息吗？"><a href="#Q6：3d卷积是处理视频问题的吧？也可以处理rgb加深度信息吗？" class="headerlink" title="Q6：3d卷积是处理视频问题的吧？也可以处理rgb加深度信息吗？"></a>Q6：3d卷积是处理视频问题的吧？也可以处理rgb加深度信息吗？</h5><blockquote>
<p>都可以，rgb加深度信息甚至可以用2d卷积处理。</p>
</blockquote>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>20-填充和步幅</title>
    <url>/2024/04/23/11-01-20/</url>
    <content><![CDATA[<h2 id="20-填充和步幅"><a href="#20-填充和步幅" class="headerlink" title="20-填充和步幅"></a>20-填充和步幅</h2><h3 id="1-填充"><a href="#1-填充" class="headerlink" title="1. 填充"></a>1. 填充</h3><p><strong>填充</strong>(Padding)指的是在输入周围添加额外的行/列</p>
<img src="/2024/04/23/11-01-20/20-01.png" class>
<p><strong>维度变化</strong>：</p>
<img src="/2024/04/23/11-01-20/20-02.png" class>
<p><strong>两种不同的卷积方式</strong>：<br>①Valid 卷积：不进行填充，卷积运算过后得到的矩阵形状为(n-f+1)×(n-f+1)。 </p>
<p>②Same 卷积：先对矩阵进行填充，然后再进行卷积运算，使得运算前后矩阵大小不变。</p>
<img src="/2024/04/23/11-01-20/20-03.png" class>
<h3 id="2-步幅"><a href="#2-步幅" class="headerlink" title="2. 步幅"></a>2. 步幅</h3><p><strong>想法来源：</strong>如果按照原来的操作(卷积步长为1)，那么给定输入大小为224x224，在使用5x5卷积核的情况下，需要<strong>55层</strong>才能将输出降低到4x4，也就是说，需要大量的计算才能得到维度较小的输出。</p>
<p><strong>步幅</strong>是指行/列的滑动步长</p>
<img src="/2024/04/23/11-01-20/20-04.png" class>
<p><strong>维度变化</strong>:</p>
<img src="/2024/04/23/11-01-20/20-05.png" class>
<p>注意：第三点可以当做结论来记(Same卷积或Valid卷积(且s≥k时))。一般来说，如果n是偶数，s取2，池化层做Valid卷积(不填充)且k=2，此时输出维度直接可以写成n/2 x n/2。如果怕搞混，直接记第一个公式每次现推也可。</p>
<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><ul>
<li><p>填充和步幅是卷积层的<strong>超参数</strong></p>
</li>
<li><p><strong>填充</strong>(padding)在输入周围添加额外的行/列，来控制输出形状的减少量</p>
</li>
<li><strong>步幅</strong>(stride)是每次滑动核窗口时的行/列的步长，可以成倍地减少输出形状</li>
</ul>
<h3 id="4-代码"><a href="#4-代码" class="headerlink" title="4. 代码"></a>4. 代码</h3><h4 id="4-1-填充和步幅"><a href="#4-1-填充和步幅" class="headerlink" title="4.1 填充和步幅"></a>4.1 填充和步幅</h4><p><strong>导入包，定义comp_conv2d函数  (进行卷积操作, 输出后两维，便于观察高宽的维度变化)</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">comp_conv2d</span>(<span class="params">conv2d, X</span>):</span><br><span class="line">    X = X.reshape((<span class="number">1</span>, <span class="number">1</span>) + X.shape) <span class="comment">#X的维度之前加入批量大小数(batch_size)和输入通道数(channel_in)</span></span><br><span class="line">    Y = conv2d(X)                    </span><br><span class="line">    <span class="keyword">return</span> Y.reshape(Y.shape[<span class="number">2</span>:])  <span class="comment">#去掉前面的两维后(原来四维) 进行输出</span></span><br></pre></td></tr></table></figure>
<h4 id="4-2-padding"><a href="#4-2-padding" class="headerlink" title="4.2 padding"></a>4.2 padding</h4><p><strong>在所有侧边填充1个像素(padding=1, 即(1,1))</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conv2d = nn.Conv2d(<span class="number">1</span>, <span class="number">1</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>) <span class="comment">#输入输出通道数为1, 卷积核大小3x3, 填充为1(上下左右各填充一行)</span></span><br><span class="line">X = torch.rand(size=(<span class="number">8</span>, <span class="number">8</span>))         </span><br><span class="line">comp_conv2d(conv2d, X).shape</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.Size([<span class="number">8</span>, <span class="number">8</span>])</span><br></pre></td></tr></table></figure>
<p><strong>填充不同的高度和宽度(padding=(2,1))</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conv2d = nn.Conv2d(<span class="number">1</span>, <span class="number">1</span>, kernel_size=(<span class="number">5</span>, <span class="number">3</span>), padding=(<span class="number">2</span>, <span class="number">1</span>))</span><br><span class="line">comp_conv2d(conv2d, X).shape</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.Size([<span class="number">8</span>, <span class="number">8</span>])</span><br></pre></td></tr></table></figure>
<h4 id="4-3-stride"><a href="#4-3-stride" class="headerlink" title="4.3 stride"></a>4.3 stride</h4><p><strong>将高度和宽度的步幅设置为2</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conv2d = nn.Conv2d(<span class="number">1</span>, <span class="number">1</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>, stride=<span class="number">2</span>)</span><br><span class="line">comp_conv2d(conv2d, X).shape</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.Size([<span class="number">4</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure>
<p><strong>一个稍微复杂的例子</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conv2d = nn.Conv2d(<span class="number">1</span>, <span class="number">1</span>, kernel_size=(<span class="number">3</span>, <span class="number">5</span>), padding=(<span class="number">0</span>, <span class="number">1</span>), stride=(<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">comp_conv2d(conv2d, X).shape</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.Size([<span class="number">2</span>, <span class="number">2</span>])</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>19-卷积层</title>
    <url>/2024/04/23/11-01-19/</url>
    <content><![CDATA[<h2 id="19-卷积层"><a href="#19-卷积层" class="headerlink" title="19-卷积层"></a>19-卷积层</h2><h4 id="本讲文字介绍部分请参考沐神在线书籍-：https-zh-v2-d2l-ai-chapter-convolutional-neural-networks-why-conv-html"><a href="#本讲文字介绍部分请参考沐神在线书籍-：https-zh-v2-d2l-ai-chapter-convolutional-neural-networks-why-conv-html" class="headerlink" title="本讲文字介绍部分请参考沐神在线书籍~：https://zh-v2.d2l.ai/chapter_convolutional-neural-networks/why-conv.html"></a>本讲文字介绍部分请参考沐神在线书籍~：<a href="https://zh-v2.d2l.ai/chapter_convolutional-neural-networks/why-conv.html">https://zh-v2.d2l.ai/chapter_convolutional-neural-networks/why-conv.html</a></h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">corr2d</span>(<span class="params">X,K</span>):    <span class="comment">#X为输入，K为核矩阵</span></span><br><span class="line">    h,w=K.shape    <span class="comment">#h得到K的行数，w得到K的列数</span></span><br><span class="line">    Y=torch.zeros((X.shape[<span class="number">0</span>]-h+<span class="number">1</span>,X.shape[<span class="number">1</span>]-w+<span class="number">1</span>))  <span class="comment">#用0初始化输出矩阵Y</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(Y.shape[<span class="number">0</span>]):   <span class="comment">#卷积运算</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(Y.shape[<span class="number">1</span>]):</span><br><span class="line">          Y[i,j]=(X[i:i+h,j:j+w]*K).<span class="built_in">sum</span>()</span><br><span class="line">    <span class="keyword">return</span> Y</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#样例点测试</span></span><br><span class="line">X=torch.tensor([[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]])</span><br><span class="line">K=torch.tensor([[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">3</span>]])</span><br><span class="line">corr2d(X,K)</span><br></pre></td></tr></table></figure>
<pre><code>&gt;&gt;&gt; tensor([[19., 25.],
            [37., 43.]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#实现二维卷积层</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Conv2d</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_init_</span>(<span class="params">self,kernel_size</span>):</span><br><span class="line">        <span class="built_in">super</span>()._init_()</span><br><span class="line">        self.weight=nn.Parameter(torch.rand(kerner_size))</span><br><span class="line">        self.bias=nn.Parameter(torch.zeros(<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,x</span>):</span><br><span class="line">        <span class="keyword">return</span> corr2d(x,self.weight)+self.bias </span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X=torch.ones((<span class="number">6</span>,<span class="number">8</span>))</span><br><span class="line">X[:,<span class="number">2</span>:<span class="number">6</span>]=<span class="number">0</span></span><br><span class="line">X</span><br></pre></td></tr></table></figure>
<pre><code>&gt;&gt;&gt; tensor([[1., 1., 0., 0., 0., 0., 1., 1.],
        [1., 1., 0., 0., 0., 0., 1., 1.],
        [1., 1., 0., 0., 0., 0., 1., 1.],
        [1., 1., 0., 0., 0., 0., 1., 1.],
        [1., 1., 0., 0., 0., 0., 1., 1.],
        [1., 1., 0., 0., 0., 0., 1., 1.]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">K=torch.tensor([[-<span class="number">1</span>,<span class="number">1</span>]])  <span class="comment">#这个K只能检测垂直边缘</span></span><br><span class="line">Y=corr2d(X,K)</span><br><span class="line">Y</span><br></pre></td></tr></table></figure>
<pre><code>&gt;&gt;&gt; tensor([[ 0., -1.,  0.,  0.,  0.,  1.,  0.],
            [ 0., -1.,  0.,  0.,  0.,  1.,  0.],
            [ 0., -1.,  0.,  0.,  0.,  1.,  0.],
            [ 0., -1.,  0.,  0.,  0.,  1.,  0.],
            [ 0., -1.,  0.,  0.,  0.,  1.,  0.],
            [ 0., -1.,  0.,  0.,  0.,  1.,  0.]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">corr2d(X.t(),K)</span><br></pre></td></tr></table></figure>
<pre><code>&gt;&gt;&gt; tensor([[0., 0., 0., 0., 0.],
            [0., 0., 0., 0., 0.],
            [0., 0., 0., 0., 0.],
            [0., 0., 0., 0., 0.],
            [0., 0., 0., 0., 0.],
            [0., 0., 0., 0., 0.],
            [0., 0., 0., 0., 0.],
            [0., 0., 0., 0., 0.]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conv2d = nn.Conv2d(<span class="number">1</span>, <span class="number">1</span>, kernel_size=(<span class="number">1</span>, <span class="number">2</span>), bias=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">X = X.reshape((<span class="number">1</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">8</span>))</span><br><span class="line">Y = Y.reshape((<span class="number">1</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">7</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    Y_hat = conv2d(X)</span><br><span class="line">    l = (Y_hat - Y)**<span class="number">2</span></span><br><span class="line">    conv2d.zero_grad()</span><br><span class="line">    l.<span class="built_in">sum</span>().backward()</span><br><span class="line">    conv2d.weight.data[:] -= <span class="number">3e-2</span> * conv2d.weight.grad</span><br><span class="line">    <span class="keyword">if</span> (i + <span class="number">1</span>) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;batch <span class="subst">&#123;i+<span class="number">1</span>&#125;</span>, loss <span class="subst">&#123;l.<span class="built_in">sum</span>():<span class="number">.3</span>f&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>&gt;&gt;&gt; batch 2, loss 3.852
    batch 4, loss 1.126
    batch 6, loss 0.386
    batch 8, loss 0.145
    batch 10, loss 0.057
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conv2d.weight.data.reshape((<span class="number">1</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<pre><code>&gt;&gt;&gt; tensor([[-1.0173,  0.9685]])
</code></pre>]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>18-预测房价竞赛总结</title>
    <url>/2024/04/23/11-01-18/</url>
    <content><![CDATA[<h2 id="18-预测房价竞赛总结"><a href="#18-预测房价竞赛总结" class="headerlink" title="18-预测房价竞赛总结"></a>18-预测房价竞赛总结</h2><h3 id="1-方法总结"><a href="#1-方法总结" class="headerlink" title="1.方法总结"></a>1.方法总结</h3><blockquote>
<p>下面提供了排行榜前几使用的方法介绍链接</p>
</blockquote>
<ul>
<li><p>第二和第七：autogluon</p>
<p><a href="https://www.bilibili.com/video/BV1rh411m7Hb/">https://www.bilibili.com/video/BV1rh411m7Hb/</a></p>
</li>
<li><p>第三：h2o</p>
<p><a href="https://www.kaggle.com/wuwawa/automl-using-h2o">https://www.kaggle.com/wuwawa/automl-using-h2o</a></p>
</li>
<li><p>第四：随机森林</p>
<p><a href="https://www.kaggle.com/jackzh/the-4th-place-approach-random-forest">https://www.kaggle.com/jackzh/the-4th-place-approach-random-forest</a></p>
</li>
</ul>
<h3 id="2-分析"><a href="#2-分析" class="headerlink" title="2.分析"></a>2.分析</h3><ul>
<li><p>已知的排名靠前的4个成绩均使用了集成学习</p>
</li>
<li><p>目前不知道是否有使用书中的mlp取得好成绩</p>
<blockquote>
<p>通过调参数，是能够取得很好的结果的</p>
</blockquote>
<p> 对于mlp来说，特征预处理和超参数的调节是取得好成绩的基础</p>
</li>
<li><p>数据的难点</p>
<ul>
<li><p>数值较大</p>
<blockquote>
<p>梯度相对较大，容易发生梯度爆炸</p>
</blockquote>
<p>一个解决方案是可以对数据取对数，再进行标准化</p>
</li>
<li><p>有文本特征（地址，介绍）</p>
<blockquote>
<p>这些文字可能含有较多的噪声，对模型产生影响</p>
</blockquote>
<p>解决办法日后会讲解，比如第二名用的transformer</p>
</li>
<li><p>训练数据是前6个月，公榜是后3个月，私榜是再往后3个月</p>
<blockquote>
<p>利用历史的数据进行训练，在实践中自然会有不同的影响（可能过拟合）</p>
<p>因此公榜与私榜的排名有一定差异</p>
</blockquote>
<pre><code>       这个问题称为Covariate Shift，没有特别好的解决方案  ，可以让模型尽可能稳定，不去仔细调参
</code></pre></li>
</ul>
</li>
</ul>
<h3 id="3-关于automl"><a href="#3-关于automl" class="headerlink" title="3.关于automl"></a>3.关于automl</h3><h4 id="3-1-课程内容"><a href="#3-1-课程内容" class="headerlink" title="3.1 课程内容"></a>3.1 课程内容</h4><blockquote>
<p>这一部分李沐老师要表达的主要是我们应该深入去了解本后的原理，不要因为有”自动化”深度学习而产生一种依赖心理或者变得没有深究深度学习的动力，学习deep learning仍然是有意义的</p>
</blockquote>
<ul>
<li><p>数据科学家80%时间在处理数据，20%调模型</p>
<blockquote>
<p>处理数据是automl不能做的，automl的作用主要在调模型这块，数据科学家仍然能大展身手</p>
</blockquote>
</li>
<li><p>Automl现在能处理一些基础的情况</p>
<blockquote>
<p>目前节省10%时间，未来节省20%时间</p>
</blockquote>
</li>
<li><p>为什么还要学习深度学习</p>
<p>正如买菜只需要用到四则运算甚至不用，我们仍然需要学习三角函数去进行更深入的科学研究等其他事情。当人人都会用Automl的时候，我们仍然需要懂得一些底层的原理，毕竟Automl也是有局限性的，需要我们不断改进，或者想出其他算法。另一方面，我们也要肯定Automl带来的便利。</p>
</li>
</ul>
<h4 id="3-2-补充内容"><a href="#3-2-补充内容" class="headerlink" title="3.2 补充内容"></a>3.2 补充内容</h4><h5 id="AutoGluon"><a href="#AutoGluon" class="headerlink" title="AutoGluon"></a>AutoGluon</h5><blockquote>
<p>与大部分automl框架是基于超参数搜索技术的不同，Autogluon会利用多个机器学习包来训练模型</p>
</blockquote>
<ul>
<li><p>房价预测竞赛中模型的改动</p>
<blockquote>
<p>1.对于数据中数值比较大且数据变化大的数值取log,CPU上训练2个小时，最终排第七</p>
<p>2.房子描述里包含大量文本，使用mutimodal选项来用transformer提取特征，并做多模型融合,用GPU才跑得动，排名第二</p>
</blockquote>
</li>
<li><p>AutoGluon背后的技术</p>
<blockquote>
<p>1.stacking</p>
<p>2.k-则交叉bagging</p>
<p>3.多层stacking</p>
</blockquote>
</li>
<li><p>总结</p>
<blockquote>
<p>1.autogluon在合理的计算开销下得到还不错的模型</p>
<p>2.虽然autogluon可以做自动特征抽取，但是当加入一些人工数据处理也是不错的方法</p>
<p>3.对于比较大的数据集计算开销仍然是瓶颈，需要使用GPU甚至多台机器做分布式训练，这仍是AutoML未来的研究方向</p>
<p>4.具体讲解可参考：<a href="https://www.bilibili.com/video/BV1F84y1F7Ps/?spm_id_from=333.788.recommend_more_video.1">https://www.bilibili.com/video/BV1F84y1F7Ps/?spm_id_from=333.788.recommend_more_video.1</a></p>
</blockquote>
</li>
</ul>
<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h3><p>这节课本身就是一次对预测房价竞赛的总结，主要介绍了排名的分布情况以及一些队伍使用的方法。</p>
<h3 id="5-预测房价竞赛总结-Q-amp-A"><a href="#5-预测房价竞赛总结-Q-amp-A" class="headerlink" title="5.预测房价竞赛总结 Q&amp;A"></a>5.预测房价竞赛总结 Q&amp;A</h3><p><strong>Q1: 统计学专业本科生未来从事人工智能如何规划</strong></p>
<blockquote>
<p>注重动手能力的培养</p>
</blockquote>
<p><strong>Q2: 避免overfit是调参好还是不调参好？老师有何经验分享？</strong></p>
<blockquote>
<p>调参是需要的，首先最好有一个比较好的验证集；当你找到一个在验证集效果比较好的超参数值的时候，最好在这一值上调或下调一点看看是否敏感，如果比较敏感说明这点可能只是在这点凑巧效果好罢了，泛化性就不好；当然在实践中调参并没有像在竞赛中那么重要</p>
</blockquote>
<p><strong>Q3: 老师说的80%时间处理数据是指的找数据、清理数据这些？数据搭建pipeline不就好了， ？为什么改进模型等等不占主要时间？</strong></p>
<blockquote>
<p>处理数据并不是搭建pipeline就好了，你需要决定从哪里获取数据、怎样获取数据、如何处理噪音（清理数据）……这些都是很费时间的</p>
</blockquote>
<p><strong>Q4: AutoML与ML有严格的特征区别吗</strong></p>
<blockquote>
<p>AutoML可以看作是ML中的一类算法</p>
</blockquote>
<p><strong>Q5: 用mlp做竞赛时发现层数深的时候预测出来的房价全是一样的，层数浅一点还不会出现这个问题，为什么？</strong></p>
<blockquote>
<p>应该是梯度爆炸，或者梯度消失，也就是数值稳定性出现问题</p>
</blockquote>
<p><strong>Q6：MLP有值得精细调参的价值吗？</strong></p>
<blockquote>
<p>有。</p>
</blockquote>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>17-使用和购买GPU</title>
    <url>/2024/04/23/11-01-17/</url>
    <content><![CDATA[<h2 id="使用和购买GPU"><a href="#使用和购买GPU" class="headerlink" title="使用和购买GPU"></a>使用和购买GPU</h2><h3 id="使用GPU"><a href="#使用GPU" class="headerlink" title="使用GPU"></a>使用GPU</h3><p>（简而言之，自2000年以来，GPU性能每10年增长1000倍，本节主要介绍如何利用这种计算性能进行研究，首先是使用单个GPU，然后是如何使用多个GPU和多个服务器）</p>
<ul>
<li><p>准备：</p>
<ul>
<li><p>（首先确保至少安装了一个NVDIA GPU，然后下载<a href="https://developer.nvidia.com/cuda-downloads">NVIDIA驱动和CUDA</a>并按照提示设置适当的路径）</p>
</li>
<li><p>查看显卡信息：        </p>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">!nvidia-smi</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Fri Jan <span class="number">14</span> 03:<span class="number">23</span>:<span class="number">18</span> <span class="number">2022</span></span><br><span class="line">+-----------------------------------------------------------------------------+</span><br><span class="line">| NVIDIA-SMI <span class="number">418.67</span>       Driver Version: <span class="number">418.67</span>       CUDA Version: <span class="number">10.1</span>     |</span><br><span class="line">|-------------------------------+----------------------+----------------------+</span><br><span class="line">| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |</span><br><span class="line">| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |</span><br><span class="line">|===============================+======================+======================|</span><br><span class="line">|   <span class="number">0</span>  Tesla V100-SXM2...  Off  | <span class="number">00000000</span>:<span class="number">00</span>:1B<span class="number">.0</span> Off |                    <span class="number">0</span> |</span><br><span class="line">| N/A   43C    P0    74W / 300W |   1608MiB / 16130MiB |      <span class="number">0</span>%      Default |</span><br><span class="line">+-------------------------------+----------------------+----------------------+</span><br><span class="line">|   <span class="number">1</span>  Tesla V100-SXM2...  Off  | <span class="number">00000000</span>:<span class="number">00</span>:1C<span class="number">.0</span> Off |                    <span class="number">0</span> |</span><br><span class="line">| N/A   42C    P0    62W / 300W |   1706MiB / 16130MiB |      <span class="number">9</span>%      Default |</span><br><span class="line">+-------------------------------+----------------------+----------------------+</span><br><span class="line">|   <span class="number">2</span>  Tesla V100-SXM2...  Off  | <span class="number">00000000</span>:<span class="number">00</span>:1D<span class="number">.0</span> Off |                    <span class="number">0</span> |</span><br><span class="line">| N/A   64C    P0    68W / 300W |     11MiB / 16130MiB |      <span class="number">0</span>%      Default |</span><br><span class="line">+-------------------------------+----------------------+----------------------+</span><br><span class="line">|   <span class="number">3</span>  Tesla V100-SXM2...  Off  | <span class="number">00000000</span>:<span class="number">00</span>:1E<span class="number">.0</span> Off |                    <span class="number">0</span> |</span><br><span class="line">| N/A   57C    P0    45W / 300W |     11MiB / 16130MiB |      <span class="number">0</span>%      Default |</span><br><span class="line">+-------------------------------+----------------------+----------------------+</span><br><span class="line"></span><br><span class="line">+-----------------------------------------------------------------------------+</span><br><span class="line">| Processes:                                                       GPU Memory |</span><br><span class="line">|  GPU       PID   <span class="type">Type</span>   Process name                             Usage      |</span><br><span class="line">|=============================================================================|</span><br><span class="line">|    <span class="number">0</span>      <span class="number">5034</span>      C   ...conda3/envs/d2l-en-release-<span class="number">0</span>/<span class="built_in">bin</span>/python  1597MiB |</span><br><span class="line">|    <span class="number">1</span>      <span class="number">5034</span>      C   ...conda3/envs/d2l-en-release-<span class="number">0</span>/<span class="built_in">bin</span>/python  1695MiB |</span><br></pre></td></tr></table></figure>
<p>（可以看到这里显示有4块Tesla V100的GPU，Memory-Usage显示的是“当前使用空间 / 总空间”，GPU-Util显示的是模型训练时GPU的使用率，如果为50%以下说明模型可能不太好）</p>
<ul>
<li><p>准备（续）：</p>
<ul>
<li>在PyTorch中，每个数组都有一个设备（device）， 我们通常将其称为上下文（context）。 默认情况下，所有变量和相关的计算都分配给CPU。 有时上下文可能是GPU。 当我们跨多个服务器部署作业时，事情会变得更加棘手。 通过智能地将数组分配给上下文， 我们可以最大限度地减少在设备之间传输数据的时间。 例如，当在带有GPU的服务器上训练神经网络时， 我们通常希望模型的参数在GPU上。</li>
<li>要运行此部分中的程序，至少需要两个GPU。 注意，对于大多数桌面计算机来说，这可能是奢侈的，但在云中很容易获得。 例如，你可以使用AWS EC2的多GPU实例。 本书的其他章节大都不需要多个GPU， 而本节只是为了展示数据如何在不同的设备之间传递。</li>
</ul>
</li>
<li><p>计算设备：</p>
<ul>
<li><p>我们可以指定用于存储和计算的设备，如CPU和GPU。 默认情况下，张量是在内存中创建的，然后使用CPU计算它。所有的深度学习框架都是默认在CPU上做运算，如果要使用GPU则需要指定计算机更换运算位置 。</p>
</li>
<li><p>在PyTorch中，CPU和GPU可以用<code>torch.device(&#39;cpu&#39;)</code> 和<code>torch.device(&#39;cuda&#39;)</code>表示。</p>
</li>
<li><p><code>cpu</code>设备意味着所有物理CPU和内存， 这意味着PyTorch的计算将尝试使用所有CPU核心。 然而，<code>gpu</code>设备只代表一个卡和相应的显存。 </p>
</li>
<li><p>如果有多个GPU，我们使用<code>torch.device(f&#39;cuda:&#123;i&#125;&#39;)</code> 来表示第<em>i</em>块GPU（<em>i</em>从0开始）。 另外，<code>cuda:0</code>和<code>cuda</code>是等价的。</p>
</li>
<li><p>```python<br>import torch<br>from torch import nn</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```python</span><br><span class="line">  &quot;&quot;&quot;指定cpu, gpu设备&quot;&quot;&quot;</span><br><span class="line">  torch.device(&#x27;cpu&#x27;), torch.device(&#x27;cuda&#x27;), torch.device(&#x27;cuda:1&#x27;)</span><br><span class="line">  # cpu, gpu0, gpu1</span><br><span class="line">  </span><br><span class="line">  &quot;&quot;&quot;</span><br><span class="line">  输出:</span><br><span class="line">  (device(type=&#x27;cpu&#x27;), device(type=&#x27;cuda&#x27;), device(type=&#x27;cuda&#x27;, index=1))</span><br><span class="line">  &quot;&quot;&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>```python<br>“””查询可用gpu数量”””<br>torch.cuda.device_count()</p>
<p>“””<br>输出:<br>2<br>“””</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```python</span><br><span class="line">  &quot;&quot;&quot;定义了两个方便的函数， 这两个函数允许我们在不存在所需所有GPU的情况下运行代码&quot;&quot;&quot;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  &quot;&quot;&quot;如果存在，则返回gpu(i)，否则返回cpu()&quot;&quot;&quot;</span><br><span class="line">  def try_gpu(i=0):</span><br><span class="line">  # 不输入参数则默认i = 0 </span><br><span class="line">      if torch.cuda.device_count() &gt;= i + 1:</span><br><span class="line">          return torch.device(f&#x27;cuda:&#123;i&#125;&#x27;)</span><br><span class="line">       # 如果当前可用gpu的总数大于等于i+1，则返回第i个gpu（从0计数）		</span><br><span class="line">      return torch.device(&#x27;cpu&#x27;)</span><br><span class="line">  	# 否则证明当前没有更多可用gpu，则返回cpu</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  &quot;&quot;&quot;返回所有可用的GPU，如果没有GPU，则返回[cpu(),]&quot;&quot;&quot;</span><br><span class="line">  def try_all_gpus():</span><br><span class="line">      devices = [torch.device(f&#x27;cuda:&#123;i&#125;&#x27;)</span><br><span class="line">               for i in range(torch.cuda.device_count())]</span><br><span class="line">      # 所有可用gpu设备序号组成的列表devices</span><br><span class="line">      </span><br><span class="line">      return devices if devices else [torch.device(&#x27;cpu&#x27;)]</span><br><span class="line">  	# 如果列表devices不为空则证明此时有可用的gpu，则返回可用gpu序号列表；否则证明没有可用gpu，则返回cpu</span><br><span class="line">  </span><br><span class="line">  try_gpu(), try_gpu(10), try_all_gpus()</span><br><span class="line">  # 测试函数功能</span><br><span class="line">  # try_gpu():检测是否有第i=0号gpu</span><br><span class="line">  # try_gpu(10):检测是否有第i=10号gpu</span><br><span class="line">  # try_all_gpus():返回所有可用gpu序号列表，如果没有gpu则返回cpu</span><br><span class="line">  </span><br><span class="line">  &quot;&quot;&quot;</span><br><span class="line">  输出：</span><br><span class="line">  (device(type=&#x27;cuda&#x27;, index=0),</span><br><span class="line">   device(type=&#x27;cpu&#x27;),</span><br><span class="line">   [device(type=&#x27;cuda&#x27;, index=0), device(type=&#x27;cuda&#x27;, index=1)])</span><br><span class="line">  &quot;&quot;&quot;</span><br><span class="line">  </span><br><span class="line">  # device(type=&#x27;cuda&#x27;, index=0): 有第0号gpu</span><br><span class="line">  # device(type=&#x27;cpu&#x27;): 没有第10号gpu</span><br><span class="line">  # [device(type=&#x27;cuda&#x27;, index=0), device(type=&#x27;cuda&#x27;, index=1)]: 共有序号为0、1的两个gpu</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>张量与GPU</p>
<ul>
<li><p>```python<br>“””我们可以查询张量所在的设备。 默认情况下，张量是在CPU上创建的。”””<br>x = torch.tensor([1, 2, 3])<br>x.device</p>
<p>“””<br>device(type=’cpu’)<br>“””</p>
<h1 id="默认情况下，张量是在CPU上创建的"><a href="#默认情况下，张量是在CPU上创建的" class="headerlink" title="默认情况下，张量是在CPU上创建的"></a>默认情况下，张量是在CPU上创建的</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 注意：无论何时我们要对多个项进行操作， 它们都必须在同一个设备上。 例如，如果我们对两个张量求和， 我们需要确保两个张量都位于同一个设备上， 否则框架将不知道在哪里存储结果，甚至不知道在哪里执行计算。</span><br><span class="line"></span><br><span class="line">- 存储在GPU上：</span><br><span class="line"></span><br><span class="line">  ```python</span><br><span class="line">  &quot;&quot;&quot;我们在第一个gpu上创建张量变量X&quot;&quot;&quot; </span><br><span class="line">  X = torch.ones(2, 3, device=try_gpu())</span><br><span class="line">  &quot;&quot;&quot;</span><br><span class="line">  tensor([[1., 1., 1.],</span><br><span class="line">          [1., 1., 1.]], device=&#x27;cuda:0&#x27;)</span><br><span class="line">  &quot;&quot;&quot;</span><br><span class="line">  </span><br><span class="line">  &quot;&quot;&quot;假设你至少有两个GPU，下面的代码将在第二个GPU上创建一个随机张量&quot;&quot;&quot;</span><br><span class="line">  Y = torch.rand(2, 3, device=try_gpu(1))</span><br><span class="line">  &quot;&quot;&quot;</span><br><span class="line">  tensor([[0.3432, 0.4088, 0.7725],</span><br><span class="line">          [0.0571, 0.3341, 0.2544]], device=&#x27;cuda:1&#x27;)</span><br><span class="line">  &quot;&quot;&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>复制：如果我们要计算<code>X + Y</code>，我们需要决定在哪里执行这个操作。 例如，如下图所示， 我们可以将<code>X</code>传输到第二个GPU并在那里执行操作。 <em>不要</em>简单地<code>X</code>加上<code>Y</code>，因为这会导致异常， 运行时引擎不知道该怎么做：它在同一设备上找不到数据会导致失败。 由于<code>Y</code>位于第二个GPU上，所以我们需要将<code>X</code>移到那里， 然后才能执行相加运算。</p>
<img src="/2024/04/23/11-01-17/17-01.png" class>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>```python<br>“””将gpu(0)中的X复制到gpu(1)中的Z”””<br>Z = X.cuda(1)<br>print(X)<br>print(Z)</p>
<p>“””<br>tensor([[1., 1., 1.],</p>
<pre><code>    [1., 1., 1.]], device=&#39;cuda:0&#39;)
</code></pre><p>tensor([[1., 1., 1.],</p>
<pre><code>    [1., 1., 1.]], device=&#39;cuda:1&#39;)
</code></pre><p>“””</p>
</li>
</ul>
<pre><code>&quot;&quot;&quot;现在数据在同一个GPU上（Z和Y都在），我们可以将它们相加。&quot;&quot;&quot;
Y + Z

&quot;&quot;&quot;
tensor([[1.3432, 1.4088, 1.7725],
        [1.0571, 1.3341, 1.2544]], device=&#39;cuda:1&#39;)
&quot;&quot;&quot;


&quot;&quot;&quot;如果变量Z已经存在于第i个GPU上，再调用Z.cuda(i)只会返回Z并不会复制并分配新内存&quot;&quot;&quot;
Z.cuda(1) is Z

&quot;&quot;&quot;
True
&quot;&quot;&quot;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - 旁注：人们使用GPU来进行机器学习，因为单个GPU相对运行速度快。 但是在设备（CPU、GPU和其他机器）之间传输数据比计算慢得多。 这也使得并行化变得更加困难，因为我们必须等待数据被发送（或者接收）， 然后才能继续进行更多的操作。 这就是为什么拷贝操作要格外小心。根据经验，多个小操作比一个大操作糟糕得多。 此外，一次执行几个操作比代码中散布的许多单个操作要好得多（除非你确信自己在做什么）。 如果一个设备必须等待另一个设备才能执行其他操作， 那么这样的操作可能会阻塞。 这有点像排队订购咖啡，而不像通过电话预先订购： 当你到店的时候，咖啡已经准备好了。当我们打印张量或将张量转换为NumPy格式时， 如果数据不在内存中，框架会首先将其复制到内存中， 这会导致额外的传输开销。 更糟糕的是，它现在受制于全局解释器锁，使得一切都得等待Python完成。				</span><br><span class="line"></span><br><span class="line">- 神经网络与GPU</span><br><span class="line"></span><br><span class="line">  - 类似地，神经网络模型可以指定设备。 下面的代码将模型参数放在GPU上。</span><br><span class="line"></span><br><span class="line">    ```python</span><br><span class="line">    net = nn.Sequential(nn.Linear(3, 1))</span><br><span class="line">    net = net.to(device=try_gpu())</span><br></pre></td></tr></table></figure>
</code></pre><ul>
<li><p>当输入为GPU上的张量时，模型将在同一GPU上计算结果。总之，只要所有的数据和参数都在同一个设备上， 我们就可以有效地学习模型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">net(X)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([[0.5037],</span></span><br><span class="line"><span class="string">        [0.5037]], device=&#x27;cuda:0&#x27;, grad_fn=&lt;AddmmBackward&gt;)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">net[<span class="number">0</span>].weight.data.device</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">device(type=&#x27;cuda&#x27;, index=0)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="购买GPU"><a href="#购买GPU" class="headerlink" title="购买GPU"></a>购买GPU</h3><p>目前，AMD和NVIDIA是专用GPU的两大主要制造商。NVIDIA是第一个进入深度学习领域的公司，通过CUDA为深度学习框架提供更好的支持。因此，大多数买家选择NVIDIA GPU。</p>
<p>NVIDIA提供两种类型的GPU，针对个人用户（例如，通过GTX和RTX系列）和企业用户（通过其Tesla系列）。这两种类型的GPU提供了相当的计算能力。但是，企业用户GPU通常使用强制（被动）冷却、更多内存和ECC（纠错）内存。这些GPU更适用于数据中心，通常成本是消费者GPU的十倍。</p>
<p>如果你是一个拥有100个服务器的大公司，你应该考虑英伟达Tesla系列，或者在云中使用GPU服务器。对于实验室或10+服务器的中小型公司，英伟达RTX系列可能是最具成本效益的。你可以购买超微或华硕机箱的预配置服务器，这些服务器可以有效地容纳4-8个GPU。</p>
<p>GPU供应商通常每一到两年发布一代，例如2017年发布的GTX 1000（Pascal）系列和2019年发布的RTX 2000（Turing）系列。每个系列都提供几种不同的型号，提供不同的性能级别。GPU性能主要是以下三个参数的组合：</p>
<ol>
<li><strong>计算能力</strong>。通常我们追求32位浮点计算能力。16位浮点训练（FP16）也进入主流。如果你只对预测感兴趣，还可以使用8位整数。最新一代图灵GPU提供4-bit加速。不幸的是，目前训练低精度网络的算法还没有普及。</li>
<li><strong>内存大小</strong>。随着你的模型变大或训练期间使用的批量变大，你将需要更多的GPU内存。检查HBM2（高带宽内存）与GDDR6（图形DDR）内存。HBM2速度更快，但成本更高。</li>
<li><strong>内存带宽</strong>。只有当你有足够的内存带宽时，你才能最大限度地利用你的计算能力。如果使用GDDR6，请追求宽内存总线。</li>
</ol>
<p>对于大多数用户来说，只需看看计算能力就足够了。请注意，许多GPU提供不同类型的加速。例如，NVIDIA的Tensor Cores将操作符子集的速度提高了5×</p>
<p>。确保你的库支持这一点。GPU内存应不小于4GB（8GB更好）。尽量避免将GPU也用于显示GUI（改用内置显卡）。如果无法避免，请添加额外的2GB RAM以确保安全。</p>
<p>下图比较了各种GTX 900、GTX 1000和RTX 2000系列的（GFlops）和价格（Price）。价格是维基百科上的建议价格。</p>
<img src="/2024/04/23/11-01-17/17-02.png" class>
<p>我们可以看到很多事情：</p>
<ol>
<li>在每个系列中，价格和性能大致成比例。Titan因拥有大GPU内存而有相当的溢价。然而，通过比较980 Ti和1080 Ti可以看出，较新型号具有更好的成本效益。RTX 2000系列的价格似乎没有多大提高。然而，它们提供了更优秀的低精度性能（FP16、INT8和INT4）。</li>
<li>GTX 1000系列的性价比大约是900系列的两倍。</li>
<li>对于RTX 2000系列，浮点计算能力是价格的“仿射”函数。</li>
</ol>
<img src="/2024/04/23/11-01-17/17-03.png" class>
<p>上图显示了能耗与计算量基本成线性关系。其次，后一代更有效率。这似乎与对应于RTX 2000系列的图表相矛盾。然而，这是TensorCore不成比例的大能耗的结果。</p>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>16-Pytorch神经网络基础</title>
    <url>/2024/04/23/11-01-16/</url>
    <content><![CDATA[<h2 id="Pytorch神经网络基础"><a href="#Pytorch神经网络基础" class="headerlink" title="Pytorch神经网络基础"></a>Pytorch神经网络基础</h2><h3 id="层和块"><a href="#层和块" class="headerlink" title="层和块"></a>层和块</h3><p>在之前的内容中，我们认识了一些神经网络，比如：线性回归，Softmax回归，多层感知机；他们有的是整个模型，有的是一层神经网络，有的甚至只是一个单元，他们的功能以及复杂程度也各不相同，但他们都有着如下三个特征：</p>
<ul>
<li>接受一些输入</li>
<li>产生对应的输出</li>
<li>由一组可调整参数描述</li>
</ul>
<p>对于一些复杂的网络，研究讨论比层大但比整个模型小的部分很有意义，因为复杂的网络中经常有重复出现的部分，每个部分也常常有自己的功能。考虑到上面的三个特征，这就使得我们思考是否可以对这些部分进行一个抽象，这就得到了块的概念：块指单个层，多个层组成的部分，或者整个模型本身。使用块对整个模型进行描述就简便许多，这一过程是递归的，块的内部还可以划分为多个块，直至满足需要为止。</p>
<p>PyTorch帮我们实现了块的大部分所需功能，包括自动求导，我们只需从nn.Module继承并改写其中的一部分就能得到我们需要的块以及模型，具体做法和细节见代码中的注释</p>
<h3 id="参数管理"><a href="#参数管理" class="headerlink" title="参数管理"></a>参数管理</h3><p>在选择了架构并设置了超参数后，我们就进入了训练阶段。此时，我们的目标是找到使损失函数最小化的模型参数值。经过训练后，我们将需要使用这些参数来做出未来的预测。此外，有时我们希望提取参数，以便在其他环境中复用它们，将模型保存下来，以便它可以在其他软件中执行，或者为了获得科学的理解而进行检查。</p>
<p>此部分主要为代码实现，笔记见代码中的注释</p>
<h3 id="延后初始化"><a href="#延后初始化" class="headerlink" title="延后初始化"></a>延后初始化</h3><p>有时在建立网络时，我们不会指定网络的输入输出维度，也就不能确定网络的参数形状，深度学习框架支持延后初始化，即当第一次将数据传入模型时自动的得到所有的维度，然后初始化所有的参数。</p>
<p>PyTorch也支持这一点，比如nn.LazyLinear，但本门课程中并未介绍。</p>
<h3 id="自定义层"><a href="#自定义层" class="headerlink" title="自定义层"></a>自定义层</h3><p>深度学习成功背后的一个因素是神经网络的灵活性：我们可以用创造性的方式组合不同的层，从而设计出适用于各种任务的架构。例如，研究人员发明了专门用于处理图像、文本、序列数据和执行动态规划的层。同样的，对于层而言，深度学习框架并不能满足我们所有的需求，然而，层本身也具有极大的灵活性，我们可以自定义想要的层。</p>
<p>此部分主要为代码实现，笔记见代码中的注释</p>
<h3 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h3><p>到目前为止，我们讨论了如何处理数据，以及如何构建、训练和测试深度学习模型。然而，有时我们希望保存训练的模型，以备将来在各种环境中使用（比如在部署中进行预测）。此外，当运行一个耗时较长的训练过程时，最佳的做法是定期保存中间结果，以确保在服务器电源被不小心断掉时，我们不会损失几天的计算结果。</p>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>15-实战Kaggle比赛：预测房价</title>
    <url>/2024/04/23/11-01-15/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.04.24：初稿</li>
</ul>
<h2 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h2><ul>
<li><a href="/2024/04/24/12-18-34/" title="动手学深度学习笔记汇总">动手学深度学习笔记汇总</a>
</li>
</ul>
<h3 id="课程练习，kaggle比赛"><a href="#课程练习，kaggle比赛" class="headerlink" title="课程练习，kaggle比赛"></a>课程练习，kaggle比赛</h3><ul>
<li><a href="https://www.kaggle.com/c/house-prices-advanced-regression-techniques">kaggle</a></li>
<li>有一份解决方案公布在论坛里</li>
</ul>
<h3 id="实战Kaggle比赛：预测房价"><a href="#实战Kaggle比赛：预测房价" class="headerlink" title="实战Kaggle比赛：预测房价"></a>实战Kaggle比赛：预测房价</h3><ul>
<li><p>实际上这个时间竞赛已经结束了。</p>
</li>
<li><p>这节目的是提供大家一个实际操作的机会，使用的大多是前面学到的知识。课程提供了代码样本，酒体内容详见含注释的代码中。</p>
</li>
<li>简单介绍一下数据集的内容，数据集是加州2020年几乎全部的房子交易记录，这里选择前半年的数据作为训练集，后半年作为验证集，包括许多的信息，如：ID，洗手间个数，卧室个数，政府预测价格等等共41个特征，连结如下：<a href="https://www.kaggle.com/c/california-house-prices/data?select=train.csv">https://www.kaggle.com/c/california-house-prices/data?select=train.csv</a> 需要大家自行下载数据集（没有kaglle账户的要注册才可以下载）</li>
<li>在真实数据集上，已经提供的程序得到的效果会很差，需要我们使用各种方法来优化，例如dropout，weught decay等，期待大家取得好成绩！</li>
</ul>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>14-数值稳定性+模型初始化和激活函数</title>
    <url>/2024/04/23/11-01-14/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.04.24：初稿</li>
</ul>
<h2 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h2><ul>
<li><a href="/2024/04/24/12-18-34/" title="动手学深度学习笔记汇总">动手学深度学习笔记汇总</a>
</li>
</ul>
<h2 id="14-数值稳定性-模型初始化和激活函数"><a href="#14-数值稳定性-模型初始化和激活函数" class="headerlink" title="14-数值稳定性+模型初始化和激活函数"></a>14-数值稳定性+模型初始化和激活函数</h2><h3 id="1-数值稳定性"><a href="#1-数值稳定性" class="headerlink" title="1. 数值稳定性"></a>1. 数值稳定性</h3><p>数值稳定性是深度学习中比较重要的点，特别是当神经网络变得很深的时候，数值通常很容易变得不稳定。</p>
<h4 id="1-1-神经网络的梯度"><a href="#1-1-神经网络的梯度" class="headerlink" title="1.1 神经网络的梯度"></a>1.1 神经网络的梯度</h4><img src="/2024/04/23/11-01-14/14-01.png" class>
<p><strong>考虑d层神经网络</strong></p>
<ul>
<li><p>t表示层数，$h^{t-1}$表示第<em>t-1</em>层的输出，经过一个$f_{t}$函数后，得到第<em>t</em>层的输出。</p>
</li>
<li><p>最终输出y的表示：输入x经过若干层(<em>d</em>层)的函数作用，最后被损失函数作用得到输出y。</p>
</li>
</ul>
<p><strong>计算损失函数<em>L</em>关于第<em>t</em>层参数$W_{t}$的梯度</strong></p>
<ul>
<li><p>由链导法则得到上图中乘积公式</p>
</li>
<li><p>需要进行d-t次<strong>矩阵乘法</strong>（为什么是矩阵乘法？答：由于所有的<em>h</em>都是一些<strong>向量</strong>，导数中分子分母均为向量，所以求导得到的是矩阵，维数为[分子维度]x[分母维度]，可以参考第6节<a href="https://www.bilibili.com/video/BV1eZ4y1w7PY">视频</a>和<a href="./06-矩阵计算.md">笔记</a>）。这也是导致数值稳定性问题的<strong>主要因素</strong>，由于做了太多次的矩阵乘法。</p>
</li>
</ul>
<h4 id="1-2-数值稳定性的常见两个问题"><a href="#1-2-数值稳定性的常见两个问题" class="headerlink" title="1.2 数值稳定性的常见两个问题"></a>1.2 数值稳定性的常见两个问题</h4><p><strong>梯度爆炸</strong></p>
<p>假设梯度都是一些比1大的数比如1.5，做100次乘积之后得到$4\times 10^{17}$，这个数字很容易带来一些浮点数上限的问题（需了解更多请参考计算机系统-计算机中浮点数的存储方式）。</p>
<p><strong>梯度消失</strong></p>
<p>假设梯度都是一些比1小的数比如0.8，做100次乘积之后得到$2\times10^{-10}$，也可能会带来浮点数下溢的问题。</p>
<h4 id="1-3-例子：MLP"><a href="#1-3-例子：MLP" class="headerlink" title="1.3 例子：MLP"></a>1.3 例子：MLP</h4><p>此处我们着重探讨<a href="#11-神经网络的梯度">1.1节</a>中所述的求梯度时所做的d-t次矩阵乘法，并以一个实例MLP来探讨其结果的具体形式。</p>
<img src="/2024/04/23/11-01-14/14-02.png" class>
<ul>
<li><p>第一行公式，定义$h^{t}$和$h^{t-1}$(均为向量)的函数关系$f_{t}$，第t层的权重矩阵作用于t-1层的输出$h^{t-1}$后经过激活函数$\sigma$得到$h^{t}$，注意激活函数$\sigma$逐元素计算。</p>
</li>
<li><p>第二行公式：这里用到链导法则，激活函数$\sigma$先对内部向量逐元素求导，然后把求导后这个向量变成对角矩阵（可以理解为链导法则中内部向量$W_{t}h_{t-1}$对自身进行求导，变成一个nxn的对角矩阵，更多请参考<a href="https://nndl.github.io/nndl-book.pdf">邱锡鹏 《神经网络与深度学习》</a><sup><a href="#fn_ 图片1" id="reffn_ 图片1"> 图片1</a></sup>）</p>
</li>
</ul>
<img src="/2024/04/23/11-01-14/14-03.png" class>
<blockquote id="fn_图片1">
<sup>图片1</sup>. 引自<a href="https://nndl.github.io/nndl-book.pdf">邱锡鹏 《神经网络与深度学习》</a>附录：数学基础 <a href="#reffn_图片1" title="Jump back to footnote [图片1] in the text."> &#8617;</a>
</blockquote>
<ul>
<li>视频中<strong>勘误说明</strong>：链导法则中$\frac{\partial W^{t}h^{t-1}}{\partial h^{t-1}}= W^{t}$而不是$\left (W^{t} \right )^{T}$（这点由分子分母维度也容易推出），故最终求导结果包含$W^{t}$，而不是其转置。</li>
</ul>
<h4 id="1-3-梯度爆炸"><a href="#1-3-梯度爆炸" class="headerlink" title="1.3 梯度爆炸"></a>1.3 梯度爆炸</h4><h5 id="1-3-1-使用ReLU作为激活函数"><a href="#1-3-1-使用ReLU作为激活函数" class="headerlink" title="1.3.1 使用ReLU作为激活函数"></a>1.3.1 使用ReLU作为激活函数</h5><img src="/2024/04/23/11-01-14/14-04.png" class>
<p>由于激活函数Relu求导后或者是1或者是0，变为对角矩阵的斜对角线元素后，与$W^{i}$做乘积，斜对角线为1的部分会使得W中元素保留，最终该连乘式中有一些元素来自$\prod\left ( W^{i} \right )$ ，如果大部分$W^{i}$中 值都大于1，且层数比较大，那么连乘之后可能导致梯度爆炸的问题。</p>
<h5 id="1-3-2-梯度爆炸问题"><a href="#1-3-2-梯度爆炸问题" class="headerlink" title="1.3.2 梯度爆炸问题"></a>1.3.2 梯度爆炸问题</h5><ul>
<li><p>值超出值域（infinity）</p>
<ul>
<li>对于16位浮点数尤为严重（数值区间 [6e-5 , 6e4]），GPU用16位浮点数更快</li>
</ul>
</li>
<li><p>对学习率敏感</p>
<ul>
<li><p>如果学习率太大→大参数值→更大的梯度，如此循环几次，容易导致梯度爆炸</p>
</li>
<li><p>如果学习率太小→训练无进展</p>
</li>
<li><p>我们可能需要在训练过程中不断调整学习率</p>
</li>
</ul>
</li>
</ul>
<h4 id="1-4-梯度消失"><a href="#1-4-梯度消失" class="headerlink" title="1.4 梯度消失"></a>1.4 梯度消失</h4><h5 id="1-4-1-使用Sigmoid作为激活函数"><a href="#1-4-1-使用Sigmoid作为激活函数" class="headerlink" title="1.4.1 使用Sigmoid作为激活函数"></a>1.4.1 使用Sigmoid作为激活函数</h5><img src="/2024/04/23/11-01-14/14-05.png" class>
<ul>
<li>蓝色曲线为函数值</li>
<li>黄色曲线为梯度，注意到当输入x值取±6时，此时梯度已经变得很小，由图也可以看出，当输入值稍大或稍小都很容易引起小梯度。</li>
</ul>
<img src="/2024/04/23/11-01-14/14-06.png" class>
<p>所以最终连乘式中$\prod diag\left ( \sigma ^{‘}\left ( W^{i}h^{i-1} \right ) \right )$项乘出来会很小，导致整个梯度很小，产生梯度消失问题。</p>
<h5 id="1-4-2-梯度消失的问题"><a href="#1-4-2-梯度消失的问题" class="headerlink" title="1.4.2 梯度消失的问题"></a>1.4.2 梯度消失的问题</h5><ul>
<li><p>梯度值变为0</p>
<ul>
<li>对16位浮点数尤为严重</li>
</ul>
</li>
<li><p>训练没有进展</p>
<ul>
<li>不管如何选择学习率，由于梯度已经为0了，学习率x梯度=0</li>
</ul>
</li>
<li>对于底部层尤为严重<ul>
<li>仅仅顶部层训练得较好。第<em>t</em>层导数包含d-t个矩阵乘积，越往底层走，t越小，乘得越多，梯度消失越严重，所以底部层效果更差。</li>
<li>无法让神经网络更深。只能把顶部层训练得比较好，底部层跑不动，这和给一个浅的神经网络没有什么区别。</li>
</ul>
</li>
</ul>
<h3 id="2-模型初始化和激活函数"><a href="#2-模型初始化和激活函数" class="headerlink" title="2. 模型初始化和激活函数"></a>2. 模型初始化和激活函数</h3><h4 id="2-1-让训练更加稳定"><a href="#2-1-让训练更加稳定" class="headerlink" title="2.1 让训练更加稳定"></a>2.1 让训练更加稳定</h4><p>我们的一个核心目标是如何让训练更稳定，梯度值不要太大也不要太小</p>
<ul>
<li>目标：让梯度值在合理的范围内<ul>
<li>例如 [1e-6, 1e3]</li>
</ul>
</li>
<li><p>常用方法：</p>
<ul>
<li>将乘法变加法：<ul>
<li>ResNet（跳跃连接，如果很多层，加入加法进去）</li>
<li>LSTM（引入记忆细胞，更新门，遗忘门，通过门权重求和，控制下一步是否更新）</li>
</ul>
</li>
<li><p>归一化：</p>
<ul>
<li><p>梯度归一化（归一化均值，方差）</p>
</li>
<li><p>梯度裁剪(clipping)：比如大于/小于一个固定的阈值，就让梯度等于这个阈值，将梯度限制在一个范围中。（可以缓解梯度爆炸）</p>
</li>
</ul>
</li>
<li>合理的权重初始和激活函数：本节课讲述重点</li>
</ul>
</li>
</ul>
<p><strong>下面我们重点探讨最后一种方法：合理的权重初始和激活函数</strong></p>
<h4 id="2-2-基本假设：让每层的均值-方差是一个常数"><a href="#2-2-基本假设：让每层的均值-方差是一个常数" class="headerlink" title="2.2 基本假设：让每层的均值/方差是一个常数"></a>2.2 基本假设：让每层的均值/方差是一个常数</h4><ul>
<li><p><strong>将每层的输出和梯度都看做随机变量</strong></p>
<p>比如第i层有100维，就将输出和梯度分别看成100个随机变量</p>
</li>
<li><p><strong>让它们的均值和方差都保持一致</strong></p>
<p>我们的目标，这样不管神经网络多深，最后一层总与第一层差不多，从而不会梯度爆炸和消失</p>
</li>
</ul>
<p>根据我们的假设，可以列出如下方程式：</p>
<img src="/2024/04/23/11-01-14/14-07.png" class>
<h4 id="2-3-权重初始化"><a href="#2-3-权重初始化" class="headerlink" title="2.3 权重初始化"></a>2.3 权重初始化</h4><ul>
<li>在合理值区间里随机初始参数</li>
<li>训练<strong>开始</strong>的时候更容易有数值不稳定<ul>
<li>远离最优解的地方损失函数表面可能很复杂</li>
<li>最优解附近表面会比较平</li>
</ul>
</li>
<li>使用N(0, 0.01)分布来初始可能对小网络没问题，但不能保证深度神经网络</li>
</ul>
<h4 id="2-4-例子：MLP"><a href="#2-4-例子：MLP" class="headerlink" title="2.4 例子：MLP"></a>2.4 例子：MLP</h4><p>下面我们以MLP为例，考虑需要什么条件，才能满足<a href="#22-基本假设：让每层的均值/方差是一个常数">2.2节</a>的假设。</p>
<h5 id="2-4-1-模型假设"><a href="#2-4-1-模型假设" class="headerlink" title="2.4.1 模型假设"></a>2.4.1 模型假设</h5><ul>
<li>每一层<strong>权重</strong>中的变量均为<strong>独立同分布</strong>，并设出均值、方差。</li>
<li>每一层<strong>输入</strong>的变量<strong>独立于</strong>该层<strong>权重</strong>变量。同时<strong>输入变量</strong>之间<strong>独立同分布</strong>。</li>
<li>假设没有激活函数(先简化分析，之后会考虑有激活函数的情况)，可以求得该层输出的期望为0。</li>
</ul>
<img src="/2024/04/23/11-01-14/14-08.png" class>
<p>此处用到了一个重要性质：</p>
<img src="/2024/04/23/11-01-14/14-09.png" class>
<p>更多均值、方差运算可以参考<a href="https://blog.csdn.net/MissXy_/article/details/80705828">期望、方差、协方差及相关系数的基本运算</a></p>
<h5 id="2-4-2-正向方差"><a href="#2-4-2-正向方差" class="headerlink" title="2.4.2 正向方差"></a>2.4.2 正向方差</h5><img src="/2024/04/23/11-01-14/14-10.png" class>
<ul>
<li><p>第二行的计算中仍然用到了<a href="241模型假设">2.4.1节</a>的期望的重要性质：如果两个变量独立，它们乘积的均值=均值的乘积，再结合w的期望为0(注意w和h独立，w之间独立同分布)，即有第二行末项期望为0。</p>
</li>
<li><p>最后一行由于wi,j独立同分布，方差相同，加上做了hj独立同分布的假设，所以可以写成 <strong>[t-1层输出维度] x [t层权重方差] x [t-1层输出方差]</strong> 的形式</p>
</li>
<li><p>此时，我们回过头来看我们的终极目标<a href="#22-基本假设：让每层的均值/方差是一个常数">2.2节</a>的假设，每层输出期望为0我们已经可以满足(2.4.1节已经推导出)，而方差相同这一目标，通过上图的推导，我们发现需要&lt;$n_{t-1}\gamma _{t}=1$。</p>
</li>
</ul>
<h5 id="2-4-3-反向均值和方差"><a href="#2-4-3-反向均值和方差" class="headerlink" title="2.4.3 反向均值和方差"></a>2.4.3 反向均值和方差</h5><img src="/2024/04/23/11-01-14/14-11.png" class>
<p>反向的情况和正向的类似，不过此时我们需要满足的式子变为$n_{t}\gamma _{t}=1$。</p>
<h5 id="2-4-4-Xavier初始"><a href="#2-4-4-Xavier初始" class="headerlink" title="2.4.4 Xavier初始"></a>2.4.4 Xavier初始</h5><ul>
<li><p>上述推导带来的问题：难以同时满足$n_{t-1}\gamma _{t}=1$和$n_{t}\gamma _{t}=1$。（需要每层输出的维度都相同）</p>
</li>
<li><p>采用Xavier折中解决，不能同时满足上面两式，转而满足 [<strong>上面两式做加法后除以2</strong>] 得到的式子，用两种分布进行初始化（每层方差、均值满足推导式）。</p>
<img src="/2024/04/23/11-01-14/14-12.png" class>
</li>
<li><p>如果能确定每层输入、输出维度大小，则能确定该层权重的方差大小。</p>
</li>
<li>权重初始化方式：正态分布、均匀分布，均值/方差满足Xavier的假设。</li>
</ul>
<h5 id="2-4-5-假设线性的激活函数"><a href="#2-4-5-假设线性的激活函数" class="headerlink" title="2.4.5 假设线性的激活函数"></a>2.4.5 假设线性的激活函数</h5><p>真实情况下，我们并不会用线性的激活函数（这样相当于没有进行激活），这里为了简化问题，假设激活函数是线性的。</p>
<ul>
<li><strong>正向</strong></li>
</ul>
<img src="/2024/04/23/11-01-14/14-13.png" class>
<p>上述推导表明，为了使得前向传播的均值为0，方差固定的话，激活函数必须f(x)=x，这种恒等映射。</p>
<ul>
<li><strong>反向</strong></li>
</ul>
<img src="/2024/04/23/11-01-14/14-14.png" class>
<p>PPT上的推导似乎有点问题（上图中第二行方程），笔者重新进行了下述推导，读者也可自行推导验证：</p>
<img src="/2024/04/23/11-01-14/14-15.png" class>
<p><strong>通过正向和反向的推导，我们可以得出的【结论】是：当激活函数为f(x)=x，这种恒等映射更有利于维持神经网络的稳定性。</strong></p>
<h5 id="2-4-6-检查常用激活函数"><a href="#2-4-6-检查常用激活函数" class="headerlink" title="2.4.6 检查常用激活函数"></a>2.4.6 检查常用激活函数</h5><img src="/2024/04/23/11-01-14/14-16.png" class>
<p>对于常用激活函数：tanh，relu满足在零点附近有f(x)=x，而sigmoid函数在零点附近不满足要求，可以对sigmoid函数进行调整（根据Taylor展开式，调整其过原点）</p>
<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><ul>
<li>当数值过大或者过小时，会导致数值问题。</li>
<li><p>常发生在深度模型中，因为其会对n个数累乘。</p>
</li>
<li><p>合理的权重初始值(如Xavier)和激活函数的选取(如relu, tanh, 调整后的sigmoid)可以提升数值稳定性。</p>
</li>
</ul>
<h3 id="4-Q-amp-A"><a href="#4-Q-amp-A" class="headerlink" title="4.Q&amp;A"></a>4.Q&amp;A</h3><p><strong>问题：nan, inf是怎么产生的以及怎么解决的？</strong></p>
<blockquote>
<p>NaN和Inf怎么产生的：参考<a href="https://blog.csdn.net/qq_16334327/article/details/86526854">出现nan、inf原因</a></p>
<p>如何解决：参考<a href="https://blog.csdn.net/u011119817/article/details/103908065">深度学习中nan和inf的解决</a>以及<a href="https://zhuanlan.zhihu.com/p/89588946#:~:text=一般来说，出现NaN有以下几种情况： 1.,如果在迭代的100轮以内，出现NaN，一般情况下的原因是因为你的学习率过高，需要降低学习率。 可以不断降低学习率直至不出现NaN为止，一般来说低于现有学习率1-10倍即可。">训练网络loss出现Nan解决办法 </a></p>
</blockquote>
<p><strong>问题：训练过程中，如果网络层的输出的中间层特征元素的值突然变成nan了，是发生梯度爆炸了吗？</strong></p>
<blockquote>
<p>参考<a href="https://zhuanlan.zhihu.com/p/89588946#:~:text=一般来说，出现NaN有以下几种情况： 1.,如果在迭代的100轮以内，出现NaN，一般情况下的原因是因为你的学习率过高，需要降低学习率。 可以不断降低学习率直至不出现NaN为止，一般来说低于现有学习率1-10倍即可。">训练网络loss出现Nan解决办法 </a></p>
</blockquote>
<p><strong>问题：老师，让每层方差是一个常数的方法，您指的是batch normalization吗？想问一下bn层为什么要有伽马和贝塔？去掉可以吗</strong></p>
<blockquote>
<p>让每层方差是一个常数，和batch norm没有太多关系，(本节课介绍的方法是合理地初始化权重和设置激活函数)。batch norm可以让你的输出变成一个均值为0，方差差不多是一个固定值的东西，但它不一定能保证你的梯度。</p>
</blockquote>
<p>(此处节选几个重要的Q&amp;A，建议观看完整Q&amp;A，获得更深的理解)</p>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>13-丢弃法</title>
    <url>/2024/04/23/11-01-13/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.04.24：初稿</li>
</ul>
<h2 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h2><ul>
<li><a href="/2024/04/24/12-18-34/" title="动手学深度学习笔记汇总">动手学深度学习笔记汇总</a>
</li>
</ul>
<h2 id="13-丢弃法"><a href="#13-丢弃法" class="headerlink" title="13-丢弃法"></a>13-丢弃法</h2><h3 id="1-丢弃法动机、实现及原则"><a href="#1-丢弃法动机、实现及原则" class="headerlink" title="1.丢弃法动机、实现及原则"></a>1.丢弃法动机、实现及原则</h3><h4 id="1-1动机"><a href="#1-1动机" class="headerlink" title="1.1动机"></a>1.1动机</h4><ul>
<li>一个好的模型需要对输入数据的扰动鲁棒（健壮性）</li>
</ul>
<h4 id><a href="#" class="headerlink" title=" "></a> </h4><img src="/2024/04/23/11-01-13/13-02.jpg" class>       
<img src="/2024/04/23/11-01-13/13-03.jpg" class>
<h4 id="1-2如何实现模型的这一能力"><a href="#1-2如何实现模型的这一能力" class="headerlink" title="1.2如何实现模型的这一能力"></a>1.2如何实现模型的这一能力</h4><ul>
<li>使用有噪音的数据。</li>
<li>丢弃法：在层之间加入噪音。</li>
</ul>
<h4 id="1-3加入噪音的原则"><a href="#1-3加入噪音的原则" class="headerlink" title="1.3加入噪音的原则"></a>1.3加入噪音的原则</h4><img src="/2024/04/23/11-01-13/13-01.png" class>
<ul>
<li>例如模型的功能是识别猫猫，加入噪音可以是输入模糊的猫猫图片，但尽量不要是狗狗的图片。</li>
</ul>
<h3 id="2-丢弃法内容"><a href="#2-丢弃法内容" class="headerlink" title="2.丢弃法内容"></a>2.丢弃法内容</h3><ul>
<li>丢弃法对每个元素作如下扰动</li>
</ul>
<img src="/2024/04/23/11-01-13/13-04.png" class>
<ul>
<li>能够满足加入噪音的期望相同原则</li>
<li>一定概率变为0，一定概率变得很大</li>
</ul>
<img src="/2024/04/23/11-01-13/13-05.png" class>
<ul>
<li>期望没有发生变化，分母的意义</li>
</ul>
<h3 id="3-丢弃法使用"><a href="#3-丢弃法使用" class="headerlink" title="3.丢弃法使用"></a>3.丢弃法使用</h3><h4 id="3-1丢弃法的使用位置"><a href="#3-1丢弃法的使用位置" class="headerlink" title="3.1丢弃法的使用位置"></a>3.1丢弃法的使用位置</h4><ul>
<li>通常将丢弃法作用在隐藏全连接层的输出上</li>
</ul>
<img src="/2024/04/23/11-01-13/13-06.png" class>
<ul>
<li>随机选中某些神经元将其输出置位0，因此模型不会过分依赖某些神经元</li>
</ul>
<img src="/2024/04/23/11-01-13/13-07.png" class>
<h4 id="3-2训练中的丢弃法"><a href="#3-2训练中的丢弃法" class="headerlink" title="3.2训练中的丢弃法"></a>3.2训练中的丢弃法</h4><ul>
<li>正则项（丢弃法）仅在训练中使用：影响模型参数的更新，预测的时候便不再使用</li>
</ul>
<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h3><ul>
<li>丢弃法将一些输出项随机置0来控制模型复杂度</li>
<li>常作用在多层感知机的隐藏层输出上</li>
<li>丢弃概率是控制模型复杂度的超参数（常取0.9，0.5，0.1）</li>
</ul>
<h3 id="5-代码部分"><a href="#5-代码部分" class="headerlink" title="5.代码部分"></a>5.代码部分</h3><h4 id="5-1Dropout部分"><a href="#5-1Dropout部分" class="headerlink" title="5.1Dropout部分"></a>5.1Dropout部分</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dropout_layer</span> (X,dropout)：   <span class="comment">#X为dropout层的输入，dropout为设置的丢弃概率</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="number">0</span>&lt;=dropout&lt;=<span class="number">1</span>        <span class="comment">#丢弃概率介于0，1之间</span></span><br><span class="line">    <span class="keyword">if</span> dropout == <span class="number">1</span>:</span><br><span class="line">       <span class="keyword">return</span> torch.zeros_like(x) <span class="comment">#若丢弃概率为1，则X的全部项均被置0</span></span><br><span class="line">    <span class="keyword">if</span> dropout == <span class="number">0</span>:</span><br><span class="line">       <span class="keyword">return</span> X                   <span class="comment">#若丢弃概率为0，不对X作丢弃操作，直接返回X</span></span><br><span class="line">    mask=(torch.Tensor(X.shape).uniform_(<span class="number">0</span>,<span class="number">1</span>)&gt;dropout).<span class="built_in">float</span>() <span class="comment">#用uniform函数生成0-1间的随机实数，利用”&gt;&quot;，将大于dropout的记为1，小于dropout的记为0，实现丢弃操作</span></span><br><span class="line">    <span class="keyword">return</span> mask*X/(<span class="number">1</span>-dropout) <span class="comment">#将mask与X相乘实现丢弃操作，并除以(1-dropout)，这里不使用选中X中元素置0的原因是相乘操作相比选中操作更快</span></span><br></pre></td></tr></table></figure>
<h4 id="5-2在神经网络中使用丢弃法"><a href="#5-2在神经网络中使用丢弃法" class="headerlink" title="5.2在神经网络中使用丢弃法"></a>5.2在神经网络中使用丢弃法</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num_inputs, num_outputs, num_hiddens1, num_hiddens2 = <span class="number">784</span>, <span class="number">10</span>, <span class="number">256</span>, <span class="number">256</span></span><br><span class="line">dropout1, dropout2 = <span class="number">0.2</span>, <span class="number">0.5</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Net</span>(nn.Module)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_init_</span>(<span class="params">self,num_inputs,num_outputs,num_outputs,num_hiddens1,num_hiddens2,is_training=<span class="literal">True</span></span>):</span><br><span class="line">       <span class="built_in">super</span>(Net,self)._init_()</span><br><span class="line">       self.num_inputs=num_inputs</span><br><span class="line">       self.training=is_training</span><br><span class="line">       self.lin1=nn.Linear(num_inputs,num_hiddens1)</span><br><span class="line">       self.lin2=nn.Linear(num_hiddens1,num_hiddens2)</span><br><span class="line">       self.lin2=nn.Linear(num_hiddens2,num_outputs)</span><br><span class="line">       self.relu=nn.ReLU()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,X</span>):</span><br><span class="line">       H1=self.relu(self.lin1(X.reshape((-<span class="number">1</span>,self.num_inputs))))</span><br><span class="line">       <span class="keyword">if</span> self.training == <span class="literal">True</span>:  <span class="comment">#丢弃法仅在训练中使用</span></span><br><span class="line">           H1=dropout_layer(H1,dropout1)</span><br><span class="line">       H2=self.relu(self.lin2(H1))</span><br><span class="line">       <span class="keyword">if</span> self.training == <span class="literal">True</span>: <span class="comment">#丢弃法仅在训练中使用</span></span><br><span class="line">           H2=dropout_layer(H2,dropout2)</span><br><span class="line">       out=self.lin3(H2)  <span class="comment">#output层不再使用丢弃法</span></span><br><span class="line">       <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>12 权重衰退 Weight Decay</title>
    <url>/2024/04/23/11-01-12/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.04.24：初稿</li>
</ul>
<h2 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h2><ul>
<li><a href="/2024/04/24/12-18-34/" title="动手学深度学习笔记汇总">动手学深度学习笔记汇总</a>
</li>
</ul>
<h2 id="12-权重衰退-Weight-Decay"><a href="#12-权重衰退-Weight-Decay" class="headerlink" title="12 权重衰退 Weight Decay"></a>12 权重衰退 Weight Decay</h2><p>权重衰退是最常见的一种处理过拟合的方法，是最广泛使用的正则化技术之一。</p>
<h4 id="复习：控制模型容量"><a href="#复习：控制模型容量" class="headerlink" title="复习：控制模型容量"></a>复习：控制模型容量</h4><blockquote>
<ol>
<li>使用更少参数</li>
<li>控制每个参数（取值/可选择的值）范围较小</li>
</ol>
</blockquote>
<p>其中权重衰退属于第二种方法。</p>
<h3 id="1-硬性限制-直观理解"><a href="#1-硬性限制-直观理解" class="headerlink" title="1. 硬性限制/直观理解"></a>1. 硬性限制/直观理解</h3><p>我们的优化目标仍然是$min\space\ell(\boldsymbol{w},b)$，只是额外对$\boldsymbol{w}$添加一个限制条件$||\boldsymbol{w}||^2\leqslant\theta$，即权重的各项平方和小于一个特定的常数$\theta$。那么设定一个较小的$\theta$就会使得$\boldsymbol{w}$中每个元素的值都不会太大。</p>
<p>通常不会限制偏移b，理论上讲b表示整个数据在零点上的偏移，因此是不应该限制的，但实践中限制与否对结果都没什么影响。</p>
<p><strong>吴恩达课程中对这一现象的解释是w是高维向量，已经包含了绝大多数参数足以表达高方差问题，b作为单个数字对结果的影响就会很小.</strong></p>
<p>小的$\theta$意味着更强的正则项，对于相同的$\theta$，$\boldsymbol{w}$中元素越多则单个元素的值会越小。</p>
<h3 id="2-柔性限制-实际应用"><a href="#2-柔性限制-实际应用" class="headerlink" title="2. 柔性限制/实际应用"></a>2. 柔性限制/实际应用</h3><p>上文说的硬性限制在实际使用时比较麻烦，实际上常用的函数是</p>
<p>$$<br>\begin{split}<br>min\space\ell(\boldsymbol{w},b)+\frac{\lambda}{2}||\boldsymbol{w}||^2<br>\end{split}<br>$$</p>
<p>可以通过拉格朗日乘子证明对于每个$\theta$都可以找到$\lambda$使得硬性限制的目标函数等价于上式。</p>
<p>其中$\frac{\lambda}{2}||\boldsymbol{w}||^2$这一项被称为罚(penalty)，$\lambda$是超参数，控制了正则项的重要程度。</p>
<p>当 $\lambda=0$ 时无作用，$\lambda\rightarrow\infty$ 时最优解 $\boldsymbol{w}^*\rightarrow0$，也就是说 $\lambda$ 越大模型复杂度就被控制的越低。</p>
<p>下面是老师给出的演示图</p>
<img src="/2024/04/23/11-01-12/12-01.JPG" class>
<p>以$\boldsymbol{w}$中只有两个参数为例，其中绿色的部分是原本损失函数函数值的“等高线”，黄色部分可以看作是正则项对应函数值的“等高线” ，使用权重衰减后需要优化的损失函数相当于图中两组等高线叠加。原本最优解位于绿色中心，现在这一位置在对于正则项有很高的损失，而正则项最小值位于原点，因此现在的最终优化解会更靠近原点，而当所有参数都更靠近原点时模型的规模也就更小。</p>
<h3 id="3-参数更新"><a href="#3-参数更新" class="headerlink" title="3. 参数更新"></a>3. 参数更新</h3><h4 id="3-1-计算梯度"><a href="#3-1-计算梯度" class="headerlink" title="3.1 计算梯度"></a>3.1 计算梯度</h4><p>$$<br>\begin{split}<br>\frac{\partial{} }{\partial{\boldsymbol{w} } }(\ell(\boldsymbol{w},b)+\frac{\lambda}{2}||\boldsymbol{w}||^2)=\frac{\partial{\ell(\boldsymbol{w},b)} }{ {\partial{\boldsymbol{w} } } }+\lambda\boldsymbol{w}<br>\end{split}<br>$$</p>
<h4 id="3-2-更新参数"><a href="#3-2-更新参数" class="headerlink" title="3.2 更新参数"></a>3.2 更新参数</h4><p>将上式结果带入更新参数公式整理可得</p>
<p>$$<br>\begin{split}<br>\boldsymbol{w}_{t+1}=(1-\eta\lambda)\boldsymbol{w}_{t}-\eta\frac{\partial{\ell(\boldsymbol{w}_t,b_t)} }{ {\partial{\boldsymbol{w}_{t} } } }<br>\end{split}<br>$$</p>
<p>注意到这个公式中后一项与原来更新参数的公式没有区别，仅仅是在前一项$\boldsymbol{w}_{t}$ 上加了一个系数$(1-\eta\lambda)$。通常$\eta\lambda&lt;1$ ，也就是说由于引入了$\lambda$，每次更新参数前先给待更新参数乘上一个小于1的权重再更新，权重衰退由此得名。</p>
<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><ul>
<li>权重衰退通过L2正则项使得模型参数不会过大，从而控制模型复杂度</li>
<li>正则项权重（$\lambda$）是控制模型复杂度的超参数                                                                                                                                       </li>
</ul>
<h3 id="5-Q-amp-A"><a href="#5-Q-amp-A" class="headerlink" title="5. Q&amp;A"></a>5. Q&amp;A</h3><ul>
<li><p>Q：Pytorch是否支持复数神经网络？</p>
</li>
<li><p>A：应该不支持，但复数可以看作是二维的数，可以尝试将对应结构变成二维来实现需要的效果。</p>
</li>
<li><p>Q：为什么参数不过大复杂度就低呢？</p>
</li>
<li><p>A：确切的说是限制模型优化时只能在很小范围内取参数会使模型复杂度降低，见下图</p>
</li>
</ul>
<img src="/2024/04/23/11-01-12/12-02.JPG" class>
<p>参数选择范围大时可拟合出很复杂的曲线，限制后只能学到更平滑的曲线/选择更简单的模型，那么模型复杂度就变低了。</p>
<ul>
<li><p>Q：如果使用L1范数如何更新权重？</p>
</li>
<li><p>A：编写代码时只需把罚项改成如</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">l1_penalty</span>(<span class="params">w</span>):</span><br><span class="line">  <span class="keyword">return</span> torch.<span class="built_in">sum</span>(torch.<span class="built_in">abs</span>(w))</span><br></pre></td></tr></table></figure>
<p>老师解答就到这里，但实操不应该只改罚项函数，还需重新定义带正则项的损失函数并求导化简。</p>
<div align="center">

$\frac{\partial{} }{\partial{\mathbf{w} } }(\ell(\mathbf{w},b)+\lambda||\mathbf{w}||_1)=\frac{\partial{\ell(\mathbf{w},b)} }{ {\partial{\mathbf{w} } } }+I'\lambda$

</div>

<p>其中$I’=(a_1,…,a_n)$,当$\mathbf{w}$中第i个元素为正时$a_i=1$，反之$a_i=-1$.（=0时随意）</p>
<p>代入公式化简得</p>
<div align="center">

$\mathbf{w}_{t+1}=\mathbf{w}_{t}-\eta\frac{\partial{\ell(\mathbf{w}_t,b_t)} }{ {\partial{\mathbf{w}_{t} } } }-I'\eta\lambda$

</div>

<p>从这个式子可以看出使用L1正则化时只能对所有同号的参数施加一个相同大小的正则项（增减一个定值），而反观L2正则化对参数的影响是与参数本身的值有关的（乘上一个系数）似乎是更好的选择。不过L1正则化在特征提取上会有用处。</p>
<ul>
<li><p>Q：实践中权重衰减的值设置为多少好？跑代码时感觉效果不明显。</p>
</li>
<li><p>A：一般取1e-2,1e-3,1e-4，权重衰退的效果确实有限，之后还会讲解更多方法。如果模型真的很复杂那么权重衰退一般不会带来特别好的效果。</p>
</li>
<li><p>Q：关于L2范数的记法</p>
</li>
<li><p>A：完整的写法是$||\boldsymbol{w}||^2_2$，上标的2表示平方，下标的2表示是L2范数，下标有时省略。</p>
</li>
<li><p>Q：为什么要把$\boldsymbol{w}$往小拉？如果最优解的$\boldsymbol{w}$本来就较大权重衰减是否会起反作用？/正则项使得$\boldsymbol{w}$变得更平均没有突出的值为什么可以拟合的更好呢？</p>
</li>
<li><p>A：实际训练的数据都是有噪音的，而这些噪音可能会被拟合进去使得我们实际求解时得不到数学上的最优解，正则化起到将结果拉向最优解的作用。当然如果$\lambda$选取过大可能会拉小的过多，如果没有过拟合那权重衰减就不起作用。</p>
<p><strong>笔者注：这部分老师花了较长时间解释，建议大家自己去看视频。我的个人理解是重点不在于w大小/是否平均，而是由于数据有噪声，而噪声引起过拟合使得求出的w比数学上的最优解更大/更不平均，这时就需要正则化起到一个将结果拉向更小/平均/接近最优解的作用。</strong></p>
</li>
<li><p>Q：噪音大会使得$\boldsymbol{w}$较大是经验所得还是可以证明？</p>
</li>
<li>A：可以证明，但本课程中不讲，可以自己尝试。</li>
<li>Q：怎样调整$\lambda$？</li>
<li>A：不能确定什么时候是最优，但可以用前面讲的验证集/k折交叉验证，先取$\lambda=0$看训练结果，再改变$\lambda$看是否有改善。</li>
</ul>
<p><strong>代码和部分课后题参考答案见本讲的ipynb文件。</strong></p>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>11-模型选择+过拟合和欠拟合</title>
    <url>/2024/04/23/11-01-11/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.04.24：初稿</li>
</ul>
<h2 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h2><ul>
<li><a href="/2024/04/24/12-18-34/" title="动手学深度学习笔记汇总">动手学深度学习笔记汇总</a>
</li>
</ul>
<h2 id="11-模型选择-过拟合和欠拟合"><a href="#11-模型选择-过拟合和欠拟合" class="headerlink" title="11-模型选择+过拟合和欠拟合"></a>11-模型选择+过拟合和欠拟合</h2><h3 id="1-模型选择"><a href="#1-模型选择" class="headerlink" title="1. 模型选择"></a>1. 模型选择</h3><p>本小节主要介绍了评估模型的一些指标和方法</p>
<h4 id="1-1-实例分析：预测谁会偿还贷款"><a href="#1-1-实例分析：预测谁会偿还贷款" class="headerlink" title="1.1 实例分析：预测谁会偿还贷款"></a>1.1 实例分析：预测谁会偿还贷款</h4><ul>
<li>银行雇你来调查谁会偿还贷款，你得到了100个申请人的信息，其中五个人在3年内违约了。然后你惊讶的发现，<strong>所有的五个人在面试时都穿了蓝色衬衫</strong>。显然，你的模型也发现了这个强信号，这会有什么问题？</li>
</ul>
<p><strong>答案是，你的模型很有可能会认为所有来面试的人都会穿蓝色衬衫，而这当然是不对的。</strong></p>
<h4 id="1-2-训练误差和泛化误差"><a href="#1-2-训练误差和泛化误差" class="headerlink" title="1.2 训练误差和泛化误差"></a>1.2 训练误差和泛化误差</h4><ul>
<li>训练误差：模型在训练数据上的误差</li>
<li>泛化误差：模型在新数据上的误差</li>
<li><p>例子：根据模考成绩来预测未来考试分数</p>
<ul>
<li>在过去的考试中表现很好（<strong>训练误差</strong>）不代表未来会好（<strong>泛化误差</strong>）</li>
<li>学生A通过背书在模考中拿到很好成绩</li>
<li>学生B知道答案后面的原因</li>
</ul>
</li>
<li><p><strong>其中，泛化误差是我们所最关心的</strong></p>
</li>
</ul>
<h4 id="1-3-验证数据集和测试数据集"><a href="#1-3-验证数据集和测试数据集" class="headerlink" title="1.3 验证数据集和测试数据集"></a>1.3 验证数据集和测试数据集</h4><ul>
<li>验证数据集：一个用来评估模型好坏的数据集<ul>
<li>例如拿出50%的训练数据</li>
<li>不要跟训练数据混在一起（常犯错误）</li>
</ul>
</li>
<li><p>测试数据集：只用一次的数据集。例如：</p>
<ul>
<li>未来的考试</li>
<li>我出价的房子的实际成交价</li>
<li>用在kaggle私有排行榜中的数据集</li>
</ul>
</li>
<li><p><strong>二者最大的区别就是，验证数据集可以那来用很多次，相当于平时的模拟考，而测试数据集则只能用一次来评估模型的性能，相当于最终的考试。</strong></p>
</li>
</ul>
<h4 id="1-4-K-则交叉验证"><a href="#1-4-K-则交叉验证" class="headerlink" title="1.4 K-则交叉验证"></a>1.4 K-则交叉验证</h4><ul>
<li>在没有足够多数据时使用（这是常态）</li>
<li>算法：<ul>
<li>将训练数据分割k块</li>
<li>For i = 1，……，k<ul>
<li>使用第i块作为验证数据集，其余的作为训练数据集</li>
</ul>
</li>
<li>报告k个验证集误差的平均</li>
</ul>
</li>
<li>常用：k = 5或10<blockquote>
<p>随机打散，分割K块，k次计算，第i次，用第i块作为验证集，剩下的作为训练数据集。这样会获得k次误差，算误差平均值。</p>
</blockquote>
</li>
<li>K-则交叉验证的目的是在没有足够多数据使用时评估模型和超参数的性能，也就是说，<strong>K次训练和验证使用的是相同的超参数和模型</strong></li>
</ul>
<h4 id="1-5-总结"><a href="#1-5-总结" class="headerlink" title="1.5 总结"></a>1.5 总结</h4><ul>
<li>训练数据集：训练模型参数</li>
<li>验证数据集：选择模型超参数,保留最好的参数</li>
<li>非大数据集上通常使用k-则交叉验证</li>
</ul>
<h3 id="2-过拟合和欠拟合"><a href="#2-过拟合和欠拟合" class="headerlink" title="2. 过拟合和欠拟合"></a>2. 过拟合和欠拟合</h3><h4 id="2-1-什么是过拟合和欠拟合？"><a href="#2-1-什么是过拟合和欠拟合？" class="headerlink" title="2.1 什么是过拟合和欠拟合？"></a>2.1 什么是过拟合和欠拟合？</h4><div class="table-container">
<table>
<thead>
<tr>
<th>模型容量\数据</th>
<th>简单</th>
<th style="text-align:center">复杂</th>
</tr>
</thead>
<tbody>
<tr>
<td>低</td>
<td>正常</td>
<td style="text-align:center">欠拟合</td>
</tr>
<tr>
<td>高</td>
<td>过拟合</td>
<td style="text-align:center">正常</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>tips：模型容量即模型的复杂度，也代表了模型拟合各种函数的能力</li>
</ul>
<h4 id="2-2-模型容量"><a href="#2-2-模型容量" class="headerlink" title="2.2 模型容量"></a>2.2 模型容量</h4><ul>
<li>拟合各种函数的能力</li>
<li>低容量的模型难以拟合训练数据</li>
<li>高容量的模型可以记住所有的训练数据</li>
</ul>
<img src="/2024/04/23/11-01-11/11-01.png" class>
<ul>
<li>显然，模型容量太低或太高都不好。太低（对应第一种）过于简单，模型分类效果差，太高（对应第二种）则过于复杂，把噪声全部都拟合住了，这是我们所不希望的。</li>
</ul>
<h4 id="2-3-模型容量的影响"><a href="#2-3-模型容量的影响" class="headerlink" title="2.3 模型容量的影响"></a>2.3 模型容量的影响</h4><img src="/2024/04/23/11-01-11/11-02.png" class>
<ul>
<li>我们的核心任务就是把泛化误差往下降</li>
</ul>
<h4 id="2-4-估计模型容量"><a href="#2-4-估计模型容量" class="headerlink" title="2.4 估计模型容量"></a>2.4 估计模型容量</h4><ul>
<li>难以在不同的种类算法之间比较<ul>
<li>例如树模型和神经网络</li>
</ul>
</li>
<li>给定一个模型种类，将有两个主要因素<ul>
<li>参数的个数</li>
<li>参数的选择范围</li>
</ul>
</li>
</ul>
<img src="/2024/04/23/11-01-11/11-03.png" class>
<h4 id="2-5-VC维"><a href="#2-5-VC维" class="headerlink" title="2.5 VC维"></a>2.5 VC维</h4><p>VC维是统计学习理论的一个核心思想，这里大致了解就行，因为很难计算之后学习的模型（如CNN,RNN)的VC维，故并不经常用</p>
<ul>
<li>定义：对于一个分类模型，VC维等于一个最大的数据集的大小，不管如何给定标号，都存在一个模型对它进行完美分类。即存在H个样本，模型能把H个样本的2^H种标号方式打散的H的最大值。</li>
<li>例子：线性分类器的VC维<ul>
<li>2维输入的感知机，VC维=3（对于三个点的任意标号都能分类，而任意四个点的样本都存在不能被打散的标号形式个，如之前讲过的XOR）</li>
</ul>
</li>
</ul>
<p>3个点：</p>
<img src="/2024/04/23/11-01-11/11-04.png" class>
<p>4个点：</p>
<img src="/2024/04/23/11-01-11/11-05.png" class>
<ul>
<li>支持N维输入的感知机的VC维是N+1</li>
</ul>
<h4 id="2-6-VC维的用处"><a href="#2-6-VC维的用处" class="headerlink" title="2.6 VC维的用处"></a>2.6 VC维的用处</h4><ul>
<li>提供为什么一个模型好的理论依据<ul>
<li>它可以衡量训练误差和泛化误差之间的间隔</li>
</ul>
</li>
<li>但深度学习中很少使用<ul>
<li>衡量不是很准确</li>
<li>计算深度学习模型的VC维很困难</li>
</ul>
</li>
</ul>
<h4 id="2-7-数据复杂度"><a href="#2-7-数据复杂度" class="headerlink" title="2.7 数据复杂度"></a>2.7 数据复杂度</h4><ul>
<li>多个重要因素<ul>
<li>样本的元素个数</li>
<li>每个样本的元素个数</li>
<li>时间、空间结构</li>
<li>多样性</li>
</ul>
</li>
</ul>
<h4 id="2-8-总结"><a href="#2-8-总结" class="headerlink" title="2.8 总结"></a>2.8 总结</h4><ul>
<li>模型容量需要匹配数据复杂度，否则可能导致欠拟合和过拟合</li>
<li>统计机器学习提供数学工具来衡量模型复杂度</li>
<li>实际中一般考观察训练误差和验证误差</li>
</ul>
<h3 id="3-多项式回归"><a href="#3-多项式回归" class="headerlink" title="3. 多项式回归"></a>3. 多项式回归</h3><ul>
<li>本小节使用多项式回归为例子，在pytorch上展示过拟合和欠拟合的实际表现</li>
</ul>
<h4 id="3-1-导入库"><a href="#3-1-导入库" class="headerlink" title="3.1 导入库"></a>3.1 导入库</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br></pre></td></tr></table></figure>
<h4 id="3-2-生成数据集"><a href="#3-2-生成数据集" class="headerlink" title="3.2 生成数据集"></a>3.2 生成数据集</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">max_degree = <span class="number">20</span>  <span class="comment"># 多项式的最大阶数</span></span><br><span class="line">n_train, n_test = <span class="number">100</span>, <span class="number">100</span>  <span class="comment"># 训练和测试数据集大小</span></span><br><span class="line">true_w = np.zeros(max_degree)  <span class="comment"># 分配大量的空间</span></span><br><span class="line">true_w[<span class="number">0</span>:<span class="number">4</span>] = np.array([<span class="number">5</span>, <span class="number">1.2</span>, -<span class="number">3.4</span>, <span class="number">5.6</span>])<span class="comment">#前五个参数是有用的已知的参数，其他都是0，是不希望被学习的参数</span></span><br><span class="line"></span><br><span class="line">features = np.random.normal(size=(n_train + n_test, <span class="number">1</span>))<span class="comment">#创建特征值</span></span><br><span class="line">np.random.shuffle(features)<span class="comment">#打乱顺序</span></span><br><span class="line">poly_features = np.power(features, np.arange(max_degree).reshape(<span class="number">1</span>, -<span class="number">1</span>))<span class="comment">#通过广播机制得到每个特征值的所有多项式值</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(max_degree):</span><br><span class="line">    poly_features[:, i] /= math.gamma(i + <span class="number">1</span>)  <span class="comment"># gamma(n)=(n-1)!，除以gamma防止梯度过大</span></span><br><span class="line"><span class="comment"># labels的维度:(n_train+n_test,)</span></span><br><span class="line">labels = np.dot(poly_features, true_w)<span class="comment">#将对应多项式值与其系数相乘</span></span><br><span class="line">labels += np.random.normal(scale=<span class="number">0.1</span>, size=labels.shape)<span class="comment">#加上噪声项</span></span><br></pre></td></tr></table></figure>
<h4 id="3-3-NumPyndarray转换为tensor"><a href="#3-3-NumPyndarray转换为tensor" class="headerlink" title="3.3 NumPyndarray转换为tensor"></a>3.3 NumPyndarray转换为tensor</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">true_w, features, poly_features, labels = [torch.tensor(x, dtype=</span><br><span class="line">    torch.float32) <span class="keyword">for</span> x <span class="keyword">in</span> [true_w, features, poly_features, labels]]</span><br></pre></td></tr></table></figure>
<h4 id="3-4-对模型进行训练和测试"><a href="#3-4-对模型进行训练和测试" class="headerlink" title="3.4 对模型进行训练和测试"></a>3.4 对模型进行训练和测试</h4><p>首先让我们[实现一个函数来评估模型在给定数据集上的损失]。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">evaluate_loss</span>(<span class="params">net, data_iter, loss</span>):  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;评估给定数据集上模型的损失&quot;&quot;&quot;</span></span><br><span class="line">    metric = d2l.Accumulator(<span class="number">2</span>)  <span class="comment"># 损失的总和,样本数量</span></span><br><span class="line">    <span class="keyword">for</span> X, y <span class="keyword">in</span> data_iter:</span><br><span class="line">        out = net(X)<span class="comment">#预测值</span></span><br><span class="line">        y = y.reshape(out.shape)<span class="comment">#将y维度变为与out一样</span></span><br><span class="line">        l = loss(out, y)<span class="comment">#计算损失</span></span><br><span class="line">        metric.add(l.<span class="built_in">sum</span>(), l.numel())<span class="comment">#加入到迭代器中，进入下一个batch</span></span><br><span class="line">    <span class="keyword">return</span> metric[<span class="number">0</span>] / metric[<span class="number">1</span>]<span class="comment">#返回平均损失</span></span><br></pre></td></tr></table></figure>
<p>现在[定义训练函数]</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">train_features, test_features, train_labels, test_labels,</span></span><br><span class="line"><span class="params">          num_epochs=<span class="number">400</span></span>):</span><br><span class="line">    loss = nn.MSELoss()<span class="comment">#定义损失</span></span><br><span class="line">    input_shape = train_features.shape[-<span class="number">1</span>]</span><br><span class="line">    <span class="comment"># 不设置偏置，因为我们已经在多项式特征中实现了它（即x^0）</span></span><br><span class="line">    net = nn.Sequential(nn.Linear(input_shape, <span class="number">1</span>, bias=<span class="literal">False</span>))<span class="comment">#创建模型</span></span><br><span class="line">    batch_size = <span class="built_in">min</span>(<span class="number">10</span>, train_labels.shape[<span class="number">0</span>])</span><br><span class="line">    train_iter = d2l.load_array((train_features, train_labels.reshape(-<span class="number">1</span>,<span class="number">1</span>)),</span><br><span class="line">                                batch_size)<span class="comment">#训练集</span></span><br><span class="line">    test_iter = d2l.load_array((test_features, test_labels.reshape(-<span class="number">1</span>,<span class="number">1</span>)),</span><br><span class="line">                               batch_size, is_train=<span class="literal">False</span>)<span class="comment">#测试集</span></span><br><span class="line">    trainer = torch.optim.SGD(net.parameters(), lr=<span class="number">0.001</span>)<span class="comment">#设置优化器，这里使用SGD</span></span><br><span class="line">    animator = d2l.Animator(xlabel=<span class="string">&#x27;epoch&#x27;</span>, ylabel=<span class="string">&#x27;loss&#x27;</span>, yscale=<span class="string">&#x27;log&#x27;</span>,</span><br><span class="line">                            xlim=[<span class="number">1</span>, num_epochs], ylim=[<span class="number">1e-3</span>, <span class="number">1e2</span>],</span><br><span class="line">                            legend=[<span class="string">&#x27;train&#x27;</span>, <span class="string">&#x27;test&#x27;</span>])<span class="comment">#动画</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">        d2l.train_epoch_ch3(net, train_iter, loss, trainer)<span class="comment">#训练</span></span><br><span class="line">        <span class="keyword">if</span> epoch == <span class="number">0</span> <span class="keyword">or</span> (epoch + <span class="number">1</span>) % <span class="number">20</span> == <span class="number">0</span>:</span><br><span class="line">            animator.add(epoch + <span class="number">1</span>, (evaluate_loss(net, train_iter, loss),</span><br><span class="line">                                     evaluate_loss(net, test_iter, loss)))<span class="comment">#将当前的训练集和测试集的损失存入animator中，用于绘图</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;weight:&#x27;</span>, net[<span class="number">0</span>].weight.data.numpy())<span class="comment">#打印训练后的参数</span></span><br></pre></td></tr></table></figure>
<h4 id="3-5-三阶多项式函数拟合-正态"><a href="#3-5-三阶多项式函数拟合-正态" class="headerlink" title="3.5 [三阶多项式函数拟合(正态)]"></a>3.5 [<strong>三阶多项式函数拟合(正态)</strong>]</h4><p>我们将首先使用三阶多项式函数，它与数据生成函数的阶数相同。 结果表明，该模型能有效降低训练损失和测试损失。 学习到的模型参数也接近真实值𝑤=[5,1.2,−3.4,5.6]。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从多项式特征中选择前4个维度，即1,x,x^2/2!,x^3/3!</span></span><br><span class="line">train(poly_features[:n_train, :<span class="number">4</span>], poly_features[n_train:, :<span class="number">4</span>],</span><br><span class="line">      labels[:n_train], labels[n_train:])</span><br></pre></td></tr></table></figure>
<img src="/2024/04/23/11-01-11/11-06.png" class>
<h4 id="3-6-线性函数拟合-欠拟合"><a href="#3-6-线性函数拟合-欠拟合" class="headerlink" title="3.6 [线性函数拟合(欠拟合)]"></a>3.6 [<strong>线性函数拟合(欠拟合)</strong>]</h4><p>让我们再看看线性函数拟合，减少该模型的训练损失相对困难。 在最后一个迭代周期完成后，训练损失仍然很高。 当用来拟合非线性模式（如这里的三阶多项式函数）时，线性模型容易欠拟合。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从多项式特征中选择前2个维度，即1和x</span></span><br><span class="line">train(poly_features[:n_train, :<span class="number">2</span>], poly_features[n_train:, :<span class="number">2</span>],</span><br><span class="line">      labels[:n_train], labels[n_train:])</span><br></pre></td></tr></table></figure>
<img src="/2024/04/23/11-01-11/11-07.png" class>
<h4 id="3-7-高阶多项式函数拟合-过拟合"><a href="#3-7-高阶多项式函数拟合-过拟合" class="headerlink" title="3.7 [高阶多项式函数拟合(过拟合)]"></a>3.7 [<strong>高阶多项式函数拟合(过拟合)</strong>]</h4><p>现在，让我们尝试使用一个阶数过高的多项式来训练模型。 在这种情况下，没有足够的数据用于学到高阶系数应该具有接近于零的值。 因此，这个过于复杂的模型会轻易受到训练数据中噪声的影响。 虽然训练损失可以有效地降低，但测试损失仍然很高。 结果表明，复杂模型对数据造成了过拟合。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从多项式特征中选取所有维度</span></span><br><span class="line">train(poly_features[:n_train, :], poly_features[n_train:, :],</span><br><span class="line">      labels[:n_train], labels[n_train:], num_epochs=<span class="number">1500</span>)</span><br></pre></td></tr></table></figure>
<img src="/2024/04/23/11-01-11/11-08.png" class>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>10-多层感知机</title>
    <url>/2024/04/23/11-01-10/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.04.24：初稿</li>
</ul>
<h2 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h2><ul>
<li><a href="/2024/04/24/12-18-34/" title="动手学深度学习笔记汇总">动手学深度学习笔记汇总</a>
</li>
</ul>
<h2 id="多层感知机"><a href="#多层感知机" class="headerlink" title="多层感知机"></a>多层感知机</h2><h3 id="感知机"><a href="#感知机" class="headerlink" title="感知机"></a>感知机</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>从现在的观点来看，感知机实际上就是神经网络中的一个神经单元</p>
<img src="/2024/04/23/11-01-10/%E6%84%9F%E7%9F%A5%E6%9C%BA.png" class>
<p>感知机能解决二分类问题，但与线性回归和softmax回归有所区别：线性回归与softmax回归的输出均为实数，softmax回归的输出同时还满足概率公理。</p>
<h4 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h4><p>训练感知机的伪代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">initialize w = <span class="number">0</span> <span class="keyword">and</span> b = <span class="number">0</span></span><br><span class="line">repeat</span><br><span class="line">    <span class="comment">#此处表达式小于0代表预测结果错误</span></span><br><span class="line">    <span class="keyword">if</span> y_i[&lt;w,x_i&gt;+b] &lt;= <span class="number">0</span> then</span><br><span class="line">        w=w + yixi</span><br><span class="line">        b=b + yi</span><br><span class="line">    end <span class="keyword">if</span></span><br><span class="line">until <span class="built_in">all</span> classified correctly</span><br></pre></td></tr></table></figure>
<p>可以看出这等价于使用如下损失函数的随机梯度下降（batch_size=1）:<br>$$<br>\ell(y, \boldsymbol x,\boldsymbol w)=max(0,-y&lt;\boldsymbol w,\boldsymbol x&gt;)\\<br>=max(0,-y\boldsymbol w^T\boldsymbol x)<br>$$<br>当预测错误时，偏导数为<br>$$<br>\frac{\partial \ell}{\partial \boldsymbol w}=-y\cdot \boldsymbol x<br>$$</p>
<p>注：此处为了方便计算，将偏置项b归入w中的最后一维，并在特征x中相应的最后一维加入常数1</p>
<h4 id="收敛定理"><a href="#收敛定理" class="headerlink" title="收敛定理"></a>收敛定理</h4><p>设数据在特征空间能被半径为r的圆（球）覆盖，并且分类时有余量（即$\sigma$函数的输入不会取使输出模棱两可的值）$y(\boldsymbol x^T\boldsymbol w)\geq \rho$，若初始参数满足$\|\boldsymbol w\|^2+b^2 \leq 1$，则感知机保证在$\frac{r^2+1}{\rho ^2}$步内收敛</p>
<p><a href="https://zhuanlan.zhihu.com/p/46762820">收敛性的证明</a></p>
<h3 id="线性模型的缺陷"><a href="#线性模型的缺陷" class="headerlink" title="线性模型的缺陷"></a>线性模型的缺陷</h3><p>在前面的课程中我们学习了softmax回归，线性回归，他们有将输入向量与一个权重向量做内积再与一个偏置相加得到一个值的过程：<br>$$<br>O =W^TX+b<br>$$<br>这个过程被称为仿射变换，它是一个带有偏置项的线性变换，它最终产生的模型被称为线性模型，线性模型的特点是只能以线性的方式对特征空间进行划分：</p>
<img src="/2024/04/23/11-01-10/%E7%BA%BF%E6%80%A7%E5%88%92%E5%88%86.png" class>
<p>然而，这种线性划分依赖于线性假设，是非常不可靠的</p>
<ul>
<li>线性假设意味着单调假设，这是不可靠的：<ul>
<li>对于人体的体温与健康情况的建模，人体在37℃时最为健康，过小过大均有风险，然而这不是单调的</li>
</ul>
</li>
<li>线性假设意味着特征与预测存在线性相关性，这也是不可靠的：<ul>
<li>如果预测一个人偿还债务的可能性，那这个人的资产从0万元增至5万元和从100万元增至105万元对应的偿还债务的可能性的增幅肯定是不相等的，也就是不线性相关的</li>
</ul>
</li>
<li>线性模型的评估标准是有位置依赖性的，这是不可靠的：<ul>
<li>如果需要判断图片中的动物是猫还是狗，对于图片中一个像素的权重的改变永远是不可靠的，因为如果将图片翻转，它的类别不会改变，但是线性模型不具备这种性质，像素的权重将会失效</li>
</ul>
</li>
</ul>
<p>课程中所提到的例子是XOR问题，即希望模型能预测出XOR分类（分割图片中的一三象限与二四象限）：</p>
<img src="/2024/04/23/11-01-10/XOR%E9%97%AE%E9%A2%98.png" class>
<h3 id="多层感知机-1"><a href="#多层感知机-1" class="headerlink" title="多层感知机"></a>多层感知机</h3><h4 id="XOR问题的多层次解决"><a href="#XOR问题的多层次解决" class="headerlink" title="XOR问题的多层次解决"></a>XOR问题的多层次解决</h4><p>仍以XOR问题为例，XOR问题的一个解决思路是分类两次，先按x轴分类为+和-，再按y轴分类为+和-，最后将两个分类结果相乘，+即为一三象限，-即为二四象限：</p>
<img src="/2024/04/23/11-01-10/%E5%A4%9A%E5%B1%82%E5%88%86%E7%B1%BBXOR1.png" class>
<img src="/2024/04/23/11-01-10/%E5%A4%9A%E5%B1%82%E5%88%86%E7%B1%BBXOR2.png" class>
<p>这实际上将信息进行了多层次的传递：</p>
<img src="/2024/04/23/11-01-10/XOR%E4%BF%A1%E6%81%AF%E5%A4%9A%E5%B1%82%E6%AC%A1%E4%BC%A0%E9%80%92.png" class>
<p>其中蓝色为按X坐标的正负进行的分类，橙色为按Y坐标的正负进行的分类，灰色为将二者信息的综合，这就实现了用多层次的线性模型对非线性进行预测</p>
<h4 id="多层感知机-2"><a href="#多层感知机-2" class="headerlink" title="多层感知机"></a>多层感知机</h4><p>有了XOR问题的解决经验，可以想到如果将多个感知机堆叠起来，形成具有多个层次的结构，如图：</p>
<img src="/2024/04/23/11-01-10/%E5%8D%95%E9%9A%90%E8%97%8F%E5%B1%82.png" class>
<p>这里的模型称为多层感知机，第一层圆圈$x_1,x_2,x_3,x_4$称为输入（实际上他并非感知机），之后的一层称为隐藏层，由5个感知机构成，他们均以前一层的信息作为输入，最后是输出层，以前一层隐藏层的结果作为输入。除了输入的信息和最后一层的感知机以外，其余的层均称为隐藏层，隐藏层的设置为模型一个重要的超参数，这里的模型有一个隐藏层。</p>
<h4 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h4><p>但是仅仅有线性变换是不够的，如果我们简单的将多个线性变换按层次叠加，由于线性变换的结果仍为线性变换，所以最终的结果等价于线性变换，与单个感知机并无区别，反而加大了模型，浪费了资源，为了防止这个问题，需要对每个单元（感知机）的输出通过激活函数进行处理再交由下一层的感知机进行运算，这些激活函数就是解决非线性问题的关键。</p>
<p><em>激活函数</em>（activation function）通过计算加权和并加上偏置来确定神经元是否应该被激活，它们将输入信号转换为输出的可微运算。大多数激活函数都是非线性的。</p>
<p>主要的激活函数有：</p>
<h5 id="ReLU函数"><a href="#ReLU函数" class="headerlink" title="ReLU函数"></a>ReLU函数</h5><p>最受欢迎的激活函数是<em>修正线性单元</em>（Rectified linear<br>unit，<em>ReLU</em>），因为它实现简单，同时在各种预测任务中表现良好。<strong>ReLU提供了一种非常简单的非线性变换</strong>。给定元素$x$，ReLU函数被定义为该元素与$0$的最大值：<br>$$<br>\operatorname{ReLU}(x) = \max(x, 0)<br>$$<br>ReLU函数通过将相应的活性值设为0，仅保留正元素并丢弃所有负元素。为了直观感受一下，我们可以画出函数的曲线图。正如从图中所看到，激活函数是分段线性的。使用ReLU的原因是，它求导表现得特别好：要么让参数消失，要么让参数通过。这使得优化表现的更好，并且ReLU减轻了困扰以往神经网络的梯度消失问题</p>
<h5 id="sigmoid函数"><a href="#sigmoid函数" class="headerlink" title="sigmoid函数"></a>sigmoid函数</h5><p><strong>对于一个定义域在$\mathbb{R}$中的输入，<em>sigmoid函数</em>将输入变换为区间(0,1)上的输出</strong>。 因此，sigmoid通常称为<em>挤压函数</em>（squashing function）：它将范围$（-\infty, \infty）$中的任意输入压缩到区间（0,1）中的某个值：<br>$$<br>\operatorname{sigmoid}(x) = \frac{1}{1 + e^{-x}}.<br>$$<br>在基于梯度的学习中，sigmoid函数是一个自然的选择，因为它是一个平滑的、可微的阈值单元近似。当我们想要将输出视作二元分类问题的概率时，sigmoid仍然被广泛用作输出单元上的激活函数（你可以将sigmoid视为softmax的特例）。然而，sigmoid在隐藏层中已经较少使用，它在大部分时候被更简单、更容易训练的ReLU所取代。</p>
<h5 id="tanh函数"><a href="#tanh函数" class="headerlink" title="tanh函数"></a>tanh函数</h5><p>与sigmoid函数类似，<strong>tanh(双曲正切)函数也能将其输入压缩转换到区间(-1,1)上</strong>。tanh函数的公式如下：<br>$$<br>\operatorname{tanh}(x) = \frac{1 - e^{-2x}}{1 + e^{-2x}}<br>$$</p>
<h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>还可以使用更多隐藏层的感知机和softmax函数解决分类问题</p>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><ol>
<li>证明一个仅使用ReLU（或pReLU）的多层感知机构造了一个连续的分段线性函数。</li>
</ol>
<blockquote>
<p>绘制出RELU的图像后，我们可以发现，输出值在经过下一层隐藏层的计算后，如果结果小于等于0，则这个数据被舍弃，结果大于0则被保留，类似一个筛选的过程。相当于上一层的输出经过线性变换后在下一层被筛选，线性变换和上述筛选的过程都是连续的，因此就会产生连续而且分段的结果。</p>
</blockquote>
<ol>
<li>构建多个超参数的搜索方法。</li>
</ol>
<blockquote>
<p>有四种主要的策略可用于搜索最佳配置。</p>
<ul>
<li>试错</li>
<li>网格搜索</li>
<li>随机搜索</li>
<li>贝叶斯优化</li>
</ul>
</blockquote>
<p>详见<a href="https://www.jiqizhixin.com/articles/101401">超参数搜索不够高效？这几大策略了解一下</a></p>
<ol>
<li>权重初始化方法</li>
</ol>
<blockquote>
<ol>
<li>全零初始化：在神经网络中，把w初始化为0是不可以的。这是因为如果把w初始化0，那么每一层的神经元学到的东西都是一样的（输出是一样的），而且在BP的时候，每一层内的神经元也是相同的，因为他们的gradient相同，weight<br>update也相同。</li>
<li>随机初始化</li>
<li>Xavier初始化：保持输入和输出的方差一致（服从相同的分布），这样就避免了所有输出值都趋向于0。</li>
<li>He<br>initialization：在ReLU网络中，假定每一层有一半的神经元被激活，另一半为0（x负半轴中是不激活的），所以要保持variance不变，只需要在Xavier的基础上再除以2。</li>
<li>pre-training</li>
</ol>
</blockquote>
<p>详见<a href="https://zhuanlan.zhihu.com/p/72374385">权重/参数初始化</a></p>
<ol>
<li>超参数的调节</li>
</ol>
<blockquote>
<ol>
<li>在mlp中，第一个隐藏的的单元数可能大于输入的个数，每个隐藏层中的单元数由前至后递减，逐渐接近输出的个数。</li>
<li>多数情况下，将mlp的深度设置得较深，而每层的单元数相对较少，这样易于训练，不易过拟合，也利于逐步学习样本特征。</li>
<li>激活函数种类的选择对训练的影响小于其余的因素。</li>
</ol>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>多层感知机使用隐藏层和激活函数来得到非线性模型</p>
</li>
<li><p>常用激活函数：Sigmoid，Tanh，ReLU</p>
</li>
<li><p>使用softmax进行多分类</p>
</li>
<li><p>隐藏层数、大小为超参数</p>
</li>
</ul>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>09-softmax回归</title>
    <url>/2024/04/23/11-01-09/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.04.24：初稿</li>
</ul>
<h2 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h2><ul>
<li><a href="/2024/04/24/12-18-34/" title="动手学深度学习笔记汇总">动手学深度学习笔记汇总</a>
</li>
</ul>
<h1 id="09-softmax回归"><a href="#09-softmax回归" class="headerlink" title="09-softmax回归"></a>09-softmax回归</h1><h3 id="1-回归VS分类："><a href="#1-回归VS分类：" class="headerlink" title="1.回归VS分类："></a>1.回归VS分类：</h3><ul>
<li>回归估计一个连续值</li>
<li>分类预测一个离散类别</li>
</ul>
<img src="/2024/04/23/11-01-09/09-01.png" class>
<h4 id="1-1-从回归到多类分类："><a href="#1-1-从回归到多类分类：" class="headerlink" title="1.1 从回归到多类分类："></a>1.1 从回归到多类分类：</h4><h5 id="回归："><a href="#回归：" class="headerlink" title="回归："></a>回归：</h5><ul>
<li>单连续数值输出</li>
<li>自然区间R</li>
<li>跟真实值的区别作为损失</li>
</ul>
<img src="/2024/04/23/11-01-09/09-02.png" class>
<h5 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h5><ul>
<li><p>通常多个输出</p>
</li>
<li><p>输出i是预测为第i类的置信度</p>
</li>
</ul>
<img src="/2024/04/23/11-01-09/09-03.png" class>
<h5 id="均方损失："><a href="#均方损失：" class="headerlink" title="均方损失："></a>均方损失：</h5><ul>
<li><p>对类别进行一位有效编码</p>
<p>$y=[y_{1},y_{2},…,y_{n}]^{T}$<br>$y_{i}=\begin{cases}<br>1&amp;i=y\\<br>2&amp;otherwise<br>\end{cases}$</p>
</li>
<li><p>使用均方损失训练</p>
</li>
<li><p>最大值为预测<br>$<br>\hat{y}=\underset {i}{argmax}\quad o^{i}<br>$</p>
</li>
</ul>
<h5 id="无校验比例"><a href="#无校验比例" class="headerlink" title="无校验比例"></a>无校验比例</h5><ul>
<li><p>对类别进行一位有效编码</p>
</li>
<li><p>最大值为预测<br>$<br>\hat{y}=\underset {i}{argmax}\quad o^{i}<br>$</p>
</li>
<li><p>需要更置信的识别正确类（大余量）<br>$<br>o_y-o_i\geq\Delta(y,i)<br>$</p>
</li>
</ul>
<h5 id="校验比例"><a href="#校验比例" class="headerlink" title="校验比例"></a>校验比例</h5><ul>
<li><p>输出匹配概率（$\hat{y}$非负，和为1）<br>$<br>\hat{y}=softmax(o)<br>$</p>
<p>$<br>\hat{y_i}=\frac{exp(o_i)}{\sum_{k} exp(o_k)}<br>$</p>
</li>
</ul>
<ul>
<li>概率$y$和$\hat{y}$的区别作为损失</li>
</ul>
<h4 id="1-2-Softmax和交叉熵损失"><a href="#1-2-Softmax和交叉熵损失" class="headerlink" title="1.2 Softmax和交叉熵损失"></a>1.2 Softmax和交叉熵损失</h4><ul>
<li><p>交叉熵用来衡量两个概率的区别$H(p,q)=\sum_{i} -p_{i}log(q_i)$</p>
</li>
<li><p>将它作为损失<br>$<br>l(y,\hat{y})=-\sum_{i}y_{i}log\hat{y_{i}}=-log\hat{y_y}<br>$</p>
<blockquote>
<p>推导过程？</p>
</blockquote>
</li>
<li>其梯度是真实概率和预测概率的区别<br>$<br>\partial_{o_{i}}l(y,\hat{y})=softmax(o)_{i}-y_{i}<br>$</li>
</ul>
<blockquote>
<p>Softmax回归是一个多类分类模型</p>
<p>使用Softmax操作子得到每个类的预测置信度</p>
<p>使用交叉熵来衡量和预测标号的区别</p>
</blockquote>
<h3 id="2-损失函数"><a href="#2-损失函数" class="headerlink" title="2.损失函数"></a>2.损失函数</h3><img src="/2024/04/23/11-01-09/09-04.png" class>
<h4 id="2-1-L2-Loss-均方损失"><a href="#2-1-L2-Loss-均方损失" class="headerlink" title="2.1 L2 Loss  均方损失"></a>2.1 L2 Loss  均方损失</h4><p>$<br>l(y,y^{‘})=\frac{1}{2}(y-y^{‘})^2<br>$</p>
<img src="/2024/04/23/11-01-09/09-05.png" class>
<blockquote>
<p>蓝色：y=0<br>绿色似然函数,高斯分布<br>损失函数的梯度，一次函数<br>梯度会随着结果逼近而下降</p>
</blockquote>
<h4 id="2-2-L1-Loss-绝对值损失函数"><a href="#2-2-L1-Loss-绝对值损失函数" class="headerlink" title="2.2 L1 Loss  绝对值损失函数"></a>2.2 L1 Loss  绝对值损失函数</h4><p>$<br>l(y,y^{‘})=\lvert y-y^{‘}\rvert<br>$</p>
<img src="/2024/04/23/11-01-09/09-06.png" class>
<blockquote>
<p>梯度保持不变，但在0处梯度随机</p>
</blockquote>
<h4 id="2-3Huber’s-Robust-Loss-鲁棒损失"><a href="#2-3Huber’s-Robust-Loss-鲁棒损失" class="headerlink" title="2.3Huber’s Robust Loss   鲁棒损失"></a>2.3Huber’s Robust Loss   鲁棒损失</h4><img src="/2024/04/23/11-01-09/09-07.png" class>
<blockquote>
<p>结合L1 Loss和L2 Loss的优点</p>
</blockquote>
<h3 id="3-图片分类数据集"><a href="#3-图片分类数据集" class="headerlink" title="3.图片分类数据集"></a>3.图片分类数据集</h3><h4 id="3-1-Fashion-MNIST数据集："><a href="#3-1-Fashion-MNIST数据集：" class="headerlink" title="3.1 Fashion-MNIST数据集："></a>3.1 Fashion-MNIST数据集：</h4><ul>
<li><p>读取数据集</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过ToTensor实例将图像数据从PIL类型变换成32位浮点数格式，</span></span><br><span class="line"><span class="comment"># 并除以255使得所有像素的数值均在0～1之间</span></span><br><span class="line"><span class="comment"># 转换为张量形式 trans</span></span><br><span class="line"><span class="comment"># 读取为训练集，测试集，读取为张量形式还不是图片形式</span></span><br><span class="line">trans=transforms.ToTensor()</span><br><span class="line">mnist_train=torchvision.datasets.FashionMNIST(root=<span class="string">&quot;../data&quot;</span>,train=<span class="literal">True</span>,                                              transform=trans,download=<span class="literal">True</span>)</span><br><span class="line">mnist_test=torchvision.datasets.FashionMNIST(root=<span class="string">&quot;../data&quot;</span>,train=<span class="literal">False</span>,                                             transform=trans,download=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据集内图片大小</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一张图片的shape</span></span><br><span class="line">mnist_train[<span class="number">0</span>][<span class="number">0</span>].shape</span><br><span class="line">torch.Size([<span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>])</span><br></pre></td></tr></table></figure>
<p>表示图片为单通道（黑白）的28X28的图片</p>
</li>
<li><p>两个可视化函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_fashion_mnist_labels</span>(<span class="params">labels</span>):  </span><br><span class="line">  <span class="string">&quot;&quot;&quot;返回Fashion-MNIST数据集的文本标签&quot;&quot;&quot;</span></span><br><span class="line">  text_labels = [<span class="string">&#x27;t-shirt&#x27;</span>, <span class="string">&#x27;trouser&#x27;</span>, <span class="string">&#x27;pullover&#x27;</span>, <span class="string">&#x27;dress&#x27;</span>, <span class="string">&#x27;coat&#x27;</span>,</span><br><span class="line">                 <span class="string">&#x27;sandal&#x27;</span>, <span class="string">&#x27;shirt&#x27;</span>, <span class="string">&#x27;sneaker&#x27;</span>, <span class="string">&#x27;bag&#x27;</span>, <span class="string">&#x27;ankle boot&#x27;</span>]</span><br><span class="line">  <span class="keyword">return</span> [text_labels[<span class="built_in">int</span>(i)] <span class="keyword">for</span> i <span class="keyword">in</span> labels]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show_images</span>(<span class="params">imgs, num_rows, num_cols, titles=<span class="literal">None</span>, scale=<span class="number">1.5</span></span>):  </span><br><span class="line">  <span class="string">&quot;&quot;&quot;绘制图像列表&quot;&quot;&quot;</span></span><br><span class="line">  figsize = (num_cols * scale, num_rows * scale)</span><br><span class="line">  _, axes = d2l.plt.subplots(num_rows, num_cols, figsize=figsize)</span><br><span class="line">  axes = axes.flatten()</span><br><span class="line">  <span class="keyword">for</span> i, (ax, img) <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">zip</span>(axes, imgs)):</span><br><span class="line">      <span class="keyword">if</span> torch.is_tensor(img):</span><br><span class="line">          <span class="comment"># 图片张量</span></span><br><span class="line">          ax.imshow(img.numpy())</span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">          <span class="comment"># PIL图片</span></span><br><span class="line">          ax.imshow(img)</span><br><span class="line">      ax.axes.get_xaxis().set_visible(<span class="literal">False</span>)</span><br><span class="line">      ax.axes.get_yaxis().set_visible(<span class="literal">False</span>)</span><br><span class="line">      <span class="keyword">if</span> titles:</span><br><span class="line">          ax.set_title(titles[i])</span><br><span class="line">  <span class="keyword">return</span> axes</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>显示数据集图像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 画2行每行9个，titles拿出</span><br><span class="line">X,y = next(iter(data.DataLoader(mnist_train,batch_size=18)))</span><br><span class="line">show_images(X.reshape(18,28,28),2,9,titles=get_fashion_mnist_labels(y))</span><br></pre></td></tr></table></figure>
<img src="/2024/04/23/11-01-09/09-08.png" class>
</li>
</ul>
<ul>
<li>定义load_data_fashion_mnist函数<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_data_fashion_mnist</span>(<span class="params">batch_size, resize=<span class="literal">None</span></span>):  </span><br><span class="line">  <span class="string">&quot;&quot;&quot;下载Fashion-MNIST数据集，然后将其加载到内存中&quot;&quot;&quot;</span></span><br><span class="line">  trans = [transforms.ToTensor()]</span><br><span class="line">  <span class="keyword">if</span> resize:</span><br><span class="line">      trans.insert(<span class="number">0</span>, transforms.Resize(resize))</span><br><span class="line">  trans = transforms.Compose(trans)</span><br><span class="line">  mnist_train = torchvision.datasets.FashionMNIST(</span><br><span class="line">      root=<span class="string">&quot;../data&quot;</span>, train=<span class="literal">True</span>, transform=trans, download=<span class="literal">True</span>)</span><br><span class="line">  mnist_test = torchvision.datasets.FashionMNIST(</span><br><span class="line">      root=<span class="string">&quot;../data&quot;</span>, train=<span class="literal">False</span>, transform=trans, download=<span class="literal">True</span>)</span><br><span class="line">  <span class="keyword">return</span> (data.DataLoader(mnist_train, batch_size, shuffle=<span class="literal">True</span>,</span><br><span class="line">                          num_workers=get_dataloader_workers()),</span><br><span class="line">          data.DataLoader(mnist_test, batch_size, shuffle=<span class="literal">False</span>,</span><br><span class="line">                          num_workers=get_dataloader_workers()))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们通过指定resize参数来测试load_data_fashion_mnist函数的图像大小调整功能。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_iter, test_iter = load_data_fashion_mnist(<span class="number">32</span>, resize=<span class="number">64</span>)</span><br><span class="line"><span class="keyword">for</span> X, y <span class="keyword">in</span> train_iter:</span><br><span class="line">  <span class="built_in">print</span>(X.shape, X.dtype, y.shape, y.dtype)</span><br><span class="line">  <span class="keyword">break</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<h3 id="4-从零实现softmax回归"><a href="#4-从零实现softmax回归" class="headerlink" title="4.从零实现softmax回归"></a>4.从零实现softmax回归</h3><h4 id="softmax"><a href="#softmax" class="headerlink" title="softmax:"></a>softmax:</h4><p>$$<br>softmax(X)_{ij}=\frac{exp(X_{ij})}{\sum_{k} exp(X_{ik})}<br>$$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">softmax</span>(<span class="params">X</span>):</span><br><span class="line">    <span class="comment"># 求每一个元素的指数计算</span></span><br><span class="line">    X_exp = torch.exp(X)</span><br><span class="line">    <span class="comment"># 按行求和</span></span><br><span class="line">    partition = X_exp.<span class="built_in">sum</span>(<span class="number">1</span>, keepdim=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> X_exp / partition</span><br></pre></td></tr></table></figure>
<ol>
<li><p>将图像展平，每个图像看做长度为784的向量，因为数据集有十个类别，所以网络输出维度为10。以此设定参数大小并初始化：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 图片是一个三维的，拉长为一个向量,softmax回归输入为向量</span></span><br><span class="line">num_inputs = <span class="number">784</span></span><br><span class="line">num_outputs = <span class="number">10</span></span><br><span class="line"><span class="comment"># 用高斯回归初始权重，均值0，方差0.01，形状行列为输入输出个数，需要计算梯度</span></span><br><span class="line">W = torch.normal(<span class="number">0</span>, <span class="number">0.01</span>, size=(num_inputs, num_outputs), requires_grad=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 输出需要一个偏移</span></span><br><span class="line">b = torch.zeros(num_outputs, requires_grad=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现softmax回归模型：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">net</span>(<span class="params">X</span>):</span><br><span class="line">    <span class="keyword">return</span> softmax(torch.matmul(X.reshape((-<span class="number">1</span>, W.shape[<span class="number">0</span>])), W) + b)</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现交叉熵损失函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cross_entropy</span>(<span class="params">y_hat, y</span>):</span><br><span class="line">    <span class="keyword">return</span> - torch.log(y_hat[<span class="built_in">range</span>(<span class="built_in">len</span>(y_hat)), y])</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算正确率：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">accuracy</span>(<span class="params">y_hat, y</span>):  </span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算预测正确的数量&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(y_hat.shape) &gt; <span class="number">1</span> <span class="keyword">and</span> y_hat.shape[<span class="number">1</span>] &gt; <span class="number">1</span>:</span><br><span class="line">        y_hat = y_hat.argmax(axis=<span class="number">1</span>)</span><br><span class="line">    cmp = y_hat.<span class="built_in">type</span>(y.dtype) == y</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">float</span>(cmp.<span class="built_in">type</span>(y.dtype).<span class="built_in">sum</span>())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>评估net精度</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">evaluate_accuracy</span>(<span class="params">net, data_iter</span>):  </span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算在指定数据集上模型的精度&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(net, torch.nn.Module):</span><br><span class="line">        net.<span class="built_in">eval</span>()</span><br><span class="line">    metric = Accumulator(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> X, y <span class="keyword">in</span> data_iter:</span><br><span class="line">            metric.add(accuracy(net(X), y), y.numel())</span><br><span class="line">    <span class="keyword">return</span> metric[<span class="number">0</span>] / metric[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Accumulator</span>:  </span><br><span class="line">    <span class="string">&quot;&quot;&quot;在n个变量上累加&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n</span>):</span><br><span class="line">        self.data = [<span class="number">0.0</span>] * n</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, *args</span>):</span><br><span class="line">        self.data = [a + <span class="built_in">float</span>(b) <span class="keyword">for</span> a, b <span class="keyword">in</span> <span class="built_in">zip</span>(self.data, args)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reset</span>(<span class="params">self</span>):</span><br><span class="line">        self.data = [<span class="number">0.0</span>] * <span class="built_in">len</span>(self.data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, idx</span>):</span><br><span class="line">        <span class="keyword">return</span> self.data[idx]</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义训练模型：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train_ch3</span>(<span class="params">net, train_iter, test_iter, loss, num_epochs, updater</span>):  </span><br><span class="line">    <span class="string">&quot;&quot;&quot;训练模型（定义见第3章）&quot;&quot;&quot;</span></span><br><span class="line">    animator = Animator(xlabel=<span class="string">&#x27;epoch&#x27;</span>, xlim=[<span class="number">1</span>, num_epochs], ylim=[<span class="number">0.3</span>, <span class="number">0.9</span>],</span><br><span class="line">                        legend=[<span class="string">&#x27;train loss&#x27;</span>, <span class="string">&#x27;train acc&#x27;</span>, <span class="string">&#x27;test acc&#x27;</span>])</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">        train_metrics = train_epoch_ch3(net, train_iter, loss, updater)</span><br><span class="line">        test_acc = evaluate_accuracy(net, test_iter)</span><br><span class="line">        animator.add(epoch + <span class="number">1</span>, train_metrics + (test_acc,))</span><br><span class="line">    train_loss, train_acc = train_metrics</span><br><span class="line">    <span class="keyword">assert</span> train_loss &lt; <span class="number">0.5</span>, train_loss</span><br><span class="line">    <span class="keyword">assert</span> train_acc &lt;= <span class="number">1</span> <span class="keyword">and</span> train_acc &gt; <span class="number">0.7</span>, train_acc</span><br><span class="line">    <span class="keyword">assert</span> test_acc &lt;= <span class="number">1</span> <span class="keyword">and</span> test_acc &gt; <span class="number">0.7</span>, test_acc</span><br></pre></td></tr></table></figure>
</li>
<li><p>预测：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">predict_ch3</span>(<span class="params">net, test_iter, n=<span class="number">6</span></span>):  </span><br><span class="line">    <span class="string">&quot;&quot;&quot;预测标签（定义见第3章）&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> X, y <span class="keyword">in</span> test_iter:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    trues = d2l.get_fashion_mnist_labels(y)</span><br><span class="line">    preds = d2l.get_fashion_mnist_labels(net(X).argmax(axis=<span class="number">1</span>))</span><br><span class="line">    titles = [true +<span class="string">&#x27;\n&#x27;</span> + pred <span class="keyword">for</span> true, pred <span class="keyword">in</span> <span class="built_in">zip</span>(trues, preds)]</span><br><span class="line">    d2l.show_images(</span><br><span class="line">        X[<span class="number">0</span>:n].reshape((n, <span class="number">28</span>, <span class="number">28</span>)), <span class="number">1</span>, n, titles=titles[<span class="number">0</span>:n])</span><br><span class="line"></span><br><span class="line">predict_ch3(net, test_iter)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<img src="/2024/04/23/11-01-09/09-09.png" class>
<ol>
<li>动画<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animator</span>: </span><br><span class="line">  <span class="string">&quot;&quot;&quot;在动画中绘制数据&quot;&quot;&quot;</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, xlabel=<span class="literal">None</span>, ylabel=<span class="literal">None</span>, legend=<span class="literal">None</span>, xlim=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">               ylim=<span class="literal">None</span>, xscale=<span class="string">&#x27;linear&#x27;</span>, yscale=<span class="string">&#x27;linear&#x27;</span>,</span></span><br><span class="line"><span class="params">               fmts=(<span class="params"><span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;m--&#x27;</span>, <span class="string">&#x27;g-.&#x27;</span>, <span class="string">&#x27;r:&#x27;</span></span>), nrows=<span class="number">1</span>, ncols=<span class="number">1</span>,</span></span><br><span class="line"><span class="params">               figsize=(<span class="params"><span class="number">3.5</span>, <span class="number">2.5</span></span>)</span>):</span><br><span class="line">      <span class="comment"># 增量地绘制多条线</span></span><br><span class="line">      <span class="keyword">if</span> legend <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">          legend = []</span><br><span class="line">      d2l.use_svg_display()</span><br><span class="line">      self.fig, self.axes = d2l.plt.subplots(nrows, ncols, figsize=figsize)</span><br><span class="line">      <span class="keyword">if</span> nrows * ncols == <span class="number">1</span>:</span><br><span class="line">          self.axes = [self.axes, ]</span><br><span class="line">      <span class="comment"># 使用lambda函数捕获参数</span></span><br><span class="line">      self.config_axes = <span class="keyword">lambda</span>: d2l.set_axes(</span><br><span class="line">          self.axes[<span class="number">0</span>], xlabel, ylabel, xlim, ylim, xscale, yscale, legend)</span><br><span class="line">      self.X, self.Y, self.fmts = <span class="literal">None</span>, <span class="literal">None</span>, fmts</span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, x, y</span>):</span><br><span class="line">      <span class="comment"># 向图表中添加多个数据点</span></span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(y, <span class="string">&quot;__len__&quot;</span>):</span><br><span class="line">          y = [y]</span><br><span class="line">      n = <span class="built_in">len</span>(y)</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(x, <span class="string">&quot;__len__&quot;</span>):</span><br><span class="line">          x = [x] * n</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> self.X:</span><br><span class="line">          self.X = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> self.Y:</span><br><span class="line">          self.Y = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">      <span class="keyword">for</span> i, (a, b) <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">zip</span>(x, y)):</span><br><span class="line">          <span class="keyword">if</span> a <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> b <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">              self.X[i].append(a)</span><br><span class="line">              self.Y[i].append(b)</span><br><span class="line">      self.axes[<span class="number">0</span>].cla()</span><br><span class="line">      <span class="keyword">for</span> x, y, fmt <span class="keyword">in</span> <span class="built_in">zip</span>(self.X, self.Y, self.fmts):</span><br><span class="line">          self.axes[<span class="number">0</span>].plot(x, y, fmt)</span><br><span class="line">      self.config_axes()</span><br><span class="line">      display.display(self.fig)</span><br><span class="line">      display.clear_output(wait=<span class="literal">True</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="5-softmax的简洁实现"><a href="#5-softmax的简洁实现" class="headerlink" title="5.softmax的简洁实现"></a>5.softmax的简洁实现</h3><blockquote>
<p>调用torch内的网络层</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#train_iter 返回一个训练集测试集的迭代器</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line">batch_size=<span class="number">256</span></span><br><span class="line">train_iter,test_iter=d2l.load_data_fashion_mnist(batch_size)</span><br><span class="line">net=nn.Sequential(nn.Flatten(),nn.Linear(<span class="number">784</span>,<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_weights</span>(<span class="params">m</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(m) == nn.Linear:</span><br><span class="line">        nn.init.normal_(m.weight,std=<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line">net.apply(init_weights)</span><br><span class="line">loss=nn.CrossEntropyLoss()</span><br><span class="line">trainer=torch.optim.SGD(net.parameters(),lr=<span class="number">0.1</span>)</span><br><span class="line">num_epochs=<span class="number">10</span></span><br><span class="line">d2l.train_ch3(net,train_iter,test_iter,loss,num_epochs,trainer)</span><br></pre></td></tr></table></figure>
<h3 id="6-softmax回归Q-amp-A"><a href="#6-softmax回归Q-amp-A" class="headerlink" title="6.softmax回归Q&amp;A"></a>6.softmax回归Q&amp;A</h3><p><strong>Q1:softlabel训练策略以及为什么有效？</strong></p>
<blockquote>
<p>softmax用指数很难逼近1，softlabel将正例和负例分别标记为0.9和0.1使结果逼近变得可能，这是一个常用的小技巧。</p>
</blockquote>
<h5 id="Q2-softmax回归和logistic回归？"><a href="#Q2-softmax回归和logistic回归？" class="headerlink" title="Q2:softmax回归和logistic回归？"></a>Q2:softmax回归和logistic回归？</h5><blockquote>
<p>logistic回归为二分类问题，是softmax回归的特例</p>
</blockquote>
<h5 id="Q3-为什么使用交叉熵，而不用相对熵，互信息熵等其他基于信息量的度量？"><a href="#Q3-为什么使用交叉熵，而不用相对熵，互信息熵等其他基于信息量的度量？" class="headerlink" title="Q3:为什么使用交叉熵，而不用相对熵，互信息熵等其他基于信息量的度量？"></a>Q3:为什么使用交叉熵，而不用相对熵，互信息熵等其他基于信息量的度量？</h5><blockquote>
<p>实际上使用哪一种熵的效果区别不大，所以哪种简单就用哪种</p>
</blockquote>
<h5 id="Q4-y-log-hat-y-为什么我们只关心正确类，而不关心不正确的类呢？"><a href="#Q4-y-log-hat-y-为什么我们只关心正确类，而不关心不正确的类呢？" class="headerlink" title="Q4:$y*log\hat{y}$   为什么我们只关心正确类，而不关心不正确的类呢？"></a>Q4:$y*log\hat{y}$   为什么我们只关心正确类，而不关心不正确的类呢？</h5><blockquote>
<p>并不是不关心，而是不正确的的类标号为零，所以算式中不体现，如果使用softlabel策略，就会体现出不正确的类。</p>
</blockquote>
<h5 id="Q5-似然函数曲线是怎么得出来的？有什么参考意义？"><a href="#Q5-似然函数曲线是怎么得出来的？有什么参考意义？" class="headerlink" title="Q5:似然函数曲线是怎么得出来的？有什么参考意义？"></a>Q5:似然函数曲线是怎么得出来的？有什么参考意义？</h5><blockquote>
<p>最小化损失函数也意味着最大化似然函数，似然函数表示统计概率和模型的拟合程度。</p>
</blockquote>
<h5 id="Q6-在多次迭代之后欧如果测试精度出现上升后再下降是过拟合了吗？可以提前终止吗？"><a href="#Q6-在多次迭代之后欧如果测试精度出现上升后再下降是过拟合了吗？可以提前终止吗？" class="headerlink" title="Q6:在多次迭代之后欧如果测试精度出现上升后再下降是过拟合了吗？可以提前终止吗？"></a>Q6:在多次迭代之后欧如果测试精度出现上升后再下降是过拟合了吗？可以提前终止吗？</h5><blockquote>
<p>很有可能是过拟合，可以继续训练来观察是否持续下降</p>
</blockquote>
<h5 id="Q7-cnn网络主要学习到的是纹理还是轮廓还是所有内容的综合？"><a href="#Q7-cnn网络主要学习到的是纹理还是轮廓还是所有内容的综合？" class="headerlink" title="Q7:cnn网络主要学习到的是纹理还是轮廓还是所有内容的综合？"></a>Q7:cnn网络主要学习到的是纹理还是轮廓还是所有内容的综合？</h5><blockquote>
<p>目前认为主要学习到的是纹理信息</p>
</blockquote>
<h5 id="Q8-softmax可解释吗？"><a href="#Q8-softmax可解释吗？" class="headerlink" title="Q8:softmax可解释吗？"></a>Q8:softmax可解释吗？</h5><blockquote>
<p>单纯softmax是可解释的，可以在统计书籍中找到相关的解释。</p>
</blockquote>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>08-线性回归+基础优化算法</title>
    <url>/2024/04/23/11-01-08/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.04.24：初稿</li>
</ul>
<h2 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h2><ul>
<li><a href="/2024/04/24/12-18-34/" title="动手学深度学习笔记汇总">动手学深度学习笔记汇总</a>
</li>
</ul>
<h2 id="线性回归-基础优化算法"><a href="#线性回归-基础优化算法" class="headerlink" title="线性回归+基础优化算法"></a>线性回归+基础优化算法</h2><h3 id="1-线性回归"><a href="#1-线性回归" class="headerlink" title="1.线性回归"></a>1.线性回归</h3><ul>
<li><p>房价预测例子</p>
</li>
<li><p><strong>线性模型</strong></p>
<ul>
<li><p>输入：$x=[x_1,x_2,…,x_n]^T$</p>
</li>
<li><p>线性模型需要确定一个n维权重和一个标量偏差$\omega=[\omega_1,\omega_2,…,\omega_n]^T,b$</p>
</li>
<li><p>输出 ：$y=\omega_1x_1+\omega_2x_2+…+\omega_nx_n+b$，</p>
<p>向量版本的是 $y=&lt;\omega,x&gt;+b$</p>
</li>
<li><p>线性模型可以看作是单层神经网络</p>
<blockquote>
<ul>
<li>神经网络源于神经科学<ul>
<li>最早的神经网络是源自神经科学的，但是时至今日，很多神经网络已经远远高于神经科学，可解释性也不是很强，不必纠结</li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p>衡量估计质量</p>
<ul>
<li><p>我们需要估计模型的预估值和真实值之间的差距，例如房屋售价和股价</p>
</li>
<li><p>假设$y$是真实值，$\tilde{y}$是估计值，我们可以比较</p>
<p>$l(y,\tilde{y})=\frac{1}{2}(y-\tilde{y})^2$，这个叫做<strong>平方损失</strong></p>
</li>
</ul>
</li>
<li><p><strong>训练数据</strong></p>
<ul>
<li><p>收集一些数据点来决定参数值（权重$\omega$和偏差$b$），例如6个月内被卖掉的房子。</p>
</li>
<li><p>这被称之为训练数据</p>
</li>
<li><p>通常越多越好。需要注意的是，现实世界的数据都是有限的，但是为了训练出精确的参数往往需要训练数据越多越好，当训练数据不足的时候，我们还需要进行额外处理。</p>
</li>
<li><p>假设我们有n个样本，记为</p>
<p>$X=[x_1,x_2,…,x_n]^T,y=[y_1,y_2,…y_n]^T$</p>
<p>$X$的每一行是一个样本，$y$的每一行是一个输出的实数值。</p>
</li>
</ul>
</li>
<li><p><strong>参数学习</strong></p>
<ul>
<li><p><strong>训练损失</strong>。但我们训练参数的时候，需要定义一个损失函数来衡量参数的好坏，应用前文提过的平方损失有公式：</p>
<p>$l(X,x,\omega,b)=\frac{1}{2n}\sum_{i=1}^n(y_i-{&lt; x_i, w &gt;}-b)^2=\frac{1}{2n}||y-X\omega-b||^2$</p>
</li>
<li><p><strong>最小化损失来学习参数</strong>。训练参数的目的就是使损失函数的值尽可能小（这意味着预估值和真实值更接近）。最后求得的参数值可表示为：</p>
<p>$\omega^*,b^*=argmin_{\omega,b}l(X,x,\omega,b)$</p>
</li>
</ul>
</li>
<li><p><strong>显示解</strong></p>
<ul>
<li><p>线性回归有显示解，即可以直接矩阵数学运算，得到参数w和b的最优解，而不是用梯度下降，牛顿法等参数优化方式一点点逼近最优解。</p>
</li>
<li><p><strong>推导过程</strong>：</p>
<ul>
<li><p>为了方便矩阵表示和计算，将偏差加入权重，$X\gets[X,1],\omega\gets[\omega,b]$</p>
</li>
<li><p>损失函数是凸函数，最优解满足导数为0，可解出显示解</p>
<p>令$\frac{\partial}{\partial\omega} l(X,y,\omega)=0$</p>
<p>有$\frac{1}{n}(y-X\omega)^TX=0$</p>
<p>解得$\omega^*=(X^TX)^{-1}X^Ty$</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>总结</p>
<ul>
<li>线性回归是对n维输入的加权，外加偏差</li>
<li>使用<strong>平方损失</strong>来衡量预测值和真实值之间的误差</li>
<li><strong>线性回归有显示解</strong></li>
<li>线性回归可以看作单层神经网络</li>
</ul>
</li>
</ul>
<h3 id="2-基础优化算法"><a href="#2-基础优化算法" class="headerlink" title="2.基础优化算法"></a>2.基础优化算法</h3><ul>
<li><p><strong>梯度下降</strong></p>
<ul>
<li>当模型没有显示解的时候，应用梯度下降法逼近最优解。</li>
<li>梯度下降法的具体步骤：<ul>
<li>挑选一个初始值$\omega_0$</li>
<li>重复迭代参数，迭代公式为：$\omega_t=\omega_{t-1}-\lambda\frac{\partial l}{\partial\omega_{t-1} } $<ul>
<li><strong>$-\frac{\partial l}{\partial\omega_{t-1}}$为函数值下降最快的方向，学习率$\lambda$为学习步长。</strong></li>
</ul>
</li>
</ul>
</li>
<li>选择学习率<ul>
<li>学习率$\lambda$为学习步长，代表了沿负梯度方向走了多远，这是超参数（人为指定的的值，不是训练得到的）</li>
<li>学习率不能太大，也不能太小，需要选取适当。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>小批量随机梯度下降</strong></p>
<ul>
<li><p>在整个训练集上算梯度太贵了</p>
<ul>
<li>在实际应用中，很少直接应用梯度下降法，这是因为每次更新都需要计算训练集上所有的样本，耗费时间太长。一个深度神经网络模型，迭代一次可能需要数分钟甚至数小时。</li>
</ul>
</li>
<li><p>为了减少运算代价，我们可以==随机采样==b个样本$i_1,i_2,…,i_b$来近似损失，损失函数为：</p>
<p>​    $\frac{1}{b}\sum_{i\in I_b}l(x_i,y_i,\omega)$ , </p>
<p>其中<strong>b是批量大小(batch size)，也是超参数</strong></p>
</li>
<li><p><strong>选择批量大小</strong></p>
<ul>
<li>b也不能太大：内存消耗增加；浪费计算资源，一个极端的情况是可能会重复选取很多差不多的样本，浪费计算资源</li>
<li>b也不能太小：每次计算量太小，很难以并行，不能最大限度利用GPU资源</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>总结</strong></p>
<ul>
<li>梯度下降通过不断<strong>沿着负梯度方向</strong>更新参数求解</li>
<li>小批量随机梯度下降是深度学习默认的求解算法（简单，稳定）</li>
<li><strong>两个重要的超参数：批量大小（batch size），学习率（lr）</strong></li>
</ul>
</li>
</ul>
<h3 id="3-线性回归的从零开始实现"><a href="#3-线性回归的从零开始实现" class="headerlink" title="3.线性回归的从零开始实现"></a>3.线性回归的从零开始实现</h3><ul>
<li>代码</li>
</ul>
<h3 id="4-新型回归的简洁实现"><a href="#4-新型回归的简洁实现" class="headerlink" title="4.新型回归的简洁实现"></a>4.新型回归的简洁实现</h3><ul>
<li>代码</li>
</ul>
<ul>
<li><strong>1.为什么使用平方损失而不是绝对差值？</strong><ul>
<li>其实差别不大，最开始使用平方损失是因为它可导，现在其实都可以使用。</li>
</ul>
</li>
<li><strong>2.损失为什么要求平均？</strong><ul>
<li>本质上没有关系，但是如果不求平均，梯度的数值会比较大，这时需要学习率除以n。如果不除以n，可能会随着样本数量的增大而让梯度变得很大。</li>
</ul>
</li>
<li><strong>3.不管是梯度下降还是随机梯度下降，怎么找到合适的学习率？</strong><ul>
<li>选择对学习率不敏感的优化方法，比如Adam</li>
<li>合理参数初始化</li>
</ul>
</li>
<li><strong>4.训练过程中，过拟合和欠拟合情况下，学习率和batch_size应该如何调整？</strong><ul>
<li>理论上学习率和batch_size对最后的拟合结果不会有影响</li>
</ul>
</li>
<li><strong>5.深度学习上，设置损失函数的时候，需要考虑正则吗？</strong><ul>
<li>会考虑，但是和损失函数是分开的，深度学习中正则没有太大的用处，有很多其他的技术可以有正则的效果。</li>
</ul>
</li>
<li><strong>6.如果样本大小不是批量数的整数倍，需要随机剔除多余的样本吗？</strong><ul>
<li>就取多余的样本作为一个批次</li>
<li>直接丢弃</li>
<li>从下一个epoch里面补少的样本</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>07-链式法则与自动求导</title>
    <url>/2024/04/23/11-01-07/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.04.24：初稿</li>
</ul>
<h2 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h2><ul>
<li><a href="/2024/04/24/12-18-34/" title="动手学深度学习笔记汇总">动手学深度学习笔记汇总</a>
</li>
</ul>
<h2 id="07-链式法则与自动求导"><a href="#07-链式法则与自动求导" class="headerlink" title="07-链式法则与自动求导"></a>07-链式法则与自动求导</h2><h3 id="1-向量链式法则"><a href="#1-向量链式法则" class="headerlink" title="1. 向量链式法则"></a>1. 向量链式法则</h3><ul>
<li><h4 id="1-1-标量链式法则"><a href="#1-1-标量链式法则" class="headerlink" title="1.1 标量链式法则"></a>1.1 标量链式法则</h4></li>
</ul>
<img src="/2024/04/23/11-01-07/image-01.png" class>
<ul>
<li><h4 id="1-2-拓展到向量"><a href="#1-2-拓展到向量" class="headerlink" title="1.2 拓展到向量"></a>1.2 拓展到向量</h4><blockquote>
<p>需要注意维数的变化</p>
<p>下图三种情况分别对应：</p>
<ol>
<li>y为标量，x为向量</li>
<li>y为标量，x为矩阵</li>
<li>y、x为矩阵</li>
</ol>
</blockquote>
</li>
</ul>
<img src="/2024/04/23/11-01-07/image-02.png" class>
<hr>
<h5 id="例1（标量对向量求导）"><a href="#例1（标量对向量求导）" class="headerlink" title="例1（标量对向量求导）"></a>例1（标量对向量求导）</h5><blockquote>
<p>这里应该是用分子布局，所以是X转置</p>
</blockquote>
<p>​                                 <img src="/2024/04/23/11-01-07/image-03.png" class>   </p>
<h5 id="例2（涉及到矩阵的情况）"><a href="#例2（涉及到矩阵的情况）" class="headerlink" title="例2（涉及到矩阵的情况）"></a>例2（涉及到矩阵的情况）</h5><blockquote>
<p>X是mxn的矩阵,w为n维向量，y为m维向量；<br>z对Xw-y做L2 norm,为标量；<br>过程与例一大体一致；</p>
</blockquote>
<p>​                                   <img src="/2024/04/23/11-01-07/image-04.png" class></p>
<hr>
<blockquote>
<p>由于在神经网络动辄几百层，手动进行链式求导是很困难的，因此我们需要借助自动求导</p>
</blockquote>
<hr>
<h3 id="2-自动求导"><a href="#2-自动求导" class="headerlink" title="2. 自动求导"></a>2. 自动求导</h3><ul>
<li><p>含义：计算一个函数在指定值上的导数</p>
</li>
<li><p>自动求导有别于</p>
<ul>
<li><p>符号求导</p>
<img src="/2024/04/23/11-01-07/image-05.png" class>
</li>
<li><p>数值求导</p>
<img src="/2024/04/23/11-01-07/image-06.png" class>
</li>
</ul>
</li>
</ul>
<p>为了更好地理解自动求导，下面引入计算图的概念</p>
<h4 id="2-1-计算图"><a href="#2-1-计算图" class="headerlink" title="2.1 计算图"></a>2.1 计算图</h4><ul>
<li><p>将代码分解成操作子</p>
</li>
<li><p>将计算表示成一个<strong>无环图</strong></p>
<blockquote>
<p>下图自底向上其实就类似于链式求导过程</p>
</blockquote>
</li>
</ul>
<img src="/2024/04/23/11-01-07/image-07.png" class>
<p>​     </p>
<ul>
<li><p>计算图有两种构造方式<br>计算与上图无关</p>
<ul>
<li><p>显示构造</p>
<blockquote>
<p>可以理解为先定义公式再代值</p>
<p>Tensorflow/Theano/MXNet</p>
</blockquote>
<img src="/2024/04/23/11-01-07/image-08.png" class>
</li>
<li><p>隐式构造</p>
<blockquote>
<p>系统将所有的计算记录下来</p>
<p>Pytorch/MXNet</p>
</blockquote>
<img src="/2024/04/23/11-01-07/image-09.png" class>
</li>
</ul>
</li>
</ul>
<h4 id="2-2-自动求导的两种模式"><a href="#2-2-自动求导的两种模式" class="headerlink" title="2.2 自动求导的两种模式"></a>2.2 自动求导的两种模式</h4><ul>
<li><p>正向累积</p>
 <img src="/2024/04/23/11-01-07/image-10.png" class>
</li>
<li><p>反向累积（反向传递back propagation）</p>
<img src="/2024/04/23/11-01-07/image-11.png" class>
</li>
</ul>
<p>​    <strong>反向累积计算过程</strong></p>
<img src="/2024/04/23/11-01-07/image-12.png" class>
<blockquote>
<p>反向累积的正向过程：自底向上，需要存储中间结果</p>
<p>反向累积的反向过程：自顶向下，可以去除不需要的枝（图中的x应为w）</p>
<img src="/2024/04/23/11-01-07/image-13.png" class>
</blockquote>
<h4 id="2-3-复杂度比较"><a href="#2-3-复杂度比较" class="headerlink" title="2.3 复杂度比较"></a>2.3 复杂度比较</h4><ul>
<li><p>反向累积</p>
<ul>
<li>时间复杂度：O(n),n是操作子数<ul>
<li>通常正向和反向的代价类似</li>
</ul>
</li>
<li>空间复杂度：O(n)<ul>
<li>存储正向过程所有的中间结果</li>
</ul>
</li>
</ul>
</li>
<li><p>正向累积</p>
<blockquote>
<p>每次计算一个变量的梯度时都需要将所有节点扫一遍</p>
</blockquote>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-代码部分"><a href="#3-代码部分" class="headerlink" title="3. 代码部分"></a>3. 代码部分</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#对y = x.Tx关于列向量x求导</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">x = torch.arange(<span class="number">4.0</span>)</span><br><span class="line">x</span><br></pre></td></tr></table></figure>
<pre><code>tensor([0., 1., 2., 3.])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#存储梯度</span></span><br><span class="line">x.requires_grad_(<span class="literal">True</span>)<span class="comment">#等价于x = torch.arange(4.0,requires_grad=True)</span></span><br><span class="line">x.grad<span class="comment">#默认值是None</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y = torch.dot(x,x)</span><br><span class="line">y</span><br><span class="line"><span class="comment">#PyTorch隐式地构造计算图，grad_fn用于记录梯度计算</span></span><br></pre></td></tr></table></figure>
<pre><code>tensor(14., grad_fn=&lt;DotBackward0&gt;)
</code></pre><p><strong>通过调用反向传播函数来自动计算y关于x每个分量的梯度</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y.backward()</span><br><span class="line">x.grad</span><br></pre></td></tr></table></figure>
<pre><code>tensor([0., 2., 4., 6.])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x.grad==<span class="number">2</span>*x<span class="comment">#验证</span></span><br></pre></td></tr></table></figure>
<pre><code>tensor([True, True, True, True])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在默认情况下，PyTorch会累积梯度，我们需要清除之前的值</span></span><br><span class="line">x.grad.zero_()<span class="comment">#如果没有这一步结果就会加累上之前的梯度值，变为[1,5,9,13]</span></span><br><span class="line">y = x.<span class="built_in">sum</span>()</span><br><span class="line">y.backward()</span><br><span class="line">x.grad</span><br></pre></td></tr></table></figure>
<pre><code>tensor([1., 1., 1., 1.])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x.grad.zero_()</span><br><span class="line">y=x*x<span class="comment">#哈达玛积，对应元素相乘</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在深度学习中我们一般不计算微分矩阵</span></span><br><span class="line"><span class="comment">#而是计算批量中每个样本单独计算的偏导数之和</span></span><br><span class="line"></span><br><span class="line">y.<span class="built_in">sum</span>().backward()<span class="comment">#等价于y.backword(torch.ones(len(x)))</span></span><br><span class="line">x.grad</span><br></pre></td></tr></table></figure>
<pre><code>tensor([0., 2., 4., 6.])
</code></pre><p><strong>将某些计算移动到记录的计算图之外</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 后可用于用于将神经网络的一些参数固定住</span></span><br><span class="line">x.grad.zero_()</span><br><span class="line">y = x*x</span><br><span class="line">u = y.detach()<span class="comment">#把y当作常数</span></span><br><span class="line">z = u*x</span><br><span class="line"></span><br><span class="line">z.<span class="built_in">sum</span>().backward()</span><br><span class="line">x.grad == u</span><br></pre></td></tr></table></figure>
<pre><code>tensor([True, True, True, True])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x.grad.zero_()</span><br><span class="line">y.<span class="built_in">sum</span>().backward()</span><br><span class="line">x.grad == <span class="number">2</span>*x</span><br></pre></td></tr></table></figure>
<pre><code>tensor([True, True, True, True])
</code></pre><p><strong>即使构建函数的计算图需要用过Python控制流，仍然可以计算得到的变量的梯度</strong></p>
<p><strong>这也是隐式构造的优势，因为它会存储梯度计算的计算图，再次计算时执行反向过程就可以</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a</span>):</span><br><span class="line">    b = a * <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> b.norm()&lt;<span class="number">1000</span>:</span><br><span class="line">        b = b * <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> b.<span class="built_in">sum</span>() &gt; <span class="number">0</span>:</span><br><span class="line">        c = b</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        c = <span class="number">100</span> * b</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line">a = torch.randn(size=(),requires_grad=<span class="literal">True</span>)</span><br><span class="line">d = f(a)</span><br><span class="line">d.backward()</span><br><span class="line"></span><br><span class="line">a.grad == d / a</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="4-自动求导-Q-amp-A"><a href="#4-自动求导-Q-amp-A" class="headerlink" title="4. 自动求导 Q&amp;A"></a>4. 自动求导 Q&amp;A</h3><p><strong><code>Q1：ppt上隐式构造和显式构造看起来为啥差不多？</code></strong></p>
<blockquote>
<p>显式和隐式的差别其实就是数学上求梯度和python求梯度计算上的差别，不用深究</p>
<p>显式构造就是我们数学上正常求导数的求法，先把所有求导的表达式选出来再代值</p>
</blockquote>
<p><strong><code>Q2:需要正向和反向都算一遍吗？</code></strong></p>
<blockquote>
<p>需要正向先算一遍，自动求导时只进行反向就可以，因为正向的结果已经存储</p>
</blockquote>
<p><strong><code>Q3:为什么PyTorch会默认累积梯度</code></strong></p>
<blockquote>
<p>便于计算大批量；方便进一步设计</p>
</blockquote>
<p><strong><code>Q4:为什么深度学习中一般对标量求导而不是对矩阵或向量求导</code></strong></p>
<blockquote>
<p>loss一般都是标量</p>
</blockquote>
<p><strong><code>Q5:为什么获取.grad前需要backward</code></strong></p>
<blockquote>
<p>相当于告诉程序需要计算梯度，因为计算梯度的代价很大，默认不计算</p>
</blockquote>
<p><strong><code>Q6:pytorch或mxnet框架设计上可以实现矢量的求导吗</code></strong></p>
<blockquote>
<p>可以</p>
</blockquote>
<h3 id="5-练习"><a href="#5-练习" class="headerlink" title="5. 练习"></a>5. 练习</h3><p><strong>1.为什么计算二阶导数比一阶导数的开销要更大？</strong></p>
<p>二阶导数是在一阶导数的基础上进行的，开销自然更大</p>
<p><strong>2.在运行反向传播函数之后，立即再次运行它，看看会发生什么。</strong></p>
<p>“RuntimeError: Trying to backward through the graph a second time (or directly access saved tensors after they have already been freed). Saved intermediate values of the graph are freed when you call .backward() or autograd.grad(). Specify retain_graph=True if you need to backward through the graph a second time or if you need to access saved tensors after calling backward.”</p>
<p>说明不能连续两次运行,pytorch使用的是动态计算图,反向传播函数运行一次后计算图就被释放了</p>
<p><strong>只需要在函数接口将参数retain_graph设为True即可</strong></p>
<p>In [51]:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def f(a):</span><br><span class="line">    b = a * 2</span><br><span class="line">    while b.norm()&lt;1000:</span><br><span class="line">        b = b * 2</span><br><span class="line">    if b.sum() &gt; 0:</span><br><span class="line">        c = b</span><br><span class="line">    else:</span><br><span class="line">        c = 100 * b</span><br><span class="line">    return c</span><br><span class="line">a.grad.zero_()</span><br><span class="line">a = torch.randn(size=(),requires_grad=True)#size=0表示a是标量</span><br><span class="line">d = f(a)</span><br><span class="line">#d.backward(retain_graph=True)</span><br><span class="line">#a.grad</span><br><span class="line">d.backward()</span><br><span class="line">a.grad</span><br></pre></td></tr></table></figure>
<p>Out[51]:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tensor(4096.)</span><br></pre></td></tr></table></figure>
<p><strong>3.在控制流的例子中，我们计算d关于a的导数，如果我们将变量a更改为随机向量或矩阵，会发生什么？此时，计算结果f(a)不再是标量。结果会发生什么？我们如何分析这个结果？</strong></p>
<p>backward函数的机制本身不允许张量对张量求导，如果输入是向量或矩阵，需要将其在各个分量上求和，变为标量；所以还需要传入一个与输入同型的张量</p>
<p>In [53]:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def f(a):</span><br><span class="line">    b = a * 2</span><br><span class="line">    while b.norm()&lt;1000:</span><br><span class="line">        b = b * 2</span><br><span class="line">    if b.sum() &gt; 0:</span><br><span class="line">        c = b</span><br><span class="line">    else:</span><br><span class="line">        c = 100 * b</span><br><span class="line">    return c</span><br><span class="line">a.grad.zero_()</span><br><span class="line">a = torch.randn(10,requires_grad=True)</span><br><span class="line">d = f(a)</span><br><span class="line">#d.backward(retain_graph=True)</span><br><span class="line">#a.grad</span><br><span class="line">#d.backward()#RuntimeError: grad can be implicitly created only for scalar outputs</span><br><span class="line">d.sum().backward()#需要加上.sum()否则会报错 </span><br><span class="line">a.grad</span><br></pre></td></tr></table></figure>
<p>Out[53]:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tensor([51200., 51200., 51200., 51200., 51200., 51200., 51200., 51200., 51200.,</span><br><span class="line">        51200.])</span><br></pre></td></tr></table></figure>
<p><strong>4.重新设计一个求控制流梯度的例子。运行并分析结果。</strong></p>
<p>In [56]:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def h(x):</span><br><span class="line">    y = x * x</span><br><span class="line">    while y.norm() &lt; 2500:</span><br><span class="line">        y = y * 2</span><br><span class="line">    if y.sum() &lt; 0:</span><br><span class="line">        c = 100*y</span><br><span class="line">    else:</span><br><span class="line">        c = y</span><br><span class="line">    return c</span><br><span class="line">x.grad.zero_()</span><br><span class="line">x = torch.randn(size=(),requires_grad=True)</span><br><span class="line">y = h(x)</span><br><span class="line">y.backward()</span><br><span class="line">x.grad</span><br></pre></td></tr></table></figure>
<p>Out[56]:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tensor(-3311.5398)</span><br></pre></td></tr></table></figure>
<p><strong>5.使f(x)=sin(x)，绘制f(x)和df(x)/dx的图像，其中后者不使用f’(x)=\cos(x)。</strong></p>
<p>In [66]:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">x = torch.arange(-20,20,0.1,requires_grad=True,dtype=torch.float32)</span><br><span class="line">y = torch.sin(x)</span><br><span class="line">y.sum().backward()</span><br><span class="line">plt.plot(x.detach(),y.detach(),label=&#x27;y=sinx&#x27;)</span><br><span class="line">plt.plot(x.detach(),x.grad,label=&#x27;dy/dx&#x27;)</span><br><span class="line">plt.legend(loc=&#x27;lower right&#x27;)</span><br></pre></td></tr></table></figure>
<p>Out[66]:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;matplotlib.legend.Legend at 0x1d627d00280&gt;</span><br></pre></td></tr></table></figure>
<img src="/2024/04/23/11-01-07/image-14.png" class>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>06-矩阵计算</title>
    <url>/2024/04/23/11-01-06/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.04.24：初稿</li>
</ul>
<h2 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h2><ul>
<li><a href="/2024/04/24/12-18-34/" title="动手学深度学习笔记汇总">动手学深度学习笔记汇总</a>
</li>
</ul>
<h2 id="06-矩阵计算"><a href="#06-矩阵计算" class="headerlink" title="06-矩阵计算"></a>06-矩阵计算</h2><h3 id="1-导数的概念及几何意义"><a href="#1-导数的概念及几何意义" class="headerlink" title="1. 导数的概念及几何意义"></a>1. 导数的概念及几何意义</h3><h4 id="1-1-标量导数"><a href="#1-1-标量导数" class="headerlink" title="1.1 标量导数"></a>1.1 标量导数</h4><ul>
<li>导数是切线的斜率</li>
</ul>
<img src="/2024/04/23/11-01-06/06-01.png" class>
<ul>
<li>指向值变化最大的方向</li>
</ul>
<img src="/2024/04/23/11-01-06/06-02.png" class>
<h4 id="1-2-亚导数"><a href="#1-2-亚导数" class="headerlink" title="1.2 亚导数"></a>1.2 亚导数</h4><ul>
<li>将导数拓展到不可微的函数，在不可导的点的导数可以用一个范围内的数表示</li>
</ul>
<img src="/2024/04/23/11-01-06/06-03.png" class>
<h3 id="2-函数与标量，向量，矩阵"><a href="#2-函数与标量，向量，矩阵" class="headerlink" title="2. 函数与标量，向量，矩阵"></a>2. 函数与标量，向量，矩阵</h3><p>该部分结合课程视频和参考文章进行总结（参考了知乎文章：<a href="https://zhuanlan.zhihu.com/p/263777564">矩阵求导的本质与分子布局、分母布局的本质（矩阵求导——本质篇） - 知乎 (zhihu.com)</a>）</p>
<ul>
<li>当f，input为不同形式时，f(input)结果的表达形式</li>
</ul>
<h4 id="2-1-f-为是一个标量"><a href="#2-1-f-为是一个标量" class="headerlink" title="2.1 f 为是一个标量"></a>2.1 f 为是一个标量</h4><h5 id="2-1-1-input是一个标量"><a href="#2-1-1-input是一个标量" class="headerlink" title="2.1.1 input是一个标量"></a>2.1.1 input是一个标量</h5><img src="/2024/04/23/11-01-06/06-04.png" class>
<h5 id="2-1-2-input是一个向量"><a href="#2-1-2-input是一个向量" class="headerlink" title="2.1.2 input是一个向量"></a>2.1.2 input是一个向量</h5><img src="/2024/04/23/11-01-06/06-05.png" class>
<img src="/2024/04/23/11-01-06/06-06.png" class>
<h5 id="2-1-3-input是一个矩阵"><a href="#2-1-3-input是一个矩阵" class="headerlink" title="2.1.3 input是一个矩阵"></a>2.1.3 input是一个矩阵</h5><img src="/2024/04/23/11-01-06/06-07.png" class>
<img src="/2024/04/23/11-01-06/06-08.png" class>
<h4 id="2-2-f是一个向量"><a href="#2-2-f是一个向量" class="headerlink" title="2.2 f是一个向量"></a>2.2 f是一个向量</h4><ul>
<li><strong>f</strong>是由若干个f(标量)组成的向量</li>
</ul>
<h5 id="2-2-1-input是一个标量"><a href="#2-2-1-input是一个标量" class="headerlink" title="2.2.1 input是一个标量"></a>2.2.1 input是一个标量</h5><img src="/2024/04/23/11-01-06/06-09.png" class>
<h5 id="2-2-2-input是一个向量"><a href="#2-2-2-input是一个向量" class="headerlink" title="2.2.2 input是一个向量"></a>2.2.2 input是一个向量</h5><img src="/2024/04/23/11-01-06/06-10.png" class>
<img src="/2024/04/23/11-01-06/06-11.png" class>
<h5 id="2-2-3-input是一个矩阵"><a href="#2-2-3-input是一个矩阵" class="headerlink" title="2.2.3 input是一个矩阵"></a>2.2.3 input是一个矩阵</h5><img src="/2024/04/23/11-01-06/06-12.png" class>
<img src="/2024/04/23/11-01-06/06-13.png" class>
<h4 id="2-3-F是一个矩阵"><a href="#2-3-F是一个矩阵" class="headerlink" title="2.3 F是一个矩阵"></a>2.3 F是一个矩阵</h4><ul>
<li><strong>F</strong>是一个由若干<strong>f</strong>组成的一个矩阵</li>
</ul>
<h5 id="2-3-1-input是一个标量"><a href="#2-3-1-input是一个标量" class="headerlink" title="2.3.1 input是一个标量"></a>2.3.1 input是一个标量</h5><img src="/2024/04/23/11-01-06/06-14.png" class>
<h5 id="2-3-2-input是一个向量"><a href="#2-3-2-input是一个向量" class="headerlink" title="2.3.2 input是一个向量"></a>2.3.2 input是一个向量</h5><img src="/2024/04/23/11-01-06/06-15.png" class>
<img src="/2024/04/23/11-01-06/06-16.png" class>
<h5 id="2-3-3-input是一个向量"><a href="#2-3-3-input是一个向量" class="headerlink" title="2.3.3 input是一个向量"></a>2.3.3 input是一个向量</h5><img src="/2024/04/23/11-01-06/06-17.png" class>
<img src="/2024/04/23/11-01-06/06-18.png" class>
<h3 id="3-求导的本质"><a href="#3-求导的本质" class="headerlink" title="3. 求导的本质"></a>3. 求导的本质</h3><img src="/2024/04/23/11-01-06/06-19.png" class>
<p><strong>可以将f对x1，x2，x3的偏导分别求出来，即</strong></p>
<img src="/2024/04/23/11-01-06/06-20.png" class>
<ul>
<li>矩阵求导也是一样的，<strong>本质就是</strong> $function$ 中的<strong>每个</strong>$f$ <strong>分别对变元中的每个元素逐个求偏导，只不过写成了向量、矩阵形式而已。</strong></li>
</ul>
<img src="/2024/04/23/11-01-06/06-21.png" class>
<p>（课上是按行向量展开的）</p>
<img src="/2024/04/23/11-01-06/06-22.png" class>
<p><strong>X为矩阵时</strong>，先把矩阵变元$X$进行<strong>转置</strong>，再对<strong>转置后</strong>的<strong>每个位置</strong>的元素逐个求偏导，结果布局和<strong>转置布局一样</strong>。（课上讲的是这种展开方式）</p>
<img src="/2024/04/23/11-01-06/06-23.png" class>
<ul>
<li>所以，如果 $function$中有 $m$个$f$ (标量)，变元中有 $n$个元素，那么，每个 $f$对变元中的每个元素逐个求偏导后，我们就会产生 $m*n$个结果。</li>
</ul>
<h3 id="4-矩阵求导的布局"><a href="#4-矩阵求导的布局" class="headerlink" title="4. 矩阵求导的布局"></a>4. 矩阵求导的布局</h3><ul>
<li>经过上述对求导本质的推导，关于矩阵求导的问题，实质上就是对求导结果的进一步排布问题<br><strong>对于2.2（f为向量，input也为向量）中的情况，其求导结果有两种排布方式，一种是<code>分子布局</code>，一种是<code>分母布局</code></strong></li>
</ul>
<h5 id="4-1-分子布局"><a href="#4-1-分子布局" class="headerlink" title="4.1 分子布局"></a>4.1 分子布局</h5><p><strong>分子布局</strong>，就是分子是<strong>列向量</strong>形式，分母是<strong>行向量</strong>形式 （课上讲的）</p>
<img src="/2024/04/23/11-01-06/06-24.png" class>
<h5 id="4-2-分母布局"><a href="#4-2-分母布局" class="headerlink" title="4.2 分母布局"></a>4.2 分母布局</h5><p>2.<strong>分母布局</strong>，就是分母是<strong>列向量</strong>形式，分子是<strong>行向量</strong>形式</p>
<img src="/2024/04/23/11-01-06/06-25.png" class>
<p><strong>将求导推广到矩阵，由于矩阵可以看作由多个向量所组成，因此对矩阵的求导可以看作先对每个向量进行求导，然后再增加一个维度存放求导结果。</strong></p>
<ul>
<li>例如当F为矩阵，input为矩阵时，F中的每个元素f(标量）求导后均为一个矩阵（按照课上的展开方式），因此每个<strong>f</strong>（包含多个f（标量））求导后为存放多个矩阵的三维形状，再由于矩阵F由多个<strong>f</strong>组成，因此F求导后为存放多个<strong>f</strong>求导结果的四维形状。<br><strong>对于不同f和input求导后的维度情况总结如下图所示（课程中的截图）</strong></li>
</ul>
<img src="/2024/04/23/11-01-06/06-26.png" class>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>05-线性代数</title>
    <url>/2024/04/23/11-01-05/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.04.24：初稿</li>
</ul>
<h2 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h2><ul>
<li><a href="/2024/04/24/12-18-34/" title="动手学深度学习笔记汇总">动手学深度学习笔记汇总</a>
</li>
</ul>
<h2 id="05-线性代数"><a href="#05-线性代数" class="headerlink" title="05-线性代数"></a>05-线性代数</h2><h3 id="1-线性代数基础知识"><a href="#1-线性代数基础知识" class="headerlink" title="1. 线性代数基础知识"></a>1. 线性代数基础知识</h3><p>这部分主要是由标量过渡到向量，再从向量拓展到矩阵操作，重点在于理解矩阵层面上的操作</p>
<h4 id="1-1-标量"><a href="#1-1-标量" class="headerlink" title="1.1 标量"></a>1.1 标量</h4><img src="/2024/04/23/11-01-05/05-01.png" class>
<h4 id="1-2-向量"><a href="#1-2-向量" class="headerlink" title="1.2 向量"></a>1.2 向量</h4><img src="/2024/04/23/11-01-05/05-02.png" class>
<img src="/2024/04/23/11-01-05/05-03.png" class>
<h4 id="1-3-矩阵"><a href="#1-3-矩阵" class="headerlink" title="1.3 矩阵"></a>1.3 矩阵</h4><h5 id="1-3-1-矩阵的操作"><a href="#1-3-1-矩阵的操作" class="headerlink" title="1.3.1 矩阵的操作"></a>1.3.1 矩阵的操作</h5><img src="/2024/04/23/11-01-05/05-04.png" class>
<img src="/2024/04/23/11-01-05/05-05.png" class>
<img src="/2024/04/23/11-01-05/05-06.png" class>
<img src="/2024/04/23/11-01-05/05-07.png" class>
<p>​    (矩阵范数麻烦且不常用，一般用F范数)</p>
<h5 id="1-3-2-特殊矩阵"><a href="#1-3-2-特殊矩阵" class="headerlink" title="1.3.2 特殊矩阵"></a>1.3.2 特殊矩阵</h5><img src="/2024/04/23/11-01-05/05-08.png" class>
<img src="/2024/04/23/11-01-05/05-09.png" class>
<img src="/2024/04/23/11-01-05/05-10.png" class>
<p>​    (深度学习里基本不会涉及到正定、置换矩阵，这里明确个概念就行)</p>
<h5 id="1-3-3-特征向量和特征值"><a href="#1-3-3-特征向量和特征值" class="headerlink" title="1.3.3 特征向量和特征值"></a>1.3.3 特征向量和特征值</h5><ul>
<li><p>数学定义：设A是n阶方阵，如果存在常数<img src="https://images0.cnblogs.com/blog/650633/201407/141700142243782.png" alt="img">及非零n向量x，使得<img src="https://images0.cnblogs.com/blog/650633/201407/141700145536982.png" alt="img">，则称<img src="https://images0.cnblogs.com/blog/650633/201407/141700149439396.png" alt="img">是矩阵A的特征值，x是A属于特征值<img src="https://images0.cnblogs.com/blog/650633/201407/141700153035353.png" alt="img">的特征向量</p>
</li>
<li><p>直观理解：不被矩阵A改变方向的向量x就是A的一个特征向量</p>
<img src="/2024/04/23/11-01-05/05-11.png" class>
</li>
<li><p>矩阵不一定有特征向量，但是对称矩阵总是可以找到特征向量</p>
</li>
</ul>
<h3 id="2-线性代数实现"><a href="#2-线性代数实现" class="headerlink" title="2. 线性代数实现"></a>2. 线性代数实现</h3><p>这部分主要是应用pytorch实现基本矩阵操作，同样由标量过渡到向量最后拓展到矩阵</p>
<h4 id="2-1-标量"><a href="#2-1-标量" class="headerlink" title="2.1 标量"></a>2.1 标量</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch    <span class="comment"># 应用pytorch框架</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 标量由只有一个元素的张量表示</span></span><br><span class="line">x = torch.tensor([<span class="number">3.0</span>])     <span class="comment"># 单独一个数字表示标量也可以</span></span><br><span class="line">y = torch.tensor([<span class="number">2.0</span>])     <span class="comment"># 单独一个数字表示标量也可以</span></span><br><span class="line"><span class="built_in">print</span>(x + y)    <span class="comment"># tensor([5.])</span></span><br><span class="line"><span class="built_in">print</span>(x * y)    <span class="comment"># tensor([6.])</span></span><br><span class="line"><span class="built_in">print</span>(x / y)    <span class="comment"># tensor([1.5000])</span></span><br><span class="line"><span class="built_in">print</span>(x ** y)   <span class="comment"># tensor([9.]) 指数运算</span></span><br></pre></td></tr></table></figure>
<h4 id="2-2-向量"><a href="#2-2-向量" class="headerlink" title="2.2 向量"></a>2.2 向量</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 向量可以看作是若干标量值组成的列表</span></span><br><span class="line">x = torch.arange(<span class="number">4</span>)     <span class="comment"># tensor([0, 1, 2, 3])</span></span><br><span class="line">                        <span class="comment"># 生成[0, 4)范围内所有整数构成的张量tensor</span></span><br><span class="line"><span class="built_in">print</span>(x[<span class="number">3</span>])             <span class="comment"># tensor(3)</span></span><br><span class="line">                        <span class="comment"># 和列表相似，通过张量的索引访问元素</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(x))           <span class="comment"># 4</span></span><br><span class="line">                        <span class="comment"># 获取张量x的长度</span></span><br><span class="line"><span class="built_in">print</span>(x.shape)          <span class="comment"># torch.Size([4])</span></span><br><span class="line">                        <span class="comment"># 获取张量形状，这里x是只有一个轴的张量因此形状只有一个元素</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="2-3-矩阵"><a href="#2-3-矩阵" class="headerlink" title="2.3 矩阵"></a>2.3 矩阵</h4><h5 id="2-3-1-创建"><a href="#2-3-1-创建" class="headerlink" title="2.3.1 创建"></a>2.3.1 创建</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = torch.arange(<span class="number">6</span>)     <span class="comment"># tensor([0, 1, 2, 3, 4, 5])</span></span><br><span class="line">B = torch.tensor([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">0</span>,<span class="number">4</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]])</span><br><span class="line">C = torch.tensor([[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">                   [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],</span><br><span class="line">                   [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]],</span><br><span class="line">                  [[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">                   [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">                   [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]]])</span><br><span class="line">D = torch.arange(<span class="number">20</span>, dtype=torch.float32)</span><br></pre></td></tr></table></figure>
<h5 id="2-3-2-转置"><a href="#2-3-2-转置" class="headerlink" title="2.3.2 转置"></a>2.3.2 转置</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = torch.arange(<span class="number">6</span>)     <span class="comment"># tensor([0, 1, 2, 3, 4, 5])</span></span><br><span class="line">A = A.reshape(<span class="number">3</span>,<span class="number">2</span>)      <span class="comment"># tensor([[0, 1],</span></span><br><span class="line">                        <span class="comment">#         [2, 3],</span></span><br><span class="line">                        <span class="comment">#         [4, 5]])</span></span><br><span class="line"></span><br><span class="line">A = A.T                 <span class="comment"># 转置 A.T</span></span><br><span class="line">                        <span class="comment"># tensor([[0, 2, 4],</span></span><br><span class="line">                        <span class="comment">#         [1, 3, 5]])</span></span><br></pre></td></tr></table></figure>
<h5 id="2-3-3-reshape"><a href="#2-3-3-reshape" class="headerlink" title="2.3.3 reshape"></a>2.3.3 reshape</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用reshape方法创建一个形状为3 x 2的矩阵A</span></span><br><span class="line">A = torch.arange(<span class="number">6</span>)     <span class="comment"># tensor([0, 1, 2, 3, 4, 5])</span></span><br><span class="line">A = A.reshape(<span class="number">3</span>,<span class="number">2</span>)      <span class="comment"># tensor([[0, 1],</span></span><br><span class="line">                        <span class="comment">#         [2, 3],</span></span><br><span class="line">                        <span class="comment">#         [4, 5]])</span></span><br></pre></td></tr></table></figure>
<p>tips(确定矩阵shape)：</p>
<p>由外层到内层依次去中括号，并记下去掉中括号后此时元素的个数，任选其中一个元素重复上述去括号的操作直到该元素中无中括号，记下的数字从左到右依次排序中间用x连接即为矩阵shape</p>
<h5 id="2-3-4-clone"><a href="#2-3-4-clone" class="headerlink" title="2.3.4 clone"></a>2.3.4 clone</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = torch.arange(<span class="number">20</span>, dtype=torch.float32)</span><br><span class="line">A = A.reshape(<span class="number">5</span>,<span class="number">4</span>)</span><br><span class="line">B = A.clone()   <span class="comment"># 通过分配新内存，将A的一个副本分给B，该边B并不影响A的值</span></span><br><span class="line"><span class="built_in">print</span>(B)        <span class="comment"># tensor([[ 0.,  1.,  2.,  3.],</span></span><br><span class="line">                <span class="comment">#         [ 4.,  5.,  6.,  7.],</span></span><br><span class="line">                <span class="comment">#         [ 8.,  9., 10., 11.],</span></span><br><span class="line">                <span class="comment">#         [12., 13., 14., 15.],</span></span><br><span class="line">                <span class="comment">#         [16., 17., 18., 19.]])</span></span><br></pre></td></tr></table></figure>
<h5 id="2-3-5-sum"><a href="#2-3-5-sum" class="headerlink" title="2.3.5 sum"></a>2.3.5 sum</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = torch.tensor([[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">                   [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],</span><br><span class="line">                   [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]],</span><br><span class="line">                  [[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">                   [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">                   [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]]])</span><br><span class="line"><span class="built_in">print</span>(A.shape)</span><br><span class="line"><span class="comment"># torch.Size([2, 3, 3])</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(A.<span class="built_in">sum</span>())</span><br><span class="line"><span class="comment"># tensor(54)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(A.<span class="built_in">sum</span>(axis=<span class="number">0</span>))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([[ 1,  2,  3],</span></span><br><span class="line"><span class="string">        [ 5,  6,  7],</span></span><br><span class="line"><span class="string">        [ 9, 10, 11]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(A.<span class="built_in">sum</span>(axis=<span class="number">0</span>, keepdims=<span class="literal">True</span>))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([[[ 1,  2,  3],</span></span><br><span class="line"><span class="string">         [ 5,  6,  7],</span></span><br><span class="line"><span class="string">         [ 9, 10, 11]]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(A.<span class="built_in">sum</span>(axis=<span class="number">1</span>))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([[12, 15, 18],</span></span><br><span class="line"><span class="string">        [ 3,  3,  3]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(A.<span class="built_in">sum</span>(axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([[[12, 15, 18]],</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        [[ 3,  3,  3]]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(A.<span class="built_in">sum</span>(axis=<span class="number">2</span>))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([[ 6, 15, 24],</span></span><br><span class="line"><span class="string">        [ 0,  3,  6]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(A.<span class="built_in">sum</span>(axis=<span class="number">2</span>, keepdims=<span class="literal">True</span>))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([[[ 6],</span></span><br><span class="line"><span class="string">         [15],</span></span><br><span class="line"><span class="string">         [24]],</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        [[ 0],</span></span><br><span class="line"><span class="string">         [ 3],</span></span><br><span class="line"><span class="string">         [ 6]]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(A.<span class="built_in">sum</span>(axis=[<span class="number">0</span>,<span class="number">1</span>]))</span><br><span class="line"><span class="comment"># tensor([15, 18, 21])</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(A.<span class="built_in">sum</span>(axis=[<span class="number">0</span>,<span class="number">1</span>], keepdims=<span class="literal">True</span>))</span><br><span class="line"><span class="comment"># tensor([[[15, 18, 21]]])</span></span><br></pre></td></tr></table></figure>
<h5 id="2-3-6-numel"><a href="#2-3-6-numel" class="headerlink" title="2.3.6 numel"></a>2.3.6 numel</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = torch.tensor([[<span class="number">0.</span>,<span class="number">0.</span>,<span class="number">0.</span>],[<span class="number">1.</span>,<span class="number">1.</span>,<span class="number">1.</span>]])</span><br><span class="line"><span class="built_in">print</span>(A.numel())    <span class="comment"># 6 元素个数</span></span><br></pre></td></tr></table></figure>
<h5 id="2-3-7-mean"><a href="#2-3-7-mean" class="headerlink" title="2.3.7 mean"></a>2.3.7 mean</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = torch.tensor([[<span class="number">0.</span>,<span class="number">0.</span>,<span class="number">0.</span>],[<span class="number">1.</span>,<span class="number">1.</span>,<span class="number">1.</span>]])</span><br><span class="line"><span class="built_in">print</span>(A.numel())    <span class="comment"># 6 元素个数</span></span><br><span class="line"><span class="built_in">print</span>(A.<span class="built_in">sum</span>())      <span class="comment"># tensor(3.)</span></span><br><span class="line"><span class="built_in">print</span>(A.mean())     <span class="comment"># tensor(0.5000)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 特定轴</span></span><br><span class="line">A = torch.tensor([[<span class="number">0.</span>,<span class="number">0.</span>,<span class="number">0.</span>],[<span class="number">1.</span>,<span class="number">1.</span>,<span class="number">1.</span>]])</span><br><span class="line"><span class="built_in">print</span>(A.shape[<span class="number">0</span>])       <span class="comment"># 2</span></span><br><span class="line"><span class="built_in">print</span>(A.<span class="built_in">sum</span>(axis=<span class="number">0</span>))    <span class="comment"># tensor([1., 1., 1.])</span></span><br><span class="line"><span class="built_in">print</span>(A.mean(axis=<span class="number">0</span>))   <span class="comment"># tensor([0.5000, 0.5000, 0.5000])	平均值</span></span><br></pre></td></tr></table></figure>
<h5 id="2-3-8-dot"><a href="#2-3-8-dot" class="headerlink" title="2.3.8 dot"></a>2.3.8 dot</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.tensor([<span class="number">0.</span>,<span class="number">1.</span>,<span class="number">2.</span>,<span class="number">3.</span>])</span><br><span class="line">y = torch.tensor([<span class="number">1.</span>,<span class="number">1.</span>,<span class="number">1.</span>,<span class="number">1.</span>])</span><br><span class="line"><span class="built_in">print</span>(torch.dot(x, y))  <span class="comment"># tensor(6.)</span></span><br></pre></td></tr></table></figure>
<h5 id="2-3-9-mm、mv"><a href="#2-3-9-mm、mv" class="headerlink" title="2.3.9 mm、mv"></a>2.3.9 mm、mv</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = torch.tensor([[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">                  [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]])</span><br><span class="line">B = torch.tensor([[<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">                  [<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">                  [<span class="number">0</span>,<span class="number">0</span>]])</span><br><span class="line">x = torch.tensor([<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(torch.mv(A, x))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">向量积</span></span><br><span class="line"><span class="string">tensor([ 9, 36])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(torch.mm(A, B))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">矩阵积</span></span><br><span class="line"><span class="string">tensor([[ 1,  1],</span></span><br><span class="line"><span class="string">        [10, 10]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h5 id="2-3-10-L1、L2、F范数"><a href="#2-3-10-L1、L2、F范数" class="headerlink" title="2.3.10  L1、L2、F范数"></a>2.3.10  L1、L2、F范数</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.tensor([<span class="number">3.0</span>, -<span class="number">4.0</span>])</span><br><span class="line"><span class="built_in">print</span>(torch.<span class="built_in">abs</span>(x).<span class="built_in">sum</span>())   <span class="comment"># 向量的L1范数: tensor(7.)  x中的每个元素绝对值的和</span></span><br><span class="line"><span class="built_in">print</span>(torch.norm(x))        <span class="comment"># 向量的L2范数: tensor(5.)  x中的每个元素平方的和开根号</span></span><br><span class="line"></span><br><span class="line">A = torch.ones((<span class="number">4</span>, <span class="number">9</span>))</span><br><span class="line"><span class="built_in">print</span>(torch.norm(A))        <span class="comment"># 矩阵的F范数:  tensor(6.)  A中的每个元素平方的和开根号</span></span><br></pre></td></tr></table></figure>
<h5 id="2-3-11-运算"><a href="#2-3-11-运算" class="headerlink" title="2.3.11  运算"></a>2.3.11  运算</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = torch.arange(<span class="number">20</span>, dtype=torch.float32)</span><br><span class="line">A = A.reshape(<span class="number">5</span>,<span class="number">4</span>)</span><br><span class="line">B = A.clone()   </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(B)        <span class="comment"># tensor([[ 0.,  1.,  2.,  3.],</span></span><br><span class="line">                <span class="comment">#         [ 4.,  5.,  6.,  7.],</span></span><br><span class="line">                <span class="comment">#         [ 8.,  9., 10., 11.],</span></span><br><span class="line">                <span class="comment">#         [12., 13., 14., 15.],</span></span><br><span class="line">                <span class="comment">#         [16., 17., 18., 19.]])</span></span><br><span class="line">                </span><br><span class="line"><span class="built_in">print</span>(A == B)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([[True, True, True, True],</span></span><br><span class="line"><span class="string">        [True, True, True, True],</span></span><br><span class="line"><span class="string">        [True, True, True, True],</span></span><br><span class="line"><span class="string">        [True, True, True, True],</span></span><br><span class="line"><span class="string">        [True, True, True, True]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(A + B)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([[ 0.,  2.,  4.,  6.],</span></span><br><span class="line"><span class="string">        [ 8., 10., 12., 14.],</span></span><br><span class="line"><span class="string">        [16., 18., 20., 22.],</span></span><br><span class="line"><span class="string">        [24., 26., 28., 30.],</span></span><br><span class="line"><span class="string">        [32., 34., 36., 38.]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(A * B)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([[  0.,   1.,   4.,   9.],</span></span><br><span class="line"><span class="string">        [ 16.,  25.,  36.,  49.],</span></span><br><span class="line"><span class="string">        [ 64.,  81., 100., 121.],</span></span><br><span class="line"><span class="string">        [144., 169., 196., 225.],</span></span><br><span class="line"><span class="string">        [256., 289., 324., 361.]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h5 id="2-3-12-广播"><a href="#2-3-12-广播" class="headerlink" title="2.3.12 广播"></a>2.3.12 广播</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = torch.tensor([[<span class="number">1.</span>,<span class="number">2.</span>,<span class="number">3.</span>],</span><br><span class="line">                  [<span class="number">4.</span>,<span class="number">5.</span>,<span class="number">6.</span>]])</span><br><span class="line">B = A.<span class="built_in">sum</span>(axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(B)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([[ 6.],</span></span><br><span class="line"><span class="string">        [15.]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(A / B)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([[0.1667, 0.3333, 0.5000],</span></span><br><span class="line"><span class="string">        [0.2667, 0.3333, 0.4000]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(A + B)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([[ 7.,  8.,  9.],</span></span><br><span class="line"><span class="string">        [19., 20., 21.]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(A * B)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([[ 6., 12., 18.],</span></span><br><span class="line"><span class="string">        [60., 75., 90.]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>04-数据读取和操作</title>
    <url>/2024/04/23/11-01-04/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.04.24：初稿</li>
</ul>
<h2 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h2><ul>
<li><a href="/2024/04/24/12-18-34/" title="动手学深度学习笔记汇总">动手学深度学习笔记汇总</a>
</li>
</ul>
<h2 id="04-数据读取和操作"><a href="#04-数据读取和操作" class="headerlink" title="04-数据读取和操作"></a>04-数据读取和操作</h2><h3 id="1-数据操作"><a href="#1-数据操作" class="headerlink" title="1. 数据操作"></a>1. 数据操作</h3><p>为了能够完成各种数据操作，我们需要某种方法来存储和操作数据。通常，我们需要做两件重要的事：</p>
<ol>
<li>获取数据；</li>
<li>将数据读入计算机后对其进行处理。</li>
</ol>
<p>如果没有某种方法来存储数据，那么获取数据是没有意义的。</p>
<p>首先，我们介绍 n 维数组，也称为<strong>张量</strong>（tensor）。PyTorch的<strong>张量类</strong>与Numpy的<code>ndarray</code>类似。但在深度学习框架中应用PyTorch的<strong>张量类</strong>，又比Numpy的<code>ndarray</code>多一些重要功能：</p>
<ol>
<li>tensor可以在很好地支持GPU加速计算，而NumPy仅支持CPU计算；</li>
<li>tensor支持自动微分。</li>
</ol>
<p>这些功能使得张量类更适合深度学习。</p>
<h4 id="1-1-基本操作"><a href="#1-1-基本操作" class="headerlink" title="1.1 基本操作"></a>1.1 基本操作</h4><p>[<strong>张量表示由一些数值组成的数组，这个数组可能有多个维度</strong>]。具有一个轴的张量对应数学上的<strong>向量</strong>（vector）；具有两个轴的张量对应数学上的<strong>矩阵</strong>（matrix）；具有两个轴以上的张量没有特殊的数学名称。</p>
<p>我们可以使用<code>arange</code>创建一个行向量<code>x</code>。这个行向量包含从0开始的前12个整数，它们被<strong>默认创建为浮点数</strong>。张量中的每个值都称为张量的<strong>元素</strong>（element）。例如，张量<code>x</code>中有12个元素。除非额外指定，新的张量默认将存储在内存中，并采用基于CPU的计算。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = torch.arange(<span class="number">12</span>)</span><br><span class="line">	tensor([ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>])</span><br></pre></td></tr></table></figure>
<p>[<strong>可以通过张量的<code>shape</code>属性来访问张量（沿每个轴的长度）的<em>形状</em></strong>]。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.shape</span><br><span class="line">	torch.Size([<span class="number">12</span>])</span><br></pre></td></tr></table></figure>
<p>如果只想知道张量中元素的总数，即形状的所有元素乘积，可以检查它的大小（size）。</p>
<p>因为这里在处理的是一个向量，所以它的<code>shape</code>与它的<code>size</code>相同。在处理更高维度的的张量时，可以用这种方法获取张量中元素的个数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.numel()</span><br><span class="line">	<span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>[<strong>要想改变一个张量的形状而不改变元素数量和元素值，可以调用<code>reshape</code>函数。</strong>]</p>
<p>例如，可以把张量<code>x</code>从形状为（12,）的行向量转换为形状为（3,4）的矩阵。这个新的张量包含与转换前相同的值，但是它被看成一个3行4列的矩阵。值得注意的是，虽然张量的形状发生了改变，但其元素值并没有变。改变张量的形状时，张量中元素的个数不会改变。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>X = x.reshape(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">	tensor([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">        	[ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">        	[ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br></pre></td></tr></table></figure>
<p>我们不需要通过手动指定每个维度来改变形状。如果我们的目标形状是（高度 x 宽度），那么在知道宽度后，高度会被自动计算得出，不必我们自己做除法。我们可以通过<code>-1</code>来调用此自动计算出维度的功能即可以用<code>x.reshape(-1,4)</code>或<code>x.reshape(3,-1)</code>来取代<code>x.reshape(3,4)</code>。</p>
<p>有时，我们希望[<strong>使用全0、全1、其他常量，或者从特定分布中随机采样的数字</strong>]来初始化矩阵。我们可以创建一个形状为（2,3,4）的张量，其中所有元素都设置为0或者1。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.zeros((<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">	tensor([[[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">         	 [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">         	 [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>]],</span><br><span class="line"></span><br><span class="line">        	[[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">         	 [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">         	 [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>]]])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.ones((<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">	tensor([[[<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">         	 [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">         	 [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>]],</span><br><span class="line"></span><br><span class="line">        	[[<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">         	 [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">         	 [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>]]])</span><br></pre></td></tr></table></figure>
<p>有时我们想通过从某个特定的概率分布中随机采样来得到张量中每个元素的值。例如，当我们构造数组来作为神经网络中的参数时，我们通常会随机初始化参数的值。以下代码创建一个形状为（3,4）的张量。其中的每个元素都从均值为0、标准差为1的标准正态分布中随机采样。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.randn(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">	tensor([[ <span class="number">0.1364</span>,  <span class="number">0.3546</span>, -<span class="number">0.9091</span>, -<span class="number">1.8926</span>],</span><br><span class="line">        	[ <span class="number">0.5786</span>, -<span class="number">0.9019</span>, -<span class="number">0.1305</span>, -<span class="number">0.1899</span>],</span><br><span class="line">        	[ <span class="number">0.5696</span>,  <span class="number">1.1626</span>, -<span class="number">0.5987</span>,  <span class="number">0.4085</span>]])</span><br></pre></td></tr></table></figure>
<p>我们还可以[<strong>通过提供包含数值的Python列表（或嵌套列表），来为所需张量中的每个元素赋予确定值</strong>]。在这里，最外层的列表对应于轴0，内层的列表对应于轴1。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.tensor([[<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]])</span><br><span class="line">	tensor([[<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>],</span><br><span class="line">        	[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">        	[<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]])</span><br></pre></td></tr></table></figure>
<h4 id="1-2-简单运算"><a href="#1-2-简单运算" class="headerlink" title="1.2 简单运算"></a>1.2 简单运算</h4><p>我们想在这些数据上执行数学运算，其中最简单且最有用的操作是<strong>按元素</strong>（elementwise）运算。它们将标准标量运算符应用于数组的每个元素。对于将两个数组作为输入的函数，按元素运算将二元运算符应用于两个数组中的每对位置对应的元素。我们可以基于任何从标量到标量的函数来创建按元素函数。我们通过将标量函数升级为按元素向量运算来生成向量值$F: \mathbb{R}^d, \mathbb{R}^d \rightarrow \mathbb{R}^d$。</p>
<p>对于任意具有相同形状的张量，[<strong>常见的标准算术运算符（<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>和`</strong>`）都可以被升级为按元素运算**]。我们可以在同一形状的任意两个张量上调用按元素操作。我们使用逗号来表示一个具有5个元素的元组，其中每个元素都是按元素操作的结果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = torch.tensor([<span class="number">1.0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = torch.tensor([<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x + y, x - y, x * y, x / y, x ** y</span><br><span class="line">	(tensor([ <span class="number">3.</span>,  <span class="number">4.</span>,  <span class="number">6.</span>, <span class="number">10.</span>]),</span><br><span class="line"> 	 tensor([-<span class="number">1.</span>,  <span class="number">0.</span>,  <span class="number">2.</span>,  <span class="number">6.</span>]),</span><br><span class="line"> 	 tensor([ <span class="number">2.</span>,  <span class="number">4.</span>,  <span class="number">8.</span>, <span class="number">16.</span>]),</span><br><span class="line"> 	 tensor([<span class="number">0.5000</span>, <span class="number">1.0000</span>, <span class="number">2.0000</span>, <span class="number">4.0000</span>]),</span><br><span class="line"> 	 tensor([ <span class="number">1.</span>,  <span class="number">4.</span>, <span class="number">16.</span>, <span class="number">64.</span>]))</span><br></pre></td></tr></table></figure>
<p>(<strong>“按元素”方式可以应用更多的计算</strong>)，包括像求幂这样的一元运算符。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.exp(x)</span><br><span class="line">	tensor([<span class="number">2.7183e+00</span>, <span class="number">7.3891e+00</span>, <span class="number">5.4598e+01</span>, <span class="number">2.9810e+03</span>])</span><br></pre></td></tr></table></figure>
<p>[<strong>我们也可以把多个张量<em>连结</em>（concatenate）在一起</strong>]，把它们端对端地叠起来形成一个更大的张量。我们只需要提供张量列表，并给出沿哪个轴连结。下面的例子分别演示了当我们沿行（轴-0，形状的第一个元素）和按列（轴-1，形状的第二个元素）连结两个矩阵时，会发生什么情况。我们可以看到，第一个输出张量的轴-0长度（$6$）是两个输入张量轴-0长度的总和（$3 + 3$）；第二个输出张量的轴-1长度（$8$）是两个输入张量轴-1长度的总和（$4 + 4$）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>X = torch.arange(<span class="number">12</span>, dtype=torch.float32).reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Y = torch.tensor([[<span class="number">2.0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.cat((X, Y), dim=<span class="number">0</span>), torch.cat((X, Y), dim=<span class="number">1</span>)</span><br><span class="line">	(tensor([[ <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>],</span><br><span class="line">         	 [ <span class="number">4.</span>,  <span class="number">5.</span>,  <span class="number">6.</span>,  <span class="number">7.</span>],</span><br><span class="line">         	 [ <span class="number">8.</span>,  <span class="number">9.</span>, <span class="number">10.</span>, <span class="number">11.</span>],</span><br><span class="line">         	 [ <span class="number">2.</span>,  <span class="number">1.</span>,  <span class="number">4.</span>,  <span class="number">3.</span>],</span><br><span class="line">         	 [ <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>,  <span class="number">4.</span>],</span><br><span class="line">         	 [ <span class="number">4.</span>,  <span class="number">3.</span>,  <span class="number">2.</span>,  <span class="number">1.</span>]]),</span><br><span class="line"> 	 tensor([[ <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>,  <span class="number">2.</span>,  <span class="number">1.</span>,  <span class="number">4.</span>,  <span class="number">3.</span>],</span><br><span class="line">         	 [ <span class="number">4.</span>,  <span class="number">5.</span>,  <span class="number">6.</span>,  <span class="number">7.</span>,  <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>,  <span class="number">4.</span>],</span><br><span class="line">         	 [ <span class="number">8.</span>,  <span class="number">9.</span>, <span class="number">10.</span>, <span class="number">11.</span>,  <span class="number">4.</span>,  <span class="number">3.</span>,  <span class="number">2.</span>,  <span class="number">1.</span>]]))</span><br></pre></td></tr></table></figure>
<p>由上述例子可见，当需要按轴-x连结两个张量时，我们就在第x+1层括号内将两张量中的元素相组合。类似地，我们将两个三维张量相连结。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>X = torch.arange(<span class="number">12</span>, dtype=torch.float32).reshape((<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Y = torch.tensor([[[<span class="number">2.0</span>, <span class="number">1</span>], [<span class="number">4</span>, <span class="number">3</span>]], [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]], [[<span class="number">4</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">1</span>]]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.cat((X, Y), dim=<span class="number">0</span>), torch.cat((X, Y), dim=<span class="number">1</span>), torch.cat((X, Y), dim=<span class="number">2</span>)</span><br><span class="line">	(tensor([[[ <span class="number">0.</span>,  <span class="number">1.</span>],</span><br><span class="line">          	  [ <span class="number">2.</span>,  <span class="number">3.</span>]],</span><br><span class="line"> </span><br><span class="line">         	 [[ <span class="number">4.</span>,  <span class="number">5.</span>],</span><br><span class="line">          	  [ <span class="number">6.</span>,  <span class="number">7.</span>]],</span><br><span class="line"> </span><br><span class="line">         	 [[ <span class="number">8.</span>,  <span class="number">9.</span>],</span><br><span class="line">          	  [<span class="number">10.</span>, <span class="number">11.</span>]],</span><br><span class="line"> </span><br><span class="line">         	 [[ <span class="number">2.</span>,  <span class="number">1.</span>],</span><br><span class="line">          	  [ <span class="number">4.</span>,  <span class="number">3.</span>]],</span><br><span class="line"> </span><br><span class="line">         	 [[ <span class="number">1.</span>,  <span class="number">2.</span>],</span><br><span class="line">          	  [ <span class="number">3.</span>,  <span class="number">4.</span>]],</span><br><span class="line"> </span><br><span class="line">         	 [[ <span class="number">4.</span>,  <span class="number">3.</span>],</span><br><span class="line">          	  [ <span class="number">2.</span>,  <span class="number">1.</span>]]]),</span><br><span class="line"> 	 tensor([[[ <span class="number">0.</span>,  <span class="number">1.</span>],</span><br><span class="line">          	  [ <span class="number">2.</span>,  <span class="number">3.</span>],</span><br><span class="line">          	  [ <span class="number">2.</span>,  <span class="number">1.</span>],</span><br><span class="line">          	  [ <span class="number">4.</span>,  <span class="number">3.</span>]],</span><br><span class="line"> </span><br><span class="line">         	 [[ <span class="number">4.</span>,  <span class="number">5.</span>],</span><br><span class="line">          	  [ <span class="number">6.</span>,  <span class="number">7.</span>],</span><br><span class="line">          	  [ <span class="number">1.</span>,  <span class="number">2.</span>],</span><br><span class="line">          	  [ <span class="number">3.</span>,  <span class="number">4.</span>]],</span><br><span class="line"> </span><br><span class="line">         	 [[ <span class="number">8.</span>,  <span class="number">9.</span>],</span><br><span class="line">         	  [<span class="number">10.</span>, <span class="number">11.</span>],</span><br><span class="line">         	  [ <span class="number">4.</span>,  <span class="number">3.</span>],</span><br><span class="line">          	  [ <span class="number">2.</span>,  <span class="number">1.</span>]]]),</span><br><span class="line"> 	 tensor([[[ <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">1.</span>],</span><br><span class="line">          	  [ <span class="number">2.</span>,  <span class="number">3.</span>,  <span class="number">4.</span>,  <span class="number">3.</span>]],</span><br><span class="line"> </span><br><span class="line">        	 [[ <span class="number">4.</span>,  <span class="number">5.</span>,  <span class="number">1.</span>,  <span class="number">2.</span>],</span><br><span class="line">          	  [ <span class="number">6.</span>,  <span class="number">7.</span>,  <span class="number">3.</span>,  <span class="number">4.</span>]],</span><br><span class="line"> </span><br><span class="line">         	 [[ <span class="number">8.</span>,  <span class="number">9.</span>,  <span class="number">4.</span>,  <span class="number">3.</span>],</span><br><span class="line">         	  [<span class="number">10.</span>, <span class="number">11.</span>,  <span class="number">2.</span>,  <span class="number">1.</span>]]]))</span><br></pre></td></tr></table></figure>
<p>有时，我们想[<strong>通过<em>逻辑运算符</em>构建二元张量</strong>]。 以<code>X == Y</code>为例： 对于每个位置，如果<code>X</code>和<code>Y</code>在该位置相等，则新张量中相应项的值为1。 这意味着逻辑语句<code>X == Y</code>在该位置处为真，否则该位置为0。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>X == Y</span><br><span class="line">	tensor([[<span class="literal">False</span>,  <span class="literal">True</span>, <span class="literal">False</span>,  <span class="literal">True</span>],</span><br><span class="line">        	[<span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>],</span><br><span class="line">            [<span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>]])</span><br></pre></td></tr></table></figure>
<p>[<strong>对张量中的所有元素进行求和，会产生一个单元素张量。</strong>]</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>X.<span class="built_in">sum</span>()</span><br><span class="line">	tensor(<span class="number">66.</span>)</span><br></pre></td></tr></table></figure>
<h4 id="1-3-广播机制"><a href="#1-3-广播机制" class="headerlink" title="1.3 广播机制"></a>1.3 广播机制</h4><p>在上面的部分中，我们看到了如何在相同形状的两个张量上执行按元素操作。在某些情况下，[<strong>即使形状不同，我们仍然可以通过调用<em>广播机制</em>（broadcasting mechanism）来执行按元素操作</strong>]。这种机制的工作条件是：两个张量从后开始数，每个维度相等或者其中一个为1。这种机制的工作方式如下：首先，通过适当复制元素来扩展一个或两个数组，以便在转换之后，两个张量具有相同的形状。其次，对生成的数组执行按元素操作。在大多数情况下，我们将沿着数组中长度为1的轴进行广播，如下例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = torch.arange(<span class="number">3</span>).reshape((<span class="number">3</span>, <span class="number">1</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = torch.arange(<span class="number">2</span>).reshape((<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, a + b</span><br><span class="line">	(tensor([[<span class="number">0</span>],</span><br><span class="line">         	 [<span class="number">1</span>],</span><br><span class="line">         	 [<span class="number">2</span>]]),</span><br><span class="line"> 	 tensor([[<span class="number">0</span>, <span class="number">1</span>]]))</span><br><span class="line"> 	 tensor([[<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">        	 [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">        	 [<span class="number">2</span>, <span class="number">3</span>]])</span><br></pre></td></tr></table></figure>
<p>由于<code>a</code>和<code>b</code>分别是$3\times1$和$1\times2$矩阵，如果让它们相加，它们的形状不匹配。我们将两个矩阵<strong>广播</strong>为一个更大的$3\times2$矩阵，矩阵<code>a</code>复制列，矩阵<code>b</code>复制行，然后再按元素相加。需要注意的是，广播机制只能扩展维度，而不能凭空增加张量的维度，例如在计算沿某个轴的均值时，若张量维度不同，则会报错：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>C = torch.arange(<span class="number">24</span>, dtype=torch.float32).reshape(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C / C.<span class="built_in">sum</span>(axis=<span class="number">1</span>)</span><br><span class="line">	RuntimeError: The size of tensor a (<span class="number">3</span>) must <span class="keyword">match</span> the size of tensor b (<span class="number">2</span>) at non-singleton dimension <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>此时我们需要将<code>keepdims</code>设为True，才能正确利用广播机制扩展<code>C.sum(axis=1)</code>的维度：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>C / C.<span class="built_in">sum</span>(axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line">	tensor([[[<span class="number">0.0000</span>, <span class="number">0.0667</span>, <span class="number">0.1111</span>, <span class="number">0.1429</span>],</span><br><span class="line">         	 [<span class="number">0.3333</span>, <span class="number">0.3333</span>, <span class="number">0.3333</span>, <span class="number">0.3333</span>],</span><br><span class="line">         	 [<span class="number">0.6667</span>, <span class="number">0.6000</span>, <span class="number">0.5556</span>, <span class="number">0.5238</span>]],</span><br><span class="line"></span><br><span class="line">        	[[<span class="number">0.2500</span>, <span class="number">0.2549</span>, <span class="number">0.2593</span>, <span class="number">0.2632</span>],</span><br><span class="line">         	 [<span class="number">0.3333</span>, <span class="number">0.3333</span>, <span class="number">0.3333</span>, <span class="number">0.3333</span>],</span><br><span class="line">         	 [<span class="number">0.4167</span>, <span class="number">0.4118</span>, <span class="number">0.4074</span>, <span class="number">0.4035</span>]]])</span><br></pre></td></tr></table></figure>
<h4 id="1-4-索引和切片"><a href="#1-4-索引和切片" class="headerlink" title="1.4 索引和切片"></a>1.4 索引和切片</h4><p>就像在任何其他Python数组中一样，张量中的元素可以通过索引访问。与任何Python数组一样：第一个元素的索引是0，最后一个元素索引是-1；可以指定范围以包含第一个元素和最后一个之前的元素。如下所示，我们[<strong>可以用<code>[-1]</code>选择最后一个元素，可以用<code>[1:3]</code>选择第二个和第三个元素</strong>]：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>X[-<span class="number">1</span>], X[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">	(tensor([ <span class="number">8.</span>,  <span class="number">9.</span>, <span class="number">10.</span>, <span class="number">11.</span>]),</span><br><span class="line"> 	 tensor([[ <span class="number">4.</span>,  <span class="number">5.</span>,  <span class="number">6.</span>,  <span class="number">7.</span>],</span><br><span class="line">         	 [ <span class="number">8.</span>,  <span class="number">9.</span>, <span class="number">10.</span>, <span class="number">11.</span>]]))</span><br></pre></td></tr></table></figure>
<p>我们[<strong>可以用<code>[::2]</code>每间隔一个元素选择一个元素，可以用<code>[::3]</code>每间隔两个元素选择一个元素</strong>]：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>X[::<span class="number">2</span>, ::<span class="number">3</span>]</span><br><span class="line">	tensor([[ <span class="number">0.</span>,  <span class="number">3.</span>],</span><br><span class="line">          	[ <span class="number">8.</span>, <span class="number">11.</span>]])</span><br></pre></td></tr></table></figure>
<p>[<strong>除读取外，我们还可以通过指定索引来将元素写入矩阵。</strong>]</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>X[<span class="number">1</span>, <span class="number">2</span>] = <span class="number">9</span></span><br><span class="line">	tensor([[ <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>],</span><br><span class="line">        	[ <span class="number">4.</span>,  <span class="number">5.</span>,  <span class="number">9.</span>,  <span class="number">7.</span>],</span><br><span class="line">       	 	[ <span class="number">8.</span>,  <span class="number">9.</span>, <span class="number">10.</span>, <span class="number">11.</span>]])</span><br></pre></td></tr></table></figure>
<p>如果我们想[<strong>为多个元素赋值相同的值，我们只需要索引所有元素，然后为它们赋值。</strong>]例如，<code>[0:2, :]</code>访问第1行和第2行，其中“:”代表沿轴1（列）的所有元素。虽然我们讨论的是矩阵的索引，但这也适用于向量和超过2个维度的张量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>X[<span class="number">0</span>:<span class="number">2</span>, :] = <span class="number">12</span></span><br><span class="line">	tensor([[<span class="number">12.</span>, <span class="number">12.</span>, <span class="number">12.</span>, <span class="number">12.</span>],</span><br><span class="line">        	[<span class="number">12.</span>, <span class="number">12.</span>, <span class="number">12.</span>, <span class="number">12.</span>],</span><br><span class="line">       	 	[ <span class="number">8.</span>,  <span class="number">9.</span>, <span class="number">10.</span>, <span class="number">11.</span>]])</span><br></pre></td></tr></table></figure>
<h4 id="1-5-节约内存"><a href="#1-5-节约内存" class="headerlink" title="1.5 节约内存"></a>1.5 节约内存</h4><p>[<strong>如果在后续计算中没有重复使用<code>X</code>，我们也可以使用<code>X[:] = X + Y</code>或<code>X += Y</code>来减少操作的内存开销。</strong>]</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>before = <span class="built_in">id</span>(X)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X += Y</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(X) == before</span><br><span class="line">	<span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h4 id="1-6-转换为其他Python对象"><a href="#1-6-转换为其他Python对象" class="headerlink" title="1.6 转换为其他Python对象"></a>1.6 转换为其他Python对象</h4><p>将深度学习框架定义的张量[<strong>转换为NumPy张量（<code>ndarray</code>）</strong>]很容易，反之也同样容易。torch张量和numpy数组将共享它们的底层内存，就地操作更改一个张量也会同时更改另一个张量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>A = X.numpy()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>B = torch.tensor(A)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(A), <span class="built_in">type</span>(B)</span><br><span class="line">	(numpy.ndarray, torch.Tensor)</span><br></pre></td></tr></table></figure>
<p>要(<strong>将大小为1的张量转换为Python标量</strong>)，我们可以调用<code>item</code>函数或Python的内置函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = torch.tensor([<span class="number">3.5</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, a.item(), <span class="built_in">float</span>(a), <span class="built_in">int</span>(a)</span><br><span class="line">	(tensor([<span class="number">3.5000</span>]), <span class="number">3.5</span>, <span class="number">3.5</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<h3 id="2-数据预处理"><a href="#2-数据预处理" class="headerlink" title="2. 数据预处理"></a>2. 数据预处理</h3><p>为了能用深度学习来解决现实世界的问题，我们经常从预处理原始数据开始，而不是从那些准备好的张量格式数据开始。在Python中常用的数据分析工具中，我们通常使用<code>pandas</code>软件包。像庞大的Python生态系统中的许多其他扩展包一样，<code>pandas</code>可以与张量兼容。本节我们将简要介绍使用<code>pandas</code>预处理原始数据，并将原始数据转换为张量格式的步骤。</p>
<h4 id="2-1-读取数据集"><a href="#2-1-读取数据集" class="headerlink" title="2.1 读取数据集"></a>2.1 读取数据集</h4><p>举一个例子，我们首先(<strong>创建一个人工数据集，并存储在CSV（逗号分隔值）文件</strong>)<code>../data/house_tiny.csv</code>中。以其他格式存储的数据也可以通过类似的方式进行处理。下面我们将数据集按行写入CSV文件中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.makedirs(os.path.join(<span class="string">&#x27;..&#x27;</span>, <span class="string">&#x27;data&#x27;</span>), exist_ok=<span class="literal">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data_file = os.path.join(<span class="string">&#x27;..&#x27;</span>, <span class="string">&#x27;data&#x27;</span>, <span class="string">&#x27;house_tiny.csv&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> <span class="built_in">open</span>(data_file, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>    f.write(<span class="string">&#x27;NumRooms,Alley,Price\n&#x27;</span>)  <span class="comment"># 列名</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>    f.write(<span class="string">&#x27;NA,Pave,127500\n&#x27;</span>)  <span class="comment"># 每行表示一个数据样本</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>    f.write(<span class="string">&#x27;2,NA,106000\n&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>    f.write(<span class="string">&#x27;4,NA,178100\n&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>    f.write(<span class="string">&#x27;NA,NA,140000\n&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>要[<strong>从创建的CSV文件中加载原始数据集</strong>]，我们导入<code>pandas</code>包并调用<code>read_csv</code>函数。该数据集有四行三列。其中每行描述了房间数量（“NumRooms”）、巷子类型（“Alley”）和房屋价格（“Price”）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data = pd.read_csv(data_file)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(data)</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">NumRooms</th>
<th style="text-align:center">Alley</th>
<th style="text-align:center">Price</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">NaN</td>
<td style="text-align:center">Pave</td>
<td style="text-align:center">127500</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">2.0</td>
<td style="text-align:center">NaN</td>
<td style="text-align:center">106000</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">4.0</td>
<td style="text-align:center">NaN</td>
<td style="text-align:center">178100</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">NaN</td>
<td style="text-align:center">NaN</td>
<td style="text-align:center">140000</td>
</tr>
</tbody>
</table>
</div>
<h4 id="2-2-处理缺失值"><a href="#2-2-处理缺失值" class="headerlink" title="2.2 处理缺失值"></a>2.2 处理缺失值</h4><p>“NaN”项代表缺失值。[<strong>为了处理缺失的数据，典型的方法包括<em>插值法</em>和<em>删除法</em>，</strong>]其中插值法用一个替代值弥补缺失值，而删除法则直接忽略缺失值。通过位置索引<code>iloc</code>，我们将<code>data</code>分成<code>inputs</code>和<code>outputs</code>，其中前者为<code>data</code>的前两列，而后者为<code>data</code>的最后一列。对于<code>inputs</code>中缺少的数值，我们用同一列的均值替换“NaN”项。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>inputs, outputs = data.iloc[:, <span class="number">0</span>:<span class="number">2</span>], data.iloc[:, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>inputs = inputs.fillna(inputs.mean(numeric_only=<span class="literal">True</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(inputs)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>numeric_only=True,处理运行bug</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">NumRooms</th>
<th style="text-align:center">Alley</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">3.0</td>
<td style="text-align:center">Pave</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">2.0</td>
<td style="text-align:center">NaN</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">4.0</td>
<td style="text-align:center">NaN</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">3.0</td>
<td style="text-align:center">NaN</td>
</tr>
</tbody>
</table>
</div>
<p>利用删除法，我们删除缺失元素最多的一个样本。首先，<code>data.isnull()</code>矩阵统计每个元素是否缺失，之后在轴-1的方向上将<code>data.isnull()</code>元素求和，得到每个样本缺失元素个数，取得缺失元素个数最大的样本的序号，并将其删除。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>nan_numer = data.isnull().<span class="built_in">sum</span>(axis=<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nan_max_id = nan_numer.idxmax()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data_delete = data.drop([nan_max_id], axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">NumRooms</th>
<th style="text-align:center">Alley</th>
<th style="text-align:center">Price</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">NaN</td>
<td style="text-align:center">Pave</td>
<td style="text-align:center">127500</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">2.0</td>
<td style="text-align:center">NaN</td>
<td style="text-align:center">106000</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">4.0</td>
<td style="text-align:center">NaN</td>
<td style="text-align:center">178100</td>
</tr>
</tbody>
</table>
</div>
<p>一般情况下，利用<code>dropna</code>删除数据，其中•Axis哪个维度How如何删除，‘any’表示有nan即删除，‘all’表示全为nan删除，Thresh有多少个nan删除，Subset在哪些列中查找nan，Inplace是否原地修改。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dropna( axis=<span class="number">0</span>, how=‘<span class="built_in">any</span>’, thresh=<span class="literal">None</span>, subset=<span class="literal">None</span>, inplace=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<p>[<strong>对于<code>inputs</code>中的类别值或离散值，我们将“NaN”视为一个类别。</strong>]由于“巷子类型”（“Alley”）列只接受两种类型的类别值“Pave”和“NaN”，<code>pandas</code>可以自动将此列转换为两列“Alley_Pave”和“Alley_nan”。巷子类型为“Pave”的行会将“Alley_Pave”的值设置为1，“Alley_nan”的值设置为0。缺少巷子类型的行会将“Alley_Pave”和“Alley_nan”分别设置为0和1。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>inputs = pd.get_dummies(inputs, dummy_na=<span class="literal">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(inputs)</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">NumRooms</th>
<th style="text-align:center">Alley_Pave</th>
<th style="text-align:center">Alley_nan</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">3.0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">2.0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">4.0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">3.0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
</div>
<h4 id="2-3-转换为张量格式"><a href="#2-3-转换为张量格式" class="headerlink" title="2.3 转换为张量格式"></a>2.3 转换为张量格式</h4><p>[<strong>现在<code>inputs</code>和<code>outputs</code>中的所有条目都是数值类型，它们可以转换为张量格式。</strong>]</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> torch</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X, y = torch.tensor(inputs.values), torch.tensor(outputs.values)</span><br><span class="line">	(tensor([[<span class="number">3.</span>, <span class="number">1.</span>, <span class="number">0.</span>],</span><br><span class="line">         	 [<span class="number">2.</span>, <span class="number">0.</span>, <span class="number">1.</span>],</span><br><span class="line">         	 [<span class="number">4.</span>, <span class="number">0.</span>, <span class="number">1.</span>],</span><br><span class="line">         	 [<span class="number">3.</span>, <span class="number">0.</span>, <span class="number">1.</span>]], dtype=torch.float64),</span><br><span class="line"> 	 tensor([<span class="number">127500</span>, <span class="number">106000</span>, <span class="number">178100</span>, <span class="number">140000</span>]))</span><br></pre></td></tr></table></figure>
<h3 id="3-Q-amp-A"><a href="#3-Q-amp-A" class="headerlink" title="3. Q&amp;A"></a>3. Q&amp;A</h3><p><strong><code>Q1：reshape和view的区别？</code></strong></p>
<blockquote>
<p>View为浅拷贝，只能作用于连续型张量；Contiguous函数将张量做深拷贝并转为连续型；Reshape在张量连续时和view相同，不连续时等价于先contiguous再view。</p>
</blockquote>
<p><strong><code>Q2：数组计算吃力怎么办？</code></strong></p>
<blockquote>
<p>学习numpy的知识。</p>
</blockquote>
<p><strong><code>Q3：如何快速区分维度？</code></strong></p>
<blockquote>
<p>利用<code>a.shape</code>或<code>a.dim()</code>。</p>
</blockquote>
<p><strong><code>Q4：Tensor和Array有什么区别？</code></strong></p>
<blockquote>
<p>Tensor是数学上定义的张量，Array是计算机概念数组，但在深度学习中有时将Tensor视为多维数组。</p>
</blockquote>
<p><strong><code>Q5：新分配了y的内存，那么之前y对应的内存会自动释放吗？</code></strong></p>
<blockquote>
<p>Python会在不需要时自动释放内存。</p>
</blockquote>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>03-深度学习安装</title>
    <url>/2024/04/23/11-01-03/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.04.24：初稿</li>
</ul>
<h2 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h2><ul>
<li><a href="/2024/04/24/12-18-34/" title="动手学深度学习笔记汇总">动手学深度学习笔记汇总</a>
</li>
</ul>
<h2 id="03-安装"><a href="#03-安装" class="headerlink" title="03-安装"></a>03-安装</h2><h3 id="1-安装python"><a href="#1-安装python" class="headerlink" title="1.安装python"></a>1.安装python</h3><p>首先前提是安装python，这里推荐安装python3.8 输入命令 <strong><em>sudo apt install python3.8</em></strong> 即可</p>
<h3 id="2-安装Miniconda-Anaconda"><a href="#2-安装Miniconda-Anaconda" class="headerlink" title="2.安装Miniconda/Anaconda"></a>2.安装Miniconda/Anaconda</h3><ul>
<li><p>然后第二步，安装 Miniconda（如果已经安装conda或者Miniconda，则可以跳过该步骤)。</p>
<h4 id="2-1-安装Miniconda"><a href="#2-1-安装Miniconda" class="headerlink" title="2.1 安装Miniconda"></a>2.1 安装Miniconda</h4><ul>
<li>安装MIniconda的好处是可以创建很多虚拟环境，并且不同环境之间互相不会有依赖关系，对日后的项目有帮助，如果只想在本地安装的话，不装Miniconda只使用pip即可，第二步可以跳过。</li>
<li>如果是Windows系统，输入命令 <strong><em>wget <a href="https://repo.anaconda.com/miniconda/Miniconda3-py38_4.10.3-Windows-x86_64.exe">https://repo.anaconda.com/miniconda/Miniconda3-py38_4.10.3-Windows-x86_64.exe</a></em></strong></li>
<li>如果是macOS，输入命令 <strong><em>wget <a href="https://repo.anaconda.com/miniconda/Miniconda3-py38_4.10.3-MacOSX-x86_64.sh">https://repo.anaconda.com/miniconda/Miniconda3-py38_4.10.3-MacOSX-x86_64.sh</a></em></strong> 之后要输入命令 <strong><em>sh Miniconda3-py38_4.10.3-MacOSX-x86_64.sh -b</em></strong></li>
<li>如果是Linux系统，输入命令 <strong><em>wget <a href="https://repo.anaconda.com/miniconda/Miniconda3-py38_4.10.3-Linux-x86_64.sh">https://repo.anaconda.com/miniconda/Miniconda3-py38_4.10.3-Linux-x86_64.sh</a></em></strong> 之后输入命令 <strong><em>sh Miniconda3-py38_4.10.3-Linux-x86_64.sh -b</em></strong></li>
<li>以上都是基于python3.8版本，对于其他版本，可以访问 <strong><em><a href="https://docs.conda.io/en/latest/miniconda.html">https://docs.conda.io/en/latest/miniconda.html</a></em></strong> ，下载对应版本即可。</li>
</ul>
<h4 id="2-2-Miniconda环境操作"><a href="#2-2-Miniconda环境操作" class="headerlink" title="2.2 Miniconda环境操作"></a>2.2 Miniconda环境操作</h4><ul>
<li>对于第一次安装Miniconda的，要初始化终端shell，输入命令 <strong><em>~/miniconda3/bin/conda init</em></strong></li>
<li>这样我们就可以使用 <strong><em>conda create —name d2l python=3.8 -y</em></strong> 来创建一个名为xxx的环境，这里命名为d2l</li>
<li>打开xxx环境命令: <strong><em>conda activate xxx</em></strong> ；关闭命令：<strong><em>conda deactivate xxx</em></strong>。对于基础conda环境不用添加名</li>
</ul>
</li>
</ul>
<h3 id="3-安装Pytorch-d2l-jupyter包"><a href="#3-安装Pytorch-d2l-jupyter包" class="headerlink" title="3.安装Pytorch, d2l, jupyter包"></a>3.安装Pytorch, d2l, jupyter包</h3><ul>
<li><p>第三步，安装深度学习框架和<code>d2l</code>软件包</p>
<p>在安装深度学习框架之前，请先检查你的计算机上是否有可用的GPU（为笔记本电脑上显示器提供输出的GPU不算）。 例如，你可以查看计算机是否装有NVIDIA GPU并已安装<a href="https://developer.nvidia.com/cuda-downloads">CUDA</a>。 如果你的机器没有任何GPU，没有必要担心，因为你的CPU在前几章完全够用。 但是，如果你想流畅地学习全部章节，请提早获取GPU并且安装深度学习框架的GPU版本。</p>
<ul>
<li><p>你可以按如下方式安装PyTorch的CPU或GPU版本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install torch==1.8.1</span><br><span class="line">pip install torchvision==0.9.1</span><br></pre></td></tr></table></figure>
</li>
<li><p>也可以访问官网 <strong><em><a href="https://pytorch.org/get-started/locally/">https://pytorch.org/get-started/locally/</a></em></strong> 选择适合自己电脑pytorch版本下载!</p>
</li>
<li>
</li>
<li><p>本课程的jupyter notebook代码详见 <strong><em><a href="https://zh-v2.d2l.ai/d2l-zh.zip">https://zh-v2.d2l.ai/d2l-zh.zip</a></em></strong></p>
</li>
<li><p>下载jupyter notebook ：输入命令 <strong><em>pip install jupyter notebook</em></strong> （若pip失灵可以尝试pip3），输入密命令 <strong><em>jupyter notebook</em></strong> 即可打开。</p>
</li>
</ul>
</li>
</ul>
<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><ul>
<li>本节主要介绍<strong>安装Miniconda</strong>、<strong>CPU环境下的Pytorch</strong>和其它课程所需<strong>软件包</strong>(d2l, jupyter)。对于前面几节来说，CPU已经够用了。<ul>
<li>如果您<strong>已经安装</strong>了Miniconda/Anaconda, Pytorch框架和jupyter记事本, 您只需再安装<strong>d2l包</strong>，就可以跳过本节视频了<strong>开启深度学习之旅</strong>了; 如果希望后续章节在<strong>GPU下跑深度学习</strong>, 可以<strong>新建环境</strong>安装<strong>CUDA版本的Pytorch</strong>。</li>
<li>如果需要在Windows下<strong>安装CUDA和Pytorch</strong>(cuda版本)，用<strong>本地GPU跑深度学习</strong>，可以参考李沐老师<a href="https://www.zhihu.com/zvideo/1363284223420436480">Windows下安装CUDA和Pytorch跑深度学习</a>，如果网慢总失败的同学可以参考<a href="https://www.zhihu.com/question/425647129/answer/2278290137">cuda11.0如何安装pytorch？ - Glenn1Q84的回答 - 知乎</a>。当然，如果不方便在本地进行配置(如无GPU, GPU显存过低等)，也可以选择<a href="https://colab.research.google.com/">Colab</a>(需要科学上网)，或其它<strong>云服务器</strong>GPU跑深度学习。</li>
<li>如果pip安装比较慢，可以用镜像源安装：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install torch torchvision -i http://mirrors.aliyun.com/pypi/simple/  --trusted-host mirrors.aliyun.com</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>如果安装时经常报错, 可以参考课程评论区部分。</li>
</ul>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>02-深度学习介绍</title>
    <url>/2024/04/23/11-01-02/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.04.24：初稿</li>
</ul>
<h2 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h2><ul>
<li><a href="/2024/04/24/12-18-34/" title="动手学深度学习笔记汇总">动手学深度学习笔记汇总</a>
</li>
</ul>
<h2 id="02-深度学习介绍"><a href="#02-深度学习介绍" class="headerlink" title="02-深度学习介绍"></a>02-深度学习介绍</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><h4 id="1-1-AI地图"><a href="#1-1-AI地图" class="headerlink" title="1.1 AI地图"></a>1.1 AI地图</h4><p>首先画一个简单的人工智能地图：</p>
<img src="/2024/04/23/11-01-02/02-01.png" class>
<ul>
<li><p>x轴表示不同的模式or方法：最早的是符号学，接下来是概率模型，之后是机器学习</p>
</li>
<li><p>y轴表示可以达到的层次：由底部向上依次是</p>
<blockquote>
<p>感知：了解是什么，比如能够可以看到物体，如面前的一块屏幕</p>
<p>推理：基于感知到的现象，想象或推测未来会发生什么</p>
<p>知识：根据看到的数据或者现象，形成自己的知识</p>
<p>规划：根据学习到的知识，做出长远的规划</p>
</blockquote>
</li>
</ul>
<h4 id="1-2-AI地图解读"><a href="#1-2-AI地图解读" class="headerlink" title="1.2 AI地图解读"></a>1.2 AI地图解读</h4><ul>
<li><p>问题领域的一个简单分类</p>
<ul>
<li><p><strong>自然语言处理</strong>：</p>
<ul>
<li>停留在比较简单的<strong>感知</strong>层面，比如自然语言处理用的比较多的机器翻译，给一句中文翻译成英文，很多时候是人的潜意识里面大脑感知的一个问题。一般来说，人可以几秒钟内反应过来的东西，属于感知范围。</li>
<li>自然语言处理最早使用的方法是<strong>符号学</strong>，由于语言具有符号性；之后一段时间比较流行的有<strong>概率模型</strong>，以及现在也用的比较多的<strong>机器学习</strong>。</li>
</ul>
</li>
<li><p><strong>计算机视觉</strong>：</p>
<ul>
<li>在简单的感知层次之上，可以对图片做一些<strong>推理</strong>。 </li>
<li>图片里都是一些像素，很难用符号学解释，所以一般采用<strong>概率模型</strong>和<strong>机器学习</strong>。</li>
</ul>
</li>
<li><p><strong>深度学习</strong></p>
<ul>
<li>机器学习的一种，更深层的神经网络。</li>
<li>可以做计算机视觉，自然语言处理，强化学习等。</li>
</ul>
</li>
</ul>
</li>
<li><p>过去八年最热的方向，也是本课程关心的重点：</p>
<ul>
<li>深度学习+计算机视觉 / 自然语言处理</li>
</ul>
</li>
</ul>
<p>本节课只关注AI中的一小部分领域，即深度学习背景下的视觉和自然语言处理相关的基础应用。</p>
<hr>
<h3 id="2-深度学习的应用"><a href="#2-深度学习的应用" class="headerlink" title="2. 深度学习的应用"></a>2. 深度学习的应用</h3><h4 id="2-1-图片分类"><a href="#2-1-图片分类" class="headerlink" title="2.1 图片分类"></a>2.1 图片分类</h4><p>深度学习最早是在图片分类上有比较大的突破，ImageNet是一个比较大的图片分类数据集，</p>
<img src="/2024/04/23/11-01-02/02-02.png" class>
<p><code>x轴</code>：年份      <code>y轴</code>：错误率     <code>圆点</code>：表示某年份某研究工作/paper的错误率  <a href="https://image-net.org/">IMAGENET</a>   <a href="https://qz.com/1034972/the-data-that-changed-the-direction-of-ai-research-and-possibly-the-world/">数据来源</a></p>
<blockquote>
<p>在2010年时，错误率比较高，最好的工作错误率也在26%、%27左右；</p>
<p>在2012年，有团队首次使用深度学习将错误率降到25%以下；</p>
<p>在接下来几年中，使用深度学习可以将误差降到很低。</p>
<p>2017年基本所有的团队可以将错误率降到5%以下，基本可以达到人类识别图片的精度。</p>
</blockquote>
<h4 id="2-2-物体检测和分割"><a href="#2-2-物体检测和分割" class="headerlink" title="2.2 物体检测和分割"></a>2.2 物体检测和分割</h4><p>当你不仅仅想知道图片里有什么内容，还想知道物体是什么，在什么位置，这就是<strong>物体检测</strong>。<strong>物体分割</strong>是指每一个像素属于什么，属于飞机还是属于人(如下图)，这是图像领域更深层次的一个应用。<br><img src="/2024/04/23/11-01-02/02-03.png" class></p>
<h4 id="2-3-样式迁移"><a href="#2-3-样式迁移" class="headerlink" title="2.3 样式迁移"></a>2.3 样式迁移</h4><p>原图片+想要迁移的风格=风格迁移后的图片，加了一个可以根据输入改变图片风格的滤镜。<br><img src="/2024/04/23/11-01-02/02-04.png" class></p>
<h4 id="2-4-人脸合成"><a href="#2-4-人脸合成" class="headerlink" title="2.4 人脸合成"></a>2.4 人脸合成</h4><p>下图中所有的人脸都是假的，由机器合成的图片：<br><img src="/2024/04/23/11-01-02/02-05.png" class></p>
<h4 id="2-5-文字生成图片"><a href="#2-5-文字生成图片" class="headerlink" title="2.5 文字生成图片"></a>2.5 文字生成图片</h4><ol>
<li><p>描述：一个胡萝卜宝宝遛狗的图片。</p>
</li>
<li><p>描述：一个牛油果形状的靠背椅。</p>
<img src="/2024/04/23/11-01-02/02-06.png" class>
</li>
</ol>
<h4 id="2-6-文字生成"><a href="#2-6-文字生成" class="headerlink" title="2.6 文字生成"></a>2.6 文字生成</h4><blockquote>
<p>示例1：</p>
<p>问题输入：如何举行一个有效的董事会议 </p>
<p>机器输出：生成篇章回答</p>
<p>示例2：</p>
<p>输入：将Students从School这个table中选出来</p>
<p>输出：用于查询的SQL语言</p>
</blockquote>
<img src="/2024/04/23/11-01-02/02-07.png" class>
<h4 id="2-7-无人驾驶"><a href="#2-7-无人驾驶" class="headerlink" title="2.7 无人驾驶"></a>2.7 无人驾驶</h4><p>识别车、道路以及各种障碍物等，并规划路线。</p>
<img src="/2024/04/23/11-01-02/02-08.png" class>
<h4 id="2-8-案例研究——广告点击"><a href="#2-8-案例研究——广告点击" class="headerlink" title="2.8 案例研究——广告点击"></a>2.8 案例研究——广告点击</h4><blockquote>
<p>用户输入想要搜索的广告内容，如：baby toy</p>
<p>网站呈现最具有效益的广告(用户更可能点击，且给网站带来更高经济效益)</p>
</blockquote>
<img src="/2024/04/23/11-01-02/02-09.png" class>
<h5 id="2-8-1-步骤"><a href="#2-8-1-步骤" class="headerlink" title="2.8.1 步骤"></a>2.8.1 步骤</h5><img src="/2024/04/23/11-01-02/02-10.png" class>
<ol>
<li>触发：用户输入关键词，机器先找到一些相关的广告</li>
<li>点击率预估：   利用机器学习的模型预测用户对广告的点击率</li>
<li>排序：利用点击率x竞价的结果进行排序呈现广告，排名高的在前面呈现</li>
</ol>
<h5 id="2-8-2-模型的预测与训练"><a href="#2-8-2-模型的预测与训练" class="headerlink" title="2.8.2 模型的预测与训练"></a>2.8.2 模型的<mark>预测与训练</mark></h5><p>上述步骤的第二步中涉及到模型预测用户的点击率，具体过程如下：<br><img src="/2024/04/23/11-01-02/02-11.png" class></p>
<p><strong>模型预测</strong></p>
<p>数据 (待预测广告) → 特征提取 → 模型 → 点击率预测</p>
<p><strong>模型训练</strong></p>
<p>训练数据 (过去广告展现和用户点击) → 特征(X)和用户点击(Y) → 喂给模型训练</p>
<h5 id="2-8-3-完整的故事"><a href="#2-8-3-完整的故事" class="headerlink" title="2.8.3 完整的故事"></a>2.8.3 完整的故事</h5><img src="/2024/04/23/11-01-02/02-12.png" class>
<p><strong><font color="Navy">领域专家</font></strong>：对特定的应用有比较深的了解，根据展现情况以及用户点击分析用户的行为，期望模型对应用做一些拟合，符合真实数据和分析情况。</p>
<p><strong><font color="Navy">数据科学家</font></strong>：利用数据训练模型，训练后模型投入使用，进行预测呈现。</p>
<p><strong><font color="Navy">AI专家</font></strong>：应用规模扩大，用户数量增多，模型更加复杂，需要进一步提升精度和性能。</p>
<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><ul>
<li>通过AI地图，课程从纵向和横向两个维度解读了深度学习在重要问题领域的概况。</li>
<li>介绍了深度学习在CV和NLP方面的一些应用</li>
<li>简单分析并研究了深度学习实例——广告点击。</li>
</ul>
<hr>
<h3 id="4-深度学习介绍-Q-amp-A"><a href="#4-深度学习介绍-Q-amp-A" class="headerlink" title="4. 深度学习介绍 Q&amp;A"></a>4. 深度学习介绍 Q&amp;A</h3><p>◆ <strong>Q1：机器学习的可解释性？机器学习在图片分割为什么有效，目前有没有定论？</strong></p>
<blockquote>
<p><font color="MediumSeaGreen">A1</font>：模型的可解释性不管是深度学习还是机器学习都是非常受人关注的点，因为这像是一个黑盒，训练了一个模型，也不知道为什么work或者为什么不work。对于深度学习来说，模型的<strong>可解释性</strong>是做得不够好的；对于机器学习来说，我们对简单的模型可以理解，但当模型变得很深的时候，几乎只能放弃理解的过程。</p>
<p>特别地，<strong>为什么有效</strong>和<strong>可解释性</strong>是两个不同的概念，所有提出的新模型都会解释一下为什么有效，可解释性是说人是不是能理解这个模型，理解模型为什么工作是一个方面，还需要知道它什么时候不工作以及在什么地方会出现偏差。</p>
<p>目前来说，一个模型在一个应用/领域上为什么可以工作，会有一些解释，我们会在解释不同的模型的时候给大家进行讲解。</p>
</blockquote>
<p>◆ <strong>Q2：领域专家是什么意思？</strong></p>
<blockquote>
<p><font color="MediumSeaGreen">A2</font>：举个例子，比如我要做农业上的物体识别，我种了一棵树，想要看今年的收成怎么样，我有很多很多土地，用人去一个个查看很费力，于是我用一个无人机，将农作物的情况拍下来，假设得到了树的一些图片，而数据科学家不知道农作物什么样的情况是好，什么样是坏，于是<strong>领域专家进行解释</strong>，比如多少叶子算是好，什么样不好。同时<strong>数据科学家</strong>将领域专家的<strong>问题翻译</strong>成机器学习能做的任务。所以可以认为<strong>领域专家</strong>是<strong>提需求</strong>的人<strong>甲方</strong>，而<strong>数据科学家</strong>是<strong>乙方</strong>。</p>
</blockquote>
<p>◆ <strong>Q3：MXNet的GPU版本的安装必须要卸载CPU版本的吗？</strong></p>
<blockquote>
<p><font color="MediumSeaGreen">A3</font>：是的，但我们的课程是<strong>基于Pytorch</strong>，Pytorch会不一样一些。</p>
</blockquote>
<p>◆ <strong>Q4：深度学习无法用数学规范表述，只能用直觉理解是吗？</strong></p>
<blockquote>
<p><font color="MediumSeaGreen">A4</font>：不一定，深度学习模型可以用<strong>数学形式表示</strong>，接下来也会讲到很多数学的东西，但是说具体用数学解释它<strong>为什么工作</strong>，<strong>为什么不工作</strong>，这个是目前我们做的不好的地方。</p>
</blockquote>
<p>◆ <strong>Q5：符号学可以和机器学习融合起来吗？</strong></p>
<blockquote>
<p><font color="MediumSeaGreen">A5</font>：确实是可以的。目前来说，<strong>符号学</strong>在<strong>深度学习</strong>有一些新的进展，以前说符号学就是做一些符号上的推理，目前<strong>深度学习如图神经网络</strong>，可以做一些比较复杂的推理。</p>
</blockquote>
<p>◆ <strong>Q6：数据科学家和AI专家的主要区别在哪里？</strong></p>
<blockquote>
<p><font color="MediumSeaGreen">A6</font>：我觉得没有太多区别。数据科学家很多时候关注的是给一个数据，赶紧出一个模型，能工作就好了，<strong>关注</strong>的是如何把领域专家的一个实际的业务问题，变成一个机器学习能做的任务，训练成一个还不错的模型。<strong>AI专家也可能是数据科学家</strong>，也就是说其不仅要训练出来一个模型能用，而且会<strong>关心</strong>如何把模型精度做得很高，或者可以说，<strong>资深数据科学家可以认为是AI专家</strong>。</p>
<p>数据科学家可以有<strong>两条路线</strong>，一个是<strong>不断开拓新领域</strong>，比如机器学习在农业上的应用，在医疗上的应用等，这个是<strong>往广的走</strong>，<strong>往深的走</strong>的话可以称为是AI专家，在某一块方面了解得很深。</p>
</blockquote>
<p>◆ <strong>Q7：MAC是不是可以支持Pytorch？</strong></p>
<blockquote>
<p><font color="MediumSeaGreen">A7</font>：可以。</p>
</blockquote>
<p>◆ <strong>Q8：说自然语言处理仅仅停留在感知层面似乎不太合适？因为语言的理解和产出不仅仅是感知，也涉及到语言知识和世界知识，也涉及到规划，比如机器规划下一步要做什么。</strong></p>
<blockquote>
<p><font color="MediumSeaGreen">A8</font>：确实是这样，语言当然是一个很复杂的过程，我只是想说，自然语言处理我们做得还很一般，虽然能做一些感知以外的东西，但是我感觉是说，<strong>不如</strong>深度学习特别机器学习，在图片上的应用做得好一些。当然AI地图上也只是一个<strong>大致的分类</strong>，大家不用特别纠结。</p>
</blockquote>
<p>◆ <strong>Q9：请问老师有考虑后面讲一讲如何寻找自己领域的paper的经验吗？</strong></p>
<blockquote>
<p><font color="MediumSeaGreen">A9</font>：这是一个很好的问题，因为大家如果现在去读paper的话，可能每天都有一百篇paper出来，你怎么样去找到你想要的paper，总不能天天看朋友圈推文，这样只能知道别人读过的paper，不会有自己<strong>独特的见解</strong>，怎么样找到自己感兴趣和有启发性的论文，后面有机会和大家分享一下我的做法。</p>
</blockquote>
<p>◆ <strong>Q10：以无人驾驶为例，误判率在不断下降，但误判的影响还是很严重的，有可能从已有的判断case(样例)得到修正，从而完全避免这样的错误吗？</strong></p>
<blockquote>
<p><font color="MediumSeaGreen">A10</font>：<strong>无人驾驶</strong>中，任何一次出现的错误，都可能带来毁灭性的灾难。大家可能看到，特斯拉今天撞了，明天又撞了。所以说，无人驾驶对于<strong>错误率</strong>确实是非常注重的。</p>
<p>机器学习在学术界现在有很多关于<strong>uncertainty</strong>或者<strong>robustness</strong>的研究，就是说模型在数据偏移或者极端情况下会不会给出很不好的答案，我们不会特别深入去讲这个事情，但是无人驾驶这一块确实会通过大量的技术，比如说把不同的模型融合在一起，不是仅仅train一个模型，用多个模型来做投票。汽车有很多雷达、摄像头，它会通过不同的传感器来进行模型的融合，从而降低误差。</p>
<p>我们这个课程不会特别地讲，因为涉及到评价无人驾驶的特别技术，但在竞赛中我们会给大家看到如何通过<strong>融合多个模型提升精度</strong>的做法。</p>
</blockquote>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>01-深度学习课程安排</title>
    <url>/2024/04/23/11-01-01/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.04.24：初稿</li>
</ul>
<h2 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h2><ul>
<li><a href="/2024/04/24/12-18-34/" title="动手学深度学习笔记汇总">动手学深度学习笔记汇总</a>
</li>
</ul>
<h2 id="01-课程安排"><a href="#01-课程安排" class="headerlink" title="01-课程安排"></a>01-课程安排</h2><h3 id="1-课程目标"><a href="#1-课程目标" class="headerlink" title="1. 课程目标"></a>1. 课程目标</h3><ul>
<li>介绍深度学习经典和最新模型<ul>
<li>LeNet, ResNet, LSTM, BERT, …</li>
</ul>
</li>
<li>机器学习基础<ul>
<li>损失函数、目标函数、过拟合、优化</li>
</ul>
</li>
<li>实践<ul>
<li>使用Pytorch实现介绍的知识点</li>
<li>在真实数据上体验算法效果</li>
</ul>
</li>
</ul>
<h3 id="2-内容"><a href="#2-内容" class="headerlink" title="2. 内容"></a>2. 内容</h3><blockquote>
<p>深度学习基础：线性神经网络，多层感知机</p>
<p>卷积神经网络：LeNet, AlexNet, VGG, Inception, ResNet</p>
<p>循环神经网络：RNN，GRU，LSTM，seq2seq</p>
<p>注意力机制：Attention， Transformer</p>
<p>优化算法：SGD，Momentum，Adam</p>
<p>高性能计算：并行，多GPU，分布式</p>
<p>计算机视觉：目标检测，语义分割</p>
<p>自然语言处理：词嵌入，BERT</p>
</blockquote>
<h3 id="3-学到什么"><a href="#3-学到什么" class="headerlink" title="3. 学到什么"></a>3. 学到什么</h3><ul>
<li>What：深度学习有哪些技术，以及哪些技术可以帮你解决问题</li>
<li>How：如何实现（产品 or paper）和调参（精度or速度）</li>
<li>Why：背后的原因（直觉、数学）</li>
</ul>
<h3 id="4-基本要求"><a href="#4-基本要求" class="headerlink" title="4. 基本要求"></a>4. 基本要求</h3><ul>
<li><strong>AI相关从业人员</strong>（产品经理等）：掌握What，知道名词，能干什么</li>
<li><strong>数据科学家、工程师</strong>：掌握What、How，手要快，能出活</li>
<li><strong>研究员、学生</strong>：掌握What、How、Why，除了知道有什么和怎么做，还要知道为什么，思考背后的原因，做出新的突破</li>
</ul>
<h3 id="5-课程资源"><a href="#5-课程资源" class="headerlink" title="5. 课程资源"></a>5. 课程资源</h3><ul>
<li>课程主页：<a href="https://courses.d2l.ai/zh-v2/">https://courses.d2l.ai/zh-v2/</a></li>
<li>教材：<a href="https://zh-v2.d2l.ai/">https://zh-v2.d2l.ai/</a></li>
<li>课程论坛讨论：<a href="https://discuss.d2l.ai/c/chinese-version/16">https://discuss.d2l.ai/c/chinese-version/16</a></li>
<li>Pytorch论坛：<a href="https://discuss.pytorch.org/">https://discuss.pytorch.org/</a></li>
<li>b站视频合集：[<a href="https://space.bilibili.com/1567748478/channel/seriesdetail?sid=358497](">https://space.bilibili.com/1567748478/channel/seriesdetail?sid=358497](</a></li>
</ul>
<h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h3><ul>
<li>课程目标、内容和要求</li>
<li>相关课程资源链接</li>
</ul>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>00-深度学习预告</title>
    <url>/2024/04/23/11-01-00/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.04.24：初稿</li>
</ul>
<h2 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h2><ul>
<li><a href="/2024/04/24/12-18-34/" title="动手学深度学习笔记汇总">动手学深度学习笔记汇总</a>
</li>
</ul>
<h2 id="00-预告"><a href="#00-预告" class="headerlink" title="00-预告"></a>00-预告</h2><h3 id="1-学习深度学习关键是动手"><a href="#1-学习深度学习关键是动手" class="headerlink" title="1. 学习深度学习关键是动手"></a>1. 学习深度学习关键是动手</h3><ul>
<li>深度学习是人工智能最热的领域</li>
<li>核心是神经网络</li>
<li>神经网络是一门语言</li>
<li><p>应该像学习Python/C++一样学习深度学习</p>
<h3 id="2-参考书目《动手学深度学习》"><a href="#2-参考书目《动手学深度学习》" class="headerlink" title="2. 参考书目《动手学深度学习》"></a>2. 参考书目《动手学深度学习》</h3></li>
<li><p>是一本深度学习的教科书</p>
<ul>
<li><p>覆盖90年代至今的重要模型</p>
</li>
<li><p>每一章是一个Jupyter记事本</p>
<ul>
<li>提供所有模型的完整实现</li>
<li>在真实数据上运行</li>
</ul>
</li>
<li><p><strong>原书链接</strong>：<a href="https://zh.d2l.ai/">动手学深度学习(原书中文版)</a></p>
</li>
<li><p><strong>项目链接</strong>：<a href="https://github.com/d2l-ai/d2l-zh">Github项目</a></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>英文版：2019年推出<br>重写了所有章节</p>
<ul>
<li>加入50%新内容(如Transformer)<br>Numpy/MXNet, Pytorch和TensorFlow2.0的代码实现</li>
</ul>
</li>
</ul>
<ul>
<li>课程对应网站：<a href="https://courses.d2l.ai/zh-v2/">课程主页</a>(包含原视频<strong>课件</strong>等资源)</li>
</ul>
<ul>
<li>b站<strong>视频</strong>网站：<a href="https://space.bilibili.com/1567748478/channel/seriesdetail?sid=358497">视频合集</a></li>
</ul>
<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h3><ul>
<li>如何学习深度学习——动手跑代码</li>
<li>课程资源：书籍、视频、课件等</li>
</ul>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习笔记四 神经网络的表达</title>
    <url>/2024/04/22/13-37-13/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.04.22：初稿</li>
</ul>
<h1 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h1><ul>
<li><a href="/2024/04/18/15-40-33/" title="机器笔记汇总">吴恩达机器学习 - 笔记汇总</a>
</li>
</ul>
<h1 id="8-神经网络：表达（Neural-Networks-Representation）"><a href="#8-神经网络：表达（Neural-Networks-Representation）" class="headerlink" title="8 神经网络：表达（Neural Networks: Representation）"></a>8 神经网络：表达（Neural Networks: Representation）</h1><h2 id="8-1-非线性假设（Non-linear-Hypotheses）"><a href="#8-1-非线性假设（Non-linear-Hypotheses）" class="headerlink" title="8.1 非线性假设（Non-linear Hypotheses）"></a>8.1 非线性假设（Non-linear Hypotheses）</h2><p>理论上我们可以用多项式函数去近似任意函数（泰勒极数（Taylor series）），从而可得到任意问题的拟合曲线。</p>
<p>在实际处理时，特征量通常会很多，如果再构造高阶多项式等，特征数量将会急剧增加，这使得回归模型的复杂度太高，可见并不合适。神经网络无需构造高阶多项式，在特征量很大时也可以处理的很好。</p>
<p>那特征能有多大呢？下面是一个计算机视觉中的例子：</p>
<img src="/2024/04/22/13-37-13/20180115_084326.png" class>
<p>如上图，如果选取一小块 $50 * 50$ 像素的灰度图片（一个像素只有亮度一个值），选择每个像素点作为特征，则特征总量 $n=2500$（换成 RGB（一个像素有三个值），则 $n = 7500$），如果将其两两组合作为新特征，则特征数量将为 $C_{2500}^{2} \approx 3\ million$。</p>
<h2 id="8-2-神经网络和大脑（Neurons-and-the-Brain）"><a href="#8-2-神经网络和大脑（Neurons-and-the-Brain）" class="headerlink" title="8.2 神经网络和大脑（Neurons and the Brain）"></a>8.2 神经网络和大脑（Neurons and the Brain）</h2><p>脑科学家通过对动物实验，发现大脑中专用于处理听觉信号的脑皮层也能处理其他诸如视觉等信号，即如果切断其与耳朵的联系，将其与眼睛相连，则这块负责听觉的脑皮层区域也能接受并处理视觉信号，从而学会“看”。脑科学家通过这类换源实验，就推论假设大脑的学习算法只有一种（“one learning algorithm” hypothesis）。那么如果能找出这种学习算法并应用于计算机中，那梦想中和人一样的人工智能就成真了。</p>
<p>神经网络就源于<strong>模拟人类大脑</strong>，但其需要的计算量很大。随着计算机硬件性能的提高，神经网络逐渐从衰落变为流行，如今已广泛地被应用在各行各业中。</p>
<p>下图是根据研究做的一些应用（有兴趣可回顾视频）：</p>
<img src="/2024/04/22/13-37-13/20180115_101441.png" class>
<p>BrainPort  系统：帮助失明人士通过摄像头以及舌尖感官“看”东西</p>
<img src="/2024/04/22/13-37-13/20180115_101442.png" class>
<p>触觉皮带：在朝北时蜂鸣器会发出声响，可使人拥有方向感（声音信号转换为方向信号）。</p>
<h2 id="8-3-模型表示1（Model-Representation-I）"><a href="#8-3-模型表示1（Model-Representation-I）" class="headerlink" title="8.3 模型表示1（Model Representation I）"></a>8.3 模型表示1（Model Representation I）</h2><p>大脑神经元</p>
<img src="/2024/04/22/13-37-13/20141213201613758.jpg" class>
<p>想象一下印刷厂中流水线的工人，每个工人都有特定的任务，比如装订，塑封，贴防伪标识等等，工人们看到书本并处理完自己的任务后，就回放回传送带，紧接着传送带就传给下一个环节的工人，如此不断重复从而完成一个又一个环节，直到一本书印制完成。</p>
<p>那么类比一下，把上图中的<strong>细胞核（nucleus）</strong>类比成工人，<strong>轴突（axon）</strong>类比传送带，<strong>树突（dendrite）</strong>则比类比成工人的双眼。一个又一个细胞体，从树突接收需要处理的信息，对其进行处理后，再经由轴突通过电信号把处理完的信息传递出去，直到理解信息的内容。</p>
<p>人工神经网络中，树突对应<strong>输入（input）</strong>，细胞核对应<strong>激活单元（activation unit）</strong>，轴突对应<strong>输出（output）</strong>。</p>
<p>我们一般把神经网络划分为三部分（注意，不是只有三层！），即输入层（input layer），隐藏层（hidden layer）和输出层（output layer）。</p>
<img src="/2024/04/22/13-37-13/20180116_001543.png" class>
<p>图中的一个圈表示神经网络中的一个激活单元，输入层对应输入单元，隐藏层对应中间单元，输出层则对应输出单元。中间激活单元应用<strong>激活函数</strong>处理数据。</p>
<p>下面列出一些已有概念在神经网络中的别称：</p>
<ul>
<li>$x_0$: 偏置单元（bias unit），$x_0$=1</li>
<li>$\Theta$: 权重（weight），即参数。</li>
<li>激活函数: $g$，即逻辑函数等。</li>
<li>输入层: 对应于训练集中的特征 $x$。</li>
<li>输出层: 对应于训练集中的结果 $y$。</li>
</ul>
<blockquote>
<p>$a^{(j)}_i$: 第 $j$ 层的第 $i$ 个激活单元</p>
<p>$\Theta^{(j)}$: 从第 $j$ 层映射到第 $j+1$ 层时的权重矩阵。</p>
<p>$\Theta^{(j)}_{v,u}$: 从第 $j$ 层的第 $u$ 个单元映射到第 $j+1$ 层的第 $v$ 个单元的权重</p>
<p>$s_j$: 第 $j$ 层的激活单元数目（不包含偏置单元）</p>
</blockquote>
<p>注意：</p>
<ul>
<li><strong>每个单元会作用于下一层的所有单元</strong>（矩阵乘法运算）。</li>
<li>如果第 $j$ 层有 $s_j$ 个单元，第 $j+1$ 层有 $s_{j+1}$ 个单元，$\Theta^{(j)}$ 是一个 $s_{j+1} \times (s_j+1)$ 维的权重矩阵。即每一层的权重矩阵大小都是非固定的。</li>
<li>其中，$+1$ 来自于偏置单元，这样意味着输出层不包含偏置单元，输入层和隐藏层需要增加偏置单元。</li>
</ul>
<p>依据本节所给模型，有：</p>
<p>$Size(\Theta^{(1)})=s_{j+1} \times (s_j + 1) =s_2 \times (s_1 + 1) = 3 \times 4$</p>
<p>$Size(\Theta^{(2)})=s_3 \times (s_2 + 1) = 1 \times 4$</p>
<h2 id="8-4-模型表示2（Model-Representation-II）"><a href="#8-4-模型表示2（Model-Representation-II）" class="headerlink" title="8.4 模型表示2（Model Representation II）"></a>8.4 模型表示2（Model Representation II）</h2><img src="/2024/04/22/13-37-13/20180116_001543.png" class>
<p>对输入层（Layer 1）的所有激活单元应用激活函数，从而得到隐藏层（Layer 2）中激活单元的值：</p>
<p>$$<br>\begin{split} a_1^{(2)} = g(\Theta_{10}^{(1)}x_0 + \Theta_{11}^{(1)}x_1 + \Theta_{12}^{(1)}x_2 + \Theta_{13}^{(1)}x_3)\\<br>a_2^{(2)} = g(\Theta_{20}^{(1)}x_0 + \Theta_{21}^{(1)}x_1 + \Theta_{22}^{(1)}x_2 + \Theta_{23}^{(1)}x_3)\\<br>a_3^{(2)} = g(\Theta_{30}^{(1)}x_0 + \Theta_{31}^{(1)}x_1 + \Theta_{32}^{(1)}x_2 + \Theta_{33}^{(1)}x_3)<br>\end{split}<br>$$<br>对 Layer 2 中的所有激活单元应用激活函数，从而得到输出：</p>
<p>$h_\Theta(x) = a_1^{(3)} = g(\Theta_{10}^{(2)}a_0^{(2)} + \Theta_{11}^{(2)}a_1^{(2)} + \Theta_{12}^{(2)}a_2^{(2)} + \Theta_{13}^{(2)}a_3^{(2)})$</p>
<p>上面的计算过程被称为<strong>前向传播（Forward propagation）</strong>，即从输入层开始，一层一层地向下计算并传递结果。</p>
<p>再回顾一下逻辑回归：</p>
<p>${h_\theta}\left( x \right)=g\left( {\theta_0}+{\theta_1}{x_1}+{\theta_{2} }{x_{2} }+{\theta_{3} }x_3 \right)$</p>
<p>是不是除了符号表示，其他都完全一样？其实神经网络就好似回归模型，只不过输入变成了中间单元 $a_1^{(j)}, a_2^{(j)}, \dots, a_n^{(j)}$。从输入 $x$ 开始，下一层的每个激活单元都包含了上一层的所有信息（单元值），通过最优化算法不断迭代计算，激活单元能得出关于输入 $x$ 的更多信息，这就好像是在给假设函数加多项式。隐藏层的这些单元好似升级版的初始特征，从而能给出更好的预测。</p>
<p><strong>向量化实现</strong></p>
<p>定义 $a^{(1)}=x=\left[ \begin{matrix}x_0\\ x_1 \\ x_2 \\ x_3 \end{matrix} \right]$，$\Theta^{(1)}=\left[\begin{matrix}\Theta^{(1)}_{10}&amp; \Theta^{(1)}_{11}&amp; \Theta^{(1)}_{12}&amp; \Theta^{(1)}_{13}\\ \Theta^{(1)}_{20}&amp; \Theta^{(1)}_{21}&amp; \Theta^{(1)}_{22}&amp; \Theta^{(1)}_{23}\\ \Theta^{(1)}_{30}&amp; \Theta^{(1)}_{31}&amp; \Theta^{(1)}_{32} &amp; \Theta^{(1)}_{33}\end{matrix}\right]$，</p>
<p>$\begin{split}a_1^{(2)} = g(z_1^{(2)}) \\ a_2^{(2)} = g(z_2^{(2)}) \newline a_3^{(2)} = g(z_3^{(2)}) \newline \end{split}$，$z^{(2)}=\left[ \begin{matrix}z_1^{(2)}\\ z_1^{(2)} \\ z_1^{(2)}\end{matrix} \right]$</p>
<p>则有 $a^{(2)}= g(\Theta^{(1)}a^{(1)})=g(z^{(2)})$</p>
<p>预测结果即 $h_\Theta(x) = a^{(3)} = g(\Theta^{(2)}a^{(2)}) = g(z^{(3)})$</p>
<p>即有 $z^{(j)}_i = \Theta^{(j-1)}_{i,0}a^{(j-1)}_{0}+ \Theta^{(j-1)}_{i,1}a^{(j-1)}_{1}+\dots+ \Theta^{(j-1)}_{i,n}a^{(j-1)}_{n}$，</p>
<p> $z^{(j)} = \Theta^{(j-1)}a^{(j-1)}$，$a^{(j)} = g(z^{(j)})$，通过该式即可计算神经网络中每一层的值。</p>
<p>扩展到所有样本实例：</p>
<p>${ {z}^{\left( 2 \right)} }={ {\Theta }^{\left( 1 \right)} } { {X}^{T} }$，这时 $z^{(2)}$ 是一个 $s_2 \times m$ 维矩阵。</p>
<blockquote>
<p>$m$: 训练集中的样本实例数量</p>
<p>$s_2$: 第二层神经网络中激活单元的数量</p>
</blockquote>
<p>当然，神经网络可有多层，每层的激活单元数量也并不固定：</p>
<img src="/2024/04/22/13-37-13/20180116_105545.png" class>
<blockquote>
<p>我们习惯于将输入层称为神经网络的第 0 层，如上图的神经网络被称为三层网络。</p>
</blockquote>
<h2 id="8-5-例子和直观理解1（Examples-and-Intuitions-I）"><a href="#8-5-例子和直观理解1（Examples-and-Intuitions-I）" class="headerlink" title="8.5 例子和直观理解1（Examples and Intuitions I）"></a>8.5 例子和直观理解1（Examples and Intuitions I）</h2><p>为了更好的理解神经网络，举例单层神经网络进行逻辑运算的例子。</p>
<p>下面的例子中，$x_1,x_2$ 为二进制数。</p>
<p>逻辑与（AND）运算（都为真值则结果才为真）神经网络：</p>
<img src="/2024/04/22/13-37-13/20180117_000612.png" class>
<p>$\Theta^{(1)} =\begin{bmatrix}-30 &amp; 20 &amp; 20\end{bmatrix}$，$h_\Theta(x) = g(-30+20x_1+20x_2)$。</p>
<p>回顾 sigmoid 函数图像，根据输入则有上图中右边的表格，即 $h_\theta(x)\approx x_1\ \text{AND}\ x_2$。这样就实现了一个能够进行与运算的神经网络。 </p>
<img src="/2024/04/22/13-37-13/2413fbec8ff9fa1f19aaf78265b8a33b_Logistic_function.png" class>
<p>再举一例，逻辑或（OR）运算（有一个真值则结果就为真）神经网络：</p>
<img src="/2024/04/22/13-37-13/20180117_000349.png" class>
<h2 id="8-6-例子和直观理解2（Examples-and-Intuitions-II）"><a href="#8-6-例子和直观理解2（Examples-and-Intuitions-II）" class="headerlink" title="8.6 例子和直观理解2（Examples and Intuitions II）"></a>8.6 例子和直观理解2（Examples and Intuitions II）</h2><p>下面逐步构建复杂一点的神经网络</p>
<img src="/2024/04/22/13-37-13/20180117_004820.png" class>
<p>如上图，我们分别构建了三个单层神经网络，将这三个网络组合起来，可得到一个新的神经网络，其可完成逻辑运算中的异或（XNOR）操作：</p>
<img src="/2024/04/22/13-37-13/20180116_235545.png" class>
<p>这里的组合即为 $\text{XNOR}=( \text{x}_1\, \text{AND}\, \text{x}_2 )\, \text{OR} \left( \left( \text{NOT}\, \text{x}_1 \right) \text{AND} \left( \text{NOT}\, \text{x}_2 \right) \right)$</p>
<p>$\Theta^{(1)} =\begin{bmatrix}-30 &amp; 20 &amp; 20 \newline 10 &amp; -20 &amp; -20\end{bmatrix}$，$\Theta^{(2)} =\begin{bmatrix}-10 &amp; 20 &amp; 20\end{bmatrix}$，$\begin{split}&amp; a^{(2)} = g(\Theta^{(1)} \cdot x) \newline&amp; a^{(3)} = g(\Theta^{(2)} \cdot a^{(2)}) \newline&amp; h_\Theta(x) = a^{(3)}\end{split}$</p>
<p>可见，特征值能不断升级，并抽取出更多信息，直到计算出结果。而如此不断组合，我们就可以逐渐构造出越来越复杂、强大的神经网络，比如用于手写识别的神经网络。</p>
<h2 id="8-7-多类别分类（Multiclass-Classification）"><a href="#8-7-多类别分类（Multiclass-Classification）" class="headerlink" title="8.7 多类别分类（Multiclass Classification）"></a>8.7 多类别分类（Multiclass Classification）</h2><p>之前讨论的都是预测结果为单值情况下的神经网络，要实现多类别分类，其实只要修改一下输出层，让输出层包含多个输出单元即可。</p>
<p>举一个 4 分类问题的实例：</p>
<img src="/2024/04/22/13-37-13/20180117_010904.png" class>
<p>有四种分类情况，那么就让输出层包含 4 个输出单元即可，则 $h_\Theta$ 为 4 维向量。 </p>
<p>神经网络中的多分类算法算是对 one-vs-all 思想的扩展，定义预测结果一共有 4 种情况：</p>
<img src="/2024/04/22/13-37-13/20180117_011331.png" class>
<p>如果预测结果 $h_\Theta(x) =\begin{bmatrix}0 \newline 0 \newline 1 \newline 0 \newline\end{bmatrix}$，那么表示 $h_\Theta(x)_3$，即分为第 3 类，对应于图中的摩托车（Motorcycle）。</p>
<p><strong>总结一下</strong></p>
<p>多分类问题，要分为 $K$ 类，就在输出层放置 $K$ 个输出单元，对于单个样本实例，预测向量 $h_\Theta(x)$ 为 $K$ 维向量，我们则依据这个预测向量，得出该实例属于哪个类 $y^{(i)}$。注意，神经网络中的预测和结果都是 $K$ 维向量，而不再只是一个实数了。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习, 深度学习, 吴恩达</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习笔记三 多变量线性回归</title>
    <url>/2024/04/22/13-37-10/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.04.22：初稿</li>
</ul>
<h1 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h1><ul>
<li><a href="/2024/04/18/15-40-33/" title="机器笔记汇总">吴恩达机器学习 - 笔记汇总</a>
</li>
</ul>
<h1 id="6-逻辑回归（Logistic-Regression）"><a href="#6-逻辑回归（Logistic-Regression）" class="headerlink" title="6 逻辑回归（Logistic Regression）"></a>6 逻辑回归（Logistic Regression）</h1><h2 id="6-1-分类（Classification）"><a href="#6-1-分类（Classification）" class="headerlink" title="6.1 分类（Classification）"></a>6.1 分类（Classification）</h2><p>在分类问题中，预测的结果是离散值（结果是否属于某一类），逻辑回归算法（Logistic Regression）被用于解决这类分类问题。</p>
<ul>
<li>垃圾邮件判断</li>
<li>金融欺诈判断</li>
<li>肿瘤诊断</li>
</ul>
<p>讨论肿瘤诊断问题：</p>
<img src="/2024/04/22/13-37-10/20180109_144040.png" class>
<p>肿瘤诊断问题的目的是告诉病人<strong>是否</strong>为恶性肿瘤，是一个<strong>二元分类问题（binary class problems）</strong>，则定义 $ y \in\lbrace 0, 1\rbrace$，其中 0 表示<strong>负向类（negative class）</strong>，代表恶性肿瘤（”-“），1 为<strong>正向类（positive class）</strong>，代表良性肿瘤（”+”）。如图，定义最右边的样本为<strong>偏差项</strong>。</p>
<p>在未加入偏差项时，线性回归算法给出了品红色的拟合直线，若规定</p>
<p>$h_\theta(x) \geqslant 0.5$ ，预测为 $y = 1$，即正向类；</p>
<p>$h_\theta(x) \lt 0.5$ ，预测为 $y = 0$，即负向类。</p>
<p>即以 0.5 为<strong>阈值（threshold）</strong>，则我们就可以根据线性回归结果，得到相对正确的分类结果 $y$。</p>
<p>接下来加入偏差项，线性回归算法给出了靛青色的拟合直线，如果阈值仍然为 0.5，可以看到算法在某些情况下会给出完全错误的结果的。</p>
<p>不仅如此，线性回归算法的值域为全体实数集（$h_\theta(x) \in R$）</p>
<p>逻辑回归算法是一个分类算法，<strong>其输出值永远在 0 到 1 之间</strong>，即 $h_\theta(x) \in (0,1)$。</p>
<h2 id="6-2-假设函数表示（Hypothesis-Representation"><a href="#6-2-假设函数表示（Hypothesis-Representation" class="headerlink" title="6.2 假设函数表示（Hypothesis Representation"></a>6.2 假设函数表示（Hypothesis Representation</h2><p>为了使 $h_\theta(x) \in \left(0, 1\right)$，引入逻辑回归模型，定义假设函数<br>$$<br>h_\theta \left( x \right)=g(z)=g\left(\theta^{T}x \right)<br>$$<br>对比线性回归函数 $h_\theta \left( x \right)=\theta^{T}x$，$g$ 表示逻辑函数logistic function，复合起来，则称为逻辑回归函数。</p>
<p>逻辑函数是 S 形函数，会将所有实数映射到 $(0, 1)$ 范围。</p>
<p>sigmoid 函数（如下图）是逻辑函数的特殊情 况，其公式为 $g\left( z \right)=\frac{1}{1+{ {e}^{-z} } }$。 </p>
<img src="/2024/04/22/13-37-10/2413fbec8ff9fa1f19aaf78265b8a33b_Logistic_function.png" class>
<p>应用 sigmoid 函数，则逻辑回归模型：$$h_{\theta}(x)=g(\theta^Tx) =\frac{1}{1+e^{-\theta^Tx} }$$</p>
<p>逻辑回归模型中，$h_\theta \left( x \right)$ 的作用是，根据输入 $x$ 以及参数 $\theta$，计算得出”输出 $y=1$“的可能性（estimated probability），概率学中表示为：</p>
<p>$$<br>\begin{split}<br>&amp; h_\theta(x) = P(y=1 | x ; \theta) = 1 - P(y=0 | x ; \theta) \\<br>&amp; P(y = 0 | x;\theta) + P(y = 1 | x ; \theta) = 1<br>\end{split}<br>$$<br>以肿瘤诊断为例，$h_\theta \left( x \right)=0.7$ 表示病人有 $70\%$ 的概率得了恶性肿瘤。</p>
<h2 id="6-3-决策边界（Decision-Boundary）"><a href="#6-3-决策边界（Decision-Boundary）" class="headerlink" title="6.3 决策边界（Decision Boundary）"></a>6.3 决策边界（Decision Boundary）</h2><p>决策边界的概念，可帮助我们更好地理解逻辑回归模型的拟合原理。</p>
<p>在逻辑回归中，有假设函数 $h_\theta \left( x \right)=g(z)=g\left(\theta^{T}x \right)$。</p>
<p>为了得出分类的结果，这里和前面一样，规定以 $0.5$ 为阈值：</p>
<p>$$<br>\begin{split}<br>&amp; h_\theta(x) \geq 0.5 \rightarrow y = 1 \\<br>&amp; h_\theta(x) &lt; 0.5 \rightarrow y = 0 \\<br>\end{split}<br>$$<br>回忆一下 sigmoid 函数的图像：</p>
<img src="/2024/04/22/13-37-10/2413fbec8ff9fa1f19aaf78265b8a33b_Logistic_function.png" class>
<p>观察可得当 $g(z) \geq 0.5$ 时，有 $z \geq 0$，即 $\theta^Tx \geq 0$。</p>
<p>同线性回归模型的不同点在于：<br>$$<br>\begin{split}<br>z \to +\infty, e^{-\infty} \to 0 \Rightarrow g(z)=1 \\<br>z \to -\infty, e^{\infty}\to \infty \Rightarrow g(z)=0<br>\end{split}<br>$$<br>直观一点来个例子，${h_\theta}\left( x \right)=g\left( {\theta_0}+{\theta_1}{x_1}+{\theta_{2} }{x_{2} }\right)$ 是下图模型的假设函数：</p>
<img src="/2024/04/22/13-37-10/20180111_000814.png" class>
<p>根据上面的讨论，要进行分类，那么只要 $ {\theta_0}+{\theta_1}{x_1}+{\theta_{2} }{x_{2} }\geq0$ 时，就预测 $y = 1$，即预测为正向类。</p>
<p>如果取 $\theta = \begin{bmatrix} -3\\1\\1\end{bmatrix}$，则有 $z = -3+{x_1}+{x_2}$，当 $z \geq 0$ 即 ${x_1}+{x_2} \geq 3$ 时，易绘制图中的品红色直线即<strong>决策边界</strong>，为正向类（以红叉标注的数据）给出 $y=1$ 的分类预测结果。</p>
<p>上面讨论了逻辑回归模型中线性拟合的例子，下面则是一个多项式拟合的例子，和线性回归中的情况也是类似的。</p>
<p>为了拟合下图数据，建模多项式假设函数：</p>
<p>$$<br>{h_\theta}\left( x \right)=g\left( {\theta_0}+{\theta_1}{x_1}+{\theta_{2} }{x_{2} }+{\theta_{3} }x_{1}^{2}+{\theta_{4} }x_{2}^{2} \right)<br>$$<br>这里取 $\theta = \begin{bmatrix} -1\\0\\0\\1\\1\end{bmatrix}$，决策边界对应了一个在原点处的单位圆（${x_1}^2+{x_2}^2 = 1$），如此便可给出分类结果，如图中品红色曲线：</p>
<img src="/2024/04/22/13-37-10/20180111_000653.png" class>
<p>当然，通过一些更为复杂的多项式，还能拟合那些图像显得非常怪异的数据，使得决策边界形似碗状、爱心状等等。</p>
<p>简单来说，决策边界就是<strong>分类的分界线</strong>。</p>
<h2 id="6-4-代价函数（Cost-Function）"><a href="#6-4-代价函数（Cost-Function）" class="headerlink" title="6.4 代价函数（Cost Function）"></a>6.4 代价函数（Cost Function）</h2><p>那我们怎么知道决策边界是啥样？$\theta$ 多少时能很好的拟合数据？当然，见招拆招，总要来个 $J(\theta)$。</p>
<p>如果直接套用线性回归的代价函数： $J\left( {\theta} \right)=\frac{1}{2m}\sum\limits_{i=1}^{m}{ { {\left( h_{\theta} \left({x}^{\left( i \right)} \right)-{y}^{\left( i \right)} \right)}^{2} } }$</p>
<p>其中 $h_\theta(x) = g\left(\theta^{T}x \right)$，可绘制关于 $J(\theta)$ 的图像，如下图</p>
<img src="/2024/04/22/13-37-10/20180111_080314.png" class>
<p><strong>同济高数教材关于凸函数的定义是反的</strong><br>回忆线性回归中的平方损失函数，其是一个二次凸函数（碗状），二次凸函数的重要性质是只有一个局部最小点即全局最小点。上图中有许多局部最小点，这样将使得梯度下降算法无法确定收敛点是全局最优。</p>
<img src="/2024/04/22/13-37-10/20180111_080514.png" class>
<p>如果此处的损失函数也是一个凸函数，是否也有同样的性质，从而最优化？这类讨论凸函数最优值的问题，被称为<strong>凸优化问题（Convex optimization）</strong>。</p>
<p>当然，损失函数不止平方损失函数一种。</p>
<p>对于逻辑回归，更换平方损失函数为<strong>对数损失函数</strong>，可由统计学中的最大似然估计方法推出代价函数 $J(\theta)$：</p>
<p>$$<br>\begin{split}<br>&amp; J(\theta) = \dfrac{1}{m} \sum_{i=1}^m \mathrm{Cost}(h_\theta(x^{(i)}),y^{(i)}) \\<br>&amp; \mathrm{Cost}(h_\theta(x),y) = -\log(h_\theta(x)) \; &amp; \text{if y = 1} \\<br>&amp; \mathrm{Cost}(h_\theta(x),y) = -\log(1-h_\theta(x)) \; &amp; \text{if y = 0}<br>\end{split}<br>$$<br>则有关于 $J(\theta)$ 的图像如下：</p>
<img src="/2024/04/22/13-37-10/20180111_080614.png" class>
<p>如左图，当训练集的结果为 $y=1$（正样本）时，随着假设函数趋向于 $1$，代价函数的值会趋于 $0$，即意味着拟合程度很好。如果假设函数此时趋于 $0$，则会给出一个<strong>很高的代价</strong>，拟合程度<strong>差</strong>，算法会根据其迅速纠正 $\theta$ 值，右图 $y=0$ 同理。</p>
<p>区别于平方损失函数，对数损失函数也是一个凸函数，但没有局部最优值。</p>
<h2 id="6-5-简化的成本函数和梯度下降（Simplified-Cost-Function-and-Gradient-Descent）"><a href="#6-5-简化的成本函数和梯度下降（Simplified-Cost-Function-and-Gradient-Descent）" class="headerlink" title="6.5 简化的成本函数和梯度下降（Simplified Cost Function and Gradient Descent）"></a>6.5 简化的成本函数和梯度下降（Simplified Cost Function and Gradient Descent）</h2><p>不分类讨论，对于二元分类问题，我们可把代价函数<strong>简化</strong>为一个函数：<br>$Cost\left( {h_\theta}\left( x \right),y \right)=-y\times log\left( {h_\theta}\left( x \right) \right)-(1-y)\times log\left( 1-{h_\theta}\left( x \right) \right)$</p>
<p>成本函数：<br>$J(\theta) = - \frac{1}{m} \displaystyle \sum_{i=1}^m [y^{(i)}\log (h_\theta (x^{(i)})) + (1 - y^{(i)})\log (1 - h_\theta(x^{(i)}))]$</p>
<p>向量化实现：$J(\theta)$应该是一个对角线矩阵</p>
<p>$h = g(X\theta)$，$J(\theta) = \frac{1}{m} \cdot \left(-y^{T}\log(h)-(1-y)^{T}\log(1-h)\right)$</p>
<p>为了最优化 $\theta$，仍使用梯度下降法，算法同线性回归中一致：</p>
<p>$$<br>\begin{split}<br>&amp; \text{Repeat until convergence:} \; \lbrace \\<br>&amp;{ {\theta }_{j} }:={ {\theta }_{j} }-\alpha \frac{\partial }{\partial { {\theta }_{j} } }J\left( {\theta}  \right) \\<br>\rbrace<br>\end{split}<br>$$</p>
<p>解出偏导得：</p>
<p>$$<br>\begin{split}<br>&amp; \text{Repeat until convergence:} \; \lbrace \\<br>&amp; \theta_j := \theta_j - \alpha \frac{1}{m} \sum\limits_{i=1}^{m} (h_\theta(x^{(i)}) - y^{(i)}) \cdot x_j^{(i)} \; &amp; \text{for j := 0,1…n}\\<br>\rbrace<br>\end{split}<br>$$</p>
<p>注意，虽然形式上梯度下降算法同线性回归一样，但其中的假设函不同，即$h_\theta(x) = g\left(\theta^{T}x \right)$，不过求导后的结果也相同。</p>
<p>向量化实现：$\theta := \theta - \frac{\alpha}{m} X^{T} (g(X \theta ) - y)$</p>
<p><strong>逻辑回归中代价函数求导的推导过程：</strong><br>$$<br>J(\theta) = - \frac{1}{m} \displaystyle \sum_{i=1}^m [y^{(i)}\log (h_\theta (x^{(i)})) + (1 - y^{(i)})\log (1 - h_\theta(x^{(i)}))]<br>$$<br>令 $f(\theta) = { {y}^{(i)} }\log \left( {h_\theta}\left( { {x}^{(i)} } \right) \right)+\left( 1-{ {y}^{(i)} } \right)\log \left( 1-{h_\theta}\left( { {x}^{(i)} } \right) \right)$</p>
<p>以及, $h_\theta(x) = g(z)$，$g(z) = \frac{1}{1+e^{(-z)} }$，则</p>
<p>$$<br>\begin{split}<br>f(\theta) &amp;= { {y}^{(i)} }\log \left( \frac{1}{1+{ {e}^{-z} } } \right)+\left( 1-{ {y}^{(i)} } \right)\log \left( 1-\frac{1}{1+{ {e}^{-z} } } \right) \\<br>&amp;= -{ {y}^{(i)} }\log \left( 1+{ {e}^{-z} } \right)-\left( 1-{ {y}^{(i)} } \right)\log \left( 1+{ {e}^{z} } \right)<br>\end{split}<br>$$</p>
<p>以及，$z=\theta^Tx^{(i)}$，对 $\theta_j$ 求偏导，则没有 $\theta_j$ 的项求偏导即为 $0$，都消去，则得：</p>
<p>$$<br>\frac{\partial z}{\partial {\theta_{j} } }=\frac{\partial }{\partial {\theta_{j} } }\left( \theta^Tx^{(i)}  \right)=x^{(i)}_j<br>$$<br>所以有：</p>
<p>$$<br>\begin{split}<br>\frac{\partial }{\partial {\theta_{j} } }f\left( \theta  \right)&amp;=\frac{\partial }{\partial {\theta_{j} } }[-{ {y}^{(i)} }\log \left( 1+{ {e}^{-z} } \right)-\left( 1-{ {y}^{(i)} } \right)\log \left( 1+{ {e}^{z} } \right)] \\<br>&amp;=-{ {y}^{(i)} }\frac{\frac{\partial }{\partial {\theta_{j} } }\left(-z \right) e^{-z} }{1+e^{-z} }-\left( 1-{ {y}^{(i)} } \right)\frac{\frac{\partial }{\partial {\theta_{j} } }\left(z \right){e^{z} } }{1+e^{z} } \\<br>&amp;=-{ {y}^{(i)} }\frac{-x^{(i)}_je^{-z} }{1+e^{-z} }-\left( 1-{ {y}^{(i)} } \right)\frac{x^{(i)}_j}{1+e^{-z} } \\<br>&amp;=\left({ {y}^{(i)} }\frac{e^{-z} }{1+e^{-z} }-\left( 1-{ {y}^{(i)} } \right)\frac{1}{1+e^{-z} }\right)x^{(i)}_j \\<br>&amp;=\left({ {y}^{(i)} }\frac{e^{-z} }{1+e^{-z} }-\left( 1-{ {y}^{(i)} } \right)\frac{1}{1+e^{-z} }\right)x^{(i)}_j \\<br>&amp;=\left(\frac{ { {y}^{(i)} }(e^{-z}+1)-1}{1+e^{-z} }\right)x^{(i)}_j \\<br>&amp;={({ {y}^{(i)} }-\frac{1}{1+{ {e}^{-z} } })x_j^{(i)} } \\<br>&amp;={\left({ {y}^{(i)} }-{h_\theta}\left( { {x}^{(i)} } \right)\right)x_j^{(i)} } \\<br>&amp;=-{\left({h_\theta}\left( { {x}^{(i)} } \right)-{ {y}^{(i)} }\right)x_j^{(i)} }<br>\end{split}<br>$$</p>
<p>则可得代价函数的导数：</p>
<p>$$<br>\frac{\partial }{\partial {\theta_{j} } }J(\theta) = -\frac{1}{m}\sum\limits_{i=1}^{m}{\frac{\partial }{\partial {\theta_{j} } }f(\theta)}=\frac{1}{m} \sum\limits_{i=1}^{m} (h_\theta(x^{(i)}) - y^{(i)}) \cdot x_j^{(i)}<br>$$</p>
<h2 id="6-6-进阶优化（Advanced-Optimization）"><a href="#6-6-进阶优化（Advanced-Optimization）" class="headerlink" title="6.6 进阶优化（Advanced Optimization）"></a>6.6 进阶优化（Advanced Optimization）</h2><p>我们编写代码给出代价函数及其偏导数然后传入梯度下降算法中，接下来算法则会为我们最小化代价函数给出参数的最优解。这类算法被称为<strong>最优化算法（Optimization Algorithms）</strong>，梯度下降算法不是唯一的最小化算法。</p>
<p>一些最优化算法：</p>
<ul>
<li>梯度下降法（Gradient Descent）</li>
<li>共轭梯度算法（Conjugate gradient）</li>
<li>牛顿法和拟牛顿法（Newton’s method &amp; Quasi-Newton Methods）<ul>
<li>DFP算法</li>
<li>局部优化法（BFGS）</li>
<li>有限内存局部优化法（L-BFGS）</li>
</ul>
</li>
<li>拉格朗日乘数法（Lagrange multiplier）</li>
</ul>
<p>比较梯度下降算法：一些最优化算法虽然会更为复杂，难以调试，不过这些算法通常效率更高，并无需选择学习速率 $\alpha$。</p>
<p>Octave/Matlab 中对这类高级算法做了封装，易于调用。</p>
<p>假设有 $J(\theta) = (\theta_1-5)^2 + (\theta_2-5)^2$，要求参数 $\theta=\begin{bmatrix} \theta_1\\\theta_2\end{bmatrix}$的最优值。</p>
<p>下面为 Octave/Matlab 求解最优化问题的代码实例：</p>
<ol>
<li>创建一个函数以返回代价函数及其偏导数：</li>
</ol>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[jVal, gradient]</span> = <span class="title">costFunction</span><span class="params">(theta)</span></span></span><br><span class="line">  <span class="comment">% code to compute J(theta)</span></span><br><span class="line">  jVal=(theta(<span class="number">1</span>)<span class="number">-5</span>)^<span class="number">2</span>+(theta(<span class="number">2</span>)<span class="number">-5</span>)^<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">% code to compute derivative of J(theta)</span></span><br><span class="line">  gradient=<span class="built_in">zeros</span>(<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">  </span><br><span class="line">  gradient(<span class="number">1</span>)=<span class="number">2</span>*(theta(<span class="number">1</span>)<span class="number">-5</span>);</span><br><span class="line">  gradient(<span class="number">2</span>)=<span class="number">2</span>*(theta(<span class="number">2</span>)<span class="number">-5</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ol>
<li>将 <code>costFunction</code> 函数及所需参数传入最优化函数 <code>fminunc</code>，以求解最优化问题：</li>
</ol>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">options = optimset(<span class="string">&#x27;GradObj&#x27;</span>, <span class="string">&#x27;on&#x27;</span>, <span class="string">&#x27;MaxIter&#x27;</span>, <span class="number">100</span>);</span><br><span class="line">initialTheta = <span class="built_in">zeros</span>(<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">   [optTheta, functionVal, exitFlag] = fminunc(@costFunction, initialTheta, options);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>&#39;GradObj&#39;, &#39;on&#39;</code>: 启用梯度目标参数（则需要将梯度传入算法）</p>
<p><code>&#39;MaxIter&#39;, 100</code>: 最大迭代次数为 100 次</p>
<p><code>@xxx</code>: Octave/Matlab 中的函数指针</p>
<p><code>optTheta</code>: 最优化得到的参数向量</p>
<p><code>functionVal</code>: 引用函数最后一次的返回值</p>
<p><code>exitFlag</code>: 标记代价函数是否收敛</p>
</blockquote>
<p>注：Octave/Matlab 中可以使用 <code>help fminunc</code> 命令随时查看函数的帮助文档。</p>
<ol>
<li>返回结果</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">optTheta =</span><br><span class="line"></span><br><span class="line">     5</span><br><span class="line">     5</span><br><span class="line"></span><br><span class="line">functionVal = 0</span><br><span class="line"></span><br><span class="line">exitFlag = 1</span><br></pre></td></tr></table></figure>
<h2 id="6-7-多类别分类-一对多（Multiclass-Classification-One-vs-all）"><a href="#6-7-多类别分类-一对多（Multiclass-Classification-One-vs-all）" class="headerlink" title="6.7 多类别分类: 一对多（Multiclass Classification: One-vs-all）"></a>6.7 多类别分类: 一对多（Multiclass Classification: One-vs-all）</h2><p>一直在讨论二元分类问题，这里谈谈多类别分类问题（比如天气预报）。</p>
<img src="/2024/04/22/13-37-10/20180112_001720.png" class>
<p>原理是，转化多类别分类问题为<strong>多个二元分类问题</strong>，这种方法被称为 One-vs-all。</p>
<p>正式定义：$h_\theta^{\left( i \right)}\left( x \right)=p\left( y=i|x;\theta  \right), i=\left( 1,2,3….k \right)$</p>
<blockquote>
<p>$h_\theta^{\left( i \right)}\left( x \right)$: 输出 $y=i$（属于第 $i$ 个分类）的可能性</p>
<p>$k$: 类别总数，如上图 $k=3$。</p>
</blockquote>
<p>注意多类别分类问题中 $h_\theta(x)$ 的结果不再只是一个实数而是一个向量，如果类别总数为 $k$，现在 $h_\theta(x)$ 就是一个 $k$ 维向量。</p>
<p>对于某个样本实例，需计算所有的 $k$ 种分类情况得到 $h_\theta(x)$，然后看分为哪个类别时预测输出的值最大，就说它输出属于哪个类别，即 $y = \mathop{\max}\limits_i\,h_\theta^{\left( i \right)}\left( x \right)$。</p>
<h1 id="7-正则化（Regularization）"><a href="#7-正则化（Regularization）" class="headerlink" title="7 正则化（Regularization）"></a>7 正则化（Regularization）</h1><h2 id="7-1-过拟合问题（The-Problem-of-Overfitting）"><a href="#7-1-过拟合问题（The-Problem-of-Overfitting）" class="headerlink" title="7.1 过拟合问题（The Problem of Overfitting）"></a>7.1 过拟合问题（The Problem of Overfitting）</h2><p>对于拟合的表现，可以分为三类情况：</p>
<ul>
<li><p><strong>欠拟合（Underfitting）</strong></p>
<p>无法很好的拟合训练集中的数据，预测值和实际值的误差很大，这类情况被称为欠拟合。拟合模型比较简单（特征选少了）时易出现这类情况。</p>
</li>
<li><p><strong>优良的拟合（Just right）</strong></p>
<p>不论是训练集数据还是不在训练集中的预测数据，都能给出较为正确的结果。</p>
</li>
<li><p><strong>过拟合（Overfitting）</strong></p>
<p>能很好甚至完美拟合训练集中的数据，即 $J(\theta) \to 0$，但是对于不在训练集中的<strong>新数据</strong>，预测值和实际值的误差会很大，<strong>泛化能力弱</strong>，这类情况被称为过拟合。拟合模型过于复杂（特征选多了）时易出现这类情况。</p>
</li>
</ul>
<p>线性模型中的拟合情况（左图欠拟合，右图过拟合）：<br><img src="/2024/04/22/13-37-10/20180112_091654.png" class></p>
<p>逻辑分类模型中的拟合情况：<br><img src="/2024/04/22/13-37-10/20180112_092027.png" class></p>
<p>为了度量拟合表现，引入：</p>
<ul>
<li><p>偏差（bias）</p>
<p>指模型的预测值与真实值的<strong>偏离程度</strong>。偏差越大，预测值偏离真实值越厉害。偏差低意味着能较好地反应训练集中的数据情况。</p>
</li>
<li><p>方差（Variance）</p>
<p>指模型预测值的<strong>离散程度或者变化范围</strong>。方差越大，数据的分布越分散，函数波动越大，泛化能力越差。方差低意味着拟合曲线的稳定性高，波动小。</p>
</li>
</ul>
<p>据此，我们有对同一数据的各类拟合情况如下图：<br><img src="/2024/04/22/13-37-10/20180112_085630.png" class></p>
<p>据上图，高偏差意味着欠拟合，高方差意味着过拟合。</p>
<p>我们应尽量使得拟合模型处于低方差（较好地拟合数据）状态且同时处于低偏差（较好地预测新值）的状态。</p>
<p>避免过拟合的方法有：</p>
<ul>
<li>减少特征的数量<ul>
<li>手动选取需保留的特征</li>
<li>使用模型选择算法来选取合适的特征（如 PCA 算法）</li>
<li>减少特征的方式易丢失有用的特征信息</li>
</ul>
</li>
<li>正则化（Regularization）<ul>
<li>可保留所有参数（许多有用的特征都能轻微影响结果）</li>
<li>减少/惩罚各参数大小（magnitude），以减轻各参数对模型的影响程度</li>
<li>当有很多参数对于模型只有轻微影响时，正则化方法的表现很好</li>
</ul>
</li>
</ul>
<h2 id="7-2-代价函数（Cost-Function）"><a href="#7-2-代价函数（Cost-Function）" class="headerlink" title="7.2 代价函数（Cost Function）"></a>7.2 代价函数（Cost Function）</h2><p>很多时候由于特征数量过多，过拟合时我们很难选出要保留的特征，这时候应用正则化方法则是很好的选择。</p>
<p>上文中，$\theta_0 + \theta_1x + \theta_2x^2 + \theta_3x^3 + \theta_4x^4$ 这样一个复杂的多项式较易过拟合，在不减少特征的情况下，<strong>如果能消除类似于 $\theta_3x^3$、$\theta_4x^4$ 等复杂部分，那复杂函数就变得简单了</strong>。</p>
<p>为了保留各个参数的信息，不修改假设函数，改而修改代价函数：</p>
<ul>
<li>消除方式为如果使代价函数足够小，$\lambda$等于1000时，$\theta_3$就需要约等于0，消除了这个特征的影响。</li>
</ul>
<p>$$<br>min_\theta\ \dfrac{1}{2m}\sum_{i=1}^m (h_\theta(x^{(i)}) - y^{(i)})^2 + 1000\cdot\theta_3^2 + 1000\cdot\theta_4^2<br>$$</p>
<p>上式中，我们在代价函数中增加了 $\theta_3$、$\theta_4$ 的惩罚项（penalty term）$1000\cdot\theta_3^2 + 1000\cdot\theta_4^2$，如果要最小化代价函数，那么势必需要极大地<strong>减小 $\theta_3$、$\theta_4$</strong>，从而使得假设函数中的 $\theta_3x^3$、$\theta_4x^4$ 这两项的参数非常小，就相当于没有了，假设函数也就<strong>变得简单</strong>了，从而在保留各参数的情况下避免了过拟合问题。</p>
<img src="/2024/04/22/13-37-10/20180114_090054.png" class>
<p>根据上面的讨论，有时也无法决定要减少哪个参数，故统一惩罚除了 $\theta_0$ 外的所有参数。</p>
<p>代价函数：</p>
<p>$$<br>J\left( \theta  \right)=\frac{1}{2m}[\sum\limits_{i=1}^{m}{ { {({h_\theta}({ {x}^{(i)} })-{ {y}^{(i)} })}^{2} }+\lambda \sum\limits_{j=1}^{n}{\theta_{j}^{2} }]}<br>$$</p>
<blockquote>
<p>$\lambda$: 正则化参数（Regularization Parameter），$\lambda &gt; 0$</p>
<p>$\sum\limits_{j=1}^{n}$: 不惩罚基础参数 $\theta_0$</p>
<p>$\lambda \sum\limits_{j=1}^{n}{\theta_{j}^{2} }$: 正则化项</p>
</blockquote>
<p>$\lambda$ 正则化参数类似于学习速率，也需要我们自行对其选择一个合适的值。</p>
<ul>
<li>过大<ul>
<li>导致模型欠拟合（假设可能会变成近乎 $x = \theta_0$ 的直线）</li>
<li>无法正常去过拟问题</li>
<li>梯度下降可能无法收敛</li>
</ul>
</li>
<li>过小<ul>
<li>无法避免过拟合（等于没有）</li>
</ul>
</li>
</ul>
<blockquote>
<p>正则化符合奥卡姆剃刀（Occam’s razor）原理。在所有可能选择的模型中，能够很好地解释已知数据并且十分简单才是最好的模型，也就是应该选择的模型。从贝叶斯估计的角度来看，正则化项对应于模型的先验概率。可以假设复杂的模型有较大的先验概率，简单的模型有较小的先验概率。</p>
<p>正则化是结构风险最小化策略的实现，是去过拟合问题的典型方法，虽然看起来多了个一参数多了一重麻烦，后文会介绍自动选取正则化参数的方法。模型越复杂，正则化参数值就越大。比如，正则化项可以是模型参数向量的范数。</p>
</blockquote>
<h2 id="7-3-线性回归正则化（Regularized-Linear-Regression）"><a href="#7-3-线性回归正则化（Regularized-Linear-Regression）" class="headerlink" title="7.3 线性回归正则化（Regularized Linear Regression）"></a>7.3 线性回归正则化（Regularized Linear Regression）</h2><p>应用正则化的线性回归梯度下降算法：</p>
<p>$$<br>\begin{split}<br>&amp; \text{Repeat}\ \lbrace \\<br>&amp; \ \ \ \ \theta_0 := \theta_0 - \alpha\ \frac{1}{m}\ \sum_{i=1}^m (h_\theta(x^{(i)}) - y^{(i)})x_0^{(i)} \\<br>&amp; \ \ \ \ \theta_j := \theta_j - \alpha\ \left[ \left( \frac{1}{m}\ \sum_{i=1}^m (h_\theta(x^{(i)}) - y^{(i)})x_j^{(i)} \right) + \frac{\lambda}{m}\theta_j \right], \ \ \ j \in \lbrace 1,2…n\rbrace\\<br>&amp; \rbrace<br>\end{split}<br>$$<br>也可以移项得到更新表达式的另一种表示形式</p>
<p>$$<br>\theta_j := \theta_j(1 - \alpha\frac{\lambda}{m}) - \alpha\frac{1}{m}\sum_{i=1}^m(h_\theta(x^{(i)}) - y^{(i)})x_j^{(i)}<br>$$</p>
<blockquote>
<p>$\frac{\lambda}{m}\theta_j$: 正则化项</p>
</blockquote>
<p>应用正则化的正规方程法：</p>
<p>$$<br>\begin{split}<br>&amp; \theta = \left( X^TX + \lambda \cdot L \right)^{-1} X^Ty \\<br>&amp; \text{where}\ \ L = \begin{bmatrix} 0 &amp; &amp; &amp; &amp; \\<br>&amp; 1 &amp; &amp; &amp; \\<br>&amp; &amp; 1 &amp; &amp; \\<br>&amp; &amp; &amp; \ddots &amp; \\<br>&amp; &amp; &amp; &amp; 1 \\ \end{bmatrix}<br>\end{split}<br>$$</p>
<blockquote>
<p>$\lambda\cdot L$: 正则化项</p>
<p>$L$: 第一行第一列为 $0$ 的 $n+1$ 维单位矩阵</p>
</blockquote>
<p>Octave 代码：<br><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; L = <span class="built_in">eye</span>(<span class="number">5</span>)</span><br><span class="line">&gt;&gt; L(<span class="number">1</span>,<span class="number">1</span>) = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">L =</span><br><span class="line"></span><br><span class="line">     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">1</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span>     <span class="number">0</span></span><br><span class="line">     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>前文提到正则化可以解决正规方程法中不可逆的问题，即增加了 $\lambda \cdot L$ 正则化项后，可以保证 $X^TX + \lambda \cdot L$ 可逆（invertible），即便 $X^TX$ 不可逆（non-invertible）。 </p>
<h2 id="7-4-逻辑回归正则化（Regularized-Logistic-Regression）"><a href="#7-4-逻辑回归正则化（Regularized-Logistic-Regression）" class="headerlink" title="7.4 逻辑回归正则化（Regularized Logistic Regression）"></a>7.4 逻辑回归正则化（Regularized Logistic Regression）</h2><p>为逻辑回归的代价函数添加正则化项：</p>
<p>$$<br>J(\theta) = - \frac{1}{m} \sum_{i=1}^m \large[ y^{(i)}\ \log (h_\theta (x^{(i)})) + (1 - y^{(i)})\ \log (1 - h_\theta(x^{(i)}))\large] + \frac{\lambda}{2m}\sum_{j=1}^n \theta_j^2<br>$$<br>前文已经证明过逻辑回归和线性回归的代价函数的求导结果是一样的，此处通过给正则化项添加常数 $\frac{1}{2}$，则其求导结果也就一样了。</p>
<p>从而有应用正则化的逻辑回归梯度下降算法：</p>
<p>$$<br>\begin{split}<br>&amp; \text{Repeat}\ \lbrace \\<br>&amp; \ \ \ \ \theta_0 := \theta_0 - \alpha\ \frac{1}{m}\ \sum_{i=1}^m (h_\theta(x^{(i)}) - y^{(i)})x_0^{(i)} \\<br>&amp; \ \ \ \ \theta_j := \theta_j - \alpha\ \left[ \left( \frac{1}{m}\ \sum_{i=1}^m (h_\theta(x^{(i)}) - y^{(i)})x_j^{(i)} \right) + \frac{\lambda}{m}\theta_j \right], \ \ \ j \in \lbrace 1,2…n\rbrace\\<br>&amp; \rbrace \end{split}<br>$$</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习, 深度学习, 吴恩达</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习笔记二 多变量线性回归</title>
    <url>/2024/04/21/07-10-14/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.04.21：初稿</li>
</ul>
<h1 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h1><ul>
<li><a href="/2024/04/18/15-40-33/" title="机器笔记汇总">吴恩达机器学习 - 笔记汇总</a>
</li>
</ul>
<h1 id="4-多变量线性回归（Linear-Regression-with-Multiple-Variables）"><a href="#4-多变量线性回归（Linear-Regression-with-Multiple-Variables）" class="headerlink" title="4 多变量线性回归（Linear Regression with Multiple Variables）"></a>4 多变量线性回归（Linear Regression with Multiple Variables）</h1><h2 id="4-1-多特征（Multiple-Features）"><a href="#4-1-多特征（Multiple-Features）" class="headerlink" title="4.1 多特征（Multiple Features）"></a>4.1 多特征（Multiple Features）</h2><p>不同维度的多个特征。</p>
<img src="/2024/04/21/07-10-14/20180107_234509.png" class>
<p>这里由于特征不再只有一个，引入一些新的记号</p>
<blockquote>
<p>$n$: 特征的总数</p>
<p> ${x}^{\left( i \right)}$: 代表样本矩阵中第 $i$ 行，也就是第 $i$ 个训练实例。</p>
<p> ${x}_{j}^{\left( i \right)}$: 代表样本矩阵中第 $i$ 行的第 $j$ 列，也就是第 $i$ 个训练实例的第 $j$ 个特征。</p>
</blockquote>
<p>参照上图，则有 ${x}^{(2)}\text{=}\begin{bmatrix} 1416\\\ 3\\\ 2\\\ 40 \end{bmatrix}, {x}^{(2)}_{1} = 1416$</p>
<blockquote>
<p>全部写成一维向量</p>
</blockquote>
<p>多变量假设函数 $h$ 表示为：$h_{\theta}\left( x \right)={\theta_{0} }+{\theta_{1} }{x_{1} }+{\theta_{2} }{x_{2} }+…+{\theta_{n} }{x_{n} }$</p>
<p>对于 $\theta_0$，和单特征中一样，我们将其看作基础数值。</p>
<p>$$<br>h_\theta\left(x\right)=\begin{bmatrix}\theta_0\; \theta_1\; … \;\theta_n \end{bmatrix}\begin{bmatrix}x_0 \newline x_1 \newline \vdots \newline x_n\end{bmatrix}= \theta^T x<br>$$</p>
<blockquote>
<p>$\theta^T$: $\theta$ 矩阵的转置</p>
<p>$x$: 某个样本的特征向量，$n+1$ 维特征量向量</p>
<p>$x_0$: 为了计算方便我们会假设 $x_0^{(i)} = 1$</p>
</blockquote>
<h2 id="4-2-多变量梯度下降（Gradient-Descent-for-Multiple-Variables）"><a href="#4-2-多变量梯度下降（Gradient-Descent-for-Multiple-Variables）" class="headerlink" title="4.2 多变量梯度下降（Gradient Descent for Multiple Variables）"></a>4.2 多变量梯度下降（Gradient Descent for Multiple Variables）</h2><p>多变量代价函数类似于单变量代价函数，</p>
<p>即 $J\left( {\theta_{0} },{\theta_{1} }…{\theta_{n} } \right)=\frac{1}{2m}\sum\limits_{i=1}^{m}{ { {\left( h_{\theta} \left({x}^{\left( i \right)} \right)-{y}^{\left( i \right)} \right)}^{2} } }$ ，其中 $h_\theta\left(x\right)= \theta^T x$。</p>
<p>前文提到梯度下降对于最小化代价函数的通用性，则多变量梯度下降公式即</p>
<p>\begin{split}<br>&amp; \text{Repeat until convergence:} \; \lbrace \\<br>&amp;{ {\theta }_{j} }:={ {\theta }_{j} }-\alpha \frac{\partial }{\partial { {\theta }_{j} } }J\left( {\theta_{0} },{\theta_{1} }…{\theta_{n} }  \right) \\<br>\rbrace<br>\end{split}</p>
<p>解出偏导得：</p>
<p>\begin{split}<br>&amp; \text{repeat until convergence:} \; \lbrace \\<br>&amp; \theta_j := \theta_j - \alpha \frac{1}{m} \sum\limits_{i=1}^{m} (h_\theta(x^{(i)}) - y^{(i)}) \cdot x_j^{(i)} \; &amp; \text{for j := 0,1…n}\\<br>\rbrace<br>\end{split}</p>
<p>可展开为：</p>
<p>\begin{split}<br>&amp; \text{repeat until convergence:} \; \lbrace \\<br>&amp; \theta_0 := \theta_0 - \alpha \frac{1}{m} \sum\limits_{i=1}^{m} (h_\theta(x^{(i)}) - y^{(i)}) \cdot x_0^{(i)}\\<br>&amp; \theta_1 := \theta_1 - \alpha \frac{1}{m} \sum\limits_{i=1}^{m} (h_\theta(x^{(i)}) - y^{(i)}) \cdot x_1^{(i)} \\<br>&amp; \theta_2 := \theta_2 - \alpha \frac{1}{m} \sum\limits_{i=1}^{m} (h_\theta(x^{(i)}) - y^{(i)}) \cdot x_2^{(i)} \\<br>&amp; \vdots \\<br>&amp; \theta_n := \theta_n - \alpha \frac{1}{m} \sum\limits_{i=1}^{m} (h_\theta(x^{(i)}) - y^{(i)}) \cdot x_n^{(i)} &amp;\\<br>\rbrace<br>\end{split}</p>
<p>当然，同单变量梯度下降一样，计算时需要<strong>同时更新</strong>所有参数。</p>
<p>$h_\theta\left(x\right)= \theta^T x$，则得到同时更新参数的向量化（Vectorization）实现：<br>$$<br>\theta = \theta - \alpha \frac{1}{m}(X^T(X\theta-y))<br>$$</p>
<p><strong>向量化推导过程：</strong></p>
<p>\begin{split}<br>&amp;X = \begin{bmatrix}{ {x}^{(0)} } ^ T \newline { {x}^{(1)} } ^ T \newline \vdots \newline { {x}^{(m)} } ^ T\ \end{bmatrix}<br>&amp;X^T = \begin{bmatrix}{x}^{(0)}\; {x}^{(1)}\; … \;{x}^{(m)} \end{bmatrix}<br>\\<br>&amp;X\theta - y = \begin{bmatrix}{ {x}^{(0)} } ^ T \theta - y\newline { {x}^{(1)} } ^ T \theta -y \newline \vdots \newline { {x}^{(m)} } ^ T\theta -y\ \end{bmatrix} \\<br>&amp;h_\theta\left(x\right)= X\theta<br>\end{split}</p>
<blockquote>
<p>$X$: 是一个秩为1的矩阵？  一次更新一个相同的特征向量？？<br>$X$: 训练集数据，$m\times(n+1)$ 维矩阵（包含基本特征 $x_0=1$）</p>
</blockquote>
<h2 id="4-3-梯度下降实践1-特征值缩放（Gradient-Descent-in-Practice-I-Feature-Scaling）"><a href="#4-3-梯度下降实践1-特征值缩放（Gradient-Descent-in-Practice-I-Feature-Scaling）" class="headerlink" title="4.3 梯度下降实践1-特征值缩放（Gradient Descent in Practice I - Feature Scaling）"></a>4.3 梯度下降实践1-特征值缩放（Gradient Descent in Practice I - Feature Scaling）</h2><p>在应用梯度下降算法实践时，由于各特征值的范围不一，可能会影响代价函数收敛速度。</p>
<p>房屋面积大小和房间数量这两个特征。</p>
<img src="/2024/04/21/07-10-14/20180108_100751.png" class>
<p>为了优化梯度下降的收敛速度，采用特征缩放的技巧，使各特征值的<strong>范围尽量一致</strong>。</p>
<p>除了以上图人工选择并除以一个参数的方式，<strong>均值归一化（Mean normalization</strong>方法更为便捷，可采用它来对所有特征值统一缩放：</p>
<p> $x_i:=\frac{x_i-average(x)}{maximum(x)-minimum(x)}$, 使得  $x_i \in (-1,1)$</p>
<p>对于特征的范围，并不一定需要使得 $-1 \leqslant x \leqslant 1$，类似于 $1\leqslant x \leqslant 3$ 等也是可取的，而诸如 $-100 \leqslant x \leqslant 100 $，$-0.00001 \leqslant x \leqslant 0.00001$，就显得过大/过小了。</p>
<p>另外注意，一旦采用特征缩放，我们就需对所有的输入采用特征缩放，包括训练集、测试集、预测输入等。</p>
<h2 id="4-4-梯度下降实践2-学习速率（Gradient-Descent-in-Practice-II-Learning-Rate）"><a href="#4-4-梯度下降实践2-学习速率（Gradient-Descent-in-Practice-II-Learning-Rate）" class="headerlink" title="4.4 梯度下降实践2-学习速率（Gradient Descent in Practice II - Learning Rate）"></a>4.4 梯度下降实践2-学习速率（Gradient Descent in Practice II - Learning Rate）</h2><p>通常，有两种方法来确定函数是否收敛</p>
<ul>
<li>多次迭代收敛法<ul>
<li>无法确定需要多少次迭代</li>
<li>较易绘制关于迭代次数的图像</li>
<li>根据图像易预测所需的迭代次数</li>
</ul>
</li>
<li>自动化测试收敛法（比较阈值）<ul>
<li>不易选取阈值</li>
<li>代价函数近乎直线时无法确定收敛情况</li>
</ul>
</li>
</ul>
<p>对于梯度下降，一般采用多次迭代收敛法来得出最小化代价函数的参数值，自动化测试收敛法（如设定 $J\left(\theta\right) &lt; {10}^{-3}$ 时判定收敛）则几乎不会被使用。</p>
<p>我们可以通过绘制<strong>代价函数关于迭代次数的图像</strong>，可视化梯度下降的执行过程，借助直观的图形来发现代价函数趋向于多少时能趋于收敛，依据图像变化情况，确定诸如学习速率的取值，迭代次数的大小等问题。</p>
<img src="/2024/04/21/07-10-14/20180108_103357.png" class>
<p>对于学习速率 $\alpha$，一般上图展现的为适中情况，下图中，左图可能表明 <strong>$\alpha$ 过大</strong>，代价函数<strong>无法收敛</strong>，右图可能表明 <strong>$\alpha$ 过小</strong>，代价函数<strong>收敛的太慢</strong>。当然，$\alpha$ 足够小时，代价函数在每轮迭代后一定会减少。</p>
<img src="/2024/04/21/07-10-14/20180108_104701.png" class>
<p>通过不断改变 $\alpha$ 值，绘制并观察图像，并以此来确定合适的学习速率。 尝试时可取 $\alpha$ 如 $\dots\;0,001,\;0.003,\;0.01,\;0.03,\;0.1,\;\dots$</p>
<h2 id="4-5-特征和多项式回归（Features-and-Polynomial-Regression）"><a href="#4-5-特征和多项式回归（Features-and-Polynomial-Regression）" class="headerlink" title="4.5 特征和多项式回归（Features and Polynomial Regression）"></a>4.5 特征和多项式回归（Features and Polynomial Regression）</h2><p>在特征选取时，我们也可以自己归纳总结，定义一个新的特征，用来<strong>取代或拆分</strong>旧的一个或多个特征。比如，对于房屋面积特征来说，我们可以将其拆分为长度和宽度两个特征，反之，我们也可以合并长度和宽度这两个特征为面积这一个特征。</p>
<p>线性回归只能以直线来对数据进行拟合，有时候需要使用<strong>曲线</strong>来对数据进行拟合，即<strong>多项式回归（Polynomial Regression）</strong>。</p>
<p>比如一个二次方模型：$h_{\theta}\left( x \right)={\theta_{0} }+{\theta_{1} }{x_{1} }+{\theta_{2} }{x_{2}^2}$</p>
<p>或者三次方模型：$h_{\theta}\left( x \right)={\theta_{0} }+{\theta_{1} }{x_{1} }+{\theta_{2} }{x_{2}^2}+{\theta_{3} }{x_{3}^3}$ </p>
<p>或者平方根模型： $h_{\theta}\left( x \right)={\theta_{0} }+{\theta_{1} }{x_{1} }+{\theta_{2} }{x_{2}^2}+{\theta_{3} }{\sqrt{x_3} }$</p>
<img src="/2024/04/21/07-10-14/20180108_113132.png" class>
<p>在使用多项式回归时，要记住非常有必要进行特征缩放，比如 $x_1$ 的范围为 1-1000，那么 $x_1^2$ 的范围则为 1- 1000000，不使用特征缩放的话，范围不一致，也更易影响效率。</p>
<blockquote>
<p>多特征下的特征值缩放按照$x$还是$x^3$ ？</p>
</blockquote>
<h2 id="4-6-正规方程（Normal-Equation）"><a href="#4-6-正规方程（Normal-Equation）" class="headerlink" title="4.6 正规方程（Normal Equation）"></a>4.6 正规方程（Normal Equation）</h2><p>对于一些线性回归问题来说，正规方程法给出了一个更好的解决问题的方式。</p>
<p>正规方程法，即令 $\frac{\partial}{\partial{\theta_{j} } }J\left( {\theta_{j} } \right)=0$ ，通过解析函数的方式直接计算得出参数向量的值  $\theta ={ {\left( {X^T}X \right)}^{-1} }{X^{T} }y$ ，Octave/Matlab 代码： <code>theta = inv(X&#39;*X)*X&#39;*y</code>。</p>
<blockquote>
<p>${X}^{-1}$: 矩阵 $X$ 的逆，在 Octave 中，<code>inv</code> 函数用于计算矩阵的逆，类似的还有 <code>pinv</code> 函数。</p>
<p><code>X&#39;</code>: 在 Octave 中表示矩阵 X 的转置，即 $X^T$</p>
</blockquote>
<p>下表列出了正规方程法与梯度下降算法的对比</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>条件</th>
<th>梯度下降</th>
<th>正规方程</th>
</tr>
</thead>
<tbody>
<tr>
<td>是否需要选取 $\alpha$</td>
<td>需要</td>
<td>不需要</td>
</tr>
<tr>
<td>是否需要迭代运算</td>
<td>需要</td>
<td>不需要</td>
</tr>
<tr>
<td>特征量大时</td>
<td>适用，$O\left(kn^2\right)$</td>
<td>不适用，$(X^TX)^{-1}$ 复杂度 $O\left( { {n}^{3} } \right)$</td>
</tr>
<tr>
<td>适用范围</td>
<td>各类模型</td>
<td>只适用线性模型，且矩阵需可逆</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>一般来说，当 $n$ 超过 10000 时，对于正规方程而言，特征量较大。</li>
<li>梯度下降算法的普适性好，而对于特定的线性回归模型，正规方程是很好的替代品。</li>
</ul>
<p><strong>正规方程法的推导过程</strong>：(同4.2)</p>
<p>\begin{split}<br>J\left( \theta  \right)&amp; =\frac{1}{2m}\sum\limits_{i=1}^{m}{ { {\left( {h_{\theta} }\left( {x^{(i)} } \right)-{y^{(i)} } \right)}^{2} } }\\<br>&amp; =\frac{1}{2m}||X\theta-y||^2 \\<br>&amp; =\frac{1}{2m}(X\theta-y)^T(X\theta-y) \hspace{15cm}<br>\end{split}</p>
<p>展开上式可得</p>
<p>$<br>(X\theta-y)^T = \theta^T X^T - y^T<br>$</p>
<p>$J(\theta )= \frac{1}{2m}\left( { {\theta }^{T} }{ {X}^{T} }X\theta -{ {\theta}^{T} }{ {X}^{T} }y-{ {y}^{T} }X\theta + { {y}^{T} }y \right)$</p>
<p>注意到 ${ {\theta}^{T} }{ {X}^{T} }y$ 与 ${ {y}^{T} }X\theta$ 都为标量，实际上是等价的，则：</p>
<p>$J(\theta) = \frac{1}{2m}[{\theta }^{T}X^TX\theta-2\theta^TX^Ty+y^Ty]$</p>
<p>接下来对$J(\theta )$ 求偏导，根据矩阵的求导法则:</p>
<p>$\frac{d X^TAX}{d X}=2AX$</p>
<p>$\frac{d X^T}{d X}={E}$</p>
<p>$\frac{d AB}{d B}={A^T}$</p>
<p>所以有:</p>
<p>$\frac{\partial J\left( \theta  \right)}{\partial \theta }=\frac{1}{2m}\left(2{ {X}^{T} }X\theta -2{ {X}^{T} }y \right)={ {X}^{T} }X\theta -{ {X}^{T} }y$</p>
<p>令$\frac{\partial J\left( \theta  \right)}{\partial \theta }=0$, 则有<br>$$<br>\theta ={ {\left( {X^{T} }X \right)}^{-1} }{X^{T} }y<br>$$</p>
<blockquote>
<p>求最小值, 极值一定是最小值, 具有实际意义</p>
</blockquote>
<h2 id="4-7-不可逆性正规方程（Normal-Equation-Noninvertibility）"><a href="#4-7-不可逆性正规方程（Normal-Equation-Noninvertibility）" class="headerlink" title="4.7 不可逆性正规方程（Normal Equation Noninvertibility）"></a>4.7 不可逆性正规方程（Normal Equation Noninvertibility）</h2><p>（本部分内容为选讲）</p>
<p>正规方程无法应用于不可逆的矩阵，发生这种问题的概率很小，通常由于</p>
<ul>
<li><p>特征之间线性相关</p>
<p>比如同时包含英寸的尺寸和米为单位的尺寸两个特征，它们是线性相关的</p>
<p>即 ${x_{1} }={x_{2} }*{ {\left( 3.28 \right)}^{2} }$。</p>
</li>
<li><p>特征数量大于训练集的数量 $\left(m \leqslant n \right)$。</p>
</li>
</ul>
<p>如果发现 $X^TX$ 的结果不可逆，可尝试：</p>
<ul>
<li>减少多余/重复特征</li>
<li>增加训练集数量</li>
<li>使用正规化（后文）</li>
</ul>
<p>对于这类不可逆的矩阵，我们称之为<strong>奇异矩阵</strong>或<strong>退化矩阵</strong>。</p>
<p>这种情况下，如果还想使用正规方程法，在Octave中，可以选用 <code>pinv</code> 函数，<code>pinv</code> 区别于 <code>inv</code>，<code>pinv</code> 函数被称为伪逆函数，在矩阵不可逆的时候，使用这个函数仍可正确地计算出 $\theta$ 的值。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习, 深度学习, 吴恩达</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown语法</title>
    <url>/2024/04/19/22-19-04/</url>
    <content><![CDATA[<h1 id="hexo引擎更换"><a href="#hexo引擎更换" class="headerlink" title="hexo引擎更换"></a>hexo引擎更换</h1><h2 id="latex特殊转义"><a href="#latex特殊转义" class="headerlink" title="latex特殊转义"></a>latex特殊转义</h2><p>选用hexo-renderer-kramed渲染器</p>
<blockquote>
<p>作为行内代码：$ a+b $<br>行内公式：<code>\$\$ a+b \$\$</code><br>大部分公式中，符号之前要有空格，不然无法通过hexo渲染。</p>
</blockquote>
<h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><ul>
<li>换行：<code>\begin&#123;align\*&#125;  //  \end&#123;align\*&#125;</code>  转为 <code>\begin&#123;split&#125;</code></li>
<li>换行中间不能有空行</li>
<li>多行公式对齐，使用<code>&amp;</code>，所有的符号都会在每一行对齐</li>
</ul>
<h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法*"></a>乘法*</h3><ul>
<li>乘法需要加<code>a\\*b</code>转义 $a*b$</li>
</ul>
<h3 id="求导偏导"><a href="#求导偏导" class="headerlink" title="求导偏导"></a>求导偏导</h3><ul>
<li>求导 <code>d</code>  直接写 $d$</li>
<li>偏导 <code>\partial</code>  $\partial$</li>
</ul>
<h3 id="大写bold"><a href="#大写bold" class="headerlink" title="大写bold"></a>大写bold</h3><ul>
<li>改为<code>\boldsymbol&#123;x&#125;</code> $\boldsymbol{x}$</li>
</ul>
<h3 id="lim极限-求和"><a href="#lim极限-求和" class="headerlink" title="lim极限 求和"></a>lim极限 求和</h3><ul>
<li><code>\displaystyle\lim_x</code>  显示 $\displaystyle\lim_x$</li>
<li><code>\lim_x</code>  显示 $\lim_x$<h3 id="空心字"><a href="#空心字" class="headerlink" title="空心字"></a>空心字</h3></li>
<li><code>\mathbb&#123;1&#125;</code>, $\mathbb{1}$</li>
</ul>
<h1 id="hexo-创建文件夹内文章"><a href="#hexo-创建文件夹内文章" class="headerlink" title="hexo 创建文件夹内文章"></a>hexo 创建文件夹内文章</h1><ul>
<li><code>hexo new post -p /n/m</code></li>
</ul>
<h2 id="markdown"><a href="#markdown" class="headerlink" title="markdown"></a>markdown</h2><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>与正文空一行，才能正常转义</p>
<h3 id="跳转1"><a href="#跳转1" class="headerlink" title="跳转1"></a>跳转<sup><a href="#fn_1" id="reffn_1">1</a></sup></h3><ul>
<li><blockquote id="fn_1">
<sup>1</sup>. <code>[^1]</code>设置标签， 在需要跳转的地方写入<code>[^1]:</code>生成跳转箭头<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>markdown, hexo, Latex</tag>
      </tags>
  </entry>
  <entry>
    <title>vim实用技巧</title>
    <url>/2024/04/19/11-47-11/</url>
    <content><![CDATA[<h1 id="按键说明"><a href="#按键说明" class="headerlink" title="按键说明"></a>按键说明</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="动词"><a href="#动词" class="headerlink" title="动词"></a>动词</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">d 删除 delete</span><br><span class="line">r 替换 replace</span><br><span class="line">c 修改 change</span><br><span class="line">y 复制 yank</span><br><span class="line">v 选取 visual select</span><br></pre></td></tr></table></figure>
<h3 id="名词-text-object"><a href="#名词-text-object" class="headerlink" title="名词 text object"></a>名词 text object</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">w 单词word</span><br><span class="line">s 句子 sentence</span><br><span class="line">p 段落paragraph</span><br><span class="line">t HTML标签tag</span><br><span class="line">u 撤销(undo)</span><br><span class="line">. 重复最后一个命令</span><br><span class="line">引号或者各种括号所包含的文本称作一个文本块。</span><br></pre></td></tr></table></figure>
<h3 id="介词"><a href="#介词" class="headerlink" title="介词"></a>介词</h3><p>介词界定了待编辑文本的范围或者位置。例如：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">i “在…之内”inside</span><br><span class="line">a “环绕…”around</span><br><span class="line">t “到…位置前”to</span><br><span class="line">f “到…位置上”forward</span><br></pre></td></tr></table></figure></p>
<h3 id="组词为句"><a href="#组词为句" class="headerlink" title="组词为句"></a>组词为句</h3><p>动词+介词+名词<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">删除一个段落 delete inside paragraph: dip</span><br><span class="line">选取一个句子 visual select inside sentence: vis</span><br><span class="line">修改一个单词 change inside word: ciw</span><br><span class="line">修改一个单词 change around word: caw</span><br><span class="line">删除文本直到字符“x”（不包括字符“x”）delete to x: dtx</span><br><span class="line">删除文本直到字符“x”（包括字符“x”）delete forward x:dfx</span><br></pre></td></tr></table></figure></p>
<h3 id="数词"><a href="#数词" class="headerlink" title="数词"></a>数词</h3><p>动词+介词/数词+名词<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">修改三个单词 change three words: c3w</span><br><span class="line">删除两个单词 delete two words: d2w</span><br></pre></td></tr></table></figure></p>
<p>数词也可以修饰动词，表示将操作执行 n 次<br>数词+动词+名词<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">两次删除单词（等价于删除两个单词） twice delete word: <span class="number">2</span>dw</span><br><span class="line">三次删除字符（等价于删除三个字符）three times delete character: <span class="number">3</span>x</span><br></pre></td></tr></table></figure></p>
<h2 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h2><h3 id="行"><a href="#行" class="headerlink" title="行"></a>行</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> 跳转到当前行首</span><br><span class="line">^ 跳转到当前行的第一个非空字符(空格/TAB)</span><br><span class="line">$ 跳转到当前行的末尾</span><br><span class="line">gg 跳转到文件第一行(<span class="keyword">goto</span>)</span><br><span class="line">G 跳转到文件最后一行</span><br><span class="line"><span class="number">47</span>G 跳转到文件第<span class="number">47</span>行</span><br><span class="line">:<span class="number">47</span> 跳转到文件第<span class="number">47</span>行(同<span class="string">&quot;47G&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">f[<span class="type">char</span>] 跳转到第一个[<span class="type">char</span>]字符(find)</span><br><span class="line"><span class="number">3f</span>[<span class="type">char</span>] 跳转到第三个[<span class="type">char</span>]字符</span><br><span class="line">F[<span class="type">char</span>] 向左跳转到第一个[<span class="type">char</span>]字符</span><br><span class="line">t[<span class="type">char</span>] 跳转到第一个[<span class="type">char</span>]字符的前一个字符(till before - right)</span><br><span class="line">T[<span class="type">char</span>] 向左跳转到第一个[<span class="type">char</span>]字符的后一个字符(till after - left)</span><br><span class="line">; 重复最后一次的 f/F/t/T 移动命令</span><br><span class="line"> </span><br><span class="line">这里加 shift 大写，意为反向：向左</span><br></pre></td></tr></table></figure>
<h3 id="单词和文本块"><a href="#单词和文本块" class="headerlink" title="单词和文本块"></a>单词和文本块</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">w 跳转到下一个单词的开头(word)</span><br><span class="line"><span class="number">3</span>w 跳转到第三个单词的开头</span><br><span class="line">e 跳转到下一个单词的结尾(end of word)</span><br><span class="line">b 跳转到上一个单词的开头(backward beginning)</span><br><span class="line">( 跳转到上一个句子的开头</span><br><span class="line">) 跳转到下一个句子的开头</span><br><span class="line">&#123; 跳转到上一个段落的开头</span><br><span class="line">&#125; 跳转到下一个段落的开头</span><br></pre></td></tr></table></figure>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">% 在当前大括号/中括号/小括号的开始位置<span class="string">&quot;&#123;/[/(&quot;</span>和结束位置<span class="string">&quot;&#125;/]/)&quot;</span>之间跳转</span><br><span class="line">[[ 跳转到上一个函数的开头(如果光标在函数体内则跳转到当前函数的开头)</span><br><span class="line">]] 跳转到下一个函数的开头</span><br><span class="line">[&#123; 跳转到当前程序块的开头(当前程序块为当前程序的上一层，不是固定的)</span><br><span class="line">]&#125; 跳转到当前程序块的结尾</span><br></pre></td></tr></table></figure>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/[word] 搜索[word]字符串</span><br><span class="line">?[word] 向上搜索[word]字符串</span><br><span class="line">n 跳转到下一个匹配的字符串(保持最后一个搜索命令的方向)(next match)</span><br><span class="line">N 跳转到上一个匹配的字符串(保持最后一个搜索命令的方向)</span><br><span class="line">* 搜索当前光标下的单词</span><br><span class="line"># 向上搜索当前光标下的单词</span><br></pre></td></tr></table></figure>
<h2 id="插入模式"><a href="#插入模式" class="headerlink" title="插入模式"></a>插入模式</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">s 删除光标位置下的字符并进入插入模式</span><br><span class="line">S 删除当前行内容并进入插入模式</span><br></pre></td></tr></table></figure>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x 删除光标位置下的字符</span><br><span class="line">dw 删除光标之后的单词剩余部分(delete word)</span><br><span class="line">diw 删除一个单词</span><br><span class="line">dd 删除当前行</span><br><span class="line">D 删除从光标位置到当前行的末尾(同<span class="string">&quot;d$&quot;</span>)</span><br><span class="line">df[<span class="type">char</span>] 删除从光标位置到[<span class="type">char</span>]字符(delete find [<span class="type">char</span>])</span><br><span class="line">d) 删除从光标位置到下一个句子的开始</span><br><span class="line">d&#125; 删除从光标位置到该段落的末尾</span><br><span class="line">di&#123; 删除花括号之间的内容(delete inner &#123;&#125;)(同<span class="string">&quot;diB&quot;</span>)</span><br><span class="line">di( 删除小括号之间的内容(delete inner ())(同<span class="string">&quot;dib&quot;</span>)</span><br><span class="line">dit 删除闭合标签之间的内容(html/xml等标签，delete inner tag)</span><br><span class="line">dat 删除左右尖括号及之间的内容(delete a tag)</span><br><span class="line">da&lt; 删除左右尖括号及之间的内容(delete a &lt;&gt;)</span><br><span class="line">di<span class="string">&quot; 删除引号之间的内容(delete inner &quot;</span><span class="string">&quot;)</span></span><br><span class="line"><span class="string">da&quot;</span> 删除左右引号及之间的内容(delete a <span class="string">&quot;&quot;</span>)</span><br><span class="line">:<span class="number">5</span>,<span class="number">10</span>d 删除<span class="number">5</span><span class="number">-10</span>行</span><br><span class="line"><span class="number">3</span>dd 删除从当前行开始的<span class="number">3</span>行</span><br><span class="line">&lt;C-w&gt; 删除光标前的一个单词(插入模式)</span><br><span class="line">&lt;C-u&gt; 从光标位置删除到行首(插入模式)</span><br><span class="line"> </span><br><span class="line">这里加 shift 大写，意为行尾</span><br><span class="line">注：<span class="string">&quot;d&quot;</span>/<span class="string">&quot;c&quot;</span>开头的命令会将删除的文本放到寄存器(通过<span class="string">&quot;:reg&quot;</span>查看)，可以理解为剪切。</span><br><span class="line">关于<span class="string">&quot;a&quot;</span>n和<span class="string">&quot;i&quot;</span>nner可以参考<span class="string">&quot;:help object-select&quot;</span>文本对象选择部分</span><br><span class="line">另：一般向右的操作包含光标下的字符，向左的操作不包含光标下的字符</span><br></pre></td></tr></table></figure>
<h2 id="更改文本"><a href="#更改文本" class="headerlink" title="更改文本"></a>更改文本</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">J 将下一行合并的当前行的末尾(Join line)</span><br><span class="line"><span class="number">3</span>,<span class="number">9</span>j 合并<span class="number">3</span><span class="number">-9</span>行</span><br><span class="line">~ 切换光标下字符的大小写</span><br><span class="line">u 更改选定的文本为小写(可视模式)</span><br><span class="line">U 更改选定的文本为大写(可视模式)</span><br><span class="line">&lt;C-a&gt; 把当前光标下或之后的数值加<span class="number">1</span></span><br><span class="line">&lt;C-x&gt; 把当前光标下或之后的数值减<span class="number">1</span></span><br><span class="line">r[<span class="type">char</span>] 替换光标下的字符为[<span class="type">char</span>]. (replace)</span><br><span class="line">R 进入替换模式</span><br><span class="line">cw 删除光标之后的单词剩余部分并进入插入模式(change word)</span><br><span class="line">cc 删除当前行内容并进入插入模式(同<span class="string">&quot;S&quot;</span>)</span><br><span class="line">C 删除从光标位置到当前行的末尾并进入插入模式(同<span class="string">&quot;c$&quot;</span>)</span><br><span class="line">cf[<span class="type">char</span>] 删除从光标位置到[<span class="type">char</span>]字符并进入插入模式</span><br><span class="line"> </span><br><span class="line">这里<span class="string">&quot;c&quot;</span>开头加 shift 大写，意为行尾</span><br><span class="line"><span class="string">&quot;c&quot;</span>开头<span class="string">&quot;change&quot;</span>更改(删除并插入)，<span class="string">&quot;d&quot;</span>开头<span class="string">&quot;delete&quot;</span>删除，和<span class="string">&quot;y&quot;</span>开头<span class="string">&quot;yank/copy&quot;</span>，格式相同，可相互参考使用</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;&gt; 缩进当前行</span><br><span class="line">&lt;&lt; 向左缩进当前行</span><br><span class="line">&lt;C-d&gt; 缩进当前行(插入模式)</span><br><span class="line">&lt;C-t&gt; 向左缩进当前行(插入模式)</span><br><span class="line">:<span class="number">3</span>,<span class="number">9</span>&gt;&gt;&gt;&gt;&gt; 将<span class="number">3</span><span class="number">-9</span>行缩进<span class="number">5</span>个TAB</span><br><span class="line">&gt; 缩进选定的行(可视模式)</span><br><span class="line">&lt; 向左缩进选定的行(可视模式)</span><br><span class="line">&gt;i&#123; 缩进花括号之间的内容(indent inner &#123;&#125;)(同<span class="string">&quot;&gt;iB&quot;</span>)</span><br><span class="line">&gt;a&#123; 缩进花括号及之间的内容(indent a &#123;&#125;)(同<span class="string">&quot;&gt;aB&quot;</span>)</span><br><span class="line">=&#125; 缩进当前段落</span><br><span class="line">gg=G 全文缩进/格式化</span><br></pre></td></tr></table></figure>
<h2 id="复制粘贴"><a href="#复制粘贴" class="headerlink" title="复制粘贴"></a>复制粘贴</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v 进入可视模式，以字符为单位选择</span><br><span class="line">V 进入可视模式，以行为单位选择</span><br><span class="line">&lt;C-v&gt; 进入列块可视模式(如果映射<span class="string">&quot;&lt;C-v&gt;&quot;</span>为<span class="string">&quot;粘贴&quot;</span>时请注意)</span><br><span class="line">gv 重新选择最后选定的区域</span><br><span class="line">y 抽出选择的文本到寄存器(可视模式)(yank/copy)</span><br><span class="line"><span class="string">&quot;+y 抽出选择的文本到系统剪切板(可视模式)(好像不太好使)</span></span><br><span class="line"><span class="string">:co 10 复制当前行到第11行(copy)</span></span><br><span class="line"><span class="string">:co . 复制当前行到下一行(同&quot;</span>yyp<span class="string">&quot;)</span></span><br><span class="line"><span class="string">:5,10co 20 复制5-10行到第21行</span></span><br><span class="line"><span class="string">yy 复制当前行</span></span><br><span class="line"><span class="string">y$ 复制到行尾</span></span><br><span class="line"><span class="string">yw 复制光标之后的单词剩余部分(yank word)</span></span><br><span class="line"><span class="string">yb 复制光标之前的单词剩余部分</span></span><br><span class="line"><span class="string">yiw 复制一个单词</span></span><br><span class="line"><span class="string">yip 复制当前段落(yank inner paragraph)</span></span><br><span class="line"><span class="string">yas 复制一个句子(yank a sentence)</span></span><br><span class="line"><span class="string">yi&lt; 复制尖括号之间的内容(Yank inner &lt;&gt;)</span></span><br><span class="line"><span class="string">11y 复制11行</span></span><br><span class="line"><span class="string">p 粘贴(paste)</span></span><br><span class="line"><span class="string">P 粘贴到光标前</span></span><br><span class="line"><span class="string">&lt;C-r&gt;&quot;</span> 粘贴(插入模式)</span><br><span class="line"><span class="string">&quot;ayy 复制当前行到寄存器&quot;</span>a<span class="string">&quot;(可使用范围&quot;</span>a-z<span class="string">&quot;)</span></span><br><span class="line"><span class="string">&quot;</span>ap 粘贴从寄存器<span class="string">&quot;a&quot;</span></span><br><span class="line"> </span><br><span class="line">这里的<span class="string">&quot;寄存器&quot;</span>即VIM剪切板</span><br></pre></td></tr></table></figure>
<h2 id="滚动屏幕"><a href="#滚动屏幕" class="headerlink" title="滚动屏幕"></a>滚动屏幕</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">H 跳转到屏幕的顶部(home)</span><br><span class="line">M 跳转到屏幕的中间(middle)</span><br><span class="line">L 跳转到屏幕的底部(low)</span><br><span class="line">zt 将当前行滚动至屏幕顶部(top)</span><br><span class="line">zz 将当前行滚动至屏幕中间(同<span class="string">&quot;z.&quot;</span>)</span><br><span class="line">zb 将当前行滚动至屏幕中间(bottom)(同<span class="string">&quot;z-&quot;</span>)</span><br><span class="line">&lt;C-f&gt; 滚动至下一页(forwards)</span><br><span class="line">&lt;C-b&gt; 滚动至上一页(backwards)</span><br><span class="line">&lt;C-d&gt; 向下滚动半屏(downwards)</span><br><span class="line">&lt;C-u&gt; 向下滚动半屏(upwards)</span><br></pre></td></tr></table></figure>
<h2 id="键映射"><a href="#键映射" class="headerlink" title="键映射"></a>键映射</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">:<span class="built_in">map</span> 查看已映射的键列表</span><br><span class="line">:imap 查看插入模式下已映射的键列表</span><br><span class="line">:nmap 查看普通模式下已映射的键列表</span><br><span class="line">:imap jj &lt;Esc&gt; 插入模式下键入<span class="string">&quot;jj&quot;</span>映射到<span class="string">&quot;&lt;ESC&gt;&quot;</span>(返回普通模式)</span><br><span class="line">:nmap &lt;C-h&gt; &lt;C-w&gt;h 普通模式下映射<span class="string">&quot;&lt;C-h&gt;&quot;</span>到<span class="string">&quot;&lt;C-w&gt;h&quot;</span>(光标移动到左边一个窗口)</span><br></pre></td></tr></table></figure>
<h1 id="键位图"><a href="#键位图" class="headerlink" title="键位图"></a>键位图</h1><ul>
<li>绿色键：motion，移动光标，或定义操作的范围</li>
<li>黄色键：command，直接执行的命令，红色命令进入编辑模式</li>
<li>橙色键：operator，后面跟随表示操作范围的指令</li>
<li>灰色键：extra，特殊功能，需要额外的输入</li>
</ul>
<img src="/2024/04/19/11-47-11/592892-20180328123208117-408079142.gif" class>
<img src="/2024/04/19/11-47-11/57cbaf4d4db0e734254abe2717da0360.jpeg" class>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具, vim</tag>
      </tags>
  </entry>
  <entry>
    <title>27-GooLeNet</title>
    <url>/2024/04/18/15-40-53/</url>
    <content><![CDATA[<h2 id="GooLeNet"><a href="#GooLeNet" class="headerlink" title="GooLeNet"></a>GooLeNet</h2><h4 id="含并行连结的网络"><a href="#含并行连结的网络" class="headerlink" title="含并行连结的网络"></a>含并行连结的网络</h4><ul>
<li>GoogLeNet吸收了NiN中串联网络的思想，并在此基础上做了改进。我们往往不确定到底选取什么样的层效果更好，到底是3X3卷积层还是5X5的卷积层，诸如此类的问题是GooLeNet选择了另一种思路“小学生才做选择，我全都要”，这也使得GooLeNet成为了第一个模型中超过1000个层的模型。</li>
</ul>
<h4 id="Inception块"><a href="#Inception块" class="headerlink" title="Inception块"></a>Inception块</h4><ul>
<li><p>在GoogLeNet中，基本的卷积块被称为<em>Inception块</em>（Inception block）</p>
<p><img src="https://github.com/kinza99/DeepLearning-MuLi-Notes/blob/main/imgs/27/27-1.png" alt="截屏2022-01-23 上午10.11.18"></p>
</li>
<li><p>Inception块由四条并行路径组成。 前三条路径使用窗口大小为1×11×1、3×33×3和5×55×5的卷积层，从不同空间大小中提取信息。 中间的两条路径在输入上执行1×11×1卷积，以减少通道数，从而降低模型的复杂性。 第四条路径使用3×33×3最大汇聚层，然后使用1×11×1卷积层来改变通道数。 这四条路径都使用合适的填充来使输入与输出的高和宽一致，最后我们将每条线路的输出在通道维度上连结，并构成Inception块的输出。在Inception块中，通常调整的超参数是每层输出通道数。</p>
</li>
</ul>
<h4 id="GooLeNet模型"><a href="#GooLeNet模型" class="headerlink" title="GooLeNet模型"></a>GooLeNet模型</h4><ul>
<li>GoogLeNet一共使用9个Inception块和全局平均汇聚层的堆叠来生成其估计值。Inception块之间的最大汇聚层可降低维度。 第一个模块类似于AlexNet和LeNet，Inception块的组合从VGG继承，全局平均汇聚层避免了在最后使用全连接层。<img src="https://github.com/kinza99/DeepLearning-MuLi-Notes/blob/main/imgs/27/27-2.png" alt="截屏2022-01-23 上午10.17.11"></li>
<li>第一个模块是7×7卷积层。</li>
<li>第二个模块使用两个卷积层：第一个卷积层是1×1卷积层；第二个卷积层使用将通道数量增加三倍的3×3卷积层。 这对应于Inception块中的第二条路径。</li>
<li>第三个模块串联两个完整的Inception块。 第一个Inception块的输出通道数为64+128+32+32=25664+128+32+32=256，四个路径之间的输出通道数量比为64:128:32:32=2:4:1:164:128:32:32=2:4:1:1。 第二个和第三个路径首先将输入通道的数量分别减少到96/192=1/296/192=1/2和16/192=1/1216/192=1/12，然后连接第二个卷积层。第二个Inception块的输出通道数增加到128+192+96+64=480128+192+96+64=480，四个路径之间的输出通道数量比为128:192:96:64=4:6:3:2128:192:96:64=4:6:3:2。 第二条和第三条路径首先将输入通道的数量分别减少到128/256=1/2128/256=1/2和32/256=1/832/256=1/8。</li>
<li>第四模块更加复杂， 它串联了5个Inception块，其输出通道数分别是192+208+48+64=512192+208+48+64=512、160+224+64+64=512160+224+64+64=512、128+256+64+64=512128+256+64+64=512、112+288+64+64=528112+288+64+64=528和256+320+128+128=832256+320+128+128=832。 这些路径的通道数分配和第三模块中的类似，首先是含3×3卷积层的第二条路径输出最多通道，其次是仅含1×1卷积层的第一条路径，之后是含5×5卷积层的第三条路径和含3×3最大汇聚层的第四条路径。 其中第二、第三条路径都会先按比例减小通道数。 这些比例在各个Inception块中都略有不同。</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li><p>Inception块相当于一个有4条路径的子网络。它通过不同窗口形状的卷积层和最大汇聚层来并行抽取信息，并使用1×1卷积层减少每像素级别上的通道维数从而降低模型复杂度。</p>
</li>
<li><p>GoogLeNet将多个设计精细的Inception块与其他层（卷积层、全连接层）串联起来。其中Inception块的通道数分配之比是在ImageNet数据集上通过大量的实验得来的。</p>
</li>
<li><p>GoogLeNet和它的后继者们一度是ImageNet上最有效的模型之一：它以较低的计算复杂度提供了类似的测试精度。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>动手学深度学习</category>
      </categories>
      <tags>
        <tag>动手学深度学习, 深度学习, 李沐</tag>
      </tags>
  </entry>
  <entry>
    <title>机器笔记汇总</title>
    <url>/2024/04/18/15-40-33/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.04.18：初稿</li>
</ul>
<h1 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h1><ul>
<li><a href="/2024/04/18/15-34-48/" title="机器学习笔记一 单变量线性回归">机器学习笔记一 单变量线性回归</a></li>
<li><a href="/2024/04/21/07-10-14/" title="机器学习笔记二 多变量线性回归">机器学习笔记二 多变量线性回归</a></li>
<li><a href="/2024/04/22/13-37-10/" title="机器学习笔记三 多变量线性回归">机器学习笔记三 多变量线性回归</a></li>
<li><a href="/2024/04/22/13-37-13/" title="机器学习笔记四 神经网络的表达">机器学习笔记四 神经网络的表达</a></li>
<li><a href="/2024/04/23/12-43-40/" title="机器学习笔记五 神经网络的学习">机器学习笔记五 神经网络的学习</a>
</li>
</ul>
<blockquote>
<p>先学习一部分，之后遇到了再具体学习，暂停之后学习动手学深度学习。</p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习, 深度学习, 吴恩达</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习笔记一 单变量线性回归</title>
    <url>/2024/04/18/15-34-48/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.04.18：初稿</li>
</ul>
<h1 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h1><ul>
<li><a href="/2024/04/18/15-40-33/" title="机器笔记汇总">吴恩达机器学习 - 笔记汇总</a>
</li>
</ul>
<h1 id="1-引言（Introduction）"><a href="#1-引言（Introduction）" class="headerlink" title="1 引言（Introduction）"></a>1 引言（Introduction）</h1><h2 id="1-1-Welcome"><a href="#1-1-Welcome" class="headerlink" title="1.1 Welcome"></a>1.1 Welcome</h2><p>随着互联网数据不断累积，硬件不断升级迭代，在这个信息爆炸的时代，机器学习已被应用在各行各业中，可谓无处不在。</p>
<h2 id="1-2-什么是机器学习（What-is-Machine-Learning）"><a href="#1-2-什么是机器学习（What-is-Machine-Learning）" class="headerlink" title="1.2 什么是机器学习（What is Machine Learning）"></a>1.2 什么是机器学习（What is Machine Learning）</h2><ol>
<li><p>机器学习定义<br> 这里主要有两种定义：</p>
<ul>
<li><p>Arthur Samuel (1959). Machine Learning:<br>Field of study that gives computers the ability to learn without being explicitly programmed.<br>这个定义有点不正式但提出的时间最早，来自于一个懂得计算机编程的下棋菜鸟。他编写了一个程序，但没有显式地编程每一步该怎么走，而是让计算机自己和自己对弈，并不断地计算布局的好坏，来判断什么情况下获胜的概率高，从而积累经验，好似学习，最后，这个计算机程序成为了一个比他自己还厉害的棋手。</p>
</li>
<li><p>Tom Mitchell (1998) Well-posed Learning Problem:<br>A computer program is said to learn from experience E with respect to some <strong>task T</strong> and some <strong>performance measure P</strong>, if its performance on T, as measured by P, improves with <strong>experience E</strong>.<br>Tom Mitchell 的定义更为现代和正式。在过滤垃圾邮件这个例子中，电子邮件系统会根据用户对电子邮件的标记（是/不是垃圾邮件）不断学习，从而提升过滤垃圾邮件的准确率，定义中的三个字母分别代表：</p>
<ul>
<li>T(Task): 过滤垃圾邮件任务。</li>
<li>P(Performance): 电子邮件系统过滤垃圾邮件的准确率。</li>
<li>E(Experience): 用户对电子邮件的标记。<blockquote>
<p>类似监督学习</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li>机器学习算法<br>主要有两种机器学习的算法分类<ol>
<li>监督学习</li>
<li>无监督学习<br>还有一些算法也属于机器学习领域，诸如：</li>
</ol>
<ul>
<li>半监督学习: 介于监督学习于无监督学习之间</li>
<li>推荐算法: </li>
<li>强化学习: 通过观察来学习如何做出动作，每个动作都会对环境有所影响，而环境的反馈又可以引导该学习算法。</li>
<li>迁移学习: 某个领域应用到另个领域</li>
</ul>
</li>
</ol>
<h2 id="1-3-监督学习（Supervised-Learning）"><a href="#1-3-监督学习（Supervised-Learning）" class="headerlink" title="1.3 监督学习（Supervised Learning）"></a>1.3 监督学习（Supervised Learning）</h2><p>监督学习，即为教计算机如何去完成预测任务（有反馈），预先给一定数据量的输入<strong>和对应的结果</strong>即训练集，建模拟合，最后让计算机预测未知数据的结果。<br>监督学习一般有两种：</p>
<ol>
<li><p>回归问题（Regression）<br>回归问题即为预测一系列的<strong>连续值</strong>。<br>在房屋价格预测的例子中，给出了一系列的房屋面积数据，根据这些数据来预测任意面积的房屋价格。给出照片-年龄数据集，预测给定照片的年龄。</p>

</li>
<li><p>分类问题（Classification）<br>分类问题即为预测一系列的<strong>离散值</strong>。<br>即根据数据预测被预测对象属于哪个分类。<br>视频中举了癌症肿瘤这个例子，针对诊断结果，分别分类为良性或恶性。还例如垃圾邮件分类问题，也同样属于监督学习中的分类问题。</p>
<img src="/2024/04/18/15-34-48/20180105_194839.png" class>
</li>
</ol>
<p>视频中提到<strong>支持向量机</strong>这个算法，旨在解决当特征量很大的时候（特征即如癌症例子中的肿块大小，颜色，气味等各种特征），计算机内存一定会不够用的情况。<strong>支持向量机能让计算机处理无限多个特征。</strong></p>
<h2 id="1-4-无监督学习（Unsupervised-Learning）"><a href="#1-4-无监督学习（Unsupervised-Learning）" class="headerlink" title="1.4 无监督学习（Unsupervised Learning）"></a>1.4 无监督学习（Unsupervised Learning）</h2><p>相对于监督学习，训练集不会有人为标注的结果（无反馈），我们<strong>不会给出</strong>结果或<strong>无法得知</strong>训练集的结果是什么样，而是单纯由计算机通过无监督学习算法自行分析，从而“得出结果”。计算机可能会把特定的数据集归为几个不同的簇，故叫做聚类算法。</p>
<p>无监督学习一般分为两种：</p>
<ol>
<li>聚类（Clustering）<ul>
<li>新闻聚合</li>
<li>DNA 个体聚类</li>
<li>天文数据分析</li>
<li>市场细分</li>
<li>社交网络分析</li>
</ul>
</li>
<li>非聚类（Non-clustering）<ul>
<li>鸡尾酒问题</li>
</ul>
</li>
</ol>
<p><strong>新闻聚合</strong></p>
<p>在例如谷歌新闻这样的网站中，每天后台都会收集成千上万的新闻，然后将这些新闻分组成一个个的新闻专题，这样一个又一个聚类，就是应用了无监督学习的结果。</p>
<p><strong>鸡尾酒问题</strong></p>
 <img src="/2024/04/18/15-34-48/20180105_201639.png" class>
<p>在鸡尾酒会上，大家说话声音彼此重叠，几乎很难分辨出面前的人说了什么。我们很难对于这个问题进行数据标注，而这里的通过机器学习的无监督学习算法，就可以将说话者的声音同背景音乐分离出来。</p>
<h1 id="2-单变量线性回归（Linear-Regression-with-One-Variable）"><a href="#2-单变量线性回归（Linear-Regression-with-One-Variable）" class="headerlink" title="2 单变量线性回归（Linear Regression with One Variable）"></a>2 单变量线性回归（Linear Regression with One Variable）</h1><h2 id="2-1-模型表示（Model-Representation）"><a href="#2-1-模型表示（Model-Representation）" class="headerlink" title="2.1 模型表示（Model Representation）"></a>2.1 模型表示（Model Representation）</h2><ol>
<li>房价预测训练集</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>Size in $feet^2$ ($x$)</th>
<th>Price ($) in 1000’s($y$)</th>
</tr>
</thead>
<tbody>
<tr>
<td>2104</td>
<td>460</td>
</tr>
<tr>
<td>1416</td>
<td>232</td>
</tr>
<tr>
<td>1534</td>
<td>315</td>
</tr>
<tr>
<td>852</td>
<td>178</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
</div>
<p>房价预测训练集中，同时给出了输入 $x$ 和输出结果 $y$，即给出了人为标注的<strong>“正确结果”</strong>，且预测的量是连续的，属于监督学习中的回归问题。</p>
<ol>
<li><p><strong>问题解决模型</strong></p>
<img src="/2024/04/18/15-34-48/20180105_212048.png" class>
</li>
</ol>
<p>其中 $h$ 代表结果函数，也称为<strong>假设（hypothesis）</strong> 。假设函数根据输入（房屋的面积），给出预测结果输出（房屋的价格），即是一个 $X\to Y$ 的映射。</p>
<p>$h_\theta(x)=\theta_0+\theta_1x$，为解决房价问题的一种可行表达式。</p>
<blockquote>
<p>$x$: 特征/输入变量。</p>
</blockquote>
<p>上式中，$\theta$ 为参数，$\theta$ 的变化才决定了输出结果，不同以往，这里的 $x$ 被我们<strong>视作已知</strong>（不论是数据集还是预测时的输入），所以怎样解得 $\theta$ 以更好地拟合数据，成了求解该问题的最终问题。</p>
<p>单变量，即只有一个特征（如例子中房屋的面积这个特征）。</p>
<h2 id="2-2-代价函数（Cost-Function）"><a href="#2-2-代价函数（Cost-Function）" class="headerlink" title="2.2 代价函数（Cost Function）"></a>2.2 代价函数（Cost Function）</h2><blockquote>
<p>李航《统计学习方法》一书中，损失函数与代价函数两者为<strong>同一概念</strong>，未作细分区别，全书没有和《深度学习》一书一样混用，而是统一使用<strong>损失函数</strong>来指代这类类似概念。</p>
<p>吴恩达（Andrew Ng）老师在其公开课中对两者做了细分。</p>
<p><strong>损失函数</strong>（Loss/Error Function）: 计算<strong>单个</strong>样本的误差。</p>
<p><strong>代价函数</strong>（Cost Function）: 计算整个训练集<strong>所有损失函数之和的平均值</strong></p>
</blockquote>
<p>我们的目的在于求解预测结果 $h$ 最接近于实际结果 $y$ 时 $\theta$ 的取值，则问题可表达为<strong>求解 $\sum\limits_{i=1}^{m}(h_\theta(x^{(i)})-y^{(i)})$ 的最小值</strong>。</p>
<blockquote>
<p>$m$: 训练集中的样本总数</p>
<p>$y$: 目标变量/输出变量</p>
<p>$\left(x, y\right)$: 训练集中的实例</p>
<p>$\left(x^{\left(i\right)},y^{\left(i\right)}\right)$: 训练集中的第 $i$ 个样本实例</p>
</blockquote>
<img src="/2024/04/18/15-34-48/20180105_224648.png" class>
<p>上图展示了当 $\theta$ 取不同值时，$h_\theta\left(x\right)$ 对数据集的拟合情况，蓝色虚线部分代表<strong>建模误差</strong>。</p>
<p>为了求解最小值，引入代价函数（Cost Function）概念，用于度量建模误差。考虑到要计算最小值，应用二次函数对求和式建模，即应用统计学中的平方损失函数（最小二乘法）：</p>
<p>$$<br>J(\theta_0, \theta_1)= \dfrac{ 1 }{ 2m } \displaystyle \sum_ {i=1}^m\left(\hat{y}_{i}-y_{i} \right)^2=\dfrac{1}{2m}\displaystyle\sum_{i=1}^m\left(h_\theta(x_{i})-y_{i}\right)^2<br>$$</p>
<blockquote>
<p>$\hat{y}$: $y$ 的预测值</p>
<p>系数 $\frac{1}{2}$ 存在与否都不会影响结果，这里是为了在应用梯度下降时便于求解，平方的导数会抵消掉 $\frac{1}{2}$ 。</p>
</blockquote>
<p>讨论到这里，我们的问题就转化成了<strong>求解 $J\left( \theta_0, \theta_1  \right)$ 的最小值</strong>。</p>
<h2 id="2-3-代价函数-直观理解1（Cost-Function-Intuition-I）"><a href="#2-3-代价函数-直观理解1（Cost-Function-Intuition-I）" class="headerlink" title="2.3 代价函数 - 直观理解1（Cost Function - Intuition I）"></a>2.3 代价函数 - 直观理解1（Cost Function - Intuition I）</h2><p>根据上节视频，列出如下定义：</p>
<ul>
<li>假设函数（Hypothesis）: $h_\theta(x)=\theta_0+\theta_1x$</li>
<li>参数（Parameters）: $\theta_0, \theta_1$</li>
<li>代价函数（Cost Function）: $J\left( \theta_0, \theta_1  \right)=\frac{1}{2m}\sum\limits_{i=1}^{m}{ { {\left( { {h}_{\theta } }\left( { {x}^{(i)} } \right)-{ {y}^{(i)} } \right)}^{2} } }$</li>
<li>目标（Goal）: $\underset{\theta_0, \theta_1}{\text{minimize} } J \left(\theta_0, \theta_1 \right)$</li>
</ul>
<p>为了直观理解代价函数到底是在做什么，先假设 $\theta_0 = 0$，并假设训练集有三个数据，分别为$\left(1, 1\right), \left(2, 2\right), \left(3, 3\right)$，这样在平面坐标系中绘制出 $h_\theta\left(x\right)$ ，并分析 $J\left(\theta_0, \theta_1\right)$ 的变化。</p>
<img src="/2024/04/18/15-34-48/20180106_085915.png" class>
<p>右图 $J\left(\theta_0, \theta_1\right)$ 随着 $\theta_1$ 的变化而变化，可见<strong>当 $\theta_1 = 1$ 时，$J\left(\theta_0, \theta_1 \right) = 0$，取得最小值，</strong>对应于左图青色直线，即函数 $h$ 拟合程度最好的情况。</p>
<h2 id="2-4-代价函数-直观理解2（Cost-Function-Intuition-II）"><a href="#2-4-代价函数-直观理解2（Cost-Function-Intuition-II）" class="headerlink" title="2.4 代价函数 - 直观理解2（Cost Function - Intuition II）"></a>2.4 代价函数 - 直观理解2（Cost Function - Intuition II）</h2><p>给定数据集：<br><img src="/2024/04/18/15-34-48/20180106_091307.png" class></p>
<p>参数在 $\theta_0$ 不恒为 $0$ 时代价函数 $J\left(\theta\right)$ 关于 $\theta_0, \theta_1$ 的3-D图像，图像中的高度为代价函数的值。</p>
<img src="/2024/04/18/15-34-48/20180106_090904.png" class>
<p>由于3-D图形不便于标注，所以将3-D图形转换为<strong>轮廓图（contour plot）</strong>，下面用轮廓图（下图中的右图）来作直观理解，其中相同颜色的一个圈代表着同一高度（同一 $J\left(\theta\right)$ 值）。</p>
<p>$\theta_0 = 360, \theta_1 =0$ 时：</p>
<img src="/2024/04/18/15-34-48/0f38a99c8ceb8aa5b90a5f12136fdf43.png" class>
<p>大概在 $\theta_0 = 0.12, \theta_1 =250$ 时：</p>
<img src="/2024/04/18/15-34-48/20180106_092119.png" class>
<p>上图中最中心的点（红点），近乎为图像中的最低点，也即代价函数的最小值，此时对应 $h_\theta\left(x\right)$ 对数据的拟合情况如左图所示。</p>
<h2 id="2-5-梯度下降（Gradient-Descent）"><a href="#2-5-梯度下降（Gradient-Descent）" class="headerlink" title="2.5 梯度下降（Gradient Descent）"></a>2.5 梯度下降（Gradient Descent）</h2><p>在特征量很大的情况下，即便是借用计算机来生成图像，人工的方法也很难读出 $J\left(\theta\right)$ 的最小值，并且大多数情况无法进行可视化，故引入<strong>梯度下降（Gradient Descent）方法，让计算机自动找出最小化代价函数时对应的 $\theta$ 值。</strong></p>
<p>梯度下降背后的思想是：开始时，我们随机选择一个参数组合$\left( {\theta_{0} },{\theta_{1} },……,{\theta_{n} } \right)$即起始点，计算代价函数，然后寻找下一个能使得代价函数下降最多的参数组合。不断迭代，直到找到一个<strong>局部最小值（local minimum）</strong>，由于下降的情况只考虑当前参数组合周围的情况，所以无法确定当前的局部最小值是否就是<strong>全局最小值（global minimum）</strong>，不同的初始参数组合，可能会产生不同的局部最小值。</p>
<p>下图根据不同的起始点，产生了两个不同的局部最小值。</p>
<img src="/2024/04/18/15-34-48/db48c81304317847870d486ba5bb2015.jpg" class>
<p>视频中举了下山的例子，即我们在山顶上的某个位置，为了下山，就不断地看一下周围<strong>下一步往哪走</strong>下山比较快，然后就<strong>迈出那一步</strong>，一直重复，直到我们到达山下的某一处<strong>陆地</strong>。</p>
<p>梯度下降公式：</p>
<p>$$<br>\begin{split}<br>&amp; \text{Repeat until convergence:} \; \lbrace \\<br>&amp;{ {\theta }_{j} }:={ {\theta }_{j} }-\alpha \frac{\partial }{\partial { {\theta }_{j} } }J\left( {\theta_{0} },{\theta_{1} }  \right) \\<br>\rbrace<br>\end{split}<br>$$</p>
<blockquote>
<p>“-”来源于：<strong>正值向左移动减少，负值向右移动增加</strong><br>${\theta }_{j}$: 第 $j$ 个特征参数</p>
<p>”:=“: 赋值操作符</p>
<p>$\alpha$: 学习速率（learning rate）, $\alpha &gt; 0$</p>
<p>$\frac{\partial }{\partial { {\theta }_{j} } }J\left( \theta_0, \theta_j  \right)$: $J\left( \theta_0, \theta_j \right)$ 的偏导</p>
</blockquote>
<p>公式中，学习速率决定了参数值变化的速率即”<strong>走多少距离</strong>“，而偏导这部分决定了下降的方向即”<strong>下一步往哪里</strong>“走（当然实际上的走多少距离是由偏导值给出的，学习速率起到调整后决定的作用），收敛处的局部最小值又叫做极小值，即”<strong>陆地</strong>“。</p>
<img src="/2024/04/18/15-34-48/20180106_101659.png" class>
<p>注意，在计算时要<strong>批量更新 $\theta$ 值</strong>，即如上图中的左图所示，否则结果上会有所出入，原因不做细究。</p>
<h2 id="2-6-梯度下降直观理解（Gradient-Descent-Intuition）"><a href="#2-6-梯度下降直观理解（Gradient-Descent-Intuition）" class="headerlink" title="2.6 梯度下降直观理解（Gradient Descent Intuition）"></a>2.6 梯度下降直观理解（Gradient Descent Intuition）</h2><p>该节探讨 $\theta_1$ 的梯度下降更新过程，即 $\theta_1 := \theta_1 - \alpha\frac{d}{d\theta_1}J\left(\theta_1\right)$。</p>
<img src="/2024/04/18/15-34-48/20180106_184926.png" class>
<p>直线的斜率，表示了函数 $J\left(\theta\right)$ 在初始点处有<strong>正斜率</strong>，也就是说它有<strong>正导数</strong>，会<strong>向左边移动</strong>。不断重复，直到收敛。</p>
<p>初始 $\theta$ 值（初始点）是任意的。</p>
<p>对于学习速率 $\alpha$，需要选取一个合适的值才能使得梯度下降算法运行良好。</p>
<ul>
<li><p>学习速率过小图示：</p>
<img src="/2024/04/18/15-34-48/20180106_190944.png" class>
<p>收敛的太慢，需要更多次的迭代。</p>
</li>
<li><p>学习速率过大图示：</p>
<img src="/2024/04/18/15-34-48/20180106_191023.png" class>
<p>可能越过最低点，甚至导致无法收敛。</p>
</li>
</ul>
<p><strong>学习速率只需选定即可</strong>，不需要动态改变，随着斜率越来越接近于0，代价函数的变化幅度会越来越小，直到收敛到局部极小值。</p>
<p>代价函数随着迭代的进行，变化的幅度越来越小。</p>
<img src="/2024/04/18/15-34-48/20180106_191956.png" class>
<h2 id="2-7-线性回归中的梯度下降（Gradient-Descent-For-Linear-Regression）"><a href="#2-7-线性回归中的梯度下降（Gradient-Descent-For-Linear-Regression）" class="headerlink" title="2.7 线性回归中的梯度下降（Gradient Descent For Linear Regression）"></a>2.7 线性回归中的梯度下降（Gradient Descent For Linear Regression）</h2><p>线性回归模型</p>
<ul>
<li>$h_\theta(x)=\theta_0+\theta_1x$</li>
<li>$J\left( \theta_0, \theta_1  \right)=\frac{1}{2m}\sum\limits_{i=1}^{m}{ { {\left( { {h}_{\theta } }\left( { {x}^{(i)} } \right)-{ {y}^{(i)} } \right)}^{2} } }$</li>
</ul>
<p>梯度下降算法<br>$$<br>\begin{split}<br>  &amp; \text{Repeat until convergence:} \; \lbrace \\<br>  &amp;{ {\theta }_{j} }:={ {\theta }_{j} }-\alpha \frac{\partial }{\partial { {\theta }_{j} } }J\left( {\theta_{0} },{\theta_{1} }  \right) \\<br>  \rbrace<br>  \end{split}<br>$$</p>
<p>直接将线性回归模型公式代入梯度下降公式可得出公式</p>
<img src="/2024/04/18/15-34-48/20180106_203726.png" class>
<p>当 $j = 0, j = 1$ 时，<strong>线性回归中代价函数求导的推导过程（：</strong></p>
<p>$$<br>\begin{split}<br>\frac{\partial}{\partial\theta_j} J(\theta_1, \theta_1)&amp;=\frac{\partial}{\partial\theta_j} \left(\frac{1}{2m}\sum\limits_{i=1}^{m}{ {\left( { {h}_{\theta } }\left( { {x}^{(i)} } \right)-{ {y}^{(i)} } \right)}^{2} } \right)\\<br>&amp;=\left(\frac{1}{2m}*2\sum\limits_{i=1}^{m}{ {\left( { {h}_{\theta } }\left( { {x}^{(i)} } \right)-{ {y}^{(i)} } \right)} } \right)*\frac{\partial}{\partial\theta_j}{ {\left( { {h}_{\theta } }\left( { {x}^{(i)} } \right)-{ {y}^{(i)} } \right)} } \\<br>&amp;=\left(\frac{1}{m}\sum\limits_{i=1}^{m}{ {\left( { {h}_{\theta } }\left( { {x}^{(i)} } \right)-{ {y}^{(i)} } \right)} } \right)*\frac{\partial}{\partial\theta_j} {\left( \theta_0 + \theta_1{x_1^{(i)} }-{ {y}^{(i)} } \right)}<br>\end{split}<br>$$</p>
<p>所以当 $j = 0$ 时：</p>
<p>$$<br>\frac{\partial}{\partial\theta_0} J(\theta)=\frac{1}{m}\sum\limits_{i=1}^{m}{ {\left( { {h}_{\theta } }\left( { {x}^{(i)} } \right)-{ {y}^{(i)} } \right)} }<br>$$</p>
<p>所以当 $j = 1$ 时：</p>
<p>$$<br>\frac{\partial}{\partial\theta_1} J(\theta)=\frac{1}{m}\sum\limits_{i=1}^{m}{ {\left( { {h}_{\theta } }\left( { {x}^{(i)} } \right)-{ {y}^{(i)} } \right)} } *x_1^{(i)}<br>$$</p>
<p>上文中所提到的梯度下降，都为批量梯度下降（Batch Gradient Descent），即每次计算都使用<strong>所有</strong>的数据集 $\left(\sum\limits_{i=1}^{m}\right)$ 更新。</p>
<p>由于线性回归函数呈现<strong>碗状</strong>，且<strong>只有一个</strong>全局的最优值，所以函数<strong>一定总会</strong>收敛到全局最小值（学习速率不可过大）。同时，函数 $J$ 被称为<strong>凸二次函数</strong>，而线性回归函数求解最小值问题属于<strong>凸函数优化问题</strong>。</p>
<img src="/2024/04/18/15-34-48/24e9420f16fdd758ccb7097788f879e7.png" class>
<p>另外，使用循环求解，代码较为冗余，后面会讲到如何使用<strong>向量化（Vectorization）</strong>来简化代码并优化计算，使梯度下降运行的更快更好。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习, 深度学习, 吴恩达</tag>
      </tags>
  </entry>
  <entry>
    <title>天梯赛刷题记录</title>
    <url>/2024/04/04/12-45-10/</url>
    <content><![CDATA[<h1 id="L1-039-古风排版"><a href="#L1-039-古风排版" class="headerlink" title="L1-039. 古风排版"></a>L1-039. 古风排版</h1><p>中国的古人写文字，是从右向左竖向排版的。本题就请你编写程序，把一段文字按古风排版。</p>
<p>输入格式：</p>
<p>输入在第一行给出一个正整数N（&lt;100），是每一列的字符数。第二行给出一个长度不超过1000的非空字符串，以回车结束。</p>
<p>输出格式：</p>
<p>按古风格式排版给定的字符串，每列N个字符（除了最后一列可能不足N个）</p>
<p>输入样例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">This is a test case</span><br></pre></td></tr></table></figure>
<p>输出样例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">asa T</span><br><span class="line">st ih</span><br><span class="line">e tsi</span><br><span class="line"> ce s</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法比赛</tag>
        <tag>c++</tag>
        <tag>算法模板</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 实验V ShellLab</title>
    <url>/2024/03/14/12-34-42/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.03.14：初稿</li>
</ul>
<h1 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h1><ul>
<li><a href="/2023/03/15/10-59-10/" title="csapp 笔记汇总">CSAPP - 笔记汇总</a></li>
<li><a href="/2023/03/09/11-54-50/" title="CSAPP 实验I Data Lab">I Data Lab - 位操作，数据表示</a></li>
<li><a href="/2023/03/14/09-43-26/" title="CSAPP 实验II Bomb Lab">II Bomb Lab - 汇编，栈帧与 gdb</a></li>
<li><a href="/2023/03/18/15-54-47/" title="CSAPP 实验III Attack Lab">III Attack Lab - 漏洞是如何被攻击的</a></li>
<li><a href="/2024/03/09/16-34-34/" title="CSAPP 实验IV CacheLab">IV Cache Lab - 实现一个缓存系统</a></li>
<li><a href="/2024/03/14/12-34-42/" title="CSAPP 实验V ShellLab">V Shell Lab - 实现一个Shell</a>
</li>
</ul>
<h1 id="任务目标"><a href="#任务目标" class="headerlink" title="任务目标"></a>任务目标</h1><p>ShellLab实验，理解程序控制和信号，完成一个简单Shell。</p>
<h1 id="相关内容"><a href="#相关内容" class="headerlink" title="相关内容"></a>相关内容</h1><ul>
<li><p><code>tsh&gt; /bin/ls -l -d</code>，<code>&amp;</code>后台运行</p>
</li>
<li><p><code>int main(int argc, char *argv[])</code></p>
<ul>
<li><p><code>argc</code>：参数个数  <code>argv[]</code>：从左往右的参数</p>
</li>
<li><p><code>ctrl-c</code> SIGINT终止信号，<code>ctrl-z</code>SIGTSTP停止信号，SIGCONT继续信号</p>
</li>
<li><p><code>jobs</code>：列出所有作业</p>
</li>
<li><p><code>bg &lt;job&gt;</code>：后台暂停的作业开始运行</p>
</li>
<li><p><code>fg &lt;job&gt;</code>：前台暂停的作业开始运行</p>
</li>
<li><p><code>kill &lt;job&gt;</code>：杀死作业</p>
</li>
</ul>
</li>
<li><p><strong>tsh</strong>的规格</p>
<ul>
<li><p>提示符为<code>tsh&gt;</code></p>
</li>
<li><p>输入命令为<code>name arguments</code>：如果name是内置命令，直接执行，否则视为可执行文件路径，并调用初始子进程运行</p>
</li>
<li><p>不需要支持<code>|</code>和<code>&lt;</code>，<code>&gt;</code></p>
</li>
<li><p>信号需要传递到所有子进程</p>
</li>
<li><p>命令末尾带<code>&amp;</code>，后台运行</p>
</li>
<li><p>进程PID<code>%5</code>，作业JID<code>5</code></p>
</li>
<li><p>需要支持内置命令<code>quit</code>，<code>jobs</code>，<code>bg &lt;job&gt;</code>，<code>fg &lt;job&gt;</code></p>
</li>
<li><p>如果僵尸进程没有收到信号就终止了，需要打印出异常信息</p>
</li>
</ul>
</li>
<li><p>检查作业</p>
<ul>
<li><p><code>tshref</code>：样例tsh，可以对比自己的shell</p>
</li>
<li><p><code>sdriver.pl</code>：打印输入的shell命令和输出信息<br> <code>./sdriver.pl -t trace01.txt -s ./tsh -a &quot;-p&quot;</code>：<code>-t</code>追踪文件，<code>-s</code>指定shell，<code>-a &quot;-p&quot;</code>不输出提示符</p>
</li>
<li><p>也可以使用<code>make test01</code>测试自己的shell，<code>make rtest01</code>测试样例shell</p>
</li>
<li><p><code>trace01.txt</code>序号从01-16，越小测试越简单</p>
</li>
<li><p><code>tshref.out</code>所有的输出信息以供参考</p>
</li>
</ul>
</li>
<li><p>提示</p>
<ul>
<li><p>根据追踪文件来设计shell，依次从简单开始，按照输出完成设计</p>
</li>
<li><p>要检测出<code>kill -pid</code>的错误</p>
</li>
<li><p>多使用下列函数</p>
<ul>
<li><p><code>pid_t waitpid (pid_t pid, int* statusp, int options)</code>：</p>
<blockquote>
<p>成功时返回子进程的PID，  </p>
<p>options = WNOHANG时立即返回0     表示没有任何子进程终止</p>
<p>options = WUNTRACED时，接收到SIGSTOP信号，终止或暂停。</p>
<p>如果发生其他错误返回-1。</p>
</blockquote>
</li>
<li><p><code>kill</code>:<code>kill -s &lt;信号&gt;</code></p>
<blockquote>
<p>用指定信号形式终止进程，可以杀死可以暂停</p>
<p>-s，会将s的进程组全部执行</p>
</blockquote>
</li>
<li><p><code>int fork(void)</code>:</p>
<blockquote>
<p>创建一个子进程，子进程返回0，父进程返回子进程的ID，调用一次返回两次，先返回子进程，再返回父进程</p>
</blockquote>
</li>
<li><p><code>int execve(const char *filename, char *const argv[], char *const envp[]);</code>: </p>
<blockquote>
<p>参数为新程序的路径名称，命令行参数数组，环境变量参数数组</p>
<p>替换进程的状态和上下文，切换另一个进程</p>
<p>执行成功不会返回到调用，错误返回-1</p>
</blockquote>
</li>
<li><p><code>int setpgid(pid_t pid, pid_t pgid)</code>:</p>
<blockquote>
<p>给pid进程设置为pgid进程组识别码，如果pid为0设置当前进程，pgid为0，用当前组识别码取代，返回为组识别码，-1错误</p>
</blockquote>
</li>
<li><p><code>sigprocmash</code>:</p>
<blockquote>
<p>int sigprocmask(int how, const sigset_t <em>set, sigset_t </em>oldset);<br>参数：<br>how：用于指定信号修改的方式，可能选择有三种：<br>SIG_BLOCK //加入信号到进程屏蔽。<br>SIG_UNBLOCK //从进程屏蔽里将信号删除。<br>SIG_SETMASK //将set的值设定为新的进程屏蔽。</p>
<p>set：为指向信号集的指针，在此专指新设的信号集，如果仅想读取现在的屏蔽值，可将其置为NULL。<br>oldset：也是指向信号集的指针，在此存放原来的信号集。<br>返回说明：<br>成功执行时，返回0。失败返回-1，errno被设为EINVAL。</p>
</blockquote>
</li>
<li><p><code>exit(int status)</code>：</p>
<blockquote>
<p>终止进程，正常返回状态0</p>
</blockquote>
</li>
<li><p>尽量不要在自己的shell中使用more, less, vi, emacs，多使用/bin/ls,/bin/ps, /bin/echo</p>
</li>
<li><p>如果在Unix shell中像自己的shell输入 ctrl-c：fork之后执行之前，子进程先调用<code>setpgid(0, 0)</code>，放入一个新的进程组，保证Unix shell的进程组中只有shell。不会把命令传递给所有Unix shell的进程组，只传递给shell。</p>
</li>
<li><p>建议在<code>waitfg</code>的循环中用<code>sleep</code>函数，在<code>sigchld_handler</code>中调用<code>waitpid</code></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>常用信号量</p>
<img src="/2024/03/14/12-34-42/QQ20240314-160705@2x.png" class>
<img src="/2024/03/14/12-34-42/QQ20240314-154949@2x.png" class>
</li>
</ul>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h2><p>trace01-03比较简单，用课本中代码写入就可以，修改一下fork和execve封装。</p>
<h2 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h2><h3 id="trace04"><a href="#trace04" class="headerlink" title="trace04"></a>trace04</h3><p>根据标准输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./sdriver.pl -t trace04.txt -s ./tsh -a &quot;-p&quot;</span><br><span class="line">#</span><br><span class="line"># trace04.txt - Run a background job.</span><br><span class="line">#</span><br><span class="line">tsh&gt; ./myspin 1 &amp;</span><br><span class="line">[1] (26252) ./myspin 1 &amp;</span><br></pre></td></tr></table></figure>
<p>在主函数执行中增加添加作业函数<code>addjob</code>，修改一下原来的输出格式，<code>printf(&quot;[%d] (%d)  %s&quot;, pid2jid(pid), pid, cmdline);</code>。</p>
<p>问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tsh&gt; ./myspin 1 &amp;</span><br><span class="line">[2] (920)  ./myspin 1 &amp;</span><br></pre></td></tr></table></figure>
<p>作业从[2]标号开始，可能是重复添加作业了。查看输出后，发现echo函数添加作业后，运行结束时没有删除作业，导致作业号多一个。</p>
<p>解决办法：</p>
<p>在waitpid之后，增加一个删除作业函数<code>deletejob</code></p>
<h2 id="trace05"><a href="#trace05" class="headerlink" title="trace05"></a>trace05</h2><p>增加打印jobs列表</p>
<h3 id="trace06"><a href="#trace06" class="headerlink" title="trace06"></a>trace06</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line"># trace06.txt - Forward SIGINT to foreground job.</span><br><span class="line">#</span><br><span class="line">/bin/echo -e tsh&gt; ./myspin 4</span><br><span class="line">./myspin 4 </span><br><span class="line"></span><br><span class="line">SLEEP 2</span><br><span class="line">INT</span><br></pre></td></tr></table></figure>
<blockquote>
<p>SLEEP命令不是输入进去的字符串，主要是获取作业的终止状态</p>
</blockquote>
<p>相关内容</p>
<ul>
<li><p>waitpid返回状态status</p>
<ul>
<li><p>WIFEXITED(status)：非0正常结束，退出状态WEXITSTATUS(status)</p>
</li>
<li><p>WIFSIGNALED(status)：非0异常终止，退出的信号编号WTERMSIG(status)</p>
</li>
<li><p>WIFSTOPPED(status)：非0暂停状态，暂停的信号编号WSTOPSIG(status)</p>
</li>
<li><p>WIFCONTINUED(status)：非0 暂停后以继续运行</p>
</li>
</ul>
</li>
<li><p>options变量</p>
<ul>
<li><p><code>WNOHANG</code>：没有子进程终止时立即返回，而不会阻塞。</p>
</li>
<li><p><code>WUNTRACED</code>：挂起，返回终止或暂停的进程pid</p>
</li>
<li><p><code>WCONTINUED</code>：挂起，返回一个正在运行的进程终止，或一个暂停的收到SIGCONT信号继续执行。</p>
</li>
</ul>
</li>
<li><p>信号量相关</p>
<ul>
<li><p><code>sigfillset(&amp;mask_all);</code>返回当前进程的信号阻塞集合</p>
</li>
<li><p><code>sigemptyset(&amp;mask_one);</code>初试空值</p>
</li>
<li><p><code>sigaddset(&amp;mask_one, SIGCHLD);</code>，添加一位阻塞位</p>
</li>
<li><p><code>sigprocmask(int how, sigset_t *set, sigset_t *oldset)</code></p>
<blockquote>
<p>how: <code>SIG_SETMASK</code>赋值  </p>
<pre><code>      `SIG_BLOCK`阻塞 做或运算   与原来的集合

      `SIG_UNBLOCK` 解除  做与运算
</code></pre><p>set，操作集合</p>
<p>oldset，保存原集合，可以为NULL</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>对add函数和del函数阻塞信号。</p>
<p>检测INT键，绑定响应函数，用kill杀死进程，系统发出<code>SIGCHLD</code>信号，在<code>SIGCHLD</code>响应函数中删除作业。</p>
<h3 id="trace07"><a href="#trace07" class="headerlink" title="trace07"></a>trace07</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line"># trace07.txt - Forward SIGINT only to foreground job.</span><br><span class="line">#</span><br><span class="line">/bin/echo -e tsh&gt; ./myspin 4 \046</span><br><span class="line">./myspin 4 &amp;</span><br><span class="line"></span><br><span class="line">/bin/echo -e tsh&gt; ./myspin 5</span><br><span class="line">./myspin 5 </span><br><span class="line"></span><br><span class="line">SLEEP 2</span><br><span class="line">INT</span><br><span class="line"></span><br><span class="line">/bin/echo tsh&gt; jobs</span><br><span class="line">jobs</span><br></pre></td></tr></table></figure>
<p>06已经做完了，输出完整。</p>
<h3 id="trace08"><a href="#trace08" class="headerlink" title="trace08"></a>trace08</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/bin/echo -e tsh&gt; ./myspin 4 \046</span><br><span class="line">./myspin 4 &amp;</span><br><span class="line"></span><br><span class="line">/bin/echo -e tsh&gt; ./myspin 5</span><br><span class="line">./myspin 5 </span><br><span class="line"></span><br><span class="line">SLEEP 2</span><br><span class="line">TSTP</span><br><span class="line"></span><br><span class="line">/bin/echo tsh&gt; jobs</span><br><span class="line">jobs</span><br></pre></td></tr></table></figure>
<p>完成前台进程暂停信号响应。kill函数可以暂停进程。</p>
<p>代码可以正常暂停，但是暂停之后不会终止，无法退出。</p>
<p>解决：</p>
<p>用kill(-pid,sig);函数对进程组整体操作。</p>
<h3 id="trace09"><a href="#trace09" class="headerlink" title="trace09"></a>trace09</h3><p>问题：</p>
<p>需要完成bg内置命令，暂停程序后台运行。</p>
<blockquote>
<p>不太清楚中间一次输出信息，为什么不需要换行。</p>
</blockquote>
<h3 id="trace10"><a href="#trace10" class="headerlink" title="trace10"></a>trace10</h3><p>完成fg内置命令</p>
<h3 id="trace11-13"><a href="#trace11-13" class="headerlink" title="trace11-13"></a>trace11-13</h3><img src="/2024/03/14/12-34-42/QQ20240316-185955@2x.png" class>
<p>输出信息与样例shell相同，但和答案不同。</p>
<h3 id="trace14"><a href="#trace14" class="headerlink" title="trace14"></a>trace14</h3><p>问题：</p>
<p>简单的错误处理，处理输入输出格式错误。</p>
<h3 id="trace15-16"><a href="#trace15-16" class="headerlink" title="trace15-16"></a>trace15-16</h3><p>运行结果都对</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>不处理行数问题了，没有评分程序。只有所有例子都输出相同，不太确定是不是都是正确的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * tsh - A tiny shell program with job control</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;Put your name and login ID here&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Misc manifest constants */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 1024   <span class="comment">/* max line size */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXARGS 128    <span class="comment">/* max args on a command line */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXJOBS 16     <span class="comment">/* max jobs at any point in time */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXJID 1 &lt;&lt; 16 <span class="comment">/* max job ID */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Job states */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNDEF 0 <span class="comment">/* undefined */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FG 1    <span class="comment">/* running in foreground */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BG 2    <span class="comment">/* running in background */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ST 3    <span class="comment">/* stopped */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Jobs states: FG (foreground), BG (background), ST (stopped)</span></span><br><span class="line"><span class="comment"> * Job state transitions and enabling actions:</span></span><br><span class="line"><span class="comment"> *     FG -&gt; ST  : ctrl-z</span></span><br><span class="line"><span class="comment"> *     ST -&gt; FG  : fg command</span></span><br><span class="line"><span class="comment"> *     ST -&gt; BG  : bg command</span></span><br><span class="line"><span class="comment"> *     BG -&gt; FG  : fg command</span></span><br><span class="line"><span class="comment"> * At most 1 job can be in the FG state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Global variables */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ;   <span class="comment">/* defined in libc */</span></span><br><span class="line"><span class="type">char</span> prompt[] = <span class="string">&quot;tsh&gt; &quot;</span>; <span class="comment">/* command line prompt (DO NOT CHANGE) */</span></span><br><span class="line"><span class="type">int</span> verbose = <span class="number">0</span>;         <span class="comment">/* if true, print additional output */</span></span><br><span class="line"><span class="type">int</span> nextjid = <span class="number">1</span>;         <span class="comment">/* next job ID to allocate */</span></span><br><span class="line"><span class="type">char</span> sbuf[MAXLINE];      <span class="comment">/* for composing sprintf messages */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> &#123;</span>           <span class="comment">/* The job struct */</span></span><br><span class="line">  <span class="type">pid_t</span> pid;             <span class="comment">/* job PID */</span></span><br><span class="line">  <span class="type">int</span> jid;               <span class="comment">/* job ID [1, 2, ...] */</span></span><br><span class="line">  <span class="type">int</span> state;             <span class="comment">/* UNDEF, BG, FG, or ST */</span></span><br><span class="line">  <span class="type">char</span> cmdline[MAXLINE]; <span class="comment">/* command line */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> <span class="title">jobs</span>[<span class="title">MAXJOBS</span>];</span> <span class="comment">/* The job list */</span></span><br><span class="line"><span class="comment">/* End global variables */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Function prototypes */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//补充函数</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">Fork</span><span class="params">(<span class="type">void</span>)</span>;                                                              <span class="comment">//封装fork</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> environ[])</span>;  <span class="comment">//封装execv函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Here are the functions that you will implement */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">eval</span><span class="params">(<span class="type">char</span> *cmdline)</span>;  <span class="comment">//分析命令</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">builtin_cmd</span><span class="params">(<span class="type">char</span> **argv)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">do_bgfg</span><span class="params">(<span class="type">char</span> **argv)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">waitfg</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigchld_handler</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sigtstp_handler</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sigint_handler</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Here are helper routines that we&#x27;ve provided for you */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">parseline</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cmdline, <span class="type">char</span> **argv)</span>;  <span class="comment">//返回bg标志  1 后台</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigquit_handler</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">clearjob</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *job)</span>;                                     <span class="comment">//清除队列中的一个作业</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initjobs</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs)</span>;                                    <span class="comment">//初始化</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxjid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs)</span>;                                       <span class="comment">//返回以分配的最大作业号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">addjob</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs, <span class="type">pid_t</span> pid, <span class="type">int</span> state, <span class="type">char</span> *cmdline)</span>;  <span class="comment">//添加一个作业  返回1  满了返回0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deletejob</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs, <span class="type">pid_t</span> pid)</span>;                         <span class="comment">//删除队列中一个作业   成功返回1</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fgpid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs)</span>;                                      <span class="comment">//返回一个前台运行的作业号    没有返回0</span></span><br><span class="line"><span class="keyword">struct</span> <span class="type">job_t</span> *<span class="title function_">getjobpid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs, <span class="type">pid_t</span> pid)</span>;               <span class="comment">//使用pid查找一个作业  没找到 返回空</span></span><br><span class="line"><span class="keyword">struct</span> <span class="type">job_t</span> *<span class="title function_">getjobjid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs, <span class="type">int</span> jid)</span>;                 <span class="comment">//用jid查找一个作业</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pid2jid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;                                               <span class="comment">// 用pid 返回 jid,  没找到返回0</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">listjobs</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs)</span>;                                    <span class="comment">//打印作业队列</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">usage</span><span class="params">(<span class="type">void</span>)</span>;                                   <span class="comment">//打印帮助菜单</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">unix_error</span><span class="params">(<span class="type">char</span> *msg)</span>;                         <span class="comment">// unix风格打印错误信息</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">app_error</span><span class="params">(<span class="type">char</span> *msg)</span>;                          <span class="comment">// app风格的错误信息</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> <span class="title function_">handler_t</span><span class="params">(<span class="type">int</span>)</span>;                        <span class="comment">//一个int参数,无返回</span></span><br><span class="line"><span class="type">handler_t</span> *<span class="title function_">Signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">handler_t</span> *handler)</span>;  <span class="comment">//信号包装器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * main - The shell&#x27;s main routine</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">  <span class="type">char</span> cmdline[MAXLINE];</span><br><span class="line">  <span class="type">int</span> emit_prompt = <span class="number">1</span>; <span class="comment">/* emit prompt (default) */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//不用管    重定向输出</span></span><br><span class="line">  <span class="comment">/* Redirect stderr to stdout (so that driver will get all output</span></span><br><span class="line"><span class="comment">   * on the pipe connected to stdout) */</span></span><br><span class="line">  dup2(<span class="number">1</span>, <span class="number">2</span>);  <span class="comment">//把1的文件描述符 复制给2</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Parse the command line */</span></span><br><span class="line">  <span class="keyword">while</span> ((c = getopt(argc, argv, <span class="string">&quot;hvp&quot;</span>)) != EOF) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>: <span class="comment">/* print help message */</span></span><br><span class="line">        usage();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>: <span class="comment">/* emit additional diagnostic info */</span></span><br><span class="line">        verbose = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:          <span class="comment">/* don&#x27;t print a prompt */</span></span><br><span class="line">        emit_prompt = <span class="number">0</span>; <span class="comment">/* handy for automatic testing */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        usage();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Install the signal handlers */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* These are the ones you will need to implement */</span></span><br><span class="line">  Signal(SIGINT, sigint_handler);   <span class="comment">/* ctrl-c */</span></span><br><span class="line">  Signal(SIGTSTP, sigtstp_handler); <span class="comment">/* ctrl-z */</span></span><br><span class="line">  Signal(SIGCHLD, sigchld_handler); <span class="comment">/* Terminated or stopped child */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* This one provides a clean way to kill the shell */</span></span><br><span class="line">  Signal(SIGQUIT, sigquit_handler);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Initialize the job list */</span></span><br><span class="line">  initjobs(jobs);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Execute the shell&#x27;s read/eval loop */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* Read command line */</span></span><br><span class="line">    <span class="keyword">if</span> (emit_prompt) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, prompt);</span><br><span class="line">      fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((fgets(cmdline, MAXLINE, <span class="built_in">stdin</span>) == <span class="literal">NULL</span>) &amp;&amp; ferror(<span class="built_in">stdin</span>))</span><br><span class="line">      app_error(<span class="string">&quot;fgets error&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (feof(<span class="built_in">stdin</span>)) &#123; <span class="comment">/* End of file (ctrl-d) */</span></span><br><span class="line">      fflush(<span class="built_in">stdout</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Evaluate the command line */</span></span><br><span class="line">    eval(cmdline);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">/* control never reaches here */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * eval - Evaluate the command line that the user has just typed in</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the user has requested a built-in command (quit, jobs, bg or fg)</span></span><br><span class="line"><span class="comment"> * then execute it immediately. Otherwise, fork a child process and</span></span><br><span class="line"><span class="comment"> * run the job in the context of the child. If the job is running in</span></span><br><span class="line"><span class="comment"> * the foreground, wait for it to terminate and then return.  Note:</span></span><br><span class="line"><span class="comment"> * each child process must have a unique process group ID so that our</span></span><br><span class="line"><span class="comment"> * background children don&#x27;t receive SIGINT (SIGTSTP) from the kernel</span></span><br><span class="line"><span class="comment"> * when we type ctrl-c (ctrl-z) at the keyboard.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">eval</span><span class="params">(<span class="type">char</span> *cmdline)</span> &#123;</span><br><span class="line">  <span class="type">char</span> *argv[MAXARGS]; <span class="comment">/*Argument list execve() */</span></span><br><span class="line">  <span class="type">char</span> buf[MAXLINE];   <span class="comment">/*Holds modified command line */</span></span><br><span class="line">  <span class="type">int</span> bg;              <span class="comment">/*Should the job run in bg or fg? */</span></span><br><span class="line">  <span class="type">pid_t</span> pid;           <span class="comment">/*Process id */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">sigset_t</span> mask_all, mask_one, prev_one;</span><br><span class="line">  sigfillset(&amp;mask_all);</span><br><span class="line">  sigemptyset(&amp;mask_one);</span><br><span class="line">  sigaddset(&amp;mask_one, SIGCHLD);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(buf, cmdline);</span><br><span class="line">  bg = parseline(buf, argv);</span><br><span class="line">  <span class="keyword">if</span> (argv[<span class="number">0</span>] == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">/* Ignore empty lines */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!builtin_cmd(argv)) &#123;</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;mask_one, &amp;prev_one);   <span class="comment">//阻塞SIGCHLD</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pid = Fork()) == <span class="number">0</span>) &#123;         <span class="comment">/* Child runs user job */</span></span><br><span class="line">      setpgid(<span class="number">0</span>, <span class="number">0</span>);          <span class="comment">//单独加入一个组</span></span><br><span class="line">      sigprocmask(SIG_SETMASK, &amp;prev_one, <span class="literal">NULL</span>);  <span class="comment">//解除SIGCHLD阻塞 赋值新的mask</span></span><br><span class="line">      Execve(argv[<span class="number">0</span>], argv, environ);  <span class="comment">//执行函数不会返回   会结束运行</span></span><br><span class="line">    &#125;                                  <span class="comment">/* Parent waits for foreground job to terminate */</span></span><br><span class="line">    <span class="comment">//添加作业     FG = 0 + 1 = 1    BG = 1 + 1 = 2</span></span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;mask_all, <span class="literal">NULL</span>);   <span class="comment">//应该是重置作用</span></span><br><span class="line">    addjob(jobs, pid, bg + <span class="number">1</span>, cmdline);</span><br><span class="line">    sigprocmask(SIG_SETMASK, &amp;prev_one, <span class="literal">NULL</span>); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!bg) &#123;</span><br><span class="line">      waitfg(pid);   <span class="comment">//等待前台运行结束</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d)  %s&quot;</span>, pid2jid(pid), pid, cmdline);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * parseline - Parse the command line and build the argv array.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Characters enclosed in single quotes are treated as a single</span></span><br><span class="line"><span class="comment"> * argument.  Return true if the user has requested a BG job, false if</span></span><br><span class="line"><span class="comment"> * the user has requested a FG job.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">parseline</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cmdline, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">char</span> <span class="built_in">array</span>[MAXLINE]; <span class="comment">/* holds local copy of command line */</span></span><br><span class="line">  <span class="type">char</span> *buf = <span class="built_in">array</span>;          <span class="comment">/* ptr that traverses command line */</span></span><br><span class="line">  <span class="type">char</span> *delim;                <span class="comment">/* points to first space delimiter */</span></span><br><span class="line">  <span class="type">int</span> argc;                   <span class="comment">/* number of args */</span></span><br><span class="line">  <span class="type">int</span> bg;                     <span class="comment">/* background job? */</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(buf, cmdline);</span><br><span class="line">  buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="string">&#x27; &#x27;</span>;   <span class="comment">/* replace trailing &#x27;\n&#x27; with space */</span></span><br><span class="line">  <span class="keyword">while</span> (*buf &amp;&amp; (*buf == <span class="string">&#x27; &#x27;</span>)) <span class="comment">/* ignore leading spaces */</span></span><br><span class="line">    buf++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Build the argv list */</span></span><br><span class="line">  argc = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (*buf == <span class="string">&#x27;\&#x27;&#x27;</span>) &#123;</span><br><span class="line">    buf++;</span><br><span class="line">    delim = <span class="built_in">strchr</span>(buf, <span class="string">&#x27;\&#x27;&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    delim = <span class="built_in">strchr</span>(buf, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (delim) &#123;</span><br><span class="line">    argv[argc++] = buf;</span><br><span class="line">    *delim = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    buf = delim + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (*buf &amp;&amp; (*buf == <span class="string">&#x27; &#x27;</span>)) <span class="comment">/* ignore spaces */</span></span><br><span class="line">      buf++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*buf == <span class="string">&#x27;\&#x27;&#x27;</span>) &#123;</span><br><span class="line">      buf++;</span><br><span class="line">      delim = <span class="built_in">strchr</span>(buf, <span class="string">&#x27;\&#x27;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      delim = <span class="built_in">strchr</span>(buf, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  argv[argc] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc == <span class="number">0</span>) <span class="comment">/* ignore blank line */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* should the job run in the background? */</span></span><br><span class="line">  <span class="keyword">if</span> ((bg = (*argv[argc - <span class="number">1</span>] == <span class="string">&#x27;&amp;&#x27;</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">    argv[--argc] = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * builtin_cmd - If the user has typed a built-in command then execute</span></span><br><span class="line"><span class="comment"> *    it immediately.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">builtin_cmd</span><span class="params">(<span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;quit&quot;</span>))</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;jobs&quot;</span>)) &#123;</span><br><span class="line">    listjobs(jobs);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;bg&quot;</span>) || !<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;fg&quot;</span>)) &#123;</span><br><span class="line">    do_bgfg(argv);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;&amp;&quot;</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* not a builtin command */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * do_bgfg - Execute the builtin bg and fg commands</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_bgfg</span><span class="params">(<span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  <span class="type">int</span> doid;</span><br><span class="line">  <span class="type">pid_t</span> pid;</span><br><span class="line">  <span class="type">pid_t</span> t_pid;</span><br><span class="line">  <span class="keyword">if</span>(argv[<span class="number">1</span>] == <span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s command requires PID or %%jobid argument\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> jflag = <span class="number">0</span>;  <span class="comment">//组标记</span></span><br><span class="line">  <span class="keyword">if</span>(argv[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27;%&#x27;</span>)&#123;</span><br><span class="line">    jflag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isdigit</span>(argv[<span class="number">1</span>][<span class="number">1</span>]) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s: argument must be a PID or %%jobid\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    doid = atoi(&amp;argv[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isdigit</span>(argv[<span class="number">1</span>][<span class="number">0</span>]) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s: argument must be a PID or %%jobid\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    doid = atoi(&amp;argv[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> * <span class="title">job</span>;</span></span><br><span class="line">  <span class="keyword">if</span>(jflag)&#123;</span><br><span class="line">    job = getjobjid(jobs, doid);  <span class="comment">//jid</span></span><br><span class="line">    <span class="keyword">if</span>(job == <span class="literal">NULL</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d: No such job\n&quot;</span>, doid);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    job = getjobpid(jobs, doid);  <span class="comment">//pid</span></span><br><span class="line">    <span class="keyword">if</span>(job == <span class="literal">NULL</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;(%d): No such process\n&quot;</span>, doid);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;bg&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    kill(-job-&gt;pid, SIGCONT); <span class="comment">//发送继续命令</span></span><br><span class="line">    job-&gt;state = BG;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>,job-&gt;jid,job-&gt;pid,job-&gt;cmdline);  <span class="comment">//不清楚为什么不换行</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    </span><br><span class="line">    t_pid = fgpid(jobs);   <span class="comment">//找当前的前台作业</span></span><br><span class="line">    <span class="keyword">if</span>(job-&gt;state == ST)&#123;</span><br><span class="line">      kill(-job-&gt;pid, SIGCONT); <span class="comment">//发送继续命令</span></span><br><span class="line">    &#125;</span><br><span class="line">    job-&gt;state = FG;</span><br><span class="line">    pid = job-&gt;pid;</span><br><span class="line">    <span class="keyword">if</span>(t_pid != <span class="number">0</span>)&#123;  <span class="comment">//有前台作业 转为后台</span></span><br><span class="line">      job = getjobpid(jobs, doid);</span><br><span class="line">      job-&gt;state = BG;</span><br><span class="line">    &#125;</span><br><span class="line">    waitfg(pid);  <span class="comment">//等待前台运行</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * waitfg - Block until process pid is no longer the foreground process</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">同一时间只有一个fg作业</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">waitfg</span><span class="params">(<span class="type">pid_t</span> pid)</span> &#123;</span><br><span class="line">  <span class="keyword">while</span>(pid == fgpid(jobs))</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*****************</span></span><br><span class="line"><span class="comment"> * Signal handlers</span></span><br><span class="line"><span class="comment"> *****************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sigchld_handler - The kernel sends a SIGCHLD to the shell whenever</span></span><br><span class="line"><span class="comment"> *     a child job terminates (becomes a zombie), or stops because it</span></span><br><span class="line"><span class="comment"> *     received a SIGSTOP or SIGTSTP signal. The handler reaps all</span></span><br><span class="line"><span class="comment"> *     available zombie children, but doesn&#x27;t wait for any other</span></span><br><span class="line"><span class="comment"> *     currently running children to terminate.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  响应 停止信号 处理函数  </span></span><br><span class="line"><span class="comment">  回收所有僵尸进程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigchld_handler</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">  <span class="type">int</span> olderrno = errno;</span><br><span class="line">  <span class="type">sigset_t</span> mask_all,prev_all;</span><br><span class="line">  <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> status; <span class="comment">//获取返回状态</span></span><br><span class="line">  sigfillset(&amp;mask_all);</span><br><span class="line">  <span class="comment">//回收所有的僵尸进程</span></span><br><span class="line">  <span class="keyword">while</span>((pid = waitpid(<span class="number">-1</span>,&amp;status,WNOHANG | WUNTRACED))&gt;<span class="number">0</span>)&#123;  <span class="comment">//如果都没终止返回0 有一个被终止 返回终止pid</span></span><br><span class="line">    <span class="keyword">if</span> (WIFEXITED(status))  &#123;  <span class="comment">//正常终止</span></span><br><span class="line">      sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev_all);</span><br><span class="line">      deletejob(jobs, pid);</span><br><span class="line">      sigprocmask(SIG_SETMASK, &amp;prev_all, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(WIFSIGNALED(status))  &#123;  <span class="comment">//正常终止</span></span><br><span class="line">      sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev_all);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Job [%d] (%d) terminated by signal %d\n&quot;</span>, pid2jid(pid), pid, WTERMSIG(status));</span><br><span class="line">      deletejob(jobs, pid);</span><br><span class="line">      sigprocmask(SIG_SETMASK, &amp;prev_all, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(WIFSTOPPED(status))  &#123;  <span class="comment">//正常暂停</span></span><br><span class="line">      sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev_all);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Job [%d] (%d) stopped by signal %d\n&quot;</span>, pid2jid(pid), pid, WSTOPSIG(status));</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> * <span class="title">fgjob</span> =</span> getjobpid(jobs, pid);  <span class="comment">//查找前台进程指针</span></span><br><span class="line">      fgjob-&gt;state = ST;</span><br><span class="line">      sigprocmask(SIG_SETMASK, &amp;prev_all, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  errno = olderrno;  </span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sigint_handler - The kernel sends a SIGINT to the shell whenver the</span></span><br><span class="line"><span class="comment"> *    user types ctrl-c at the keyboard.  Catch it and send it along</span></span><br><span class="line"><span class="comment"> *    to the foreground job.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">SIGINT 信号只会传递给前台进程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigint_handler</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">  <span class="type">int</span> olderrno = errno;</span><br><span class="line">  <span class="type">pid_t</span> pid;</span><br><span class="line">  pid = fgpid(jobs);</span><br><span class="line">  kill(-pid, sig);  <span class="comment">//发送给前台作业</span></span><br><span class="line">  errno = olderrno;  </span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sigtstp_handler - The kernel sends a SIGTSTP to the shell whenever</span></span><br><span class="line"><span class="comment"> *     the user types ctrl-z at the keyboard. Catch it and suspend the</span></span><br><span class="line"><span class="comment"> *     foreground job by sending it a SIGTSTP.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigtstp_handler</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">  <span class="type">int</span> olderrno = errno;</span><br><span class="line">  <span class="type">pid_t</span> pid;</span><br><span class="line">  pid = fgpid(jobs);</span><br><span class="line">  kill(-pid, sig);  <span class="comment">//发送给前台作业</span></span><br><span class="line">  errno = olderrno;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************</span></span><br><span class="line"><span class="comment"> * End signal handlers</span></span><br><span class="line"><span class="comment"> *********************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//补充函数</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">Fork</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">    unix_error(<span class="string">&quot;Fork error&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> environ[])</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (execve(filename, argv, environ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: Command not found.\n&quot;</span>, filename);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************************************</span></span><br><span class="line"><span class="comment"> * Helper routines that manipulate the job list</span></span><br><span class="line"><span class="comment"> **********************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* clearjob - Clear the entries in a job struct */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clearjob</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *job)</span> &#123;</span><br><span class="line">  job-&gt;pid = <span class="number">0</span>;</span><br><span class="line">  job-&gt;jid = <span class="number">0</span>;</span><br><span class="line">  job-&gt;state = UNDEF;</span><br><span class="line">  job-&gt;cmdline[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* initjobs - Initialize the job list */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initjobs</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">    clearjob(&amp;jobs[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* maxjid - Returns largest allocated job ID */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxjid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i, max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">    <span class="keyword">if</span> (jobs[i].jid &gt; max)</span><br><span class="line">      max = jobs[i].jid;</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* addjob - Add a job to the job list */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">addjob</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs, <span class="type">pid_t</span> pid, <span class="type">int</span> state, <span class="type">char</span> *cmdline)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pid &lt; <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (jobs[i].pid == <span class="number">0</span>) &#123;</span><br><span class="line">      jobs[i].pid = pid;</span><br><span class="line">      jobs[i].state = state;</span><br><span class="line">      jobs[i].jid = nextjid++;</span><br><span class="line">      <span class="keyword">if</span> (nextjid &gt; MAXJOBS)</span><br><span class="line">        nextjid = <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">strcpy</span>(jobs[i].cmdline, cmdline);</span><br><span class="line">      <span class="keyword">if</span> (verbose) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Added job [%d] %d %s\n&quot;</span>, jobs[i].jid, jobs[i].pid, jobs[i].cmdline);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Tried to create too many jobs\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* deletejob - Delete a job whose PID=pid from the job list */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deletejob</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs, <span class="type">pid_t</span> pid)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pid &lt; <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (jobs[i].pid == pid) &#123;</span><br><span class="line">      clearjob(&amp;jobs[i]);</span><br><span class="line">      nextjid = maxjid(jobs) + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* fgpid - Return PID of current foreground job, 0 if no such job */</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fgpid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">    <span class="keyword">if</span> (jobs[i].state == FG)</span><br><span class="line">      <span class="keyword">return</span> jobs[i].pid;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* getjobpid  - Find a job (by PID) on the job list */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="type">job_t</span> *<span class="title function_">getjobpid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs, <span class="type">pid_t</span> pid)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pid &lt; <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">    <span class="keyword">if</span> (jobs[i].pid == pid)</span><br><span class="line">      <span class="keyword">return</span> &amp;jobs[i];</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* getjobjid  - Find a job (by JID) on the job list */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="type">job_t</span> *<span class="title function_">getjobjid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs, <span class="type">int</span> jid)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (jid &lt; <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">    <span class="keyword">if</span> (jobs[i].jid == jid)</span><br><span class="line">      <span class="keyword">return</span> &amp;jobs[i];</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* pid2jid - Map process ID to job ID */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pid2jid</span><span class="params">(<span class="type">pid_t</span> pid)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pid &lt; <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">    <span class="keyword">if</span> (jobs[i].pid == pid) &#123;</span><br><span class="line">      <span class="keyword">return</span> jobs[i].jid;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* listjobs - Print the job list */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">listjobs</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (jobs[i].pid != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) &quot;</span>, jobs[i].jid, jobs[i].pid);</span><br><span class="line">      <span class="keyword">switch</span> (jobs[i].state) &#123;</span><br><span class="line">        <span class="keyword">case</span> BG:</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;Running &quot;</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FG:</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;Foreground &quot;</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ST:</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;Stopped &quot;</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;listjobs: Internal error: job[%d].state=%d &quot;</span>,</span><br><span class="line">                 i, jobs[i].state);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, jobs[i].cmdline);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment"> * end job list helper routines</span></span><br><span class="line"><span class="comment"> ******************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************</span></span><br><span class="line"><span class="comment"> * Other helper routines</span></span><br><span class="line"><span class="comment"> ***********************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * usage - print a help message</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">usage</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Usage: shell [-hvp]\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;   -h   print this message\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;   -v   print additional diagnostic information\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;   -p   do not emit a command prompt\n&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * unix_error - unix-style error routine</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">unix_error</span><span class="params">(<span class="type">char</span> *msg)</span> &#123;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;%s: %s\n&quot;</span>, msg, strerror(errno));</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app_error - application-style error routine</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">app_error</span><span class="params">(<span class="type">char</span> *msg)</span> &#123;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;%s\n&quot;</span>, msg);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Signal - wrapper for the sigaction function</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">handler_t</span> *<span class="title function_">Signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">handler_t</span> *handler)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">action</span>, <span class="title">old_action</span>;</span></span><br><span class="line"></span><br><span class="line">  action.sa_handler = handler;</span><br><span class="line">  sigemptyset(&amp;action.sa_mask); <span class="comment">/* block sigs of type being handled */</span></span><br><span class="line">  action.sa_flags = SA_RESTART; <span class="comment">/* restart syscalls if possible */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sigaction(signum, &amp;action, &amp;old_action) &lt; <span class="number">0</span>)</span><br><span class="line">    unix_error(<span class="string">&quot;Signal error&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> (old_action.sa_handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sigquit_handler - The driver program can gracefully terminate the</span></span><br><span class="line"><span class="comment"> *    child shell by sending it a SIGQUIT signal.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigquit_handler</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Terminating after receipt of SIGQUIT signal\n&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 实验IV CacheLab</title>
    <url>/2024/03/09/16-34-34/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.03.09：初稿</li>
</ul>
<h1 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h1><ul>
<li><a href="/2023/03/15/10-59-10/" title="csapp 笔记汇总">CSAPP - 笔记汇总</a></li>
<li><a href="/2023/03/09/11-54-50/" title="CSAPP 实验I Data Lab">I Data Lab - 位操作，数据表示</a></li>
<li><a href="/2023/03/14/09-43-26/" title="CSAPP 实验II Bomb Lab">II Bomb Lab - 汇编，栈帧与 gdb</a></li>
<li><a href="/2023/03/18/15-54-47/" title="CSAPP 实验III Attack Lab">III Attack Lab - 漏洞是如何被攻击的</a></li>
<li><a href="/2024/03/09/16-34-34/" title="CSAPP 实验IV CacheLab">IV Cache Lab - 实现一个缓存系统</a></li>
<li><a href="/2024/03/14/12-34-42/" title="CSAPP 实验V ShellLab">V Shell Lab - 实现一个Shell</a>
</li>
</ul>
<h1 id="任务目标"><a href="#任务目标" class="headerlink" title="任务目标"></a>任务目标</h1><p>CacheLab实验，第一部分需要模拟Cache计算命中，未命中次数，第二部分实现代码优化，减少未命中次数。</p>
<h1 id="相关内容"><a href="#相关内容" class="headerlink" title="相关内容"></a>相关内容</h1><ol>
<li><p>Cache</p>
<blockquote>
<img src="/2024/03/09/16-34-34/QQ20240309-165258@2x.png" class>
<p>不需要关注 <code>b</code> bits，使用LRU替换策略。</p>
<p>Cache是一个二维数组cache[S][E]，S=2^s，组数。</p>
<p>每一个cache行包含：Valid bit， Tag， LRU counter。</p>
<p>用Tag对比E匹配line。</p>
</blockquote>
</li>
<li><p>生成内存调试工具命令: <code>linux&gt; valgrind --log-fd=1 --tool=lackey -v --trace-mem=yes ls -l</code></p>
<blockquote>
<p>参数<code>ls -l</code>：打印输出在文件stdout</p>
<p>格式为<code>[space]operation address,size</code>，除了I操作外，前都有一个空格</p>
<p>操作：I-instruction load，L-data load，S-data store， M-data modify。M包含L，S。</p>
<p>address：64-bit 16进制</p>
<p>size：字节数</p>
</blockquote>
</li>
</ol>
<h1 id="题目及解法"><a href="#题目及解法" class="headerlink" title="题目及解法"></a>题目及解法</h1><h2 id="Part-A-Writing-a-Cache-Simulator"><a href="#Part-A-Writing-a-Cache-Simulator" class="headerlink" title="Part A Writing a Cache Simulator"></a>Part A Writing a Cache Simulator</h2><p>完成<code>csim.c</code>文件，使用<code>valgrind</code>生成测试数据，输出命中，未命中和替换次数，输出格式为<code>hits:4 misses:5 evictions:3</code>。</p>
<h3 id="相关内容-1"><a href="#相关内容-1" class="headerlink" title="相关内容"></a>相关内容</h3><ul>
<li><p>修改<code>csim.c</code>文件</p>
</li>
<li><p>可参考的二进制文件<code>csim-ref</code>，使用命令<code>./csim-ref [-hv] -s &lt;s&gt; -E &lt;E&gt; -b &lt;b&gt; -t &lt;tracefile&gt;</code></p>
<blockquote>
<p>参数：v-打印内存追踪记录</p>
</blockquote>
</li>
<li><p>自动评分工具<code>test-csim</code></p>
</li>
<li><p>建议代码像参考模拟器显示输出，方便测试。</p>
</li>
<li><p>使用<code>getopt</code>分析命令行参数。需包含头文件<getopt.h>，<unistd.h>，<stdlib.h>。可以获取函数参数。</stdlib.h></unistd.h></getopt.h></p>
</li>
<li><p>使用<code>fscanf</code>按行读取文件</p>
</li>
<li><p>使用<code>malloc</code>，<code>free</code>，防止内存泄漏</p>
</li>
<li><p>使用<code>printSummary(hit_count, miss_count, eviction_count);</code>，打印输出</p>
</li>
<li><p>数据是对齐，且不会出现跨块访问。</p>
</li>
</ul>
<h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSetbits 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxLine 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxBytebits 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Myline</span>&#123;</span></span><br><span class="line">  <span class="type">int</span> valid; <span class="comment">//有效位</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> tag;   <span class="comment">//tag标记  十进制</span></span><br><span class="line">  <span class="type">int</span> lru_num;   <span class="comment">// 最近使用标记 0 - (E - 1)</span></span><br><span class="line">&#125;Myline;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Mycache</span>&#123;</span></span><br><span class="line">  <span class="type">int</span> S;            <span class="comment">// set 大小</span></span><br><span class="line">  <span class="type">int</span> E;            <span class="comment">// line 大小</span></span><br><span class="line">  <span class="type">int</span> B;            <span class="comment">//偏移大小</span></span><br><span class="line">  <span class="type">int</span> size_Tag;     <span class="comment">// tag bits = 64 - s- b</span></span><br><span class="line">  Myline **<span class="built_in">set</span>;    <span class="comment">//set数组</span></span><br><span class="line">&#125;Mycache;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//get command line arguments</span></span><br><span class="line"><span class="comment">//p_s s的指针   p_E E的指针   p_b b的指针    fn 文件名</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Mygetopt</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[], <span class="type">int</span> *p_s, <span class="type">int</span> *p_E, <span class="type">int</span> *p_b, <span class="type">char</span> *fn, <span class="type">int</span> *flag_v)</span>;   </span><br><span class="line"><span class="comment">//16进制转换十进制</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="title function_">Hex2dec</span><span class="params">(<span class="type">char</span> *hex)</span>;</span><br><span class="line"><span class="comment">//返回tag</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="title function_">GetDecTag</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> dec, <span class="type">int</span> s, <span class="type">int</span> b)</span>;</span><br><span class="line"><span class="comment">//返回组号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">GetDecSetNum</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> dec, <span class="type">int</span> s, <span class="type">int</span> b)</span>;</span><br><span class="line"><span class="comment">//返回这个dec地址下当前偏移量开始剩余的字节数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">GetDecRestByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> dec, <span class="type">int</span> s, <span class="type">int</span> b, <span class="type">int</span> B)</span>;</span><br><span class="line"><span class="comment">//初始化set</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Initset</span><span class="params">(Mycache *mc)</span>;</span><br><span class="line"><span class="comment">//处理最近未使用</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">GetminLRU</span><span class="params">(Myline *<span class="built_in">set</span>, <span class="type">int</span> E)</span>;</span><br><span class="line"><span class="comment">//是否set满了</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">IsFullSet</span><span class="params">(Myline *<span class="built_in">set</span>, <span class="type">int</span> E)</span>;</span><br><span class="line"><span class="comment">//命中处理  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HitDeal</span><span class="params">(Myline *<span class="built_in">set</span>, <span class="type">int</span> E, <span class="type">int</span> Eindex)</span>;</span><br><span class="line"><span class="comment">//未命中 加载cache</span></span><br><span class="line"><span class="comment">// 有空余line加载</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MissLoadDeal</span><span class="params">(Myline *<span class="built_in">set</span>, <span class="type">int</span> E, <span class="type">int</span> Eindex, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> dec_tag)</span>;</span><br><span class="line"><span class="comment">//line替换</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MissEvictionDeal</span><span class="params">(Myline *<span class="built_in">set</span>, <span class="type">int</span> E, <span class="type">int</span> delindex, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> dec_tag)</span>;</span><br><span class="line"><span class="comment">//访问处理   返回1 hit   2  miss  3 miss eviction</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">LoadDeal</span><span class="params">(Myline *<span class="built_in">set</span>, <span class="type">int</span> E, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> now_tag, <span class="type">int</span> flag_v)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">StoreDeal</span><span class="params">(Myline *<span class="built_in">set</span>, <span class="type">int</span> E, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> now_tag, <span class="type">int</span> flag_v)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ModifyDeal</span><span class="params">(Myline *<span class="built_in">set</span>, <span class="type">int</span> E, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> now_tag, <span class="type">int</span> flag_v)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  FILE *fp;</span><br><span class="line">  <span class="type">int</span> hit_count, miss_count, eviction_count;</span><br><span class="line">  <span class="type">int</span> s, E, b;</span><br><span class="line">  <span class="type">int</span> flag_v = <span class="number">0</span>;     <span class="comment">//opt v 的标记</span></span><br><span class="line">  <span class="type">char</span> *file_name;</span><br><span class="line">  <span class="type">char</span> optcache = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  <span class="type">char</span> ignorechar = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  <span class="type">char</span> hex[<span class="number">65</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="type">int</span> size = <span class="number">0</span>;        <span class="comment">//个数</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> dec;</span><br><span class="line"></span><br><span class="line">  hit_count = <span class="number">0</span>;</span><br><span class="line">  miss_count = <span class="number">0</span>;</span><br><span class="line">  eviction_count = <span class="number">0</span>;</span><br><span class="line">  Mycache cache;</span><br><span class="line">  file_name = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * <span class="number">30</span>);</span><br><span class="line">  Mygetopt(argc, argv, &amp;s, &amp;E, &amp;b, file_name, &amp;flag_v);</span><br><span class="line">  cache.S = <span class="built_in">pow</span>(<span class="number">2</span>, s);</span><br><span class="line">  cache.E = E;</span><br><span class="line">  cache.B = <span class="built_in">pow</span>(<span class="number">2</span>, b);</span><br><span class="line">  cache.size_Tag = <span class="number">64</span> - s - b;</span><br><span class="line">  Initset(&amp;cache);</span><br><span class="line"></span><br><span class="line">  fp = fopen(file_name, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">fscanf</span>(fp, <span class="string">&quot; %c %[^,]%c%d&quot;</span>, &amp;optcache, hex, &amp;ignorechar, &amp;size) != <span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(optcache == <span class="string">&#x27;I&#x27;</span>)&#123;</span><br><span class="line">      <span class="built_in">fscanf</span>(fp, <span class="string">&quot;%c&quot;</span>, &amp;ignorechar);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag_v == <span class="number">1</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%c %s,%d&quot;</span>, optcache, hex, size);</span><br><span class="line">    &#125;</span><br><span class="line">    dec = Hex2dec(hex);</span><br><span class="line">    <span class="comment">//========处理内存访问</span></span><br><span class="line">    <span class="type">int</span> setnum = <span class="number">0</span>;  <span class="comment">//组号</span></span><br><span class="line">    <span class="type">int</span> flag_kind = <span class="number">0</span>;   <span class="comment">//cache 类型   hit miss  </span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> dectag = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//int restbyte = 0;  // 当前偏移量下剩余的字节数</span></span><br><span class="line">    <span class="comment">//int loadbyte = 0;  //已加载的字节数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> loaddec = dec;   <span class="comment">//当前加载的地址</span></span><br><span class="line">    setnum = GetDecSetNum(loaddec, s, b);</span><br><span class="line">    dectag = GetDecTag(loaddec, s, b);</span><br><span class="line">    <span class="comment">//restbyte = GetDecRestByte(loaddec, s, b, cache.B);   //剩余加载的字节数</span></span><br><span class="line">    flag_kind = LoadDeal(cache.<span class="built_in">set</span>[setnum], E, dectag, flag_v);</span><br><span class="line">    <span class="comment">/*loadbyte += restbyte;</span></span><br><span class="line"><span class="comment">    loaddec += restbyte;   //当前地址加上剩余字节数  如果加载字节数不够  这就是下一个加载地址</span></span><br><span class="line"><span class="comment">    while(loadbyte &lt; size)&#123;</span></span><br><span class="line"><span class="comment">      setnum = GetDecSetNum(loaddec, s, b);</span></span><br><span class="line"><span class="comment">      dectag = GetDecTag(loaddec, s, b);</span></span><br><span class="line"><span class="comment">      LoadDeal(cache.set[setnum], E, dectag, flag_v);</span></span><br><span class="line"><span class="comment">      loadbyte += cache.B;</span></span><br><span class="line"><span class="comment">      loaddec += cache.B;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="keyword">if</span>(flag_kind == <span class="number">1</span>)&#123;</span><br><span class="line">      hit_count++;</span><br><span class="line">      <span class="keyword">if</span>(flag_v == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; hit&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(flag_kind == <span class="number">2</span>)&#123;</span><br><span class="line">        miss_count++;</span><br><span class="line">        <span class="keyword">if</span>(flag_v == <span class="number">1</span>)&#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot; miss&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">        miss_count++;</span><br><span class="line">        eviction_count++;</span><br><span class="line">        <span class="keyword">if</span>(flag_v == <span class="number">1</span>)&#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot; miss eviction&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(optcache == <span class="string">&#x27;M&#x27;</span>)&#123;</span><br><span class="line">      hit_count++;   <span class="comment">//修改  store一定hit</span></span><br><span class="line">      <span class="keyword">if</span>(flag_v == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; hit\n&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(flag_v == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//=====================</span></span><br><span class="line">    <span class="built_in">fscanf</span>(fp, <span class="string">&quot;%c&quot;</span>, &amp;ignorechar);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  printSummary(hit_count, miss_count, eviction_count);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Mygetopt</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[], <span class="type">int</span> *p_s, <span class="type">int</span> *p_E, <span class="type">int</span> *p_b, <span class="type">char</span> *fn, <span class="type">int</span> *flag_v)</span>&#123;</span><br><span class="line">  <span class="type">int</span> opt;</span><br><span class="line">  <span class="keyword">while</span> ((opt = getopt(argc, argv, <span class="string">&quot;vh:s:E:b:t:&quot;</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">        *p_s = atoi(optarg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:</span><br><span class="line">        *p_E = atoi(optarg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">        *p_b = atoi(optarg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line">        <span class="built_in">strcpy</span>(fn, optarg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:</span><br><span class="line">        *flag_v = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="title function_">Hex2dec</span><span class="params">(<span class="type">char</span> *hex)</span>&#123;</span><br><span class="line">  <span class="type">int</span> len = <span class="built_in">strlen</span>(hex);</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> dec = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> pow16 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isdigit</span>(hex[i]))&#123;</span><br><span class="line">      dec += (hex[i] - <span class="string">&#x27;0&#x27;</span>) * pow16;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      dec += (hex[i] - <span class="number">87</span>) * pow16;</span><br><span class="line">    &#125;</span><br><span class="line">    pow16 *= <span class="number">16</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dec;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="title function_">GetDecTag</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> dec, <span class="type">int</span> s, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> dec &gt;&gt; (s + b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">GetDecSetNum</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> dec, <span class="type">int</span> s, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">  <span class="type">int</span> setbits = (<span class="number">1</span> &lt;&lt; s);</span><br><span class="line">  setbits = ~(~setbits + <span class="number">1</span>);</span><br><span class="line">  dec = dec &gt;&gt; (b);</span><br><span class="line">  <span class="keyword">return</span> dec &amp; setbits;   <span class="comment">//返回set组号</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">GetDecRestByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> dec, <span class="type">int</span> s, <span class="type">int</span> b, <span class="type">int</span> B)</span>&#123;</span><br><span class="line">  <span class="type">int</span> Bytebits = <span class="number">1</span> &lt;&lt; b;</span><br><span class="line">  Bytebits = ~(~Bytebits + <span class="number">1</span>);</span><br><span class="line">  dec = dec &amp; Bytebits;   <span class="comment">//剩余偏移量</span></span><br><span class="line">  <span class="keyword">return</span> B - dec;  <span class="comment">//返回剩余的字节数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Initset</span><span class="params">(Mycache *mc)</span>&#123;</span><br><span class="line">  <span class="type">int</span> S = (*mc).S;</span><br><span class="line">  <span class="type">int</span> E = (*mc).E;</span><br><span class="line">  (*mc).<span class="built_in">set</span> = (Myline **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Myline *) * S);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; S; i++)&#123;</span><br><span class="line">    (*mc).<span class="built_in">set</span>[i] = (Myline *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Myline) * E);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; (*mc).S; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; (*mc).E; j++)&#123;</span><br><span class="line">      (*mc).<span class="built_in">set</span>[i][j].valid = <span class="number">0</span>;  <span class="comment">//有效位为0</span></span><br><span class="line">      (*mc).<span class="built_in">set</span>[i][j].lru_num = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">GetminLRU</span><span class="params">(Myline *<span class="built_in">set</span>, <span class="type">int</span> E)</span>&#123;</span><br><span class="line">  <span class="type">int</span> min = <span class="number">1000</span>;</span><br><span class="line">  <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; E; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">set</span>[i].valid == <span class="number">0</span>)&#123;   <span class="comment">// 如果存在一个无效位置 直接返回</span></span><br><span class="line">      k = i;</span><br><span class="line">      <span class="keyword">break</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">set</span>[i].lru_num &lt; min)&#123;  </span><br><span class="line">      min = <span class="built_in">set</span>[i].lru_num;</span><br><span class="line">      k = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">IsFullSet</span><span class="params">(Myline *<span class="built_in">set</span>, <span class="type">int</span> E)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; E; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">set</span>[i].valid == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">HitDeal</span><span class="params">(Myline *<span class="built_in">set</span>, <span class="type">int</span> E, <span class="type">int</span> Eindex)</span>&#123;</span><br><span class="line">  <span class="type">int</span> nowLRU = <span class="built_in">set</span>[Eindex].lru_num;</span><br><span class="line">  <span class="comment">//把比现在要访问的cache set中lrunum大的全部减一  </span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; E; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">set</span>[i].lru_num &gt; nowLRU)&#123;</span><br><span class="line">      <span class="built_in">set</span>[i].lru_num--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">set</span>[Eindex].lru_num = E - <span class="number">1</span>;  <span class="comment">//最新访问的cache LRU设置为最大</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">MissLoadDeal</span><span class="params">(Myline *<span class="built_in">set</span>, <span class="type">int</span> E, <span class="type">int</span> Eindex, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> dec_tag)</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//把比现在要访问的cache set中lrunum大的全部减一  </span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; E; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">set</span>[i].lru_num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">set</span>[i].lru_num--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">set</span>[Eindex].tag = dec_tag;</span><br><span class="line">  <span class="built_in">set</span>[Eindex].valid = <span class="number">1</span>;  </span><br><span class="line">  <span class="built_in">set</span>[Eindex].lru_num = E - <span class="number">1</span>;  <span class="comment">//最新访问的cache LRU设置为最大</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MissEvictionDeal</span><span class="params">(Myline *<span class="built_in">set</span>, <span class="type">int</span> E, <span class="type">int</span> delindex, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> dec_tag)</span>&#123;</span><br><span class="line">  <span class="comment">//将要替换的line命中  改为最近访问过,然后再替换掉tag值</span></span><br><span class="line">  HitDeal(<span class="built_in">set</span>, E, delindex);</span><br><span class="line">  <span class="built_in">set</span>[delindex].tag = dec_tag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">LoadDeal</span><span class="params">(Myline *<span class="built_in">set</span>, <span class="type">int</span> E, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> now_tag, <span class="type">int</span> flag_v)</span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; E; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">set</span>[i].tag == now_tag &amp;&amp; <span class="built_in">set</span>[i].valid == <span class="number">1</span>)&#123;</span><br><span class="line">      HitDeal(<span class="built_in">set</span>, E, i);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(i == E)&#123;</span><br><span class="line">    <span class="type">int</span> Lindex = GetminLRU(<span class="built_in">set</span>, E);</span><br><span class="line">    <span class="keyword">if</span>(IsFullSet(<span class="built_in">set</span>, E) == <span class="number">1</span>)&#123;</span><br><span class="line">      <span class="comment">//满的  替换</span></span><br><span class="line">      MissEvictionDeal(<span class="built_in">set</span>, E, Lindex, now_tag);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      MissLoadDeal(<span class="built_in">set</span>, E, Lindex, now_tag);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">StoreDeal</span><span class="params">(Myline *<span class="built_in">set</span>, <span class="type">int</span> E, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> now_tag, <span class="type">int</span> flag_v)</span>&#123;</span><br><span class="line">  <span class="comment">//Store 相当于 Load</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ModifyDeal</span><span class="params">(Myline *<span class="built_in">set</span>, <span class="type">int</span> E, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> now_tag, <span class="type">int</span> flag_v)</span>&#123;</span><br><span class="line">  <span class="comment">//int kind = LoadDeal(set, E, now_tag,flag_v);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Part-B-Optimizing-Matrix-Transpose"><a href="#Part-B-Optimizing-Matrix-Transpose" class="headerlink" title="Part B Optimizing Matrix Transpose"></a>Part B Optimizing Matrix Transpose</h2><p>完成<code>trans.c</code>文件，实现一个转置矩阵代码<code>transpose_submit</code>，尽可能少的产生cache未命中。</p>
<h3 id="相关内容-2"><a href="#相关内容-2" class="headerlink" title="相关内容"></a>相关内容</h3><ul>
<li><p>只允许使用最多12个本地int变量，调用函数中一起计算</p>
</li>
<li><p>不允许使用long或者其他存储数值的方法，不允许使用数组</p>
</li>
<li><p>不能递归</p>
</li>
<li><p>使用参考模拟器来测试代码，cache参数为<code>s = 5， E = 1， b = 5</code></p>
</li>
<li><p>int为4个字节。</p>
</li>
<li><p>只有三种形式的矩阵，32*32，64*64，61*67。</p>
</li>
<li><img src="/2024/03/09/16-34-34/QQ20240310-152729@2x.png" class> 
<p>矩阵乘法的分块技术</p>
</li>
<li><p>两个数组的第一个数据，在cache中存储到相同位置，数组按照行优先存储，数据是对齐的</p>
</li>
<li><p><code>./test-trans -M 32 -N 32</code> 测试函数 </p>
</li>
<li><p><code>./tracegen -M 64 -N 64 -F 0</code> 输出错误信息 </p>
</li>
</ul>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>数据是对齐的，所以一个cache行包含32个字节，存储8个int数据，cache能存储256个int数据，根据<del><code>3B^2 &lt;&lt; C</code>，块长为B=8</del>。根据<code>2B^2 &lt;&lt; C</code>，块长&lt;=11，由于cache行可以存8个数据，所以选择块长8。</p>
<img src="/2024/03/09/16-34-34/QQ20240310-191918@2x.png" class>
<p>以32*32的矩阵为例，除了处于对角线上的块会产生冲突不命中，其他块都可以优化不命中情况</p>
<p>以上这种情况对32*32是成立的，64*64和61*67不成立，所以重新思考了这道题的解法，根据data lab中数据的操作都是在内存中进行的。</p>
<p><strong>数组的首地址给出后，行优先数据为一维连续存储形式</strong></p>
<p>这道题可以转换为数组A[N][M]在内存中连续存放，每一个位置x的数根据相同的转换方式保存到数组B[M][N]的位置y，转换公式为<code>i_a = x / M</code>，<code>j_a = x % M</code>，<code>y = j_a * N + i_a * M</code>。于是存储公式为<code>B(y) = A(x)</code>。</p>
<img src="/2024/03/09/16-34-34/QQ20240312-145802@2x.png" class>
<blockquote>
<p>示意图如上，cache行存2个数据，3*3的数组中，无法直观看出内存区别，而cache的分块目的是为了在内存中读取到cache时减少miss次数，所以我们根据内存进行重排数组，改为5*2的数组。</p>
</blockquote>
<p>所以这道题可以把数组转换为32列的任意数组，由于一行只有32列，远远小于cache的容量256个数据，所以相邻行的上下两个数据不会映射的同一个cache行。</p>
<p>需要把文件放入linux的文件夹中，如果在共享文件夹中会出现运行超时。</p>
<h3 id="32-x-32"><a href="#32-x-32" class="headerlink" title="32 x 32"></a>32 x 32</h3><p>基本步骤：</p>
<ul>
<li><p>重排数组</p>
</li>
<li><p>处理AB数组中x，y映射相同的位置，先用局部变量保存，然后处理这一行的其他数据，最后保存在B数组的中，cache行自动换出。</p>
</li>
</ul>
<p><strong>分析原因</strong></p>
<blockquote>
<p>当<code>A[i][j]</code>与<code>B[j][i]</code>的cache映射相同set内时，取出<code>A[i][j]</code>中的值，写入B数组时会换出A的cache行，导致下次访问A的同一行cache数据时需要继续换出一次。</p>
</blockquote>
<p><strong>解决办法</strong></p>
<blockquote>
<p>用局部变量保存访问冲突的值，等循环结束后，在写入B中。</p>
<p>计算所在行，x表示数组一维连续内存的位置(0开始)，cache 组号<code>s=（x%256 ) / 8;</code></p>
</blockquote>
<p><strong>结果</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> A[N][M], <span class="type">int</span> B[M][N])</span> &#123;</span><br><span class="line">  <span class="comment">//int t_1, t_2, t_3;</span></span><br><span class="line">  <span class="type">int</span> t_4, t_5;</span><br><span class="line">  <span class="type">int</span> i, j, ii, jj;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i += <span class="number">8</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; M; j += <span class="number">8</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (ii = i; ii &lt; ((i + <span class="number">8</span>) &lt; N ? i + <span class="number">8</span> : N); ii++) &#123;</span><br><span class="line">        <span class="comment">//标记没有访问冲突</span></span><br><span class="line">        t_4 = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (jj = j; jj &lt; ((j + <span class="number">8</span>) &lt; M ? j + <span class="number">8</span> : M); jj++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (ii * M + jj == jj * N + ii) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t_4 == <span class="number">-1</span>) &#123;</span><br><span class="line">              t_4 = ii;</span><br><span class="line">              t_5 = jj;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// printf(&quot;**  2-- %d  3--  %d\n&quot;, t_2, t_3);</span></span><br><span class="line">          B[jj][ii] = A[ii][jj];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t_4 != <span class="number">-1</span>) &#123;</span><br><span class="line">          B[t_5][t_4] = A[t_4][t_5];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2024/03/09/16-34-34/QQ20240312-183951@2x.png" class>
<p>miss数量287，满分</p>
<h3 id="64-x-64"><a href="#64-x-64" class="headerlink" title="64 x 64"></a>64 x 64</h3><p>出现一个cache行中两次相同映射的问题</p>
<p><strong>分析原因</strong></p>
<blockquote>
<p>在32 x 32的数组中，一个cache行为8，块为8x8，一个cache行最多只有对角线的的一个元素冲突miss，但是64x64的数组中，8x8的块中，前四行与后四行冲突miss，所以一个cache行的8个数据中，最多有两个元素冲突miss</p>
</blockquote>
<p><strong>解决办法</strong></p>
<blockquote>
<p>继续添加一个局部变量记录冲突位置，一行遍历完后再处理。</p>
<p>继续出现了只遍历到了32，在64 X 64的数组转换为32列时，行数为128。</p>
</blockquote>
<img src="/2024/03/09/16-34-34/QQ20240312-225626@2x.png" class>
<p>miss数量为4611，还需要继续调低。</p>
<p><strong>分析原因</strong></p>

<p><del>错误答案</del></p>
<p>64X64中，改了内存排列后，第二行与第一行的转置不在同一cache行内。</p>
<p>按照左上右上，左下，右下顺序。</p>
<p><strong>结果</strong></p>
<img src="/2024/03/09/16-34-34/QQ20240313-183244@2x.png" class>
<p><strong>分析原因</strong></p>
<blockquote>
<p>没有拿到满分，按照上下划分为两个4X8的数组</p>
<p>下边的4X8数组，一行中的后四列在B数组中会cache冲突行，如图<img src="/2024/03/09/16-34-34/QQ20240313-191649@2x.png" class></p>
<p>注意：</p>
<p>上四行转置之后，B数组的下四行正在cache中，为了不换出，先转置A数组的右下，再左下。</p>
</blockquote>
<p><strong>结果</strong></p>
<img src="/2024/03/09/16-34-34/QQ20240313-193617@2x.png" class>
<p>减少到1547，但是还没有满分。</p>
<p>继续修改</p>
<blockquote>
<p>题目要求减少miss数量，可以利用cache中空闲的地方保存数据  最后在替换出去</p>
<img src="/2024/03/09/16-34-34/QQ20240313-202434@2x.png" class>
<p>如图，A的上半部分的后四列存到B的后四列中</p>
<img src="/2024/03/09/16-34-34/QQ20240313-202818@2x.png" class>
<p>下半部分的第一列，先把B数组的第一行后四列保存到下部分的第一行，这样第一个cache就替换完成，依次完成其他行，最后把右下角转置过去。</p>
</blockquote>
<p><strong>结果</strong></p>
<img src="/2024/03/09/16-34-34/QQ20240313-210554@2x.png" class>
<p>miss数1339，差39次满分，没有找到优化位置。</p>
<h3 id="61-X-67"><a href="#61-X-67" class="headerlink" title="61 X 67"></a>61 X 67</h3><p><strong>结果</strong></p>
<img src="/2024/03/09/16-34-34/QQ20240313-210917@2x.png" class>
<p><strong>最终得分</strong></p>
<img src="/2024/03/09/16-34-34/QQ20240314-144148@2x.png" class>
<p>拿到了51.5分，之后有时间再来查代码优化的地方。</p>
]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 笔记六 存储器层次结构</title>
    <url>/2023/07/23/09-27-18/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>23.07.23：初稿</li>
</ul>
<h1 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h1><ul>
<li><a href="/2023/03/15/10-59-10/" title="csapp 笔记汇总">CSAPP - 笔记汇总</a></li>
<li><a href="/2023/05/24/13-04-09/" title="CSAPP 笔记三 程序的机器级表示">第三章 - 程序的机器级表示</a></li>
<li><a href="/2023/07/06/14-25-42/" title="CSAPP 笔记五 优化程序性能">第五章 - 优化程序性能</a></li>
<li><a href="/2023/07/23/09-27-18/" title="CSAPP 笔记六 存储器层次结构">第六章 - 存储器层次结构</a>
</li>
</ul>
<h1 id="The-Memory-Hierarchy"><a href="#The-Memory-Hierarchy" class="headerlink" title="The Memory Hierarchy"></a>The Memory Hierarchy</h1><h2 id="Storage-technologies-and-trends"><a href="#Storage-technologies-and-trends" class="headerlink" title="Storage technologies and trends"></a>Storage technologies and trends</h2><p><strong>Random-Access Memory(RAM)</strong></p>
<p>根据存储单元实现方式区分为：</p>
<p><strong>SRAM(Static)</strong></p>
<ul>
<li><p>4或6个晶体存储 1 bit， 成本很高</p>
</li>
<li><p>访问速度比DRAM快</p>
</li>
<li><p>不太需要EDC(error detection and correction)错误检测和纠正</p>
</li>
<li><p>组成cache</p>
</li>
</ul>
<p><strong>DRAM(Dynamic)</strong></p>
<ul>
<li><p>一个晶体存储 1 bit</p>
</li>
<li><p>需要刷新 </p>
</li>
<li><p>需要EDC</p>
</li>
<li><p>组成主存储器，图形显卡的帧缓存(frame buffers)</p>
</li>
</ul>
<p><strong>Nonvolatile Memories</strong></p>
<p>Read-only memory(ROM):生产期间硬编程一次</p>
<p>Programmable ROM(PROM): 可编程ROM</p>
<p>Eraseable PROM(EPROM): 可擦拭可编程ROM</p>
<p>Electrically eraseable PROM(EEPROM): 电子可擦拭可编程ROM</p>
<p>Flash memory: 闪存，提供了擦拭模块，但是会有损耗。</p>
<p><strong>Disk Drive</strong></p>
<p>因为机械特性，硬盘会比SRAM，DRAM慢很多。</p>
<img src="/2023/07/23/09-27-18/QQ20230723-095730@2x.jpg" class>
<p>Sectors：扇区</p>
<img src="/2023/07/23/09-27-18/QQ20230723-143055@2x.jpg" class>
<p>Cylinder: 柱面</p>
<p>Logical Disk Blocks：逻辑块</p>
<p>实现物理块与逻辑块之间的映射关系。</p>
<p><strong>Solid State Disks(SSDs)</strong></p>
<img src="/2023/07/23/09-27-18/QQ20230723-143913@2x.jpg" class>
<ul>
<li><p>没有机械部件，由闪存翻译层固件控制</p>
</li>
<li><p>以页为单位读写，写入时必须擦拭整个块</p>
</li>
</ul>
<h2 id="Locality-of-reference"><a href="#Locality-of-reference" class="headerlink" title="Locality of reference"></a>Locality of reference</h2><p>程序的局部性</p>
<p>程序需要良好的局部性，有利用于读写内存。</p>
<h2 id="Caching-in-the-Memory-Hierarchy"><a href="#Caching-in-the-Memory-Hierarchy" class="headerlink" title="Caching in the Memory Hierarchy"></a>Caching in the Memory Hierarchy</h2><p>利用缓存和局部性原理构建了存储器层次结构。</p>
<img src="/2023/07/23/09-27-18/QQ20230723-144603@2x.jpg" class>
<blockquote>
<p>高层保存着从低层检索到的数据</p>
</blockquote>
<p><strong>Caches</strong></p>
<img src="/2023/07/23/09-27-18/QQ20230723-144821@2x.jpg" class>
<p>Cold (compulsory) miss: 冷命中，初始时cache为空</p>
<p>Conflict miss: 冲突不命中，位置被占用了</p>
<p>Capacity miss: 容量不命中，不可以容纳超过缓存大小的工作集</p>
]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 实验V Performance Lab</title>
    <url>/2023/07/07/16-27-21/</url>
    <content><![CDATA[<p>更新历史：</p>
<ul>
<li>23.07.07：初稿</li>
<li>23.07.22：没学过汇编，复杂代码看不懂，明年有时间再回头做这个实验</li>
<li>24.03.09：实验作废，用cache lab 替代。</li>
</ul>
<h1 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h1><ul>
<li><a href="/2023/03/15/10-59-10/" title="csapp 笔记汇总">CSAPP - 笔记汇总</a>
</li>
</ul>
<h1 id="任务目标"><a href="#任务目标" class="headerlink" title="任务目标"></a>任务目标</h1><p>采用代码移动，循环展开以及指令并行对图像的旋转和平滑函数进行优化。</p>
<h1 id="相关内容"><a href="#相关内容" class="headerlink" title="相关内容"></a>相关内容</h1><ol>
<li><p><code>make driver</code>：生成运行文件， 运行<code>./driver</code>参数</p>
<blockquote>
<p><code>-g</code>：尽运行<code>rotate</code>和<code>smooth</code>函数</p>
<p><code>-f</code>：指定文件输入运行</p>
<p><code>-d</code>： 运行写入指定文件</p>
<p><code>-q</code>：写入文件后结束运行</p>
</blockquote>
</li>
<li><p><code>指导文件建议</code>：观看汇编代码，平滑函数计算密集，翻转函数存储密集。</p>
</li>
<li><p>允许添加宏，全局变量和其他函数(过程)。</p>
</li>
<li><p>假定图像矩阵的大小为32的倍数</p>
</li>
</ol>
<h1 id="题目及解法"><a href="#题目及解法" class="headerlink" title="题目及解法"></a>题目及解法</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>课程中讲过的常见优化方式：代码移动，减少重复过程调用，消除不必要的内存引用，循环展开以及提高并行性。先查看汇编代码，根据汇编代码选择合适的方法对函数进行优化。</p>
<h2 id="Phase-Rotate"><a href="#Phase-Rotate" class="headerlink" title="Phase Rotate"></a>Phase Rotate</h2><p>原函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">naive_rotate</span><span class="params">(<span class="type">int</span> dim, pixel *src, pixel *dst)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; dim; i++)</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; dim; j++)</span><br><span class="line">        dst[RIDX(dim<span class="number">-1</span>-j, i, dim)] = src[RIDX(i, j, dim)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>汇编：</p>
<img src="/2023/07/07/16-27-21/QQ20230719-190626@2x.jpg" class>
<img src="/2023/07/07/16-27-21/QQ20230719-190641@2x.jpg" class>
<blockquote>
<p><del>之前的lab里讲过实验环境在32位shark机器下，这里汇编代码在push占用了8个字节，不太明白是不是我的环境不对</del></p>
<p><code>已解决</code>：确实环境不对，没有32位依赖，更新之后push占用4个字节</p>
<p><code>imul multi， src， des</code>三目运算</p>
</blockquote>
<p><strong>1.数据存放方式</strong></p>
<p>数据在栈空间中小端存放，<code>rdi</code>存放在<code>rsp + 0x18</code>，<code>edi</code>存放在加4个字节的位置。所以 0x1c(%esp) 的值就是dim。</p>
]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
        <tag>shell</tag>
        <tag>gdb</tag>
        <tag>objdump</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 笔记五 优化程序性能</title>
    <url>/2023/07/06/14-25-42/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>23.07.06：初稿</li>
</ul>
<h1 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h1><ul>
<li><a href="/2023/03/15/10-59-10/" title="csapp 笔记汇总">CSAPP - 笔记汇总</a></li>
<li><a href="/2023/05/24/13-04-09/" title="CSAPP 笔记三 程序的机器级表示">第三章 - 程序的机器级表示</a></li>
<li><a href="/2023/07/06/14-25-42/" title="CSAPP 笔记五 优化程序性能">第五章 - 优化程序性能</a></li>
<li><a href="/2023/07/23/09-27-18/" title="CSAPP 笔记六 存储器层次结构">第六章 - 存储器层次结构</a>
</li>
</ul>
<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>通过查看汇编代码，对没有优化的代码进行调整。</p>
<h1 id="Generally-Useful-Optimizations"><a href="#Generally-Useful-Optimizations" class="headerlink" title="Generally Useful Optimizations"></a>Generally Useful Optimizations</h1><ul>
<li><p>Code Motion：代码移动，把常用的结果存到循环外。优化等级1以上，编译器会自动完成这个工作。</p>
</li>
<li><p>Reduction in Strength：减少计算量，乘法换左移或加法。</p>
</li>
<li><p>Share Common Subexpressions：寻找公共表达式，减少计算量。</p>
</li>
</ul>
<h1 id="Optimization-Blockers"><a href="#Optimization-Blockers" class="headerlink" title="Optimization Blockers"></a>Optimization Blockers</h1><ul>
<li><p>Procedure Calls：循环中进行相同结果的重复调用。</p>
<blockquote>
<p>编译器无法优化的原因：</p>
<p>1.不知道是否在循环中修改了字符串；2. 文件单独编译，编译器不知道函数使用的是哪个文件中的函数，编译器事先假设函数是一个黑盒。</p>
</blockquote>
</li>
<li><p>Memory Matters: 循环中重复读取内存。</p>
<blockquote>
<p>无法优化的原因：</p>
<p>编译器不确定C语言是否存在内存别名，之前的结果会不会影响下一次读取的内存值。所以每次都进行读取写入操作。</p>
</blockquote>
</li>
<li><p>Memory Aliasing：引入局部变量防止内存重叠。</p>
</li>
</ul>
<h1 id="Exploiting-Instruction-Level-Parallelism"><a href="#Exploiting-Instruction-Level-Parallelism" class="headerlink" title="Exploiting Instruction-Level Parallelism"></a>Exploiting Instruction-Level Parallelism</h1><p>采用指令级并行，适用于各种机器的通用优化方法</p>
<h2 id="Benchmark-Example"><a href="#Benchmark-Example" class="headerlink" title="Benchmark Example"></a>Benchmark Example</h2><p>基准例子，使用一个抽象的数据结构。</p>
<img src="/2023/07/06/14-25-42/WX20230706-153904@2x.png" class>
<p><strong>Basic Optimizations</strong></p>
<ul>
<li><p>计算数组长度移出循环</p>
</li>
<li><p>移除边界检查，用新函数获取数组</p>
</li>
<li><p>引入局部变量</p>
</li>
</ul>
<img src="/2023/07/06/14-25-42/WX20230706-154041@2x.png" class>
<p>优化后性能：</p>
<img src="/2023/07/06/14-25-42/WX20230706-154316@2x.png" class>
<p><code>优化的基本限制</code>: 程序限制了整数和浮点数的乘法必须顺序执行，所需要的周期为3和5。</p>
<p><strong>Modern CPU Design</strong></p>
<img src="/2023/07/06/14-25-42/WX20230706-163939@2x.png" class>
<p> 1995年的CPU，了解流程。</p>
<p> 超标量乱序执行：顺序指令分解重组，实现指令级并行。</p>
<p>Superscalar Processor：超标量处理器</p>
<p><strong>Pipelined Functional Units</strong></p>
<img src="/2023/07/06/14-25-42/WX20230706-170033@2x.png" class>
<p>指令流水线：<code>这里假设指令需要三个阶段完成</code></p>
<h2 id="Loop-Unrolling"><a href="#Loop-Unrolling" class="headerlink" title="Loop Unrolling"></a>Loop Unrolling</h2><p><code>循环展开</code>: 循环中计算多个值，而不是计算一次。</p>
<img src="/2023/07/06/14-25-42/WX20230707-094102@2x.png" class>
<blockquote>
<p>每次循环计算两个操作数</p>
<p><code>limit</code>: n-1, 循环i跳出时满足 i + 1 &lt; (n - 1) + 1 = n; </p>
</blockquote>
<img src="/2023/07/06/14-25-42/WX20230707-094654@2x.png" class>
<blockquote>
<p>只有加法的CPE有了提升，降低了循环计数的消耗。其他没用提升是因为接近了延迟界限。</p>
</blockquote>
<p>调整循环展开的计算顺序：</p>
<p><code>x = x OP (d[i] OP d[i+1])</code></p>
<img src="/2023/07/06/14-25-42/WX20230707-105030@2x.png" class>
<p>吞吐量突破了延迟界限，浮点数两个乘法器，一个加法器。</p>
<img src="/2023/07/06/14-25-42/WX20230707-105355@2x.png" class>
<p>减少了计算的依赖，两个元素的计算不需要等上一个x的结果。浮点数不满足结合律，改变括号可能会发生舍入溢出，结果发生变化。</p>
<p><code>Latency Bound</code>：严格顺序执行时，一条指令需要花费的全部时间。</p>
<p><code>Throughput Bound</code>：基于硬件数量和性能限制，<code>只有两个load单元，吞吐量为0.5</code></p>
<p><strong>Separate Accumulators</strong></p>
<p>多累加器，改变元素组合的顺序，如奇偶分开。</p>
<img src="/2023/07/06/14-25-42/WX20230707-112901@2x.png" class>
<p><strong>Unrolling &amp; Accumulating</strong></p>
<p>以K为因子展开一个L长度的数组，CPE可以接近吞吐界限</p>
<h2 id="Programming-with-AVX2"><a href="#Programming-with-AVX2" class="headerlink" title="Programming with AVX2"></a>Programming with AVX2</h2><p><strong>YMM Registers</strong></p>
<p>总共有16个32字节的寄存器 ，是%XMM的二倍。</p>
<h2 id="SIMD-Operations"><a href="#SIMD-Operations" class="headerlink" title="SIMD Operations"></a>SIMD Operations</h2><img src="/2023/07/06/14-25-42/WX20230707-114005@2x.png" class>
<p><code>Vector Instructions</code>矢量指令：并行执行八次单精度或四次双精度浮点操作</p>
<p>矢量指令是为处理视频，声音，图形引入的</p>
<p>gcc对矢量指令的优化是有限的</p>
<h1 id="Dealing-with-Conditionals"><a href="#Dealing-with-Conditionals" class="headerlink" title="Dealing with Conditionals"></a>Dealing with Conditionals</h1><h2 id="What-About-Branches？"><a href="#What-About-Branches？" class="headerlink" title="What About Branches？"></a>What About Branches？</h2><p><strong>Branch Prediction</strong></p>
<p>分支预测技术：先执行猜测的分支，然后再判断分支是否正确</p>
<blockquote>
<p>所有的分支预测结果都写在寄存器副本中，错误时会回退正确的寄存器结果</p>
</blockquote>
<p><strong>Performance Cost</strong></p>
<p>执行代价就是用了很多时钟周期处理所有的分支指令，可能会执行大量无效操作</p>
]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 笔记三 程序的机器级表示</title>
    <url>/2023/05/24/13-04-09/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>23.05.24：初稿</li>
</ul>
<h1 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h1><ul>
<li><a href="/2023/03/15/10-59-10/" title="csapp 笔记汇总">CSAPP - 笔记汇总</a></li>
<li><a href="/2023/05/24/13-04-09/" title="CSAPP 笔记三 程序的机器级表示">第三章 - 程序的机器级表示</a></li>
<li><a href="/2023/07/06/14-25-42/" title="CSAPP 笔记五 优化程序性能">第五章 - 优化程序性能</a></li>
<li><a href="/2023/07/23/09-27-18/" title="CSAPP 笔记六 存储器层次结构">第六章 - 存储器层次结构</a>
</li>
</ul>
<h1 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h1><h2 id="Intel-x86-Processors"><a href="#Intel-x86-Processors" class="headerlink" title="Intel x86 Processors"></a>Intel x86 Processors</h2><ul>
<li><p>CISC - Complex 复杂指令集，RISC - Reduced 精简指令集。</p>
</li>
<li><p>x86-64，Linux的命名</p>
</li>
<li><p>ARM架构- Acorn RISC Machine</p>
</li>
<li><p>两种汇编语法：AT&amp;T和Intel。Linux和课程使用的是AT&amp;T。</p>
</li>
</ul>
<h2 id="C-assembly-machine-code"><a href="#C-assembly-machine-code" class="headerlink" title="C,assembly, machine code"></a>C,assembly, machine code</h2><ul>
<li>Micro architecture：微指令架构，CSAPP中很少涉及</li>
</ul>
<p><strong>Turning C into Object Code</strong></p>
<ul>
<li>编译命令<br><code>gcc -Og p1.c p2.c -o p</code><br><code>gcc -Og -S sum.c</code>：<br><code>-S</code>:编译阶段终止，生成汇编语言<br><code>-Og</code>:Optimize编译优化，<code>O1</code>是过去的优化级别，<code>g</code>级可以使代码更可读</li>
</ul>
<p><strong>Assembly Characteristics</strong></p>
<p>Data Types</p>
<ul>
<li><p>integer: 以1，2，4，8字节存储<br>数据和地址都用整型保存，不区分无符号和有符号。</p>
</li>
<li><p>floating point: 4，8，10字节</p>
</li>
<li><p>没有数组以及结构体，这些是由编译器构造的。</p>
</li>
</ul>
<p><strong>Operations</strong></p>
<ul>
<li><p>执行算术操作</p>
</li>
<li><p>在内存和寄存器之间传送数据</p>
</li>
<li><p>转移控制</p>
</li>
</ul>
<p>Disassembling Object Code</p>
<blockquote>
<p>指令长度在1-15个字节</p>
</blockquote>
<p>反汇编：将目标代码文件反汇编为类汇编语言。</p>
<ul>
<li><code>objdump -d sum</code>: 反汇编</li>
</ul>
<h2 id="Assembly-Basics-Registers-operands-move"><a href="#Assembly-Basics-Registers-operands-move" class="headerlink" title="Assembly Basics: Registers, operands, move"></a>Assembly Basics: Registers, operands, move</h2><p><strong>Integer Registers</strong></p>
<img src="/2023/05/24/13-04-09/WX20230603-145124@2x.png" class>
<ul>
<li><p>参数：1<code>rdi</code>, 2<code>rsi</code>, 3<code>rdx</code>, 4<code>rcx</code>, 5<code>r8</code>, 6<code>r9</code>，只能传递整型或者指针，浮点数由另外一组单独的寄存器传递。超出的参数存在栈里。</p>
</li>
<li><p>返回值：<code>rax</code></p>
</li>
</ul>
<p><strong>Moving Data</strong></p>
<blockquote>
<p><code>mov Source, Dest</code></p>
</blockquote>
<ul>
<li><p>不允许从内存取出，存入内存。从内存取出，只能存入寄存器。</p>
</li>
<li><p><code>mov $0x4, %rax</code>：目的地址是寄存器<br><code>mov $0x4, (%rax)</code>: 目的地址是内存</p>
</li>
<li><p><code>D(R)</code>: Mem[Reg[R] + D]</p>
</li>
<li><p><code>D(Rb, Ri, S)</code>: Mem[Reg[Rb] + S * Reg[Ri] + D]</p>
</li>
</ul>
<h2 id="Arithmetic-amp-logical-operations"><a href="#Arithmetic-amp-logical-operations" class="headerlink" title="Arithmetic &amp; logical operations"></a>Arithmetic &amp; logical operations</h2><p><strong>lea Src, Dst</strong></p>
<blockquote>
<p>C语言中的&amp;，取地址</p>
</blockquote>
<p>实际使用中C语言编译器喜欢用这条指令做算术运算，<code>lea (%rdi, %rdi, 2), %rax</code>, mov是将地址指向的内存值取出，lea指令将内存值所在地址取出，相当于存入的是<code>%rdi + %rdi * 2</code>。</p>
<p>Some ArTwo Operand Instructions</p>
<img src="/2023/05/24/13-04-09/WX20230603-152227@2x.png" class>
<ul>
<li><p>目的操作数作为第一个操作数，类似<code>x+=y</code></p>
</li>
<li><p>算术左移和逻辑左移相同</p>
</li>
</ul>
<p>One Operand Instructions</p>
<img src="/2023/05/24/13-04-09/WX20230603-152823@2x.png" class>
<h1 id="Control"><a href="#Control" class="headerlink" title="Control"></a>Control</h1><h2 id="Condition-Codes"><a href="#Condition-Codes" class="headerlink" title="Condition Codes"></a>Condition Codes</h2><p><strong>Single bit registers</strong></p>
<ul>
<li><p><code>CF</code>: Carry Flag (for unsigned)，同样表示无符号数溢出</p>
</li>
<li><p><code>SF</code>: Sign Flag (for signed)，负数为1</p>
</li>
<li><p><code>ZF</code>: Zero Flag</p>
</li>
<li><p><code>OF</code>: Overflow Flag (for signed)</p>
</li>
</ul>
<p><strong>Explicit Setting</strong></p>
<p>Compare</p>
<blockquote>
<p>cmpq Src2, Src1</p>
</blockquote>
<p>类似减法，Src1 - Src2，但是不保存值，只改变四个条件码</p>
<ul>
<li><p>溢出：<code>cmp b， a</code>，有符号补码<br>同号不会溢出，异号才会溢出</p>
<ul>
<li><p>负溢出：a-，b+， a-b&gt;0</p>
</li>
<li><p>正溢出：a+，b-，a-b&lt;0</p>
</li>
</ul>
</li>
</ul>
<p>Test</p>
<blockquote>
<p>testq Src2, Src1</p>
</blockquote>
<p>与运算，改变SF和ZF。</p>
<p>SetX Instructions</p>
<img src="/2023/05/24/13-04-09/WX20230605-113101@2x.png" class>
<blockquote>
<p>x86-64中4字节计算结果会将高4字节零填充，而2字节操作只会改变2字节。</p>
</blockquote>
<h2 id="Conditional-branches"><a href="#Conditional-branches" class="headerlink" title="Conditional branches"></a>Conditional branches</h2><p><strong>Jumping</strong></p>
<p>JX Instructions</p>
<img src="/2023/05/24/13-04-09/WX20230605-113806@2x.png" class>
<p><strong>Using Conditional Moves</strong></p>
<p>分支预测技术，更多时候分支预测正确率很低，选择执行分支的两部分指令，计算出两个结果，在最后一分钟选择需要的结果。只适用在两个分支都是简单计算。</p>
<blockquote>
<p><code>cmovle</code>: 小于等于的时候移动</p>
</blockquote>
<h2 id="Loops"><a href="#Loops" class="headerlink" title="Loops"></a>Loops</h2><p>C代码中最底层的控制就是跳转和测试。</p>
<h2 id="Switch-Statements"><a href="#Switch-Statements" class="headerlink" title="Switch Statements"></a>Switch Statements</h2><ul>
<li><p>用跳转表保存代码块的地址，可以快速跳转到该地址。</p>
</li>
<li><p>无论最小值是多少，通过增加偏置变为0</p>
</li>
<li><p>跳转表由编译器生成，汇编程序填写。</p>
</li>
<li><p>值范围很大，相对稀疏，会转变为条件树。</p>
</li>
</ul>
<h1 id="Procedures"><a href="#Procedures" class="headerlink" title="Procedures"></a>Procedures</h1><h2 id="Stack-Structure"><a href="#Stack-Structure" class="headerlink" title="Stack Structure"></a>Stack Structure</h2><ul>
<li><p>内存地址从下往上递增</p>
</li>
<li><p>栈底在上，push时rsp减小</p>
</li>
</ul>
<p><strong>Push &amp; Pop</strong></p>
<ul>
<li><p>Push：先减小，在写入</p>
</li>
<li><p>Pop：rsp增加</p>
</li>
</ul>
<h2 id="Calling-Conventions"><a href="#Calling-Conventions" class="headerlink" title="Calling Conventions"></a>Calling Conventions</h2><p><strong>Passing Control</strong></p>
<ul>
<li><p><code>call label</code>: 返回地址入栈，跳转到label</p>
</li>
<li><p><code>ret</code>: 出栈，返回</p>
</li>
<li><p><code>pc</code>寄存器就存在<code>rip</code>。</p>
</li>
</ul>
<p><strong>Passing data</strong></p>
<p>数据在寄存器和内存中传递，采用默认的规则，在不同的编译器下都可以传递参数。</p>
<p><strong>Managing local data</strong></p>
<p>Stack Frame</p>
<p>每个函数使用的内存块称为栈帧。</p>
<ul>
<li><p><code>rbp</code>: 表示基指针，栈底。调用者的<code>rbp</code>保存在被调用者的栈底。</p>
</li>
<li><p><code>rsp</code>: 栈顶，当它被分配了多少字节，就知道需要释放多少字节</p>
</li>
</ul>
<h2 id="Illustration-of-Recursion"><a href="#Illustration-of-Recursion" class="headerlink" title="Illustration of Recursion"></a>Illustration of Recursion</h2><p>栈帧是递归调用的前提。</p>
<h1 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h1><h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><p><strong>One-dimensional</strong></p>
<ul>
<li>指针加常量， 常量会被适当放缩。</li>
</ul>
<p><strong>Multi-dimensional(nested)</strong></p>
<ul>
<li>多维嵌套数组，按行或列连续存储。</li>
</ul>
<p><strong>Multi-level</strong></p>
<ul>
<li>三个数组，一个以为指针数组保存三个数组的起始地址。</li>
</ul>
<h2 id="Structures"><a href="#Structures" class="headerlink" title="Structures"></a>Structures</h2><p><strong>Access</strong></p>
<ul>
<li>通过字节偏移访问对应的结构体成员。</li>
</ul>
<p><strong>Alignment</strong></p>
<ul>
<li><p>字节对齐，访问更方便，数据不会跨越多个块</p>
</li>
<li><p>占m字节的变量，就存放在m的倍数地址处</p>
</li>
<li><p>调整声明顺序，可以优化对齐</p>
</li>
</ul>
<h2 id="Floating-Point"><a href="#Floating-Point" class="headerlink" title="Floating Point"></a>Floating Point</h2><img src="/2023/05/24/13-04-09/WX20230605-164923@2x.png" class>
<h1 id="Advanced-Topics"><a href="#Advanced-Topics" class="headerlink" title="Advanced Topics"></a>Advanced Topics</h1><h2 id="Memory-Layout"><a href="#Memory-Layout" class="headerlink" title="Memory Layout"></a>Memory Layout</h2><p>目前64位的内存只允许使用47位。Linux栈的大小为8MB。</p>
<ul>
<li><p>Stack: 局部变量</p>
</li>
<li><p>Text：执行的机器指令，只可读</p>
</li>
<li><p>Data：存放全局变量，静态变量，字符串常量</p>
</li>
<li><p>Heap：动态申请，malloc，calloc，new</p>
</li>
<li><p>Shared Libraries：存放库函数，动态加载</p>
</li>
</ul>
<p>堆分配的内存是从高位低位向中间分配，中间的一部分没有分配的内存访问段错误。<code>这是由操作系统的管理策略决定</code></p>
<h2 id="Buffer-Overflow"><a href="#Buffer-Overflow" class="headerlink" title="Buffer Overflow"></a>Buffer Overflow</h2><p><strong>Vulnerability</strong></p>
<ul>
<li><p><code>gets()</code>: 函数不检查缓冲区大小，容易越界。 </p>
</li>
<li><p><code>strcpy</code>, <code>strcat</code>,<code>scanf</code>, <code>fscanf</code>, <code>sscanf</code>, 都有溢出风险。</p>
</li>
<li><p>机器指令是小端存放的，低位在前。 </p>
</li>
</ul>
<p><strong>Code Injection Attacks</strong></p>
<p>代码注入攻击，把字符填充到缓冲区中，形成可执行的指令，修改返回指针。</p>
<blockquote>
<p>Worm与Virus：蠕虫可以自己生存，病毒不能独自运行。</p>
</blockquote>
<p><strong>Protection</strong></p>
<p><strong>Randomized stack offsets</strong>栈随机化</p>
<p>栈随机化会让缓冲区随机变化，无法预测下一个地址。</p>
<p><strong>Nonexecutable code segments</strong></p>
<p>标记栈是不可执行的代码。</p>
<p><strong>Stack Canaries</strong></p>
<p><code>gcc -fstack-protector</code> 默认启动栈保护</p>
<p><code>%fs</code>: 特殊寄存器，某块内存的值，如果Canay值改变了说明有溢出。Canay值是<code>小端存放</code>。</p>
<blockquote>
<p>Canay的值最低位字节为0，这是字符串的off-by-one bug，虽然字符串的空字符占用了Canay值，产生了溢出，但是检测不到溢出。</p>
</blockquote>
<p><strong>Return-Oriented Programming Attacks</strong></p>
<p>Canay无法破解，但是我们知道代码在什么地方，全局变量和代码的位置没有改变，通过找到某段代码组合在一起，面向返回编程。</p>
<blockquote>
<p>gadget: 通过截断一些指令，形成新的指令，替换了程序计数器</p>
</blockquote>
<img src="/2023/05/24/13-04-09/WX20230608-112255@2x.png" class>
<p>attack Lab中关闭了canary，可以通过缓冲区溢出设置需要的返回地址。</p>
<h2 id="Unions"><a href="#Unions" class="headerlink" title="Unions"></a>Unions</h2><ul>
<li><p>联合体只会为最大的域分配地址。</p>
</li>
<li><p>联合体可以用来做类型转换，不改变位。</p>
</li>
</ul>
<h2 id="大端小端"><a href="#大端小端" class="headerlink" title="大端小端"></a>大端小端</h2><ul>
<li><p>IA32：字节小端存放</p>
</li>
<li><p>x86-64：字节小端存放</p>
</li>
</ul>
]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 实验III Attack Lab</title>
    <url>/2023/03/18/15-54-47/</url>
    <content><![CDATA[<p>更新历史：</p>
<ul>
<li>23.03.18：初稿</li>
</ul>
<h1 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h1><ul>
<li><a href="/2023/03/15/10-59-10/" title="csapp 笔记汇总">CSAPP - 笔记汇总</a>
</li>
<li><a href="/2023/03/09/11-54-50/" title="CSAPP 实验I Data Lab">I Data Lab - 位操作，数据表示</a>
</li>
<li><a href="/2023/03/14/09-43-26/" title="CSAPP 实验II Bomb Lab">II Bomb Lab - 汇编，栈帧与 gdb</a>
</li>
<li><a href="/2023/03/18/15-54-47/" title="CSAPP 实验III Attack Lab">III Attack Lab - 漏洞是如何被攻击的</a>
</li>
<li><a href="/2024/03/09/16-34-34/" title="CSAPP 实验IV CacheLab">IV Cache Lab - 实现一个缓存系统</a>
</li>
<li><a href="/2024/03/14/12-34-42/" title="CSAPP 实验V ShellLab">V Shell Lab - 实现一个Shell</a>
</li>
</ul>
<h1 id="任务目标"><a href="#任务目标" class="headerlink" title="任务目标"></a>任务目标</h1><p>Attack Lab实验，采用 code-injection 和 return-oriented 两种方法攻击程序。</p>
<h1 id="相关内容"><a href="#相关内容" class="headerlink" title="相关内容"></a>相关内容</h1><ol>
<li><code>./ctarget -q</code>：运行目标文件用参数<code>-q</code>，不使用服务器</li>
<li><code>-i FILE</code>: 文件输入</li>
<li><code>./hex2raw &lt; 1.txt | ./ctarget -q</code>: 答案不换行，用<code>hex2raw</code>转换成字符串，注意需要用小端存储。</li>
<li><code>call</code>指令会将8个字节的<code>rip</code>值入栈，作为<code>ret</code>返回地址。</li>
<li>code-injection：关闭了栈随机化，栈不可执行和canary。</li>
<li>return-oriented：打开栈随机化和不可执行，关闭canary。</li>
</ol>
<h1 id="题目及解法"><a href="#题目及解法" class="headerlink" title="题目及解法"></a>题目及解法</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>和课程中讲解的两种漏洞的破解方式相同：代码注入利用缓冲区溢出，把需要执行的指令输入到栈中。面向返回编程将需要的指令片段返回地址输入到缓冲区中，模拟一个程序计数器，顺序执行需要执行的指令。由于bomb实验对每一条汇编命令都进行了解释，这个实验就不逐条解释了，把之前做过的答案重新整理一遍。</p>
<h2 id="Phase-1"><a href="#Phase-1" class="headerlink" title="Phase 1"></a>Phase 1</h2><p>思路：第一个很简单输入函数开辟了0x28的空间用于保存输入,返回地址在rsp+0x28的位置,所以输入一段0x28字节的字符串后面跟上返回touch1的地址,注意地址是小端存放:<code>C0 17 40 00 00 00 00 00</code>, 以下答案为了方便观看添加了换行，运行程序时需要去掉换行。</p>
<ol>
<li><p>gdb进入程序，对test函数反汇编：</p>
<img src="/2023/03/18/15-54-47/WX20230609-103056@2x.png" class>
</li>
<li><p>调用了getbuf函数，可以查看一下汇编代码，找出缓冲区的大小</p>
<img src="/2023/03/18/15-54-47/WX20230609-103332@2x.png" class>
</li>
<li><p>缓冲区大小为<code>0x28</code>，40个字节，输入的字符串保存在当前<code>rsp</code>处。然后输入40个字节无用数据，充满缓冲区，继续输入8个字节的touch1地址，覆盖掉原地址。</p>
</li>
<li><p>对要跳转的touch1函数反汇编，找一下函数入口地址：</p>
<img src="/2023/03/18/15-54-47/WX20230609-102814@2x.png" class>
</li>
<li><p>所以需要返回的地址为<code>0x00000000004017c0</code>，输入小端存放。</p>
</li>
</ol>
<p>答案：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">c0 <span class="number">17</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br></pre></td></tr></table></figure>
<h2 id="Phase-2"><a href="#Phase-2" class="headerlink" title="Phase 2"></a>Phase 2</h2><p>思路：</p>
<p>第二个需要注入可执行代码, 需要把touch2的参数寄存器<code>rdi</code>内容设置为cookie, 这样重置ret到touch2才能正确执行, 所有第一次在getbuf中把返回值重置为一个栈地址, 然后在这个地址内写入一系列操作, 每次ret后返回地址会自动退栈, 所以先把<code>rsp</code>-8, 然后在<code>rdi</code>写入touch2的地址,然后将<code>rdi</code>写入<code>rsp</code>指向的栈地址中,然后把cookie值写入<code>rdi</code>中,最后ret。</p>
<ol>
<li><p>先查看一下touch2函数的入口在哪里：</p>
<img src="/2023/03/18/15-54-47/WX20230609-104729@2x.png" class>
</li>
<li><p>可以看到需要返回地址为<code>0x00000000004017ec</code>， 参数可以进入touch2函数打印一下那个局部变量的值，也可以在上一个题目输出信息那里看到，我的cookie值为<code>0x59b997fa</code>。</p>
</li>
<li><p>这次需要让指令在栈中执行，所以需要知道getbuf时<code>%rsp</code>的值，可以在test处打断点，<code>display $rsp</code>，值为<code>$rsp = (void *) 0x5561dcb0</code>。test函数中分配8个字节，call getbuf 时使用了8个字节，getbuf分配40个字节，一共分配了56个字节，所以在我们输入字符串时，<code>rsp</code>指向的地址值应该是<code>0x5561dc78</code></p>
</li>
<li><p>接下来就是注入一段需要运行的代码，可以先写汇编代码，通过指令<code>gcc -c foo.s</code>，生成二进制代码<code>foo.o</code>， 在通过<code>objdump -d foo.o</code>反汇编，生成可读的机器指令。</p>
</li>
</ol>
<p>答案：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">48</span> <span class="number">83</span> ec <span class="number">08</span>           <span class="comment">/*  sub    $0x8,%rsp */</span></span><br><span class="line"><span class="number">48</span> c7 c7 ec <span class="number">17</span> <span class="number">40</span> <span class="number">00</span>  <span class="comment">/*  mov    $0x4017ec,%rdi */</span></span><br><span class="line"><span class="number">48</span> <span class="number">89</span> <span class="number">3</span>c <span class="number">24</span>           <span class="comment">/*  mov    %rdi,(%rsp) */</span></span><br><span class="line"><span class="number">48</span> c7 c7 fa <span class="number">97</span> b9 <span class="number">59</span>  <span class="comment">/*  mov    $0x59b997fa,%rdi   -   set cookie */</span></span><br><span class="line">c3                    <span class="comment">/*  retq  */</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span></span><br><span class="line"><span class="number">78</span> dc <span class="number">61</span> <span class="number">55</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span><span class="comment">/* return adress, execute exploit code */</span></span><br></pre></td></tr></table></figure>
<h2 id="Phase-3"><a href="#Phase-3" class="headerlink" title="Phase 3"></a>Phase 3</h2><p>思路：</p>
<p>第三题和第二题基本相同return到touch3后要进行一次cookie对比,第二题是十六进制的数字对比,可以提前把cookie写入<code>rdi</code>寄存器里,但是第三题的参数是一个字符串指针,所以要把字符串地址写入<code>rsi</code>第二个参数寄存器里,不能用在栈中写,因为后面还有两次函数调用,栈空间很容易被覆盖,找了一下变量cookie的地址,这个地址<code>0x6044e4</code>的后面有很长一段地址没有使用过,所以可以把字符串写入<code>0x6044ec</code>,<code>rsi</code>的参数传递在<code>0x6044ec</code>,还有一个地方是字符串<code>0x59b997fa</code>,每个字符存在一个字节里,一共需要8个字节的空间,可以用<code>mov</code>,写入十六进制数,但是要注意字符串大端存放,数字是小端存放,翻转一下就可以了.</p>
<ol>
<li><p>根据实验指南中提示的函数<code>hexmatch</code>, 做了一个字符串对比，第二个参数是字符串地址，而且在函数中将传入的cookie值转换成了一个随机地址的字符串，然后进行字符串对比，所以我们需要提前把字符串写入到固定的地址，然参数传进去。</p>
</li>
<li><p><code>disas touch3</code></p>
<img src="/2023/03/18/15-54-47/WX20230609-123834@2x.png" class>
</li>
<li><p>可以看出cookie值存在内存的<code>0x6044e4</code>处，打印一下周围的内存值，<code>x/6xg</code></p>
<img src="/2023/03/18/15-54-47/WX20230609-130233@2x.png" class>
</li>
<li><p>上面可以看到后面有一部分是没有使用的内存，选一个<code>0x6044ec</code>，把我们的字符串写入这里，注意大端存放。</p>
</li>
<li><p>接下来注入要运行的指令，和上一题相同，但是要把字符串写入到选定的地址里，字符串<code>59b997fa</code>转换为16进制为<code>0x35 0x39 0x62 0x39 0x39 0x37 0x66 0x61</code>，但是要注意小端存放的值为<code>0x6166373939623935</code>，所以写入这个值，当做字符串读出时刚好是cookie值。<code>movabs</code>：用于64位立即数赋值。</p>
</li>
</ol>
<p>答案：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">48</span> <span class="number">83</span> ec <span class="number">08</span>           <span class="comment">/*  sub    $0x8,%rsp */</span></span><br><span class="line">bf fa <span class="number">18</span> <span class="number">40</span> <span class="number">00</span>        <span class="comment">/*  mov    $0x4018fa,%edi */</span></span><br><span class="line"><span class="number">48</span> <span class="number">89</span> <span class="number">3</span>c <span class="number">24</span>           <span class="comment">/*  mov    %rdi,(%rsp) */</span></span><br><span class="line">bf ec <span class="number">44</span> <span class="number">60</span> <span class="number">00</span>        <span class="comment">/*  mov    $0x6044ec,%edi  */</span></span><br><span class="line"><span class="number">48</span> be <span class="number">35</span> <span class="number">39</span> <span class="number">62</span> <span class="number">39</span> <span class="number">39</span>  </span><br><span class="line"><span class="number">37</span> <span class="number">66</span> <span class="number">61</span>              <span class="comment">/*  movabs $0x6166373939623935,%rsi */</span></span><br><span class="line"><span class="number">48</span> <span class="number">89</span> <span class="number">37</span>              <span class="comment">/*  mov    %rsi,(%rdi)    */</span></span><br><span class="line">c3                    <span class="comment">/*  retq  */</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span></span><br><span class="line"><span class="number">78</span> dc <span class="number">61</span> <span class="number">55</span> <span class="comment">/* return adress, execute exploit code */</span></span><br></pre></td></tr></table></figure>
<h2 id="Phase-4"><a href="#Phase-4" class="headerlink" title="Phase 4"></a>Phase 4</h2><p>思路：</p>
<p>第四题,和第二题相同,需要把代码返回到touch2里面,但是不能像phase2中代码注入运行代码,因为栈内标记为不可执行了,所以要使用ROP的方法来操作,在给出的gadget中选择两个连续的48 89 c7 c3, mov %rax,%rdi,   还有一个58 c3, popq %rax,将这两条指令的地址用栈溢出的方法写到返回里,在返回地址中间加上cookie码。</p>
<ol>
<li><p><strong><em><code>gcc -c farm.c</code>：生成目标文件<br><code>objdump -d farm.o &gt; farm.s</code>：反汇编生成可读指令<br><code>这里需要注意优化级别为 -Og，与实验的优化级别相同</code></em></strong><br><code>objdump -d rtarget.o &gt; rtarget.s</code>：直接对可执行文件反汇编生成的指令带地址，更方便看一些。</p>
</li>
<li><p>在<code>rtarget.s</code>中找我们需要的指令，</p>
</li>
<li><p><code>setval_426</code>函数中有：地址为<code>4019c5</code></p>
<img src="/2023/03/18/15-54-47/WX20230609-140230@2x.png" class>
</li>
<li><p>找到我们需要的<code>48 89 c7</code>，后续的<code>90</code>是一个nop，什么也不做，计数器加1，最后跟着<code>c3</code>ret。</p>
</li>
<li><p>上面把<code>rax</code>的值存到<code>rdi</code>中了，接下来我们就是找一个pop指令<code>58 90 c3</code>，退栈到<code>rax</code>中，找到<code>getval_280</code>：地址为<code>4019cc</code></p>
<img src="/2023/03/18/15-54-47/WX20230609-140336@2x.png" class>
</li>
<li><p>所以溢出的输入为退栈到<code>rax</code>，栈顶是cookie值，然后执行<code>0x4019c5</code>的mov指令，最后返回touch2。注意所有的操作都是8字节。</p>
</li>
</ol>
<p>答案：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">01</span> <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>   <span class="comment">/*40个字节溢出  */</span></span><br><span class="line">cc <span class="number">19</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">fa <span class="number">97</span> b9 <span class="number">59</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">c5 <span class="number">19</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">ec <span class="number">17</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br></pre></td></tr></table></figure>
<h2 id="Phase-5"><a href="#Phase-5" class="headerlink" title="Phase 5"></a>Phase 5</h2><p>思路：</p>
<p>和Phase 3相同，但是要把代码注入改为target序列执行指令，可能需要对寄存器的低字节进行操作，还没想出怎么做这个题目，后面有时间了再来做。</p>
<p>答案：</p>
]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
        <tag>shell</tag>
        <tag>gdb</tag>
        <tag>objdump</tag>
      </tags>
  </entry>
  <entry>
    <title>csapp 笔记汇总</title>
    <url>/2023/03/15/10-59-10/</url>
    <content><![CDATA[<h1 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h1><h2 id="CMU-15-213笔记"><a href="#CMU-15-213笔记" class="headerlink" title="CMU 15-213笔记"></a>CMU 15-213笔记</h2><ul>
<li><a href="/2023/05/24/13-04-09/" title="CSAPP 笔记三 程序的机器级表示">第三章 - 程序的机器级表示</a></li>
<li><a href="/2023/07/06/14-25-42/" title="CSAPP 笔记五 优化程序性能">第五章 - 优化程序性能</a></li>
<li><a href="/2023/07/23/09-27-18/" title="CSAPP 笔记六 存储器层次结构">第六章 - 存储器层次结构</a>
</li>
</ul>
<h2 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h2><p><a href="https://github.com/PKunicor/CsappLab">PKunicor/Csapp lab</a></p>
<h2 id="实验笔记"><a href="#实验笔记" class="headerlink" title="实验笔记"></a>实验笔记</h2><ul>
<li><a href="/2023/03/09/11-54-50/" title="CSAPP 实验I Data Lab">I Data Lab - 位操作，数据表示</a></li>
<li><a href="/2023/03/14/09-43-26/" title="CSAPP 实验II Bomb Lab">II Bomb Lab - 汇编，栈帧与 gdb</a></li>
<li><a href="/2023/03/18/15-54-47/" title="CSAPP 实验III Attack Lab">III Attack Lab - 漏洞是如何被攻击的</a></li>
<li><a href="/2024/03/09/16-34-34/" title="CSAPP 实验IV CacheLab">IV Cache Lab - 实现一个缓存系统</a></li>
<li><a href="/2024/03/14/12-34-42/" title="CSAPP 实验V ShellLab">V Shell Lab - 实现一个Shell</a>
</li>
</ul>
<h1 id="实验指南"><a href="#实验指南" class="headerlink" title="实验指南"></a>实验指南</h1><ul>
<li><p><a href="https://www.bilibili.com/video/BV1iW411d7hd/?spm_id_from=333.788.top_right_bar_window_custom_collection.content.click&amp;vd_source=d5a3522259c17126f1b623c977d04c3e">B站CS15-213翻译课程</a> </p>
</li>
<li><p><a href="https://scs.hosted.panopto.com/Panopto/Pages/Sessions/List.aspx#folderID=%22b96d90ae-9871-4fae-91e2-b1627b43e25e%22">实验课程指导</a> <code>lab重点</code> </p>
</li>
</ul>
<blockquote>
<p>做Lab非常推荐看一下官方给的Lab指导课程，课程里详细介绍了实验上手方式以及需要用到的命令。 </p>
</blockquote>
]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 实验II Bomb Lab</title>
    <url>/2023/03/14/09-43-26/</url>
    <content><![CDATA[<p>更新历史：</p>
<ul>
<li>23.03.14：初稿</li>
<li>23.03.18：新增secret_phase</li>
</ul>
<h1 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h1><ul>
<li><a href="/2023/03/15/10-59-10/" title="csapp 笔记汇总">CSAPP - 笔记汇总</a>
</li>
<li><a href="/2023/03/09/11-54-50/" title="CSAPP 实验I Data Lab">I Data Lab - 位操作，数据表示</a>
</li>
<li><a href="/2023/03/14/09-43-26/" title="CSAPP 实验II Bomb Lab">II Bomb Lab - 汇编，栈帧与 gdb</a>
</li>
<li><a href="/2023/03/18/15-54-47/" title="CSAPP 实验III Attack Lab">III Attack Lab - 漏洞是如何被攻击的</a>
</li>
<li><a href="/2024/03/09/16-34-34/" title="CSAPP 实验IV CacheLab">IV Cache Lab - 实现一个缓存系统</a>
</li>
<li><a href="/2024/03/14/12-34-42/" title="CSAPP 实验V ShellLab">V Shell Lab - 实现一个Shell</a>
</li>
</ul>
<h1 id="任务目标"><a href="#任务目标" class="headerlink" title="任务目标"></a>任务目标</h1><p>Bomb Lab实验，使用GDB工具拆除六个阶段的炸弹，需要仔细输入，爆炸次数过多实验会失败。</p>
<h1 id="相关内容"><a href="#相关内容" class="headerlink" title="相关内容"></a>相关内容</h1><ol>
<li><p>下载自己的炸弹，不能修改bomb.c代码。</p>
</li>
<li><p>每爆炸一次失去一半的分数。</p>
</li>
<li><p>测试命令</p>
<blockquote>
<p><code>./bomb</code>：运行炸弹程序， <code>psol.txt</code>：文件输入答案</p>
</blockquote>
</li>
<li><p>GDB命令</p>
<blockquote>
<p><code>gdb boom</code>：调试命令。参数：<code>-e</code>：置顶可执行文件名<br><code>quit</code>：退出调试<br><code>run [参数]</code>：运行程序；<code>&lt; psol.txt</code>：文件输入<br><code>continue</code>：断点继续<br><code>print expr</code>：打印表达式值，区别：x打印的内存的值<br><code>nexti</code>：单步执行，不进入函数调用<br><code>stepi</code>：单步执行进入函数调用<br><code>break function</code>：函数处断点<br><code>break *address</code>：内存地址处断点<br><code>delete n</code>：删除n号断点<br><code>delete</code>：删除所有断点<br><code>finish</code>：运行的当前函数返回停止<br><code>x/5cb str</code> ：显示5个单字节；<code>h</code>：两个；<code>w</code>：四个；<code>g</code>：八个<br><code>x/1sb str</code> ：显示字符串str<br><code>x/4dw arr</code> ：取4个整型数字以十进制格式显示<br><code>display arr</code>：每次断点都打印数据，参数<code>/x /s /u /c</code>。<br><code>disas</code>：反汇编当前函数<br><code>info registers</code>：显示寄存器内容</p>
</blockquote>
</li>
<li><p>objdump命令 <code>反汇编</code></p>
<blockquote>
<p><code>objdump -t</code>：打印变量内容的存储位置<br><code>objdump -d bomb &gt; bomb.s</code>：反汇编生成bomb.s文件。<code>需要使用gdb查看函数</code></p>
</blockquote>
</li>
<li><p>screen 命令 <code>分屏看汇编文件，也可以不分屏在GDB中使用disas命令</code></p>
<blockquote>
<p><code>screen -ls</code>：查看所有screen终端<br><code>screen -S name</code> ：创建终端<br><code>screen -r name or id</code> ：连接终端。连接失败用<code>screen -d **</code>：连接<br><code>exit</code>：退出终端<br><code>Ctrl + a，d</code>：暂离；<code>c</code>：创建子会话；<code>w</code>：子会话列表；<code>p</code>：上一个；<code>n</code>：下一个；<code>0-9</code>：切换；<code>：</code>：命令行模式(<code>resize 80</code>)调整窗口大小。<br><code>screen -S id -X quit</code>：关闭视窗</p>
</blockquote>
</li>
<li><p>函数参数传递相关寄存器</p>
<blockquote>
<p><code>%rax</code>：返回值<br><code>%rdi</code>：第一个参数<br><code>%rsi</code>：第二个参数<br><code>%rdx</code>：第三个参数<br><code>%rcx</code>：第四个参数<br><code>%d8</code>，<code>%d9</code>，<code>%d10</code>依次是后面的参数</p>
</blockquote>
</li>
</ol>
<h1 id="题目及解法"><a href="#题目及解法" class="headerlink" title="题目及解法"></a>题目及解法</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先从源码<code>bomb.c</code>可以看出调用顺序，通过函数<code>explode_bomb</code>让炸弹爆炸，所有我们在调试过程中，在这个函数处打断点，每次只要输入错误密码，炸弹爆炸的时候程序都会进入断点，这样就不会扣分了。从源码里还能看出每一个关卡的函数都是<code>phase_x</code>，所以每次调试之前，在爆炸处打断点，在<code>phase_x</code>处打断点，进入这关之后，用反汇编命令<code>disas</code>，显示函数的汇编代码，然后进行解题。</p>
<h2 id="phase-1"><a href="#phase-1" class="headerlink" title="phase_1"></a>phase_1</h2><p>思路：</p>
<p>第一个比较简单，找到字符串对比函数，参数1放在寄存器rdi里，参数2放在寄存器rsi里。<br>在字符串对比函数内打断点，命令<code>x/1sb $rsi</code>,打印出寄存器里的字符串内容。<br>做法：</p>
<ol>
<li><p><code>break phase_1</code> ：打断点</p>
</li>
<li><p><code>disas</code>：显示汇编指令</p>
<img src="/2023/03/14/09-43-26/WX20230315-120145@2x.png" class>
</li>
<li><p><code>break explode_bomb</code> ：在爆炸函数打断点，防止进入这里引爆炸弹  </p>
</li>
<li><p>根据汇编语言可以看出，输入的字符串在调用字符串对比函数中进行对比，根据返回值进行选择是否爆炸。<br><code>break strings_not_equal</code> ：打断点</p>
</li>
<li><p><code>x/1sb $rsi</code>：打印<code>$rsi</code>内容，根据phase_1函数的汇编指令中，改变了rsi内容，说明我们输入的密码在<code>$rdi</code>中，解密的密码在<code>$rsi</code>中。</p>
<img src="/2023/03/14/09-43-26/WX20230315-122703@2x.png" class>
</li>
</ol>
<p>答案:</p>
<p><code>Border relations with Canada have never been better.</code></p>
<h2 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h2><p>思路：</p>
<p>第二个主要是是在函数分配的栈里面进行操作,通过sscanf函数的第二个参数,format,”%d %d %d %d %d %d”，可以看出密码应该是六个数,通过记录的<code>%rsi</code>是phase2函数的<code>%rsp</code>，可以知道最终密码应该是保存在主函数的栈区，第一次和1比较,相同才能继续，第一个数字是1， 后面每一个数字都是和前一个数字*2相比较，那么就是一个等比数列，公比2。<br>做法：</p>
<ol>
<li><p><code>break phase_2</code> ：打断点</p>
</li>
<li><p><code>disas</code>：显示汇编指令</p>
<img src="/2023/03/14/09-43-26/WX20230315-164003@2x.png" class>
<p>发现函数调用了read_six_numbers函数，所以继续在这里打断点，看具体输入了什么。</p>
</li>
<li><p><code>break read_six_numbers</code>，查看这个函数的汇编指令</p>
<img src="/2023/03/14/09-43-26/WX20230315-164335@2x.png" class>
<p>从调用sscanf函数之前可以看出输入格式在第二个参数里 ，以在调用之前打断点，打印<code>rsi</code>的内容。从调用爆炸函数的条件也可以看出来，sscanf返回值大于等于6的时候才会正常跳转，输入的数太少会直接爆炸。</p>
<img src="/2023/03/14/09-43-26/WX20230315-164848@2x.png" class>
<p>这道题的密码应该是6位数字，输入的内容保存在后面的传参里，地址在<code>rsi</code>寄存器里，根据phase_2的调用之前，<code>rsi</code>寄存器里存的是<code>rsp</code>的地址，所以可以判断出，读取函数把输入的数字存到了<code>rsp</code>内的地址里。</p>
</li>
<li><p>根据返回到phase_2函数的下一条指令<code>cmpl   $0x1,(%rsp)</code><br><code>cmpl</code>：代表双字，四个字节，用<code>x/6dw $rsp</code>：打印输入的内容看一下是不是自己输入的；根据跳转条件可以看出，第一个密码是1，</p>
</li>
<li><p>第一个密码正确后，依次看后面的指令:<br><code>lea    0x4(%rsp),%rbx</code>：下四个字节，第二个密码地址放到<code>rbx</code>里。<br><code>lea    0x18(%rsp),%rbp</code>：第24字节地址放到<code>rbx</code>里。<code>相当于for循环结束条件</code><br><code>mov    -0x4(%rbx),%eax</code>：第一个密码1存到<code>eax</code>。<br><code>add    %eax,%eax</code>：<code>eax</code>+<code>eax</code>。<code>乘2</code><br><code>cmp    %eax,(%rbx)</code>：对比第二个密码是不是2。<br><code>add    $0x4,%rbx</code>：<code>rbx</code>指向下四个字节，第三个密码。<br><code>cmp    %rbp,%rbx</code>：对比是不是到了结束末尾，否则继续进行循环。<br>所以这六个数字密码是一个1开头的等比数列，公比为2。</p>
</li>
</ol>
<p>答案:</p>
<p><code>1 2 4 8 16 32</code></p>
<h2 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h2><p>思路：</p>
<p>第三个和第二个相同,查看输入的是两个%d,存在phase3的栈里面,不一样的地方是,这道题目的答案有7种,因为第一个密码小于7,所有一共有8组答案,分别是0,207,   1-0x137,2-0x2c3,3-0x100,4-0x185,5-0xce, 6-0x2aa, 7-0x147.<br>做法：</p>
<ol>
<li><p><code>break phase_3</code> ：打断点</p>
</li>
<li><p><code>disas</code>：显示汇编指令</p>
<img src="/2023/03/14/09-43-26/WX20230316-103622@2x.png" class>
<p>找到<code>sscanf</code>函数，和之前一样打断点查看输入格式。</p>
</li>
<li><p><code>x/1sb $rsi</code>：这道题的密码应该是两个数</p>
<img src="/2023/03/14/09-43-26/WX20230316-103921@2x.png" class>
</li>
<li><p>基本步骤和上面一样，看一下密码对比的循环指令：<br><code>cmpl   $0x7,0x8(%rsp)</code>：对比第一个数字和7的大小<br><code>ja     0x400fad &lt;phase_3+106&gt;</code>：无符号大于就跳转，跳转之后调用了爆炸函数，说明第一个数字小于等于7并且大于等于0<code>负数当无符号数时第一位总是1，一定比8大</code>。<br><code>mov    0x8(%rsp),%eax</code>：把第一个数字放到<code>eax</code>里。<br><code>jmpq   *0x402470(,%rax,8)</code>：跳转到<code>*(0x402470 + (%rax * 8))</code><br>打印一下从<code>0x402470</code>这里开始存的是什么：<code>x/8xg 0x402470</code>或者<code>x/64xb 0x402470</code>：这里要注意数据是按照大端法存储的。</p>
<img src="/2023/03/14/09-43-26/WX20230316-110646@2x.png" class>
<p>可以看出对应跳转关系，跳转后执行的指令为：<code>mov    $0xcf,%eax</code>，根据不同的第一位数字得到的为：<code>0--0xcf</code> <code>1--0x137</code> <code>2--0x2c3</code> <code>3--0x100</code> <code>4--0x185</code> <code>5--0xce</code> <code>6--0x2aa</code> <code>7--0x147</code></p>
</li>
</ol>
<p>答案:</p>
<p><code>0 207</code></p>
<h2 id="phase-4"><a href="#phase-4" class="headerlink" title="phase_4"></a>phase_4</h2><p>思路：</p>
<p>第四个主要难点在func4函数里有一个单操作数的sar指令，之前一直以为移位的数存在寄存器cl里，后来才发现这是默认移位1，所有这个题的密码第一位是在用二分法在(0-14)中找值，但是由于函数返回值是0才不会爆炸，往右半部分查找时，返回值不为0,所以密码只能在左半部分，分别是7，3，1，0，四种答案，第二个密码是在phase_4函数里，对比的数字是0，所以第二个密码是0。<br>做法：</p>
<ol>
<li><p><code>break phase_4</code> ：打断点</p>
</li>
<li><p><code>disas</code>：显示汇编指令</p>
<img src="/2023/03/14/09-43-26/WX20230316-112833@2x.png" class>
<p>找到<code>sscanf</code>函数，和之前一样打断点查看输入格式。这道题和上一道的<code>rsi</code>内容一样，说明都是两个数。</p>
</li>
<li><p><code>cmpl   $0xe,0x8(%rsp)</code>：<br><code>jbe    0x40103a &lt;phase_4+46&gt;</code>：小于等于跳转，说明第一个密码小于等于14。<br><code>mov    $0xe,%edx</code>：14存到<code>rdx</code>第三个参数。<br><code>mov    $0x0,%esi</code>：0存到<code>rsi</code>第二个参数。<br><code>mov    0x8(%rsp),%edi</code>：第一个密码存到<code>rdi</code>第一个参数。<br><code>callq  0x400fce &lt;func4&gt;</code>：调用func4函数。</p>
</li>
<li><p><code>disas</code>：打断点反汇编，区间(a,b)</p>
<img src="/2023/03/14/09-43-26/WX20230316-113725@2x.png" class>
<p><code>mov    %edx,%eax</code>：第三个参数14存到<code>rax</code><br><code>sub    %esi,%eax</code>：<code>rax</code>-<code>rsi</code><br><code>mov    %eax,%ecx</code>：把两个参数的差存到<code>rcx</code> 记为m<br><code>shr    $0x1f,%ecx</code>：<code>ecx</code>逻辑右移31位，<code>ecx</code>是32位的，移动31位，只剩下了符号位。<br><code>add    %ecx,%eax</code>：<code>eax</code>等于0+差。<code>如果b-a=-1，ecx=1，eax+1=0</code><br><code>sar    %eax</code>：<code>eax</code>右移一位，算术右移，等于7，m<br><code>lea    (%rax,%rsi,1),%ecx</code>：加载有效地址，效果是<code>rcx</code>里存入了a+m<br><code>cmp    %edi,%ecx</code>比较中间值是否等于第一个数字。<br>如果大于：<code>lea    -0x1(%rcx),%edx</code>b等于m-1。递归函数，左边区间查找是结束递归后<code>rax</code>乘2。<br>小于等于：<br><code>mov    $0x0,%eax</code>：<code>eax</code>等于0<br><code>cmp    %edi,%ecx</code>：对比中间值和第一个数字<br><code>jge    0x401007 &lt;func4+57&gt;</code>：大于等于跳转，本来是小于等于，相等于等于跳转，所以结束标志是第一个参数等于中间值m。返回值<code>rax</code>为0。<br><code>0x1(%rcx),%esi</code>：小于时，a = m+ 1，继续递归，小于时结束递归后执行的是<code>0x1(%rax,%rax,1),%eax</code>，不为0。</p>
</li>
<li><p>根据<code>func4</code>返回后<code>test   %eax,%eax</code>，如果不相等就爆炸，所以eax只能等于0，所以第一个数字一定是在二分查找的左边区间，所以可能值为7，3，1，0。</p>
</li>
<li><p><code>cmpl   $0x0,0xc(%rsp)</code>：相等时函数结束，说明第二个密码是固定值0。</p>
</li>
</ol>
<p>答案:</p>
<p><code>0 0</code></p>
<h2 id="phase-5"><a href="#phase-5" class="headerlink" title="phase_5"></a>phase_5</h2><p>思路：</p>
<p>第五个比较有趣,还是和12一样计算字符串长度,知道密码应该是一个6位长度字符串，计算字符串是不是相等函数的参数显示待匹配的字符串是”flyers”，编译的时候用了canary，栈指针每次都不同，这个对解密应该是没影响，主要是输入的字符串，每一个字节只保留了低四位,然后加上一个地址，将内存中的值送到了rsp里，那么这个地址应该是一个数组，打印一下这个地址开始的15个字节，是一串字符maduiersnfotvbyl，需要我们从里面找出密码，位置分别是9，15，14，5，6，7。所以输入的字符串的ASCII编码后四位应该就是这个值，答案比较多，找<br>了一个’a’-‘z’中的答案。<br>做法：</p>
<ol>
<li><p><code>break phase_5</code> ：打断点</p>
</li>
<li><p><code>disas</code>：显示汇编指令</p>
<img src="/2023/03/14/09-43-26/WX20230316-132301@2x.png" class>
<p>根据字符串对比函数的下一条<code>cmp    $0x6,%eax</code>，可以看出这道题密码长度为6。</p>
</li>
<li><p>分析跳转后的代码</p>
<img src="/2023/03/14/09-43-26/WX20230316-160027@2x.png" class>
<p><code>movzbl (%rbx,%rax,1),%ecx</code>：<code>ecx</code>内存的是<code>rbx</code>的第<code>rax</code>个字节做零扩展到双字，如图是<code>0x69</code>；<code>rax</code>相当于是for循环里的i。<br><code>mov    %cl,(%rsp)</code>：把<code>rcx</code>的低八位送入栈顶指针指向的地址。<br><code>mov    (%rsp),%rdx</code>：把值继续送到<code>rdx</code>。<br><code>and    $0xf,%edx</code>：只保留<code>rdx</code>的低四位。<br><code>movzbl 0x4024b0(%rdx),%edx</code>：把<code>rdx</code>的值加上<code>0x4024b0</code>，新地址的内容存到<code>edx</code>里。<br><code>mov    %dl,0x10(%rsp,%rax,1)</code>：把<code>rdx</code>的低八位存入<code>rax+rsp+0x10</code>的位置。<br><code>add    $0x1,%rax</code>：i自加<br><code>cmp    $0x6,%rax</code>：循环结束判断</p>
</li>
<li><p>后续指令把所有的输入字符改变之后保存在了<code>rsp + 0x10</code>指向的地址里，然后调用<code>strings_not_equal</code>：我们可以根据查看传参，看一下标准答案是什么。</p>
<img src="/2023/03/14/09-43-26/WX20230316-161808@2x.png" class>
<p>可以看到密码是字符串<code>flyers</code>，对应的字节是<code>0x66 0x6c 0x79 0x65 0x72 0x73</code>。</p>
</li>
<li><p>我们在打印一下for循环里跳转的地址<code>0x4024b0</code>保存的是什么?</p>
<img src="/2023/03/14/09-43-26/WX20230316-162400@2x.png" class>
<p>由于偏移量总是低四位，范围是0-15，所以字符串只需要关注<br><code>maduiersnfotvbyl</code>前面这些，需要我们从里面找出密码，位置分别是9，15，14，5，6，7。所以输入的字符串的ASCII编码后四位应该就是这个值，答案比较多，找了一个’a’-‘z’中的答案。</p>
</li>
</ol>
<p>答案:</p>
<p><code>ionefg</code></p>
<h2 id="phase-6"><a href="#phase-6" class="headerlink" title="phase_6"></a>phase_6</h2><p>思路：</p>
<p>第六个是一个链表，节点的前八个字节中低位是数据，高位是输入的密码，高位的8个字节是下一跳地址，根据输入的6个数必须是1-6，切两两不相同，还进行了一次处理，每一位密码x，变成了y = 7-x。</p>
<p>然后是链表的操作，每一个密码的节点对应的是(y - 1) * 8 + 结点首地址， 分配好结点后进行结点连接。<br>每一位密码的下一跳就是下一位密码对应的结点地址，最后一位结点的下一跳是0；要求是必要让结点中的数据，满足前一个结点大于等于后一个结点，<br>而所有结点的数据分别是：<br>(1):332<br>(2):168<br>(3):924<br>(4):691<br>(5):477<br>(6):443<br>所以数据最大的结点应该在最前面，序号应该是3 4 5 6 1 2。<br>而输入的密码应该是7 - y：   4 3 2 1 6 5<br>做法：</p>
<ol>
<li><p><code>break phase_6</code> ：打断点</p>
</li>
<li><p><code>disas</code>：显示汇编指令</p>
<img src="/2023/03/14/09-43-26/WX20230316-163103@2x.png" class>
<img src="/2023/03/14/09-43-26/WX20230316-163118@2x.png" class>
<img src="/2023/03/14/09-43-26/WX20230316-163134@2x.png" class>
</li>
<li><p>根据指令，这道题是读取了六个数字，我们直接看后面的处理。输入的数字保存在<code>rsp</code>指向的地址里。每个数字存储在四个字节里<br><code>mov    %rsp,%r14</code>：把输入的数组起始地址送到<code>r14</code><br><code>mov    $0x0,%r12d</code>：<code>r12d</code>赋值0，记为<code>i</code><br><code>mov    %r13,%rbp</code>：<code>rbp</code>保存栈顶指针，数组起始地址<br><code>mov    0x0(%r13),%eax</code>：<code>rax</code>等于输入的第一个值<br><code>sub    $0x1,%eax</code>：自减1<br><code>cmp    $0x5,%eax</code>：判断<code>rax</code>是不是等于5<br><code>jbe    0x401128 &lt;phase_6+52&gt;</code>：无符号小于等于才不会爆炸，所以输入的数字自减前必须是<code>1-6</code>。<br><code>add    $0x1,%r12d</code>：<code>i</code>+1<br><code>cmp    $0x6,%r12d</code>：循环结束标志，相等跳转<br>不相等：<br><code>mov    %r12d,%ebx</code>：把<code>i</code>送到<code>rbx</code>， 记为<code>j = i + 1</code>。<br><code>movslq %ebx,%rax</code>：符号扩展送到<code>rax</code>，等于<code>j</code><br><code>mov    (%rsp,%rax,4),%eax</code>：输入的第<code>j</code>个数 送到 <code>rax</code><br><code>cmp    %eax,0x0(%rbp)</code>：对比<code>rax</code>和栈顶指针指向的数是否相同，相等就爆炸，数字不能重复。<br><code>add    $0x1,%ebx</code>：<code>j++</code><br><code>cmp    $0x5,%ebx</code>：循环跳出条件，后面的每一个数不能和第一个数相等。<br><code>add    $0x4,%r13</code>：循环重复，<code>i</code>指向下一个数<br>所有的数范围是<code>1-6</code>，且不重复时。</p>
</li>
<li><p><code>lea    0x18(%rsp),%rsi</code>：把最后一个数的地址送到<code>rsi</code><br><code>mov    %r14,%rax</code>：数组的第一个地址送到<code>rax</code><br><code>mov    $0x7,%ecx</code>：<code>rcx</code>等于7<br><code>mov    %ecx,%edx</code>：<code>rdx</code> = 7<br><code>sub    (%rax),%edx</code>：<code>rdx</code> = 7 - <code>*rax</code>，数组的第一个数<br><code>mov    %edx,(%rax)</code>：覆盖这个数<br><code>add    $0x4,%rax</code>：数组下一个<br><code>cmp    %rsi,%rax</code>：跳出条件<br>这段代码把所有数组的数，全部用7减，保存差</p>
</li>
<li><p><code>mov    $0x0,%esi</code>：<code>rsi</code> = 0，记为<code>i</code><br><code>mov    (%rsp,%rsi,1),%ecx</code>：<code>rcx</code>保存<code>rsp</code>的第<code>i</code>个字节地址的数字，记为<code>x</code>，注意数字在4的倍数字节处<br><code>cmp    $0x1,%ecx</code>：<code>x</code> == 1，1进行这个if判断<br>如果x==1：<br><code>mov    $0x6032d0,%edx</code>：<code>rdx</code>赋值，这里要注意应该就是密码所在地<br>如果x&gt;1：<br><code>mov    $0x1,%eax</code>：<code>rax</code> = 1<br><code>mov    $0x6032d0,%edx</code>:<br><code>mov    0x8(%rdx),%rdx</code>：<code>rdx</code> =  （<code>rdx</code> + 8地址保存的数据），就是<code>rdx</code>地址指向的节点的next。<br><code>add    $0x1,%eax</code>：<code>rax</code> + 1<br><code>cmp    %ecx,%eax</code>：对比<code>x</code>和<code>rax</code><br>不相等时<code>rax</code>一直加1，最终<code>rdx</code>指向第x个节点地址<br>if判断结束：<br><code>mov    %rdx,0x20(%rsp,%rsi,2)</code>：把<code>rdx</code>数送入<code>rsp</code> + 2 <em> i + 0x20，这个地址，相当于把数组整体换位置，后面是偏移量。<br><code>add    $0x4,%rsi</code>：<code>i</code> = <code>i</code> + 4<br><code>cmp    $0x18,%rsi</code>：结束条件<br>这段循环把数组里的数，全部向后偏移保存了一个数组，这个数组中0，1对应的是固定值<code>$0x6032d0</code>，大于1的值都是`$0x6032d0 + 8 </em> (x - 1)`。新数组的每一个数长度是8字节，数据是一串地址。</p>
<img src="/2023/03/14/09-43-26/WX20230317-124521@2x.png" class>
<p>可以看出在<code>rsp</code>后0x20地址处，是六个地址。</p>
</li>
<li><p><code>mov    0x20(%rsp),%rbx</code>：<code>rbx</code>等于新建数组的第一个数，记为<code>i</code><br><code>lea    0x28(%rsp),%rax</code>：<code>rax</code>是新数组第二个数的地址，记为<code>&amp;j</code><br><code>lea    0x50(%rsp),%rsi</code>：<code>rsi</code>数组最大地址<br><code>mov    %rbx,%rcx</code>：<code>rcx</code>存第一个数，记为<code>i</code><br>循环：<br><code>mov    (%rax),%rdx</code>：<code>rdx</code>：存下个数，记为<code>j</code><br><code>mov    %rdx,0x8(%rcx)</code>：把<code>j</code>放到<code>i</code>后8个字节处<br><code>add    $0x8,%rax</code>：<code>&amp;j = &amp;j + 8</code>，后移八个字节<br><code>cmp    %rsi,%rax</code>：对比有没有到了数组末尾<br>没有到最后一个地址：<br><code>mov    %rdx,%rcx</code>：<code>rcx</code> = <code>rdx</code>，<code>i</code>后移8个字节<br>继续上面的循环<br>如果到了最后一个地址：<br><code>movq   $0x0,0x8(%rdx)</code>：把0存到最后一个节点的后8字节处，尾结点的next=0。<br>上面把所有链表连接起来了。链接方式是按照输入的六个数字进行连接，按照1-6的顺序，数字越大，地址越大。每个数字代表一个地址，从1-6链接起来。</p>
</li>
<li><p>下面进行的是爆炸判断：<br><code>mov    $0x5,%ebp</code>：<code>rbp</code> = 5<br>循环：<br><code>mov    0x8(%rbx),%rax</code>：<code>rax</code>=第一个节点的next<br><code>mov    (%rax),%eax</code>：<code>rax</code>=地址保存的数<br><code>cmp    %eax,(%rbx)</code>：<em>next对比*</em>this<br>小于就爆炸：<br>大于等于：<br><code>mov    0x8(%rbx),%rbx</code>：this向后移动8位<br><code>sub    $0x1,%ebp</code>：<code>rbp</code>减1<br>不等于0时，循环继续<br>上面这段循环如果链表的数据表示的地址内存的数是递增的就爆炸了。所以就是要把链表调整为递减的链表，通过输入的1-6。</p>
</li>
<li><p>打印看一下这个<code>$0x6032d0</code>地址处保存的数据是什么？<br>链接之前的链表：</p>

<p>重新链接之后的链表：</p>

<p>根据爆炸判断，这道题就是让链表排序成递减。</p>
</li>
</ol>
<p>答案:</p>
<p><code>4 3 2 1 6 5</code></p>
<h2 id="secret-phase"><a href="#secret-phase" class="headerlink" title="secret_phase"></a>secret_phase</h2><p>重新开始写解题笔记的时候，按照小土刀的博客搭建了hexo博客，根据他的文章格式写出了这篇解题笔记，在他的文章里发现还有一道彩蛋题目，藏在了<code>phase_defused</code>函数里。这个不仔细读汇编代码很难发现，因为一般不会看拆弹成功的函数。现在自己把这个彩蛋也做一下。</p>
<p>思路：</p>
<p>做法：</p>
<ol>
<li><p>在函数<code>phase_defused</code>处打断点。</p>
<img src="/2023/03/14/09-43-26/WX20230317-143025@2x.png" class>
<p>发现这里有一个<code>secret_phase</code>函数，对这个函数打断点发现不会进入。<br>在汇编代码里找一下函数入口。</p>
</li>
<li><p><code>cmpl   $0x6,0x202181(%rip)        # 0x603760 &lt;num_input_strings&gt;</code>：对比当前的关卡数，不等于6时跳转，等于6时，可能会进入彩蛋。</p>
</li>
<li><p><code>mov    $0x402619,%esi</code>和<code>mov    $0x603870,%edi</code>，根据这两个参数，应该是调用的sscanf函数，看一下输入参数是什么？</p>
<img src="/2023/03/14/09-43-26/WX20230317-145028@2x.png" class>
<p>可以看出密码是两个数字一个字符串。</p>
</li>
<li><p><code>mov    $0x402622,%esi</code>：打印看一下这里存的是什么？</p>
<img src="/2023/03/14/09-43-26/WX20230317-150241@2x.png" class>
<p>可以确定第三个密码是<code>DrEvil</code></p>
</li>
<li><p><code>mov    $0x4024f8,%edi</code>：<br><code>mov    $0x402520,%edi</code>：打印看一下这里是什么？</p>
<img src="/2023/03/14/09-43-26/WX20230317-150454@2x.png" class>
</li>
<li><p>修改一下我们的<code>psol.txt</code>，最后一行加上<code>0 0 DrEvil</code>，重新调试进入<code>secret_phase</code>看一下汇编代码，代码没有进入，说明输入不在最后，继续看一下汇编代码。</p>
</li>
<li><p>根据sscanf的第一个参数地址在<code>0x603870</code>，我们就找一下之前输入的数据哪一个存放在这周围，在<code>bomb.s</code>文件里搜一下最近的是<code>read_line</code>函数里的<code>0x603780</code>。<br>看一下附件的代码：<br><code>lea    (%rax,%rax,4),%rsi</code>：<br><code>shl    $0x4,%rsi</code>：<br><code>add    $0x603780,%rsi</code>：<br><code>rax</code>放的是题目序号，乘5，左移4位，加上<code>0x603780</code>后等于我要的值，<code>rax</code>应该等于3。也就是说第三道题目解出来之后，第四道题目的输入缓冲区在<code>0x603870</code>。把输入文件改一下。</p>
</li>
<li><p>成功进入彩蛋函数，现在开始解这个彩蛋。<br>这里要把彩蛋的输入放在第六道题的下一行，彩蛋的入口在第四道题的输入后面。<br><code>disas</code>：先看一下汇编代码</p>
<img src="/2023/03/14/09-43-26/WX20230317-163059@2x.png" class>
<p><code>mov    $0xa,%edx</code>：<code>rdx</code>=10<br><code>mov    $0x0,%esi</code>：<code>rsi</code>=0<br><code>mov    %rax,%rdi</code>：<code>rdi</code> = read_line的返回值。就是我们输入的字符串地址。<br><code>callq  0x400bd0 &lt;strtol@plt&gt;</code>：调用函数，找开头的十进制数转换为long int，存在<code>rax</code>里，结尾的下一个地址放在<code>rsi</code>里。<br><code>mov    %rax,%rbx</code>：<code>rbx</code>=数字<br><code>lea    -0x1(%rax),%eax</code>：<code>rax</code>-1存到<code>rax</code>里<br><code>cmp    $0x3e8,%eax</code>：对比如果，0x3e8是1000<br>如果大于，爆炸：<br>如果小于等于：<br><code>mov    %ebx,%esi</code>：<code>rsi</code>=<code>rbx</code><br><code>mov    $0x6030f0,%edi</code>：<code>rdi</code>赋值，这里应该是密码所在地<br><code>callq  0x401204 &lt;fun7&gt;</code>：跳转到fun7函数</p>
</li>
<li><p>在fun7函数里打断点，看下汇编代码</p>
<img src="/2023/03/14/09-43-26/WX20230317-174533@2x.png" class>
<p><code>test   %rdi,%rdi</code>：test<code>rdi</code><br>如果等于0就跳转：<br><code>mov    $0xffffffff,%eax</code>：赋值32位全1，返回<br>不等于0：<br><code>mov    (%rdi),%edx</code>：把<code>rdi</code>地址保存的数据<code>$</code>给<code>rdx</code><br><code>cmp    %esi,%edx</code>：对比<code>rdx</code>和我们输入的密码<br><code>jle    0x401220 &lt;fun7+28&gt;</code>：<br>如果<code>rdx</code>&lt;=<code>rsi</code>：<br><code>mov    $0x0,%eax</code>：赋值0<br><code>cmp    %esi,%edx</code>：继续对比<br>如果<code>rdx</code>==<code>rsi</code>：返回0。根据彩蛋的汇编代码，可以看出返回值等于2才可以拆弹成功。<br>如果<code>rdx</code>&lt;<code>rsi</code>：<br><code>mov    0x10(%rdi),%rdi</code>：把<code>rdi</code>指向的地址+0x10，取数据送到<code>rdi</code><br>递归fun7。<br><code>lea    0x1(%rax,%rax,1),%eax</code>：<code>rax</code>左移一位再加1。<br>如果<code>rdx</code> &gt; <code>rsi</code>：<br><code>mov    0x8(%rdi),%rdi</code>：把<code>rdi</code>指向的地址+0x8，取数据送到<code>rdi</code><br>递归fun7。<br><code>add    %eax,%eax</code>：<code>rax</code>左移一位</p>
</li>
<li><p>根据上面的分析。递归的返回值一共四种<br>（1）：返回32位1<br>（2）：左移一位<br>（3）：0<br>（4）：左移一位加1<br>要想拆掉炸弹，需要返回的是2。<br>返回值顺序是：左移一位&lt;左移一位加1&lt;返回0<br>先从内层递归找条件：fun(x，y)<br>返回0：<code>rdi</code>指向的数 == y<br>左移一位加1：<code>rdi</code>指向的数 &lt; y，这里x+16字节<br>左移一位：<code>rdi</code>指向的数 &gt; y，这里x+8字节<br>递归顺序为：<br>fun(x，y) -&gt; fun(x + 8，y) -&gt; fun(x+16，y)</p>
</li>
<li><p>打印一下链表存的数据是哪些？</p>
<img src="/2023/03/14/09-43-26/WX20230317-174533@2x.png" class>
<img src="/2023/03/14/09-43-26/WX20230317-174534@2x.png" class>
<p>根据搜索路径可以看出，需要输入的密码应该是22。</p>
</li>
<li><p>测试一下</p>
<img src="/2023/03/14/09-43-26/WX20230317-174535@2x.png" class>
<p>彩蛋拆除成功！！</p>
</li>
</ol>
<p>答案：<code>22</code>+任意字符串</p>
]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
        <tag>shell</tag>
        <tag>gdb</tag>
        <tag>objdump</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux和SSH相关命令</title>
    <url>/2023/03/11/15-22-24/</url>
    <content><![CDATA[<h1 id="linux命令"><a href="#linux命令" class="headerlink" title="linux命令"></a>linux命令</h1><h2 id="ln链接文件"><a href="#ln链接文件" class="headerlink" title="ln链接文件"></a>ln链接文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ln -s 源文件  目的文件    #建立软链接</span><br><span class="line">ln    源文件  目的文件    #硬链接</span><br></pre></td></tr></table></figure>
<h2 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a>pwd命令</h2><p>显示当前地址</p>
<h1 id="SSH命令"><a href="#SSH命令" class="headerlink" title="SSH命令"></a>SSH命令</h1><h2 id="scp传输文件"><a href="#scp传输文件" class="headerlink" title="scp传输文件"></a>scp传输文件</h2><p><code>注意要在本地使用这个命令，ssh登录后使用，文件从服务器下载到服务器了</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scp username@ip_address:/home/username/filename ~/   #从服务器下载到本地</span><br><span class="line"># 参数 -P 端口号   要大写</span><br><span class="line"># 参数 -r 文件夹</span><br><span class="line">scp -P2222 -r</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>ssh</tag>
        <tag>mac</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 实验I Data Lab</title>
    <url>/2023/03/09/11-54-50/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>23.03.10：初稿</li>
<li></li>
</ul>
<h1 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h1><ul>
<li><a href="/2023/03/15/10-59-10/" title="csapp 笔记汇总">CSAPP - 笔记汇总</a></li>
<li><a href="/2023/03/09/11-54-50/" title="CSAPP 实验I Data Lab">I Data Lab - 位操作，数据表示</a></li>
<li><a href="/2023/03/14/09-43-26/" title="CSAPP 实验II Bomb Lab">II Bomb Lab - 汇编，栈帧与 gdb</a></li>
<li><a href="/2023/03/18/15-54-47/" title="CSAPP 实验III Attack Lab">III Attack Lab - 漏洞是如何被攻击的</a></li>
<li><a href="/2024/03/09/16-34-34/" title="CSAPP 实验IV CacheLab">IV Cache Lab - 实现一个缓存系统</a></li>
<li><a href="/2024/03/14/12-34-42/" title="CSAPP 实验V ShellLab">V Shell Lab - 实现一个Shell</a>
</li>
</ul>
<h1 id="任务目标"><a href="#任务目标" class="headerlink" title="任务目标"></a>任务目标</h1><p>DataLab实验，需要我们完善函数，条件是使用限定的操作符，并且操作符的数量也有限制，“=”不做数量限制。</p>
<h1 id="相关内容"><a href="#相关内容" class="headerlink" title="相关内容"></a>相关内容</h1><ol>
<li><p>自己定义的int整型的赋值范围是0到0xFF，8bits</p>
</li>
<li><p>机器是32位</p>
</li>
<li><p>只能使用一元操作符<code>!</code> <code>~</code>，二元操作符<code>&amp;</code> <code>|</code> <code>+</code> <code>&lt;&lt;</code> <code>&gt;&gt;</code> </p>
</li>
<li><p>不可以调用其他函数</p>
</li>
<li><p>测试命令</p>
<blockquote>
<p><code>make clean</code>：清除生成，每次修改<code>bits.c</code>文件都要清除重新生成<code>make</code>：生成文件<br><code>./btest -f funname -1 v</code>：测试单独的函数，带参数 <code>-T 100</code>：修改限制时间<br><code>./dlc bits.c</code> ：测试编码是否符合规则,符合规则无输出，参数<code>-e</code>，输出所有信息<br><code>./ishow 22</code>：输出int值的二进制，数值<br><code>./fshow 22</code>：输出float的二进制，数值，已经非规范值</p>
</blockquote>
</li>
</ol>
<h1 id="题目及解法"><a href="#题目及解法" class="headerlink" title="题目及解法"></a>题目及解法</h1><h2 id="bitXor"><a href="#bitXor" class="headerlink" title="bitXor"></a>bitXor</h2><ul>
<li><p>题目要求：返回两个int的异或值</p>
</li>
<li><p>允许操作：<code>~ &amp;</code></p>
</li>
<li><p>操作数量：14</p>
</li>
<li><p>分值：1</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bitXor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ~(~(~x &amp; y) &amp; ~(x &amp; ~y));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="tmin"><a href="#tmin" class="headerlink" title="tmin"></a>tmin</h2><ul>
<li><p>题目要求：求补码的最小值</p>
</li>
<li><p>允许操作：<code>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</code></p>
</li>
<li><p>操作数量：4</p>
</li>
<li><p>分值：1</p>
</li>
</ul>
<p>32位机器码的补码最小值是最高位为1，其他位0，所以用1左移31位形成。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tmin</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">  x = x &lt;&lt; <span class="number">31</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="isTmax"><a href="#isTmax" class="headerlink" title="isTmax"></a>isTmax</h2><ul>
<li><p>题目要求：如果x是补码最大值返回1，否则返回0</p>
</li>
<li><p>允许操作：<code>! ~ &amp; ^ | +</code></p>
</li>
<li><p>操作数量：10</p>
</li>
<li><p>分值：1</p>
</li>
</ul>
<p>补码的最大值是最高位0，其他位1。加1后是最小值，Tmin和Tmax每位都相反，Tmin^Tmax是全1，可以使用这个值进行返回。需要注意补码的特殊值Tmin，Tmax，还需要注意-1，32位全1 <code>1111</code>，因为-1 ^ 0 = 1，需要排除这种情况</p>
<ul>
<li><p>flag_2 表示x是否等于 -1 </p>
<ol>
<li><p>如果x==-1， y=0，y^0 == 0   flag_2为0</p>
</li>
<li><p>如果x!=-1，y!=0， y^0 != 0，flag_2不为0，flag的值是0或1，所以需要取非两次，把非零值转换为1</p>
</li>
</ol>
</li>
<li><p>flag_1 表示(x+1)^x，有两种情况结果为全1，x是<code>Tmax</code>和<code>-1</code>，我们只需要全为1的情况，所以先取反~，换成全0，再取非!， 转为1。</p>
</li>
<li><p>返回值为两个标志相与，用flag_2排除掉flag_1中-1的这种情况，剩下的就是Tmax</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isTmax</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> y = x + <span class="number">1</span>;  <span class="comment">//Tmin</span></span><br><span class="line">  <span class="type">int</span> flag_1 = !(~(x ^ y)); </span><br><span class="line">  <span class="type">int</span> flag_2= !!(y ^ <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> flag_1 &amp; flag_2; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="allOddBits"><a href="#allOddBits" class="headerlink" title="allOddBits"></a>allOddBits</h2><ul>
<li><p>题目要求：如果每一个偶数位都是1返回1，否则返回0</p>
</li>
<li><p>允许操作：<code>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</code></p>
</li>
<li><p>操作数量：12</p>
</li>
<li><p>分值：2</p>
</li>
</ul>
<p>先从32比特中只保留所有偶数位的值，其他位赋值0，再和<code>0xAAAAAAAA</code>作对比相等返回1，因为不能用等号，所以用异或^代替判断，如果相等全为0，取非!值为1，否则为0。</p>
<ul>
<li><p>移位和加法让变量y等于0xAAAAAAAA。</p>
</li>
<li><p>x与y相与，只留下x的偶数位的值</p>
</li>
<li><p>用异或判断x与y是不是相等</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">allOddBits</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> y = <span class="number">0xAA</span>; </span><br><span class="line">  <span class="comment">//+优先级大于 &lt;&lt; </span></span><br><span class="line">  y  = y + (y &lt;&lt; <span class="number">8</span>);</span><br><span class="line">  y = y + (y &lt;&lt; <span class="number">16</span>);</span><br><span class="line">  <span class="comment">//只留下x的偶数位值</span></span><br><span class="line">  x = x &amp; y;</span><br><span class="line">  <span class="keyword">return</span> !(y ^ x) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="negate"><a href="#negate" class="headerlink" title="negate"></a>negate</h2><ul>
<li><p>题目要求：返回-x</p>
</li>
<li><p>允许操作：<code>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</code></p>
</li>
<li><p>操作数量：5</p>
</li>
<li><p>分值：2</p>
</li>
</ul>
<p>这个比较简单，根据二进制补码x与-x就是按位取反再加1。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">negate</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ~x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="isAsciiDigit"><a href="#isAsciiDigit" class="headerlink" title="isAsciiDigit"></a>isAsciiDigit</h2><ul>
<li><p>题目要求：判断x是不是ASCII码的0-9， 相当于判断x的值是不是0x30到0x39。</p>
</li>
<li><p>允许操作：<code>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</code></p>
</li>
<li><p>操作数量：15</p>
</li>
<li><p>分值：3</p>
</li>
</ul>
<p>先观察0-9的补码形式</p>
<p>0x30 <code>110000</code>  </p>
<p>0x37 <code>110111</code>  </p>
<p>0x38 <code>111000</code>  </p>
<p>0x39 <code>111001</code></p>
<p>首先需要满足除后6位外，高位全为0，满足第一个条件后0-7满足前三位为<code>110</code>，剩下的直接对比是不是等于8或9。<code>不能使用等号所以用异或判断相等</code></p>
<ul>
<li><p>flag_1 右移6位后，如果高位全为0，就是0，取非!为1，不然就是0</p>
</li>
<li><p>flag_2 右移3位后，满足第一个条件的除了低3位其他全为0，与<code>110</code>比较相等就是0到7中的值</p>
</li>
<li><p>flag_3， flag_4，直接判断是不是等于8，9。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isAsciiDigit</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> y = x &amp; <span class="number">0x3f</span>; <span class="comment">//截取x的后6位</span></span><br><span class="line">  <span class="type">int</span> flag_1 = !(x &gt;&gt; <span class="number">6</span>); <span class="comment">//右移六位后,取非为1   x的高位全是0  符合条件</span></span><br><span class="line">  <span class="type">int</span> flag_2 = !((x &gt;&gt; <span class="number">3</span>) ^ <span class="number">0x6</span>);  <span class="comment">//满足第一个条件后,右移3位   异或110   如果为0  就是属于&#x27;0&#x27; 到&#x27;7&#x27;</span></span><br><span class="line">  <span class="type">int</span> flag_3 = !(y ^ <span class="number">0x38</span>);  <span class="comment">//满足第一个条件后   是&#x27;8&#x27;</span></span><br><span class="line">  <span class="type">int</span> flag_4 = !(y ^ <span class="number">0x39</span>);   <span class="comment">//满足第一个条件后   是&#x27;9&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> flag_1 &amp; (flag_2 | flag_3 | flag_4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="conditional"><a href="#conditional" class="headerlink" title="conditional"></a>conditional</h2><ul>
<li><p>题目要求：x不为0，返回y， x等于0，返回z。</p>
</li>
<li><p>允许操作：<code>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</code></p>
</li>
<li><p>操作数量：16</p>
</li>
<li><p>分值：3</p>
</li>
</ul>
<p>先找返回值，x等于0，return (x &amp; y) ^ (~x &amp; z)，x不等于0的时候，结果很多，这时候把x处理一下变为全1，返回值就相等了。</p>
<ul>
<li><p>对于x不等于0的情况，换全1比较麻烦，对x取非!，把x简化成0或1。</p>
</li>
<li><p>把x扩展到全1和全0，用移位加也能做出来而且满足操作数量的限制，继续做后面的题目<code>logicalNeg</code>想到了一个快速扩展的方法，0或1，取反加1，就是全0或者全1。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">conditional</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> &#123;</span><br><span class="line">  x = !x;   <span class="comment">//取非 把x变为 0 1两种    把他们扩展到32位</span></span><br><span class="line">  x = ~x + <span class="number">1</span>;  <span class="comment">//01快速扩展到全0全1 </span></span><br><span class="line"> <span class="comment">// x = (x &lt;&lt; 1) + x;</span></span><br><span class="line"> <span class="comment">// x = (x &lt;&lt; 2) + x;</span></span><br><span class="line"> <span class="comment">// x = (x &lt;&lt; 4) + x;</span></span><br><span class="line"> <span class="comment">// x = (x &lt;&lt; 8) + x;</span></span><br><span class="line"> <span class="comment">// x = (x &lt;&lt; 16) + x;</span></span><br><span class="line">  <span class="keyword">return</span> ((~x) &amp; y) ^ (x &amp; z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="isLessOrEqual"><a href="#isLessOrEqual" class="headerlink" title="isLessOrEqual"></a>isLessOrEqual</h2><ul>
<li><p>题目要求：x&lt;=y，返回1，否则返回0。</p>
</li>
<li><p>允许操作：<code>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</code></p>
</li>
<li><p>操作数量：24</p>
</li>
<li><p>分值：3</p>
</li>
</ul>
<p>找出所以返回1的情况，一共两种情况，相等，小于。相等的时候比较好做，用异或判断相等，小于的情况比较复杂。</p>
<ul>
<li><p>等于：flag_3表示相等的情况  异或判断</p>
</li>
<li><p>小于：有两种情况 <code>需要注意减法同号一点不会溢出</code></p>
<ol>
<li><p>flag_5：x负数，y正数。</p>
</li>
<li><p>flag_4：x，y同号，x &lt; y，转换为 y-x&gt;0。</p>
</li>
</ol>
</li>
<li><p>用flag_5 表示x负数，y正数。   <code>用右移31位看符号看判断正负</code></p>
</li>
<li><p>用flag_6 表示x正数，y负数。</p>
</li>
<li><p>用sum=y - x，flag_4 表示符号。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isLessOrEqual</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">  <span class="type">int</span> nagete_x = ~x + <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> sum = y + nagete_x; </span><br><span class="line">  <span class="type">int</span> flag_3 = !(x ^ y);</span><br><span class="line">  <span class="type">int</span> flag_5 = (x &gt;&gt; <span class="number">31</span>) &amp; !(y &gt;&gt; <span class="number">31</span>);   </span><br><span class="line">  <span class="type">int</span> flag_6 = !(x &gt;&gt; <span class="number">31</span>) &amp; (y &gt;&gt; <span class="number">31</span>);   </span><br><span class="line">  <span class="type">int</span> flag_4 = !(sum &gt;&gt; <span class="number">31</span>) &amp; !flag_5 &amp; !flag_6;   <span class="comment">//xy同号  减法不会溢出  减法有效</span></span><br><span class="line">  <span class="keyword">return</span> flag_3 | flag_4 | flag_5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="logicalNeg"><a href="#logicalNeg" class="headerlink" title="logicalNeg"></a>logicalNeg</h2><ul>
<li><p>题目要求：实现取非!的功能</p>
</li>
<li><p>允许操作：<code>~ &amp; ^ | + &lt;&lt; &gt;&gt;</code></p>
</li>
<li><p>操作数量：12</p>
</li>
<li><p>分值：4</p>
</li>
</ul>
<p>思路：取非结果只有0和1，把全0或全1加1，就是1或0，所以就需要把0转换为全1，非0转换为全0，然后加1，就是返回值。默认返回0，找出返回1的情况，也就是全1。<code>只有0和Tmin的负值和自己符号相同，其他的符号都相反</code></p>
<ul>
<li><p>取负值，对符号位扩展，然后自己的符号位和负值符号位相加，</p>
<ol>
<li><p>0和Tmin，结果为0。</p>
</li>
<li><p>其他结果为全1。</p>
</li>
</ol>
</li>
<li><p>flag_1：~sum，0和Tmin结果为全1， 其他为全0。</p>
</li>
<li><p>flag_2：~Tmin 01111 ~0全1</p>
</li>
<li><p>flag_3：flag_1 中排除到flag_2的Tmin情况</p>
<ol>
<li><p>Tmin <code>0111</code>  0为<code>1111</code>  其余为<code>0000</code></p>
</li>
<li><p>取反，只保留符号位， Tmin <code>1111</code> 0为<code>0000</code> 其余为<code>1111</code></p>
</li>
<li><p>加1后，0为<code>0001</code>， 其余都统一为<code>0000</code></p>
</li>
</ol>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">logicalNeg</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> neg_x = ~x;</span><br><span class="line">  <span class="type">int</span> y = neg_x + <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> hight_x = x &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  <span class="type">int</span> hight_y = y &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  <span class="type">int</span> flag_1 = ~(hight_x + hight_y);</span><br><span class="line">  <span class="type">int</span> flag_2 = neg_x;</span><br><span class="line">  <span class="type">int</span> flag_3 = (~(flag_1 &amp; flag_2) &gt;&gt; <span class="number">31</span>) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> flag_3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="howManyBits"><a href="#howManyBits" class="headerlink" title="howManyBits"></a>howManyBits</h2><ul>
<li><p>题目要求：返回表示x的补码最短长度 <code>注意-1，用一位</code></p>
</li>
<li><p>允许操作：<code>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</code></p>
</li>
<li><p>操作数量：90</p>
</li>
<li><p>分值：4</p>
</li>
</ul>
<p>思路：用上面做的函数 conditional 做两个if功能， 一次返回分半查找的剩余一半函数 ，一次计算分半如果选择前一半，bit数要加上一半的长度，选择后面长度加0不做处理。</p>
<blockquote>
<p>用0xffff0000 留下x的前16位,如果不等于0 说明位数大于16 等于0 说明位数小于16 在后16位内再进行分半查找</p>
</blockquote>
<p>正负数的处理<code>重点</code><br>都处理成正数，方便右移添0。加上符号位就是有效位数。</p>
<ul>
<li><p>正数：找出最高位的1。</p>
</li>
<li><p>负数：找出最高位的0，<code>Tmin也符合</code></p>
<blockquote>
<p>负数高位连续的1都是无用数据，只需要找到高位连续的1后的第一个0在哪里，做法是取反，如<code>1110010</code>，有用的数据是<code>10010</code>，全部取反后<code>0001101</code>， 有效位数是4位，加上符号位。</p>
</blockquote>
</li>
<li><p>flag_nage： x是负数 值为1</p>
</li>
<li><p>重点代码，</p>
<ol>
<li><p>if函数功能</p>
<blockquote>
<p><code>x = (extend_f_n &amp; (~x)) ^ ((~extend_f_n) &amp; x);</code> ：如果标记为全1，选择的~x， 如果为全0，选择的x。异或的两边有一个一直为全0，结果一定是另一个。</p>
</blockquote>
</li>
<li><p>一个二分法</p>
<blockquote>
<p><code>x_32 = x &amp; bit_32;</code> ：取x的前16位<br><code>x_32 = !x_32;</code>：取非，如果前16位全0，值就是1，否则是0<br><code>x_32 = ~x_32 + 1;</code> 前16位全0，扩充到全1，否则扩充到全0<br><code>flag_32 = ~x_32;</code> 这里是为了减少一个op值，重复使用代码<br><code>x_16 = (flag_32 &amp; (x &gt;&gt; 16)) ^ ((x_32 &amp; (x &amp; (~bit_32))));</code><br>x_32如果全0，说明前16位，有1，那就把x右移16位，覆盖掉后面，继续对这16位进行二分法。<code>这里不用考虑右移补1，因为都是正数最高位都是0</code>。并且总数加16。<br>如果全1，说明前16位都是0，要从后16位开始二分法，不用移位，x_16要等于x的后16位。总数加0。<br><code>sum = sum + (flag_32 &amp; 16);</code>：</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">howManyBits</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> x_32, x_16, x_8, x_4, x_2;  <span class="comment">//分别表示x的不同比特</span></span><br><span class="line">  <span class="type">int</span> bit_8 = <span class="number">0xff</span> &lt;&lt; <span class="number">8</span>;</span><br><span class="line">  <span class="type">int</span> bit_32 = (bit_8 + <span class="number">0xff</span>) &lt;&lt; <span class="number">16</span>;   </span><br><span class="line">  <span class="type">int</span> bit_16 = bit_8;</span><br><span class="line">  <span class="type">int</span> flag_32,flag_16,flag_8,flag_4,flag_2;  <span class="comment">//表示 ~x_32  重使用一次 减少 ops数量</span></span><br><span class="line">  <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> flag_nage = !!(x &gt;&gt; <span class="number">31</span>);     <span class="comment">//  x是负数   值为1</span></span><br><span class="line">  <span class="comment">//通过负0和Tmin 都是自己   ^之后为0  排除x是0的情况    当x是Tmin 是值为1</span></span><br><span class="line">  <span class="comment">//int flag_Tmin = !(x ^ (~x + 1)) &amp; x; </span></span><br><span class="line">  <span class="type">int</span> flag_Tmin = !(x &lt;&lt; <span class="number">1</span>) &amp; x;   <span class="comment">//Tmin 左移一位 去掉符号位后是全0   比上面的方法减少op</span></span><br><span class="line">  <span class="type">int</span> extend_f_T = ~flag_Tmin + <span class="number">1</span>;      <span class="comment">//扩展flag_Tmin</span></span><br><span class="line">  <span class="type">int</span> extend_f_n = ~flag_nage + <span class="number">1</span>;      <span class="comment">//扩展flag_nage</span></span><br><span class="line">  sum = sum + (flag_Tmin &amp; <span class="number">32</span>);</span><br><span class="line">  x = (extend_f_T &amp; <span class="number">0</span>) ^ ((~extend_f_T) &amp; x);  <span class="comment">// flag_Tmin 是1时  x赋值0   是0是  x不变</span></span><br><span class="line"></span><br><span class="line">  x = (extend_f_n &amp; (~x)) ^ ((~extend_f_n) &amp; x);  <span class="comment">// flag_nage 是1时  x赋值~x   是0是  x不变</span></span><br><span class="line"></span><br><span class="line">  bit_8 = <span class="number">0xf0</span>; </span><br><span class="line">  x_32 = x &amp; bit_32;</span><br><span class="line">  x_32 = !x_32;</span><br><span class="line">  x_32 = ~x_32 + <span class="number">1</span>;</span><br><span class="line">  flag_32 = ~x_32;</span><br><span class="line">  x_16 = (flag_32 &amp; (x &gt;&gt; <span class="number">16</span>)) ^ ((x_32 &amp; (x &amp; (~bit_32))));</span><br><span class="line">  sum = sum + (flag_32 &amp; <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">  x = x_16;   <span class="comment">//改变x</span></span><br><span class="line">  x_16 = x &amp; bit_16;</span><br><span class="line">  x_16 = !x_16;</span><br><span class="line">  x_16 = ~x_16 + <span class="number">1</span>;</span><br><span class="line">  flag_16 = ~x_16;</span><br><span class="line">  x_8 = (flag_16 &amp; (x &gt;&gt; <span class="number">8</span>)) ^ ((x_16 &amp; (x &amp; <span class="number">0xff</span>)));</span><br><span class="line">  sum = sum + (flag_16 &amp; <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">  x = x_8;   <span class="comment">//改变x</span></span><br><span class="line">  x_8 = x &amp; bit_8;</span><br><span class="line">  x_8 = !x_8;</span><br><span class="line">  x_8 = ~x_8 + <span class="number">1</span>;</span><br><span class="line">  flag_8 = ~x_8;</span><br><span class="line">  x_4 = (flag_8 &amp; (x &gt;&gt; <span class="number">4</span>)) ^ ((x_8 &amp; (x &amp; (<span class="number">0xf</span>))));   <span class="comment">//~bit_8  改为0xf  省一个op</span></span><br><span class="line">  sum = sum + (flag_8 &amp; <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">  x = x_4;   <span class="comment">//改变x</span></span><br><span class="line">  x_4 = x &amp; <span class="number">12</span>;</span><br><span class="line">  x_4 = !x_4;</span><br><span class="line">  x_4 = ~x_4 + <span class="number">1</span>;</span><br><span class="line">  flag_4 = ~x_4;</span><br><span class="line">  x_2 = (flag_4 &amp; (x &gt;&gt; <span class="number">2</span>)) ^ ((x_4 &amp; (x &amp; <span class="number">3</span>)));</span><br><span class="line">  sum = sum + (flag_4 &amp; <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  x = x_2;</span><br><span class="line">  x_2 = x_2 &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  x_2 = !x_2;</span><br><span class="line">  x_2 = ~x_2 + <span class="number">1</span>;</span><br><span class="line">  flag_2 = ~x_2;</span><br><span class="line">  x = (flag_2 &amp; (x &gt;&gt; <span class="number">1</span>)) ^ ((x_2 &amp; (x &amp; <span class="number">1</span>)));</span><br><span class="line">  sum = sum + (flag_2 &amp; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  sum = sum + (x &amp; <span class="number">1</span>);  <span class="comment">//如果x是0  或者处理之后的Tmin  剩余位全是0    不加最后一个比特位   其他情况加上1</span></span><br><span class="line"></span><br><span class="line">  sum = sum + (!flag_Tmin &amp; <span class="number">1</span>);   <span class="comment">//非Tmin  加上符号位    0符号位就是0  一个bit表示</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="floatScale2"><a href="#floatScale2" class="headerlink" title="floatScale2"></a>floatScale2</h2><ul>
<li><p>题目要求：无符号数保存的float值，返回乘2</p>
</li>
<li><p>允许操作：<code>所有的int，无符号操作符，if，while</code></p>
</li>
<li><p>操作数量：30</p>
</li>
<li><p>分值：4</p>
</li>
</ul>
<p>思路：</p>
<ol>
<li><p>0返回0</p>
</li>
<li><p>exp全1： 为无穷 直接返回</p>
</li>
<li><p>exp全0： <code>非规格化值：小数部分没有隐藏位</code></p>
<blockquote>
<p>f不是全0 直接加左移一位 最后补上符号。<code>非规格化到规格化的过渡</code><br>f是全0 不做处理 返回原值 ，就是第一种情况</p>
</blockquote>
</li>
<li><p>exp 不全1全0 直接加1 相当于乘2</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="title function_">floatScale2</span><span class="params">(<span class="type">unsigned</span> uf)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> bit_exp;</span><br><span class="line">  <span class="type">unsigned</span> bit_f;  <span class="comment">//小数部分</span></span><br><span class="line">  <span class="type">unsigned</span> flag_s;  <span class="comment">//符号位</span></span><br><span class="line">  <span class="keyword">if</span>(uf == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bit_f = uf &amp; (<span class="number">0x007fffff</span>);</span><br><span class="line">  bit_exp = uf &amp; (<span class="number">0x7f800000</span>);   <span class="comment">//取出指数部分</span></span><br><span class="line">  flag_s = uf &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  <span class="keyword">if</span>(bit_exp == <span class="number">0x7f800000</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> uf;</span><br><span class="line">  &#125;</span><br><span class="line">  bit_exp = bit_exp &gt;&gt; <span class="number">23</span>;       <span class="comment">//exp的值</span></span><br><span class="line">  <span class="keyword">if</span>(bit_exp != <span class="number">0</span>)&#123;</span><br><span class="line">    bit_exp = bit_exp + <span class="number">1</span>;</span><br><span class="line">    bit_exp = bit_exp &lt;&lt; <span class="number">23</span>;</span><br><span class="line">    uf = uf &amp; ~(<span class="number">0x7f800000</span>);</span><br><span class="line">    uf = uf ^ bit_exp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(bit_exp == <span class="number">0</span> &amp;&amp; bit_f != <span class="number">0</span>)&#123;</span><br><span class="line">      uf = uf &lt;&lt; <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(flag_s == <span class="number">1</span>)&#123;</span><br><span class="line">        uf = uf | (flag_s &lt;&lt; <span class="number">31</span>);  <span class="comment">//补上符号位</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> uf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="floatFloat2Int"><a href="#floatFloat2Int" class="headerlink" title="floatFloat2Int"></a>floatFloat2Int</h2><ul>
<li><p>题目要求：float转int值</p>
</li>
<li><p>允许操作：<code>所有的int，无符号操作符，if，while</code></p>
</li>
<li><p>操作数量：30</p>
</li>
<li><p>分值：4</p>
</li>
</ul>
<p>思路：<code>确定指数的范围</code></p>
<ol>
<li><p>exp &lt; 127 指数小于0时，是小数，返回0。</p>
</li>
<li><p>exp &gt; 158 指数大于31 越界</p>
</li>
<li><p>exp 全0 返回0</p>
</li>
<li><p>exp 全1 返回0x80000000u</p>
</li>
<li><p>exp 其他情况下 对f部分补上隐藏位1 再右移exp-127位，最后补上符号位</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">floatFloat2Int</span><span class="params">(<span class="type">unsigned</span> uf)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> bit_exp;</span><br><span class="line">  <span class="type">unsigned</span> bit_f;  <span class="comment">//小数部分</span></span><br><span class="line">  <span class="type">unsigned</span> flag_s;  <span class="comment">//符号位</span></span><br><span class="line">  <span class="type">unsigned</span> E;      <span class="comment">//指数</span></span><br><span class="line">  <span class="type">int</span> F2Int;</span><br><span class="line">  bit_f = uf &amp; (<span class="number">0x007fffff</span>);   <span class="comment">//取出小数部分</span></span><br><span class="line">  bit_f = bit_f | (<span class="number">0x00800000</span>);  <span class="comment">//补上前面隐藏1</span></span><br><span class="line">  bit_exp = uf &amp; (<span class="number">0x7f800000</span>);   <span class="comment">//取出指数部分</span></span><br><span class="line">  bit_exp = bit_exp &gt;&gt; <span class="number">23</span>;</span><br><span class="line">  flag_s = uf &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  <span class="comment">//printf(&quot;s %u %x  exp  %u %x   f  %u  %x\n&quot;, flag_s, flag_s, bit_exp, bit_exp, bit_f, bit_f);</span></span><br><span class="line">  <span class="keyword">if</span>(bit_exp == <span class="number">0xff</span> || bit_exp &gt; <span class="number">158</span>)&#123;  <span class="comment">//无穷   或者NaN   指数越界  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x80000000</span>u;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(bit_exp &lt; <span class="number">127</span> || bit_exp  == <span class="number">0</span>)&#123;  <span class="comment">//指数是负数   非规格数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;   </span><br><span class="line">  E = bit_exp - <span class="number">127</span>;</span><br><span class="line">  bit_f = bit_f &gt;&gt; (<span class="number">23</span> - E);  <span class="comment">//右移</span></span><br><span class="line">  <span class="comment">//printf(&quot;E %u %x  bit_f   %u %x \n&quot;, E, E, bit_f, bit_f);</span></span><br><span class="line">  F2Int = bit_f;   </span><br><span class="line">  <span class="keyword">if</span>(flag_s == <span class="number">1</span>)&#123;</span><br><span class="line">    F2Int = -F2Int;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> F2Int;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="floatPower2"><a href="#floatPower2" class="headerlink" title="floatPower2"></a>floatPower2</h2><ul>
<li><p>题目要求：返回float值 2的x次方，x为32位int</p>
</li>
<li><p>允许操作：<code>所有的int，无符号操作符，if，while</code></p>
</li>
<li><p>操作数量：30</p>
</li>
<li><p>分值：4</p>
</li>
</ul>
<p>思路：<code>确定指数的范围</code> x为-127到128之间。</p>
<p>时间超时 10s内跑不完所有测试数据 可能是电脑问题</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="title function_">floatPower2</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> bit_exp;</span><br><span class="line">  <span class="type">unsigned</span> bit_float;  <span class="comment">//float值的bit位</span></span><br><span class="line">  <span class="type">unsigned</span> INF = <span class="number">0x7f800000</span>;</span><br><span class="line">  <span class="keyword">if</span>(x &lt; <span class="number">-127</span>)&#123;  <span class="comment">//值太小</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;   </span><br><span class="line">  <span class="keyword">if</span>(x &gt; <span class="number">128</span>)&#123;  <span class="comment">//太大  返回+INF</span></span><br><span class="line">    <span class="keyword">return</span> INF;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//printf(&quot;x    %d\n&quot;, x);</span></span><br><span class="line">  bit_exp = x + <span class="number">127</span>;</span><br><span class="line">  bit_exp = bit_exp &lt;&lt; <span class="number">23</span>;</span><br><span class="line">  <span class="comment">//printf(&quot;bit_float  %u  %x\n&quot;, bit_float, bit_float);</span></span><br><span class="line">  <span class="keyword">return</span> bit_exp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
      </tags>
  </entry>
  <entry>
    <title>git笔记</title>
    <url>/2023/03/08/14-59-55/</url>
    <content><![CDATA[<h1 id="克隆项目到当前文件夹"><a href="#克隆项目到当前文件夹" class="headerlink" title="克隆项目到当前文件夹"></a>克隆项目到当前文件夹</h1><ul>
<li><p>git clone https:// .</p>
</li>
<li><p>注意 .</p>
</li>
</ul>
<h1 id="文件夹初始化为仓库上传"><a href="#文件夹初始化为仓库上传" class="headerlink" title="文件夹初始化为仓库上传"></a>文件夹初始化为仓库上传</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 1. 在当前目录初始化一个新的Git仓库</span><br><span class="line">git init</span><br><span class="line"> </span><br><span class="line"># 2. 添加所有文件到暂存区</span><br><span class="line">git add .</span><br><span class="line"> </span><br><span class="line"># 3. 提交暂存区的内容到本地仓库</span><br><span class="line">git commit -m &quot;Initial commit&quot;</span><br><span class="line"></span><br><span class="line"># 4. 添加远程仓库地址（以GitHub为例，替换成你的远程仓库URL）</span><br><span class="line">git remote add origin https://github.com/username/repository.git</span><br><span class="line"> </span><br><span class="line"># 5. 推送代码到远程仓库，同时设置远程仓库的主分支</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：如果使用https链接上传，需要令牌密码，使用ssh连接上传，只需要本地的ssh密码</p>
</blockquote>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>算法模板</title>
    <url>/2023/03/08/14-45-11/</url>
    <content><![CDATA[<h1 id="特殊函数"><a href="#特殊函数" class="headerlink" title="特殊函数"></a>特殊函数</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//万能头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span> </span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="built_in">sort</span>(a,a+n,<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;());<span class="comment">//内置类型的由小到大排序</span></span><br><span class="line"><span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line"><span class="comment">//作用相当于 bool cmd();</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line">  string s;</span><br><span class="line">  s = <span class="built_in">bitset</span>&lt;<span class="number">8</span>&gt;(a[i]).<span class="built_in">to_string</span>();     <span class="comment">//  转换字符串</span></span><br><span class="line">  <span class="built_in">to_ulong</span>()    <span class="comment">// 转换为unsigned long类型</span></span><br><span class="line">  <span class="built_in">to_ullong</span>();　<span class="comment">// 转换成unsigned long long类型</span></span><br><span class="line">  <span class="built_in">set</span>(x, v);    <span class="comment">// 没有参数时 将全部位设为1</span></span><br><span class="line">                <span class="comment">// 有一个x， 将x下标处设为1</span></span><br><span class="line">                <span class="comment">// 两个参数，将x处设为v值</span></span><br><span class="line">  <span class="built_in">reset</span>(x);    <span class="comment">// 置0   无参全部置，有参置下标</span></span><br><span class="line">  <span class="built_in">flip</span>(x);     <span class="comment">// 取反，无参全部取，有参取下标处</span></span><br><span class="line">  <span class="built_in">text</span>(x);     <span class="comment">// 检测下标处是不是1 返回true 0返回false</span></span><br><span class="line">  <span class="built_in">any</span>();       <span class="comment">// 检查是否有1</span></span><br><span class="line">  <span class="built_in">none</span>();      <span class="comment">// 检查是否没有1</span></span><br><span class="line">  <span class="built_in">all</span>();       <span class="comment">// 检查是否全为1</span></span><br><span class="line">  <span class="built_in">count</span>();     <span class="comment">// 求1的个数</span></span><br><span class="line">  <span class="built_in">size</span>();      <span class="comment">// 求位数</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="built_in">typeid</span>(x).<span class="built_in">name</span>();   <span class="comment">// 获取x的类型</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输出重定向</span></span><br><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"><span class="comment">//控制台输入数据，如何输入文件结束标志</span></span><br><span class="line"><span class="comment">//**在Windows下，输入完毕后先按Enter键，再按Ctrl＋Z键，最后再按Enter键</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加快输入速度的两种方法</span></span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);   cin &gt;&gt; x;</span><br><span class="line"><span class="built_in">scanf</span>()；</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类型转换</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line">ss.<span class="built_in">clear</span>();  <span class="comment">// 清空</span></span><br><span class="line">ss &lt;&lt; s;</span><br><span class="line">ss &gt;&gt; a;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="built_in">isdigit</span>(s[i]);  <span class="comment">// 若参数c为阿拉伯数字0~9 字符，则返回非0值，否则返回0。</span></span><br><span class="line"><span class="type">int</span> n = <span class="built_in">stoi</span>(s);   <span class="comment">//  把s转化为int型 </span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line">cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>);   <span class="comment">// 设置位数</span></span><br><span class="line"><span class="built_in">setprecision</span>(n)     <span class="comment">//设置显示小数精度为n位</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">stefill</span>(c);  <span class="comment">// 设置填充字符</span></span><br><span class="line"><span class="built_in">setiosflags</span>(ios::scientific)   <span class="comment">//指数表示</span></span><br><span class="line"><span class="built_in">setiosflags</span>(ios::left)     <span class="comment">//左对齐</span></span><br><span class="line"><span class="built_in">setiosflags</span>(ios::right)    <span class="comment">//右对齐</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">include &lt;string&gt;</span><br><span class="line"><span class="built_in">substr</span>(<span class="type">int</span> index, <span class="type">int</span> mum); <span class="comment">// 返回一个子字符串 </span></span><br><span class="line"><span class="comment">//std::string::npos是一个常数，它等于size_type类型可以表示的最大值</span></span><br><span class="line"><span class="comment">//用在 s.find()  返回值</span></span><br></pre></td></tr></table></figure>
<h1 id="算法模板"><a href="#算法模板" class="headerlink" title="算法模板"></a>算法模板</h1><h2 id><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法比赛</tag>
        <tag>c++</tag>
        <tag>算法模板</tag>
      </tags>
  </entry>
  <entry>
    <title>macOS使用ssh登陆WSL2的ubuntu</title>
    <url>/2023/03/07/14-58-00/</url>
    <content><![CDATA[<h1 id="ssh-登录wsl-ubuntu"><a href="#ssh-登录wsl-ubuntu" class="headerlink" title="ssh 登录wsl ubuntu"></a>ssh 登录wsl ubuntu</h1><h2 id="固定wsl2的ip地址"><a href="#固定wsl2的ip地址" class="headerlink" title="固定wsl2的ip地址"></a>固定wsl2的ip地址</h2><p>wsl2的ip地址每次都会改变，所以一直要重新设置防火墙端口，通过脚本，每次管理员运行脚本固定ip，就不需要重复设置防火墙端口。</p>
<ul>
<li>优化之后固定wsl2 IP:192.168.120.181,运行脚本,转发端口,设置防火墙,自动命令</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@echo off</span><br><span class="line">setlocal enabledelayedexpansion</span><br><span class="line"></span><br><span class="line">::先停掉wsl实例</span><br><span class="line">wsl --shutdown</span><br><span class="line">::重新拉起，启动ssh服务</span><br><span class="line">wsl -u root -d Ubuntu-20.04 service ssh start</span><br><span class="line">:: 固定IP</span><br><span class="line">wsl -u root ip addr | findstr &quot;192.168.120.181&quot; &gt; nul</span><br><span class="line">if !errorlevel! equ 0 (</span><br><span class="line">   echo wsl ip has set</span><br><span class="line">) else (</span><br><span class="line">   wsl -u root ip addr add 192.168.120.181/24 broadcast 192.168.120.0 dev eth0 label eth0:1</span><br><span class="line">   echo set wsl ip success: 192.168.120.181</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">::windows作为wsl的宿主，在wsl的固定IP的同一网段也给安排另外一个IP</span><br><span class="line">ipconfig | findstr &quot;192.168.120.100&quot; &gt; nul</span><br><span class="line">if !errorlevel! equ 0 (</span><br><span class="line">    echo windows ip has set</span><br><span class="line">) else (</span><br><span class="line">    netsh interface ip add address &quot;vEthernet (WSL)&quot; 192.168.120.100 255.255.255.0</span><br><span class="line">    echo set windows ip success: 192.168.120.100</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">::windows的2222端口转发到ubuntu</span><br><span class="line">netsh interface portproxy add v4tov4 listenaddress=0.0.0.0 listenport=2222 connectaddress=192.168.120.181 connectport=2222</span><br><span class="line">::防火墙开启入站规则</span><br><span class="line">::netsh advfirewall firewall add rule name=WSL2 dir=in action=allow protocol=TCP localport=2222</span><br><span class="line"></span><br><span class="line">pause</span><br></pre></td></tr></table></figure>
<ul>
<li><p>管理员模式运行脚本后直接连接</p>
</li>
<li><p>连接 ip为<code>windows的地址</code></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh name@ip -p2222</span><br></pre></td></tr></table></figure>
<h2 id="ssh服务器命令"><a href="#ssh服务器命令" class="headerlink" title="ssh服务器命令"></a>ssh服务器命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo service ssh restart</span><br><span class="line">sudo service ssh start</span><br><span class="line">sudo service ssh stop</span><br><span class="line">sudo service ssh status</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="wsl命令"><a href="#wsl命令" class="headerlink" title="wsl命令"></a>wsl命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wsl -- hostname -I    #显示wsl的ip</span><br><span class="line">wsl -l -v             #列出当前linux版本状态</span><br><span class="line">wsl --shutdown        #关闭linux</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>ssh</tag>
        <tag>ubuntu</tag>
        <tag>wsl2</tag>
        <tag>mac</tag>
      </tags>
  </entry>
</search>
