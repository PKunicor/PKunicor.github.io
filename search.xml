<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>csapp 笔记汇总</title>
    <url>/2023/03/15/10-59-10/</url>
    <content><![CDATA[<h1 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h1><h2 id="CMU-15-213笔记"><a href="#CMU-15-213笔记" class="headerlink" title="CMU 15-213笔记"></a>CMU 15-213笔记</h2><ul>
<li><a href="/2023/05/24/13-04-09/" title="CSAPP 笔记三 程序的机器级表示">第三章 - 程序的机器级表示</a></li>
<li><a href="/2023/07/06/14-25-42/" title="CSAPP 笔记五 优化程序性能">第五章 - 优化程序性能</a></li>
<li><a href="/2023/07/23/09-27-18/" title="CSAPP 笔记六 存储器层次结构">第六章 - 存储器层次结构</a></li>
</ul>
<h2 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h2><p><a href="https://github.com/PKunicor/CsappLab">PKunicor&#x2F;Csapp lab</a></p>
<h2 id="实验笔记"><a href="#实验笔记" class="headerlink" title="实验笔记"></a>实验笔记</h2><ul>
<li><a href="/2023/03/09/11-54-50/" title="CSAPP 实验I Data Lab">I Data Lab - 位操作，数据表示</a></li>
<li><a href="/2023/03/14/09-43-26/" title="CSAPP 实验II Bomb Lab">II Bomb Lab - 汇编，栈帧与 gdb</a></li>
<li><a href="/2023/03/18/15-54-47/" title="CSAPP 实验III Attack Lab">III Attack Lab - 漏洞是如何被攻击的</a></li>
<li><a href="/2024/03/09/16-34-34/" title="CSAPP 实验IV CacheLab">IV Cache Lab - 实现一个缓存系统</a></li>
<li><a href="/2024/03/14/12-34-42/" title="CSAPP实验VShellLab">V Shell Lab - 实现一个Shell</a></li>
</ul>
<h1 id="实验指南"><a href="#实验指南" class="headerlink" title="实验指南"></a>实验指南</h1><ul>
<li><p><a href="https://www.bilibili.com/video/BV1iW411d7hd/?spm_id_from=333.788.top_right_bar_window_custom_collection.content.click&vd_source=d5a3522259c17126f1b623c977d04c3e">B站CS15-213翻译课程</a> </p>
</li>
<li><p><a href="https://scs.hosted.panopto.com/Panopto/Pages/Sessions/List.aspx#folderID=%22b96d90ae-9871-4fae-91e2-b1627b43e25e%22">实验课程指导</a> <code>lab重点</code></p>
</li>
</ul>
<blockquote>
<p>做Lab非常推荐看一下官方给的Lab指导课程，课程里详细介绍了实验上手方式以及需要用到的命令。 </p>
</blockquote>
]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
      </tags>
  </entry>
  <entry>
    <title>天梯赛刷题记录</title>
    <url>/2024/04/04/12-45-10/</url>
    <content><![CDATA[<h1 id="L1-039-古风排版"><a href="#L1-039-古风排版" class="headerlink" title="L1-039. 古风排版"></a>L1-039. 古风排版</h1><p>中国的古人写文字，是从右向左竖向排版的。本题就请你编写程序，把一段文字按古风排版。</p>
<p>输入格式：</p>
<p>输入在第一行给出一个正整数N（&lt;100），是每一列的字符数。第二行给出一个长度不超过1000的非空字符串，以回车结束。</p>
<p>输出格式：</p>
<p>按古风格式排版给定的字符串，每列N个字符（除了最后一列可能不足N个）</p>
<p>输入样例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">This is a test case</span><br></pre></td></tr></table></figure>

<p>输出样例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">asa T</span><br><span class="line">st ih</span><br><span class="line">e tsi</span><br><span class="line"> ce s</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法比赛</tag>
        <tag>c++</tag>
        <tag>算法模板</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 实验V ShellLab</title>
    <url>/2024/03/14/12-34-42/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.03.14：初稿</li>
</ul>
<h1 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h1><ul>
<li><a href="/2023/03/15/10-59-10/" title="csapp 笔记汇总">CSAPP - 笔记汇总</a></li>
<li><a href="/2023/03/09/11-54-50/" title="CSAPP 实验I Data Lab">I Data Lab - 位操作，数据表示</a></li>
<li><a href="/2023/03/14/09-43-26/" title="CSAPP 实验II Bomb Lab">II Bomb Lab - 汇编，栈帧与 gdb</a></li>
<li><a href="/2023/03/18/15-54-47/" title="CSAPP 实验III Attack Lab">III Attack Lab - 漏洞是如何被攻击的</a></li>
<li><a href="/2024/03/09/16-34-34/" title="CSAPP 实验IV CacheLab">IV Cache Lab - 实现一个缓存系统</a></li>
<li><a href="/2024/03/14/12-34-42/" title="CSAPP 实验V ShellLab">V Shell Lab - 实现一个Shell</a></li>
</ul>
<h1 id="任务目标"><a href="#任务目标" class="headerlink" title="任务目标"></a>任务目标</h1><p>ShellLab实验，理解程序控制和信号，完成一个简单Shell。</p>
<h1 id="相关内容"><a href="#相关内容" class="headerlink" title="相关内容"></a>相关内容</h1><ul>
<li><p><code>tsh&gt; /bin/ls -l -d</code>，<code>&amp;</code>后台运行</p>
</li>
<li><p><code>int main(int argc, char *argv[])</code></p>
<ul>
<li><p><code>argc</code>：参数个数  <code>argv[]</code>：从左往右的参数</p>
</li>
<li><p><code>ctrl-c</code> SIGINT终止信号，<code>ctrl-z</code>SIGTSTP停止信号，SIGCONT继续信号</p>
</li>
<li><p><code>jobs</code>：列出所有作业</p>
</li>
<li><p><code>bg &lt;job&gt;</code>：后台暂停的作业开始运行</p>
</li>
<li><p><code>fg &lt;job&gt;</code>：前台暂停的作业开始运行</p>
</li>
<li><p><code>kill &lt;job&gt;</code>：杀死作业</p>
</li>
</ul>
</li>
<li><p><strong>tsh</strong>的规格</p>
<ul>
<li><p>提示符为<code>tsh&gt; </code></p>
</li>
<li><p>输入命令为<code>name arguments</code>：如果name是内置命令，直接执行，否则视为可执行文件路径，并调用初始子进程运行</p>
</li>
<li><p>不需要支持<code>|</code>和<code>&lt;</code>，<code>&gt;</code></p>
</li>
<li><p>信号需要传递到所有子进程</p>
</li>
<li><p>命令末尾带<code>&amp;</code>，后台运行</p>
</li>
<li><p>进程PID<code>%5</code>，作业JID<code>5</code></p>
</li>
<li><p>需要支持内置命令<code>quit</code>，<code>jobs</code>，<code>bg &lt;job&gt;</code>，<code>fg &lt;job&gt;</code></p>
</li>
<li><p>如果僵尸进程没有收到信号就终止了，需要打印出异常信息</p>
</li>
</ul>
</li>
<li><p>检查作业</p>
<ul>
<li><p><code>tshref</code>：样例tsh，可以对比自己的shell</p>
</li>
<li><p><code>sdriver.pl</code>：打印输入的shell命令和输出信息<br> <code>./sdriver.pl -t trace01.txt -s ./tsh -a &quot;-p&quot;</code>：<code>-t</code>追踪文件，<code>-s</code>指定shell，<code>-a &quot;-p&quot;</code>不输出提示符</p>
</li>
<li><p>也可以使用<code>make test01</code>测试自己的shell，<code>make rtest01</code>测试样例shell</p>
</li>
<li><p><code>trace01.txt</code>序号从01-16，越小测试越简单</p>
</li>
<li><p><code>tshref.out</code>所有的输出信息以供参考</p>
</li>
</ul>
</li>
<li><p>提示</p>
<ul>
<li><p>根据追踪文件来设计shell，依次从简单开始，按照输出完成设计</p>
</li>
<li><p>要检测出<code>kill -pid</code>的错误</p>
</li>
<li><p>多使用下列函数</p>
<ul>
<li><p><code>pid_t waitpid (pid_t pid, int* statusp, int options)</code>：</p>
<blockquote>
<p>成功时返回子进程的PID，  </p>
<p>options &#x3D; WNOHANG时立即返回0     表示没有任何子进程终止</p>
<p>options &#x3D; WUNTRACED时，接收到SIGSTOP信号，终止或暂停。</p>
<p>如果发生其他错误返回-1。</p>
</blockquote>
</li>
<li><p><code>kill </code>:<code>kill -s &lt;信号&gt;</code></p>
<blockquote>
<p>用指定信号形式终止进程，可以杀死可以暂停</p>
<p>-s，会将s的进程组全部执行</p>
</blockquote>
</li>
<li><p><code>int fork(void)</code>:</p>
<blockquote>
<p>创建一个子进程，子进程返回0，父进程返回子进程的ID，调用一次返回两次，先返回子进程，再返回父进程</p>
</blockquote>
</li>
<li><p><code>int execve(const char *filename, char *const argv[], char *const envp[]);</code>: </p>
<blockquote>
<p>参数为新程序的路径名称，命令行参数数组，环境变量参数数组</p>
<p>替换进程的状态和上下文，切换另一个进程</p>
<p>执行成功不会返回到调用，错误返回-1</p>
</blockquote>
</li>
<li><p><code>int setpgid(pid_t pid, pid_t pgid)</code>:</p>
<blockquote>
<p>给pid进程设置为pgid进程组识别码，如果pid为0设置当前进程，pgid为0，用当前组识别码取代，返回为组识别码，-1错误</p>
</blockquote>
</li>
<li><p><code>sigprocmash</code>:</p>
<blockquote>
<p>int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);<br>参数：<br>how：用于指定信号修改的方式，可能选择有三种：<br>SIG_BLOCK &#x2F;&#x2F;加入信号到进程屏蔽。<br>SIG_UNBLOCK &#x2F;&#x2F;从进程屏蔽里将信号删除。<br>SIG_SETMASK &#x2F;&#x2F;将set的值设定为新的进程屏蔽。</p>
<p>set：为指向信号集的指针，在此专指新设的信号集，如果仅想读取现在的屏蔽值，可将其置为NULL。<br>oldset：也是指向信号集的指针，在此存放原来的信号集。<br>返回说明：<br>成功执行时，返回0。失败返回-1，errno被设为EINVAL。</p>
</blockquote>
</li>
<li><p><code>exit(int status)</code>：</p>
<blockquote>
<p>终止进程，正常返回状态0</p>
</blockquote>
</li>
<li><p>尽量不要在自己的shell中使用more, less, vi, emacs，多使用&#x2F;bin&#x2F;ls,&#x2F;bin&#x2F;ps, &#x2F;bin&#x2F;echo</p>
</li>
<li><p>如果在Unix shell中像自己的shell输入 ctrl-c：fork之后执行之前，子进程先调用<code>setpgid(0, 0)</code>，放入一个新的进程组，保证Unix shell的进程组中只有shell。不会把命令传递给所有Unix shell的进程组，只传递给shell。</p>
</li>
<li><p>建议在<code>waitfg</code>的循环中用<code>sleep</code>函数，在<code>sigchld_handler</code>中调用<code>waitpid</code></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>常用信号量</p>
<img src="/2024/03/14/12-34-42/QQ20240314-160705@2x.png" class="">

<img src="/2024/03/14/12-34-42/QQ20240314-154949@2x.png" class=""></li>
</ul>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h2><p>trace01-03比较简单，用课本中代码写入就可以，修改一下fork和execve封装。</p>
<h2 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h2><h3 id="trace04"><a href="#trace04" class="headerlink" title="trace04"></a>trace04</h3><p>根据标准输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./sdriver.pl -t trace04.txt -s ./tsh -a &quot;-p&quot;</span><br><span class="line">#</span><br><span class="line"># trace04.txt - Run a background job.</span><br><span class="line">#</span><br><span class="line">tsh&gt; ./myspin 1 &amp;</span><br><span class="line">[1] (26252) ./myspin 1 &amp;</span><br></pre></td></tr></table></figure>

<p>在主函数执行中增加添加作业函数<code>addjob</code>，修改一下原来的输出格式，<code>printf(&quot;[%d] (%d)  %s&quot;, pid2jid(pid), pid, cmdline);</code>。</p>
<p>问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tsh&gt; ./myspin 1 &amp;</span><br><span class="line">[2] (920)  ./myspin 1 &amp;</span><br></pre></td></tr></table></figure>

<p>作业从[2]标号开始，可能是重复添加作业了。查看输出后，发现echo函数添加作业后，运行结束时没有删除作业，导致作业号多一个。</p>
<p>解决办法：</p>
<p>在waitpid之后，增加一个删除作业函数<code>deletejob</code></p>
<h2 id="trace05"><a href="#trace05" class="headerlink" title="trace05"></a>trace05</h2><p>增加打印jobs列表</p>
<h3 id="trace06"><a href="#trace06" class="headerlink" title="trace06"></a>trace06</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line"># trace06.txt - Forward SIGINT to foreground job.</span><br><span class="line">#</span><br><span class="line">/bin/echo -e tsh&gt; ./myspin 4</span><br><span class="line">./myspin 4 </span><br><span class="line"></span><br><span class="line">SLEEP 2</span><br><span class="line">INT</span><br></pre></td></tr></table></figure>

<blockquote>
<p>SLEEP命令不是输入进去的字符串，主要是获取作业的终止状态</p>
</blockquote>
<p>相关内容</p>
<ul>
<li><p>waitpid返回状态status</p>
<ul>
<li><p>WIFEXITED(status)：非0正常结束，退出状态WEXITSTATUS(status)</p>
</li>
<li><p>WIFSIGNALED(status)：非0异常终止，退出的信号编号WTERMSIG(status)</p>
</li>
<li><p>WIFSTOPPED(status)：非0暂停状态，暂停的信号编号WSTOPSIG(status)</p>
</li>
<li><p>WIFCONTINUED(status)：非0 暂停后以继续运行</p>
</li>
</ul>
</li>
<li><p>options变量</p>
<ul>
<li><p><code>WNOHANG</code>：没有子进程终止时立即返回，而不会阻塞。</p>
</li>
<li><p><code>WUNTRACED</code>：挂起，返回终止或暂停的进程pid</p>
</li>
<li><p><code>WCONTINUED</code>：挂起，返回一个正在运行的进程终止，或一个暂停的收到SIGCONT信号继续执行。</p>
</li>
</ul>
</li>
<li><p>信号量相关</p>
<ul>
<li><p><code>sigfillset(&amp;mask_all);</code>返回当前进程的信号阻塞集合</p>
</li>
<li><p><code>sigemptyset(&amp;mask_one);</code>初试空值</p>
</li>
<li><p><code>sigaddset(&amp;mask_one, SIGCHLD);</code>，添加一位阻塞位</p>
</li>
<li><p><code>sigprocmask(int how, sigset_t *set, sigset_t *oldset)</code></p>
<blockquote>
<p>how: <code>SIG_SETMASK</code>赋值  </p>
<p>          <code>SIG_BLOCK</code>阻塞 做或运算   与原来的集合</p>
<p>          <code>SIG_UNBLOCK</code> 解除  做与运算</p>
<p>set，操作集合</p>
<p>oldset，保存原集合，可以为NULL</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>对add函数和del函数阻塞信号。</p>
<p>检测INT键，绑定响应函数，用kill杀死进程，系统发出<code>SIGCHLD</code>信号，在<code>SIGCHLD</code>响应函数中删除作业。</p>
<h3 id="trace07"><a href="#trace07" class="headerlink" title="trace07"></a>trace07</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line"># trace07.txt - Forward SIGINT only to foreground job.</span><br><span class="line">#</span><br><span class="line">/bin/echo -e tsh&gt; ./myspin 4 \046</span><br><span class="line">./myspin 4 &amp;</span><br><span class="line"></span><br><span class="line">/bin/echo -e tsh&gt; ./myspin 5</span><br><span class="line">./myspin 5 </span><br><span class="line"></span><br><span class="line">SLEEP 2</span><br><span class="line">INT</span><br><span class="line"></span><br><span class="line">/bin/echo tsh&gt; jobs</span><br><span class="line">jobs</span><br></pre></td></tr></table></figure>

<p>06已经做完了，输出完整。</p>
<h3 id="trace08"><a href="#trace08" class="headerlink" title="trace08"></a>trace08</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/bin/echo -e tsh&gt; ./myspin 4 \046</span><br><span class="line">./myspin 4 &amp;</span><br><span class="line"></span><br><span class="line">/bin/echo -e tsh&gt; ./myspin 5</span><br><span class="line">./myspin 5 </span><br><span class="line"></span><br><span class="line">SLEEP 2</span><br><span class="line">TSTP</span><br><span class="line"></span><br><span class="line">/bin/echo tsh&gt; jobs</span><br><span class="line">jobs</span><br></pre></td></tr></table></figure>

<p>完成前台进程暂停信号响应。kill函数可以暂停进程。</p>
<p>代码可以正常暂停，但是暂停之后不会终止，无法退出。</p>
<p>解决：</p>
<p>用kill(-pid,sig);函数对进程组整体操作。</p>
<h3 id="trace09"><a href="#trace09" class="headerlink" title="trace09"></a>trace09</h3><p>问题：</p>
<p>需要完成bg内置命令，暂停程序后台运行。</p>
<blockquote>
<p>不太清楚中间一次输出信息，为什么不需要换行。</p>
</blockquote>
<h3 id="trace10"><a href="#trace10" class="headerlink" title="trace10"></a>trace10</h3><p>完成fg内置命令</p>
<h3 id="trace11-13"><a href="#trace11-13" class="headerlink" title="trace11-13"></a>trace11-13</h3><img src="/2024/03/14/12-34-42/QQ20240316-185955@2x.png" class="">

<p>输出信息与样例shell相同，但和答案不同。</p>
<h3 id="trace14"><a href="#trace14" class="headerlink" title="trace14"></a>trace14</h3><p>问题：</p>
<p>简单的错误处理，处理输入输出格式错误。</p>
<h3 id="trace15-16"><a href="#trace15-16" class="headerlink" title="trace15-16"></a>trace15-16</h3><p>运行结果都对</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>不处理行数问题了，没有评分程序。只有所有例子都输出相同，不太确定是不是都是正确的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * tsh - A tiny shell program with job control</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;Put your name and login ID here&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Misc manifest constants */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 1024   <span class="comment">/* max line size */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXARGS 128    <span class="comment">/* max args on a command line */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXJOBS 16     <span class="comment">/* max jobs at any point in time */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXJID 1 &lt;&lt; 16 <span class="comment">/* max job ID */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Job states */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNDEF 0 <span class="comment">/* undefined */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FG 1    <span class="comment">/* running in foreground */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BG 2    <span class="comment">/* running in background */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ST 3    <span class="comment">/* stopped */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Jobs states: FG (foreground), BG (background), ST (stopped)</span></span><br><span class="line"><span class="comment"> * Job state transitions and enabling actions:</span></span><br><span class="line"><span class="comment"> *     FG -&gt; ST  : ctrl-z</span></span><br><span class="line"><span class="comment"> *     ST -&gt; FG  : fg command</span></span><br><span class="line"><span class="comment"> *     ST -&gt; BG  : bg command</span></span><br><span class="line"><span class="comment"> *     BG -&gt; FG  : fg command</span></span><br><span class="line"><span class="comment"> * At most 1 job can be in the FG state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Global variables */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ;   <span class="comment">/* defined in libc */</span></span><br><span class="line"><span class="type">char</span> prompt[] = <span class="string">&quot;tsh&gt; &quot;</span>; <span class="comment">/* command line prompt (DO NOT CHANGE) */</span></span><br><span class="line"><span class="type">int</span> verbose = <span class="number">0</span>;         <span class="comment">/* if true, print additional output */</span></span><br><span class="line"><span class="type">int</span> nextjid = <span class="number">1</span>;         <span class="comment">/* next job ID to allocate */</span></span><br><span class="line"><span class="type">char</span> sbuf[MAXLINE];      <span class="comment">/* for composing sprintf messages */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> &#123;</span>           <span class="comment">/* The job struct */</span></span><br><span class="line">  <span class="type">pid_t</span> pid;             <span class="comment">/* job PID */</span></span><br><span class="line">  <span class="type">int</span> jid;               <span class="comment">/* job ID [1, 2, ...] */</span></span><br><span class="line">  <span class="type">int</span> state;             <span class="comment">/* UNDEF, BG, FG, or ST */</span></span><br><span class="line">  <span class="type">char</span> cmdline[MAXLINE]; <span class="comment">/* command line */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> <span class="title">jobs</span>[<span class="title">MAXJOBS</span>];</span> <span class="comment">/* The job list */</span></span><br><span class="line"><span class="comment">/* End global variables */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Function prototypes */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//补充函数</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">Fork</span><span class="params">(<span class="type">void</span>)</span>;                                                              <span class="comment">//封装fork</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> environ[])</span>;  <span class="comment">//封装execv函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Here are the functions that you will implement */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">eval</span><span class="params">(<span class="type">char</span> *cmdline)</span>;  <span class="comment">//分析命令</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">builtin_cmd</span><span class="params">(<span class="type">char</span> **argv)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">do_bgfg</span><span class="params">(<span class="type">char</span> **argv)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">waitfg</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigchld_handler</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sigtstp_handler</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sigint_handler</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Here are helper routines that we&#x27;ve provided for you */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">parseline</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cmdline, <span class="type">char</span> **argv)</span>;  <span class="comment">//返回bg标志  1 后台</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigquit_handler</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">clearjob</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *job)</span>;                                     <span class="comment">//清除队列中的一个作业</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initjobs</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs)</span>;                                    <span class="comment">//初始化</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxjid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs)</span>;                                       <span class="comment">//返回以分配的最大作业号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">addjob</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs, <span class="type">pid_t</span> pid, <span class="type">int</span> state, <span class="type">char</span> *cmdline)</span>;  <span class="comment">//添加一个作业  返回1  满了返回0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deletejob</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs, <span class="type">pid_t</span> pid)</span>;                         <span class="comment">//删除队列中一个作业   成功返回1</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fgpid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs)</span>;                                      <span class="comment">//返回一个前台运行的作业号    没有返回0</span></span><br><span class="line"><span class="keyword">struct</span> <span class="type">job_t</span> *<span class="title function_">getjobpid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs, <span class="type">pid_t</span> pid)</span>;               <span class="comment">//使用pid查找一个作业  没找到 返回空</span></span><br><span class="line"><span class="keyword">struct</span> <span class="type">job_t</span> *<span class="title function_">getjobjid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs, <span class="type">int</span> jid)</span>;                 <span class="comment">//用jid查找一个作业</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pid2jid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;                                               <span class="comment">// 用pid 返回 jid,  没找到返回0</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">listjobs</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs)</span>;                                    <span class="comment">//打印作业队列</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">usage</span><span class="params">(<span class="type">void</span>)</span>;                                   <span class="comment">//打印帮助菜单</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">unix_error</span><span class="params">(<span class="type">char</span> *msg)</span>;                         <span class="comment">// unix风格打印错误信息</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">app_error</span><span class="params">(<span class="type">char</span> *msg)</span>;                          <span class="comment">// app风格的错误信息</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> <span class="title function_">handler_t</span><span class="params">(<span class="type">int</span>)</span>;                        <span class="comment">//一个int参数,无返回</span></span><br><span class="line"><span class="type">handler_t</span> *<span class="title function_">Signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">handler_t</span> *handler)</span>;  <span class="comment">//信号包装器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * main - The shell&#x27;s main routine</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">  <span class="type">char</span> cmdline[MAXLINE];</span><br><span class="line">  <span class="type">int</span> emit_prompt = <span class="number">1</span>; <span class="comment">/* emit prompt (default) */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//不用管    重定向输出</span></span><br><span class="line">  <span class="comment">/* Redirect stderr to stdout (so that driver will get all output</span></span><br><span class="line"><span class="comment">   * on the pipe connected to stdout) */</span></span><br><span class="line">  dup2(<span class="number">1</span>, <span class="number">2</span>);  <span class="comment">//把1的文件描述符 复制给2</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Parse the command line */</span></span><br><span class="line">  <span class="keyword">while</span> ((c = getopt(argc, argv, <span class="string">&quot;hvp&quot;</span>)) != EOF) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>: <span class="comment">/* print help message */</span></span><br><span class="line">        usage();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>: <span class="comment">/* emit additional diagnostic info */</span></span><br><span class="line">        verbose = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:          <span class="comment">/* don&#x27;t print a prompt */</span></span><br><span class="line">        emit_prompt = <span class="number">0</span>; <span class="comment">/* handy for automatic testing */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        usage();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Install the signal handlers */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* These are the ones you will need to implement */</span></span><br><span class="line">  Signal(SIGINT, sigint_handler);   <span class="comment">/* ctrl-c */</span></span><br><span class="line">  Signal(SIGTSTP, sigtstp_handler); <span class="comment">/* ctrl-z */</span></span><br><span class="line">  Signal(SIGCHLD, sigchld_handler); <span class="comment">/* Terminated or stopped child */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* This one provides a clean way to kill the shell */</span></span><br><span class="line">  Signal(SIGQUIT, sigquit_handler);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Initialize the job list */</span></span><br><span class="line">  initjobs(jobs);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Execute the shell&#x27;s read/eval loop */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">/* Read command line */</span></span><br><span class="line">    <span class="keyword">if</span> (emit_prompt) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, prompt);</span><br><span class="line">      fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((fgets(cmdline, MAXLINE, <span class="built_in">stdin</span>) == <span class="literal">NULL</span>) &amp;&amp; ferror(<span class="built_in">stdin</span>))</span><br><span class="line">      app_error(<span class="string">&quot;fgets error&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (feof(<span class="built_in">stdin</span>)) &#123; <span class="comment">/* End of file (ctrl-d) */</span></span><br><span class="line">      fflush(<span class="built_in">stdout</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Evaluate the command line */</span></span><br><span class="line">    eval(cmdline);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">/* control never reaches here */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * eval - Evaluate the command line that the user has just typed in</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the user has requested a built-in command (quit, jobs, bg or fg)</span></span><br><span class="line"><span class="comment"> * then execute it immediately. Otherwise, fork a child process and</span></span><br><span class="line"><span class="comment"> * run the job in the context of the child. If the job is running in</span></span><br><span class="line"><span class="comment"> * the foreground, wait for it to terminate and then return.  Note:</span></span><br><span class="line"><span class="comment"> * each child process must have a unique process group ID so that our</span></span><br><span class="line"><span class="comment"> * background children don&#x27;t receive SIGINT (SIGTSTP) from the kernel</span></span><br><span class="line"><span class="comment"> * when we type ctrl-c (ctrl-z) at the keyboard.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">eval</span><span class="params">(<span class="type">char</span> *cmdline)</span> &#123;</span><br><span class="line">  <span class="type">char</span> *argv[MAXARGS]; <span class="comment">/*Argument list execve() */</span></span><br><span class="line">  <span class="type">char</span> buf[MAXLINE];   <span class="comment">/*Holds modified command line */</span></span><br><span class="line">  <span class="type">int</span> bg;              <span class="comment">/*Should the job run in bg or fg? */</span></span><br><span class="line">  <span class="type">pid_t</span> pid;           <span class="comment">/*Process id */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">sigset_t</span> mask_all, mask_one, prev_one;</span><br><span class="line">  sigfillset(&amp;mask_all);</span><br><span class="line">  sigemptyset(&amp;mask_one);</span><br><span class="line">  sigaddset(&amp;mask_one, SIGCHLD);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(buf, cmdline);</span><br><span class="line">  bg = parseline(buf, argv);</span><br><span class="line">  <span class="keyword">if</span> (argv[<span class="number">0</span>] == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">/* Ignore empty lines */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!builtin_cmd(argv)) &#123;</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;mask_one, &amp;prev_one);   <span class="comment">//阻塞SIGCHLD</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pid = Fork()) == <span class="number">0</span>) &#123;         <span class="comment">/* Child runs user job */</span></span><br><span class="line">      setpgid(<span class="number">0</span>, <span class="number">0</span>);          <span class="comment">//单独加入一个组</span></span><br><span class="line">      sigprocmask(SIG_SETMASK, &amp;prev_one, <span class="literal">NULL</span>);  <span class="comment">//解除SIGCHLD阻塞 赋值新的mask</span></span><br><span class="line">      Execve(argv[<span class="number">0</span>], argv, environ);  <span class="comment">//执行函数不会返回   会结束运行</span></span><br><span class="line">    &#125;                                  <span class="comment">/* Parent waits for foreground job to terminate */</span></span><br><span class="line">    <span class="comment">//添加作业     FG = 0 + 1 = 1    BG = 1 + 1 = 2</span></span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;mask_all, <span class="literal">NULL</span>);   <span class="comment">//应该是重置作用</span></span><br><span class="line">    addjob(jobs, pid, bg + <span class="number">1</span>, cmdline);</span><br><span class="line">    sigprocmask(SIG_SETMASK, &amp;prev_one, <span class="literal">NULL</span>); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!bg) &#123;</span><br><span class="line">      waitfg(pid);   <span class="comment">//等待前台运行结束</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d)  %s&quot;</span>, pid2jid(pid), pid, cmdline);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * parseline - Parse the command line and build the argv array.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Characters enclosed in single quotes are treated as a single</span></span><br><span class="line"><span class="comment"> * argument.  Return true if the user has requested a BG job, false if</span></span><br><span class="line"><span class="comment"> * the user has requested a FG job.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">parseline</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cmdline, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">char</span> <span class="built_in">array</span>[MAXLINE]; <span class="comment">/* holds local copy of command line */</span></span><br><span class="line">  <span class="type">char</span> *buf = <span class="built_in">array</span>;          <span class="comment">/* ptr that traverses command line */</span></span><br><span class="line">  <span class="type">char</span> *delim;                <span class="comment">/* points to first space delimiter */</span></span><br><span class="line">  <span class="type">int</span> argc;                   <span class="comment">/* number of args */</span></span><br><span class="line">  <span class="type">int</span> bg;                     <span class="comment">/* background job? */</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(buf, cmdline);</span><br><span class="line">  buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="string">&#x27; &#x27;</span>;   <span class="comment">/* replace trailing &#x27;\n&#x27; with space */</span></span><br><span class="line">  <span class="keyword">while</span> (*buf &amp;&amp; (*buf == <span class="string">&#x27; &#x27;</span>)) <span class="comment">/* ignore leading spaces */</span></span><br><span class="line">    buf++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Build the argv list */</span></span><br><span class="line">  argc = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (*buf == <span class="string">&#x27;\&#x27;&#x27;</span>) &#123;</span><br><span class="line">    buf++;</span><br><span class="line">    delim = <span class="built_in">strchr</span>(buf, <span class="string">&#x27;\&#x27;&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    delim = <span class="built_in">strchr</span>(buf, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (delim) &#123;</span><br><span class="line">    argv[argc++] = buf;</span><br><span class="line">    *delim = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    buf = delim + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (*buf &amp;&amp; (*buf == <span class="string">&#x27; &#x27;</span>)) <span class="comment">/* ignore spaces */</span></span><br><span class="line">      buf++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*buf == <span class="string">&#x27;\&#x27;&#x27;</span>) &#123;</span><br><span class="line">      buf++;</span><br><span class="line">      delim = <span class="built_in">strchr</span>(buf, <span class="string">&#x27;\&#x27;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      delim = <span class="built_in">strchr</span>(buf, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  argv[argc] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc == <span class="number">0</span>) <span class="comment">/* ignore blank line */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* should the job run in the background? */</span></span><br><span class="line">  <span class="keyword">if</span> ((bg = (*argv[argc - <span class="number">1</span>] == <span class="string">&#x27;&amp;&#x27;</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">    argv[--argc] = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * builtin_cmd - If the user has typed a built-in command then execute</span></span><br><span class="line"><span class="comment"> *    it immediately.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">builtin_cmd</span><span class="params">(<span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;quit&quot;</span>))</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;jobs&quot;</span>)) &#123;</span><br><span class="line">    listjobs(jobs);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;bg&quot;</span>) || !<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;fg&quot;</span>)) &#123;</span><br><span class="line">    do_bgfg(argv);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;&amp;&quot;</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* not a builtin command */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * do_bgfg - Execute the builtin bg and fg commands</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_bgfg</span><span class="params">(<span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  <span class="type">int</span> doid;</span><br><span class="line">  <span class="type">pid_t</span> pid;</span><br><span class="line">  <span class="type">pid_t</span> t_pid;</span><br><span class="line">  <span class="keyword">if</span>(argv[<span class="number">1</span>] == <span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s command requires PID or %%jobid argument\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> jflag = <span class="number">0</span>;  <span class="comment">//组标记</span></span><br><span class="line">  <span class="keyword">if</span>(argv[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27;%&#x27;</span>)&#123;</span><br><span class="line">    jflag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isdigit</span>(argv[<span class="number">1</span>][<span class="number">1</span>]) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s: argument must be a PID or %%jobid\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    doid = atoi(&amp;argv[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isdigit</span>(argv[<span class="number">1</span>][<span class="number">0</span>]) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s: argument must be a PID or %%jobid\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    doid = atoi(&amp;argv[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> * <span class="title">job</span>;</span></span><br><span class="line">  <span class="keyword">if</span>(jflag)&#123;</span><br><span class="line">    job = getjobjid(jobs, doid);  <span class="comment">//jid</span></span><br><span class="line">    <span class="keyword">if</span>(job == <span class="literal">NULL</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d: No such job\n&quot;</span>, doid);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    job = getjobpid(jobs, doid);  <span class="comment">//pid</span></span><br><span class="line">    <span class="keyword">if</span>(job == <span class="literal">NULL</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;(%d): No such process\n&quot;</span>, doid);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;bg&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    kill(-job-&gt;pid, SIGCONT); <span class="comment">//发送继续命令</span></span><br><span class="line">    job-&gt;state = BG;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>,job-&gt;jid,job-&gt;pid,job-&gt;cmdline);  <span class="comment">//不清楚为什么不换行</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    </span><br><span class="line">    t_pid = fgpid(jobs);   <span class="comment">//找当前的前台作业</span></span><br><span class="line">    <span class="keyword">if</span>(job-&gt;state == ST)&#123;</span><br><span class="line">      kill(-job-&gt;pid, SIGCONT); <span class="comment">//发送继续命令</span></span><br><span class="line">    &#125;</span><br><span class="line">    job-&gt;state = FG;</span><br><span class="line">    pid = job-&gt;pid;</span><br><span class="line">    <span class="keyword">if</span>(t_pid != <span class="number">0</span>)&#123;  <span class="comment">//有前台作业 转为后台</span></span><br><span class="line">      job = getjobpid(jobs, doid);</span><br><span class="line">      job-&gt;state = BG;</span><br><span class="line">    &#125;</span><br><span class="line">    waitfg(pid);  <span class="comment">//等待前台运行</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * waitfg - Block until process pid is no longer the foreground process</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">同一时间只有一个fg作业</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">waitfg</span><span class="params">(<span class="type">pid_t</span> pid)</span> &#123;</span><br><span class="line">  <span class="keyword">while</span>(pid == fgpid(jobs))</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*****************</span></span><br><span class="line"><span class="comment"> * Signal handlers</span></span><br><span class="line"><span class="comment"> *****************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sigchld_handler - The kernel sends a SIGCHLD to the shell whenever</span></span><br><span class="line"><span class="comment"> *     a child job terminates (becomes a zombie), or stops because it</span></span><br><span class="line"><span class="comment"> *     received a SIGSTOP or SIGTSTP signal. The handler reaps all</span></span><br><span class="line"><span class="comment"> *     available zombie children, but doesn&#x27;t wait for any other</span></span><br><span class="line"><span class="comment"> *     currently running children to terminate.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  响应 停止信号 处理函数  </span></span><br><span class="line"><span class="comment">  回收所有僵尸进程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigchld_handler</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">  <span class="type">int</span> olderrno = errno;</span><br><span class="line">  <span class="type">sigset_t</span> mask_all,prev_all;</span><br><span class="line">  <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> status; <span class="comment">//获取返回状态</span></span><br><span class="line">  sigfillset(&amp;mask_all);</span><br><span class="line">  <span class="comment">//回收所有的僵尸进程</span></span><br><span class="line">  <span class="keyword">while</span>((pid = waitpid(<span class="number">-1</span>,&amp;status,WNOHANG | WUNTRACED))&gt;<span class="number">0</span>)&#123;  <span class="comment">//如果都没终止返回0 有一个被终止 返回终止pid</span></span><br><span class="line">    <span class="keyword">if</span> (WIFEXITED(status))  &#123;  <span class="comment">//正常终止</span></span><br><span class="line">      sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev_all);</span><br><span class="line">      deletejob(jobs, pid);</span><br><span class="line">      sigprocmask(SIG_SETMASK, &amp;prev_all, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(WIFSIGNALED(status))  &#123;  <span class="comment">//正常终止</span></span><br><span class="line">      sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev_all);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Job [%d] (%d) terminated by signal %d\n&quot;</span>, pid2jid(pid), pid, WTERMSIG(status));</span><br><span class="line">      deletejob(jobs, pid);</span><br><span class="line">      sigprocmask(SIG_SETMASK, &amp;prev_all, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(WIFSTOPPED(status))  &#123;  <span class="comment">//正常暂停</span></span><br><span class="line">      sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev_all);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Job [%d] (%d) stopped by signal %d\n&quot;</span>, pid2jid(pid), pid, WSTOPSIG(status));</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> * <span class="title">fgjob</span> =</span> getjobpid(jobs, pid);  <span class="comment">//查找前台进程指针</span></span><br><span class="line">      fgjob-&gt;state = ST;</span><br><span class="line">      sigprocmask(SIG_SETMASK, &amp;prev_all, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  errno = olderrno;  </span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sigint_handler - The kernel sends a SIGINT to the shell whenver the</span></span><br><span class="line"><span class="comment"> *    user types ctrl-c at the keyboard.  Catch it and send it along</span></span><br><span class="line"><span class="comment"> *    to the foreground job.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">SIGINT 信号只会传递给前台进程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigint_handler</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">  <span class="type">int</span> olderrno = errno;</span><br><span class="line">  <span class="type">pid_t</span> pid;</span><br><span class="line">  pid = fgpid(jobs);</span><br><span class="line">  kill(-pid, sig);  <span class="comment">//发送给前台作业</span></span><br><span class="line">  errno = olderrno;  </span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sigtstp_handler - The kernel sends a SIGTSTP to the shell whenever</span></span><br><span class="line"><span class="comment"> *     the user types ctrl-z at the keyboard. Catch it and suspend the</span></span><br><span class="line"><span class="comment"> *     foreground job by sending it a SIGTSTP.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigtstp_handler</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">  <span class="type">int</span> olderrno = errno;</span><br><span class="line">  <span class="type">pid_t</span> pid;</span><br><span class="line">  pid = fgpid(jobs);</span><br><span class="line">  kill(-pid, sig);  <span class="comment">//发送给前台作业</span></span><br><span class="line">  errno = olderrno;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************</span></span><br><span class="line"><span class="comment"> * End signal handlers</span></span><br><span class="line"><span class="comment"> *********************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//补充函数</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">Fork</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">    unix_error(<span class="string">&quot;Fork error&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> environ[])</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (execve(filename, argv, environ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: Command not found.\n&quot;</span>, filename);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************************************</span></span><br><span class="line"><span class="comment"> * Helper routines that manipulate the job list</span></span><br><span class="line"><span class="comment"> **********************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* clearjob - Clear the entries in a job struct */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clearjob</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *job)</span> &#123;</span><br><span class="line">  job-&gt;pid = <span class="number">0</span>;</span><br><span class="line">  job-&gt;jid = <span class="number">0</span>;</span><br><span class="line">  job-&gt;state = UNDEF;</span><br><span class="line">  job-&gt;cmdline[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* initjobs - Initialize the job list */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initjobs</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">    clearjob(&amp;jobs[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* maxjid - Returns largest allocated job ID */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxjid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i, max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">    <span class="keyword">if</span> (jobs[i].jid &gt; max)</span><br><span class="line">      max = jobs[i].jid;</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* addjob - Add a job to the job list */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">addjob</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs, <span class="type">pid_t</span> pid, <span class="type">int</span> state, <span class="type">char</span> *cmdline)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pid &lt; <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (jobs[i].pid == <span class="number">0</span>) &#123;</span><br><span class="line">      jobs[i].pid = pid;</span><br><span class="line">      jobs[i].state = state;</span><br><span class="line">      jobs[i].jid = nextjid++;</span><br><span class="line">      <span class="keyword">if</span> (nextjid &gt; MAXJOBS)</span><br><span class="line">        nextjid = <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">strcpy</span>(jobs[i].cmdline, cmdline);</span><br><span class="line">      <span class="keyword">if</span> (verbose) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Added job [%d] %d %s\n&quot;</span>, jobs[i].jid, jobs[i].pid, jobs[i].cmdline);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Tried to create too many jobs\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* deletejob - Delete a job whose PID=pid from the job list */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deletejob</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs, <span class="type">pid_t</span> pid)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pid &lt; <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (jobs[i].pid == pid) &#123;</span><br><span class="line">      clearjob(&amp;jobs[i]);</span><br><span class="line">      nextjid = maxjid(jobs) + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* fgpid - Return PID of current foreground job, 0 if no such job */</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fgpid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">    <span class="keyword">if</span> (jobs[i].state == FG)</span><br><span class="line">      <span class="keyword">return</span> jobs[i].pid;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* getjobpid  - Find a job (by PID) on the job list */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="type">job_t</span> *<span class="title function_">getjobpid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs, <span class="type">pid_t</span> pid)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pid &lt; <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">    <span class="keyword">if</span> (jobs[i].pid == pid)</span><br><span class="line">      <span class="keyword">return</span> &amp;jobs[i];</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* getjobjid  - Find a job (by JID) on the job list */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="type">job_t</span> *<span class="title function_">getjobjid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs, <span class="type">int</span> jid)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (jid &lt; <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">    <span class="keyword">if</span> (jobs[i].jid == jid)</span><br><span class="line">      <span class="keyword">return</span> &amp;jobs[i];</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* pid2jid - Map process ID to job ID */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pid2jid</span><span class="params">(<span class="type">pid_t</span> pid)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pid &lt; <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++)</span><br><span class="line">    <span class="keyword">if</span> (jobs[i].pid == pid) &#123;</span><br><span class="line">      <span class="keyword">return</span> jobs[i].jid;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* listjobs - Print the job list */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">listjobs</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXJOBS; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (jobs[i].pid != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) &quot;</span>, jobs[i].jid, jobs[i].pid);</span><br><span class="line">      <span class="keyword">switch</span> (jobs[i].state) &#123;</span><br><span class="line">        <span class="keyword">case</span> BG:</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;Running &quot;</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FG:</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;Foreground &quot;</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ST:</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;Stopped &quot;</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;listjobs: Internal error: job[%d].state=%d &quot;</span>,</span><br><span class="line">                 i, jobs[i].state);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, jobs[i].cmdline);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment"> * end job list helper routines</span></span><br><span class="line"><span class="comment"> ******************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************</span></span><br><span class="line"><span class="comment"> * Other helper routines</span></span><br><span class="line"><span class="comment"> ***********************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * usage - print a help message</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">usage</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Usage: shell [-hvp]\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;   -h   print this message\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;   -v   print additional diagnostic information\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;   -p   do not emit a command prompt\n&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * unix_error - unix-style error routine</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">unix_error</span><span class="params">(<span class="type">char</span> *msg)</span> &#123;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;%s: %s\n&quot;</span>, msg, strerror(errno));</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app_error - application-style error routine</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">app_error</span><span class="params">(<span class="type">char</span> *msg)</span> &#123;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;%s\n&quot;</span>, msg);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Signal - wrapper for the sigaction function</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">handler_t</span> *<span class="title function_">Signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">handler_t</span> *handler)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">action</span>, <span class="title">old_action</span>;</span></span><br><span class="line"></span><br><span class="line">  action.sa_handler = handler;</span><br><span class="line">  sigemptyset(&amp;action.sa_mask); <span class="comment">/* block sigs of type being handled */</span></span><br><span class="line">  action.sa_flags = SA_RESTART; <span class="comment">/* restart syscalls if possible */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sigaction(signum, &amp;action, &amp;old_action) &lt; <span class="number">0</span>)</span><br><span class="line">    unix_error(<span class="string">&quot;Signal error&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> (old_action.sa_handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sigquit_handler - The driver program can gracefully terminate the</span></span><br><span class="line"><span class="comment"> *    child shell by sending it a SIGQUIT signal.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigquit_handler</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Terminating after receipt of SIGQUIT signal\n&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 实验IV CacheLab</title>
    <url>/2024/03/09/16-34-34/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>24.03.09：初稿</li>
</ul>
<h1 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h1><ul>
<li><a href="/2023/03/15/10-59-10/" title="csapp 笔记汇总">CSAPP - 笔记汇总</a></li>
<li><a href="/2023/03/09/11-54-50/" title="CSAPP 实验I Data Lab">I Data Lab - 位操作，数据表示</a></li>
<li><a href="/2023/03/14/09-43-26/" title="CSAPP 实验II Bomb Lab">II Bomb Lab - 汇编，栈帧与 gdb</a></li>
<li><a href="/2023/03/18/15-54-47/" title="CSAPP 实验III Attack Lab">III Attack Lab - 漏洞是如何被攻击的</a></li>
<li><a href="/2024/03/09/16-34-34/" title="CSAPP 实验IV CacheLab">IV Cache Lab - 实现一个缓存系统</a></li>
<li><a href="/2024/03/14/12-34-42/" title="CSAPP实验VShellLab">V Shell Lab - 实现一个Shell</a></li>
</ul>
<h1 id="任务目标"><a href="#任务目标" class="headerlink" title="任务目标"></a>任务目标</h1><p>CacheLab实验，第一部分需要模拟Cache计算命中，未命中次数，第二部分实现代码优化，减少未命中次数。</p>
<h1 id="相关内容"><a href="#相关内容" class="headerlink" title="相关内容"></a>相关内容</h1><ol>
<li><p>Cache</p>
<blockquote>
<img src="/2024/03/09/16-34-34/QQ20240309-165258@2x.png" class="">

<p>不需要关注 <code>b</code> bits，使用LRU替换策略。</p>
<p>Cache是一个二维数组cache[S][E]，S&#x3D;2^s，组数。</p>
<p>每一个cache行包含：Valid bit， Tag， LRU counter。</p>
<p>用Tag对比E匹配line。</p>
</blockquote>
</li>
<li><p>生成内存调试工具命令: <code>linux&gt; valgrind --log-fd=1 --tool=lackey -v --trace-mem=yes ls -l</code></p>
<blockquote>
<p>参数<code>ls -l</code>：打印输出在文件stdout</p>
<p>格式为<code>[space]operation address,size</code>，除了I操作外，前都有一个空格</p>
<p>操作：I-instruction load，L-data load，S-data store， M-data modify。M包含L，S。</p>
<p>address：64-bit 16进制</p>
<p>size：字节数</p>
</blockquote>
</li>
</ol>
<h1 id="题目及解法"><a href="#题目及解法" class="headerlink" title="题目及解法"></a>题目及解法</h1><h2 id="Part-A-Writing-a-Cache-Simulator"><a href="#Part-A-Writing-a-Cache-Simulator" class="headerlink" title="Part A Writing a Cache Simulator"></a>Part A Writing a Cache Simulator</h2><p>完成<code>csim.c</code>文件，使用<code>valgrind</code>生成测试数据，输出命中，未命中和替换次数，输出格式为<code>hits:4 misses:5 evictions:3</code>。</p>
<h3 id="相关内容-1"><a href="#相关内容-1" class="headerlink" title="相关内容"></a>相关内容</h3><ul>
<li><p>修改<code>csim.c</code>文件</p>
</li>
<li><p>可参考的二进制文件<code>csim-ref</code>，使用命令<code>./csim-ref [-hv] -s &lt;s&gt; -E &lt;E&gt; -b &lt;b&gt; -t &lt;tracefile&gt;</code></p>
<blockquote>
<p>参数：v-打印内存追踪记录</p>
</blockquote>
</li>
<li><p>自动评分工具<code>test-csim</code></p>
</li>
<li><p>建议代码像参考模拟器显示输出，方便测试。</p>
</li>
<li><p>使用<code>getopt</code>分析命令行参数。需包含头文件&lt;getopt.h&gt;，&lt;unistd.h&gt;，&lt;stdlib.h&gt;。可以获取函数参数。</p>
</li>
<li><p>使用<code>fscanf</code>按行读取文件</p>
</li>
<li><p>使用<code>malloc</code>，<code>free</code>，防止内存泄漏</p>
</li>
<li><p>使用<code>printSummary(hit_count, miss_count, eviction_count);</code>，打印输出</p>
</li>
<li><p>数据是对齐，且不会出现跨块访问。</p>
</li>
</ul>
<h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSetbits 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxLine 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxBytebits 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Myline</span>&#123;</span></span><br><span class="line">  <span class="type">int</span> valid; <span class="comment">//有效位</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> tag;   <span class="comment">//tag标记  十进制</span></span><br><span class="line">  <span class="type">int</span> lru_num;   <span class="comment">// 最近使用标记 0 - (E - 1)</span></span><br><span class="line">&#125;Myline;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Mycache</span>&#123;</span></span><br><span class="line">  <span class="type">int</span> S;            <span class="comment">// set 大小</span></span><br><span class="line">  <span class="type">int</span> E;            <span class="comment">// line 大小</span></span><br><span class="line">  <span class="type">int</span> B;            <span class="comment">//偏移大小</span></span><br><span class="line">  <span class="type">int</span> size_Tag;     <span class="comment">// tag bits = 64 - s- b</span></span><br><span class="line">  Myline **<span class="built_in">set</span>;    <span class="comment">//set数组</span></span><br><span class="line">&#125;Mycache;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//get command line arguments</span></span><br><span class="line"><span class="comment">//p_s s的指针   p_E E的指针   p_b b的指针    fn 文件名</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Mygetopt</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[], <span class="type">int</span> *p_s, <span class="type">int</span> *p_E, <span class="type">int</span> *p_b, <span class="type">char</span> *fn, <span class="type">int</span> *flag_v)</span>;   </span><br><span class="line"><span class="comment">//16进制转换十进制</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="title function_">Hex2dec</span><span class="params">(<span class="type">char</span> *hex)</span>;</span><br><span class="line"><span class="comment">//返回tag</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="title function_">GetDecTag</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> dec, <span class="type">int</span> s, <span class="type">int</span> b)</span>;</span><br><span class="line"><span class="comment">//返回组号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">GetDecSetNum</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> dec, <span class="type">int</span> s, <span class="type">int</span> b)</span>;</span><br><span class="line"><span class="comment">//返回这个dec地址下当前偏移量开始剩余的字节数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">GetDecRestByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> dec, <span class="type">int</span> s, <span class="type">int</span> b, <span class="type">int</span> B)</span>;</span><br><span class="line"><span class="comment">//初始化set</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Initset</span><span class="params">(Mycache *mc)</span>;</span><br><span class="line"><span class="comment">//处理最近未使用</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">GetminLRU</span><span class="params">(Myline *<span class="built_in">set</span>, <span class="type">int</span> E)</span>;</span><br><span class="line"><span class="comment">//是否set满了</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">IsFullSet</span><span class="params">(Myline *<span class="built_in">set</span>, <span class="type">int</span> E)</span>;</span><br><span class="line"><span class="comment">//命中处理  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HitDeal</span><span class="params">(Myline *<span class="built_in">set</span>, <span class="type">int</span> E, <span class="type">int</span> Eindex)</span>;</span><br><span class="line"><span class="comment">//未命中 加载cache</span></span><br><span class="line"><span class="comment">// 有空余line加载</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MissLoadDeal</span><span class="params">(Myline *<span class="built_in">set</span>, <span class="type">int</span> E, <span class="type">int</span> Eindex, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> dec_tag)</span>;</span><br><span class="line"><span class="comment">//line替换</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MissEvictionDeal</span><span class="params">(Myline *<span class="built_in">set</span>, <span class="type">int</span> E, <span class="type">int</span> delindex, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> dec_tag)</span>;</span><br><span class="line"><span class="comment">//访问处理   返回1 hit   2  miss  3 miss eviction</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">LoadDeal</span><span class="params">(Myline *<span class="built_in">set</span>, <span class="type">int</span> E, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> now_tag, <span class="type">int</span> flag_v)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">StoreDeal</span><span class="params">(Myline *<span class="built_in">set</span>, <span class="type">int</span> E, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> now_tag, <span class="type">int</span> flag_v)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ModifyDeal</span><span class="params">(Myline *<span class="built_in">set</span>, <span class="type">int</span> E, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> now_tag, <span class="type">int</span> flag_v)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  FILE *fp;</span><br><span class="line">  <span class="type">int</span> hit_count, miss_count, eviction_count;</span><br><span class="line">  <span class="type">int</span> s, E, b;</span><br><span class="line">  <span class="type">int</span> flag_v = <span class="number">0</span>;     <span class="comment">//opt v 的标记</span></span><br><span class="line">  <span class="type">char</span> *file_name;</span><br><span class="line">  <span class="type">char</span> optcache = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  <span class="type">char</span> ignorechar = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  <span class="type">char</span> hex[<span class="number">65</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="type">int</span> size = <span class="number">0</span>;        <span class="comment">//个数</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> dec;</span><br><span class="line"></span><br><span class="line">  hit_count = <span class="number">0</span>;</span><br><span class="line">  miss_count = <span class="number">0</span>;</span><br><span class="line">  eviction_count = <span class="number">0</span>;</span><br><span class="line">  Mycache cache;</span><br><span class="line">  file_name = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * <span class="number">30</span>);</span><br><span class="line">  Mygetopt(argc, argv, &amp;s, &amp;E, &amp;b, file_name, &amp;flag_v);</span><br><span class="line">  cache.S = <span class="built_in">pow</span>(<span class="number">2</span>, s);</span><br><span class="line">  cache.E = E;</span><br><span class="line">  cache.B = <span class="built_in">pow</span>(<span class="number">2</span>, b);</span><br><span class="line">  cache.size_Tag = <span class="number">64</span> - s - b;</span><br><span class="line">  Initset(&amp;cache);</span><br><span class="line"></span><br><span class="line">  fp = fopen(file_name, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">fscanf</span>(fp, <span class="string">&quot; %c %[^,]%c%d&quot;</span>, &amp;optcache, hex, &amp;ignorechar, &amp;size) != <span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(optcache == <span class="string">&#x27;I&#x27;</span>)&#123;</span><br><span class="line">      <span class="built_in">fscanf</span>(fp, <span class="string">&quot;%c&quot;</span>, &amp;ignorechar);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag_v == <span class="number">1</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%c %s,%d&quot;</span>, optcache, hex, size);</span><br><span class="line">    &#125;</span><br><span class="line">    dec = Hex2dec(hex);</span><br><span class="line">    <span class="comment">//========处理内存访问</span></span><br><span class="line">    <span class="type">int</span> setnum = <span class="number">0</span>;  <span class="comment">//组号</span></span><br><span class="line">    <span class="type">int</span> flag_kind = <span class="number">0</span>;   <span class="comment">//cache 类型   hit miss  </span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> dectag = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//int restbyte = 0;  // 当前偏移量下剩余的字节数</span></span><br><span class="line">    <span class="comment">//int loadbyte = 0;  //已加载的字节数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> loaddec = dec;   <span class="comment">//当前加载的地址</span></span><br><span class="line">    setnum = GetDecSetNum(loaddec, s, b);</span><br><span class="line">    dectag = GetDecTag(loaddec, s, b);</span><br><span class="line">    <span class="comment">//restbyte = GetDecRestByte(loaddec, s, b, cache.B);   //剩余加载的字节数</span></span><br><span class="line">    flag_kind = LoadDeal(cache.<span class="built_in">set</span>[setnum], E, dectag, flag_v);</span><br><span class="line">    <span class="comment">/*loadbyte += restbyte;</span></span><br><span class="line"><span class="comment">    loaddec += restbyte;   //当前地址加上剩余字节数  如果加载字节数不够  这就是下一个加载地址</span></span><br><span class="line"><span class="comment">    while(loadbyte &lt; size)&#123;</span></span><br><span class="line"><span class="comment">      setnum = GetDecSetNum(loaddec, s, b);</span></span><br><span class="line"><span class="comment">      dectag = GetDecTag(loaddec, s, b);</span></span><br><span class="line"><span class="comment">      LoadDeal(cache.set[setnum], E, dectag, flag_v);</span></span><br><span class="line"><span class="comment">      loadbyte += cache.B;</span></span><br><span class="line"><span class="comment">      loaddec += cache.B;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="keyword">if</span>(flag_kind == <span class="number">1</span>)&#123;</span><br><span class="line">      hit_count++;</span><br><span class="line">      <span class="keyword">if</span>(flag_v == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; hit&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(flag_kind == <span class="number">2</span>)&#123;</span><br><span class="line">        miss_count++;</span><br><span class="line">        <span class="keyword">if</span>(flag_v == <span class="number">1</span>)&#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot; miss&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">        miss_count++;</span><br><span class="line">        eviction_count++;</span><br><span class="line">        <span class="keyword">if</span>(flag_v == <span class="number">1</span>)&#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot; miss eviction&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(optcache == <span class="string">&#x27;M&#x27;</span>)&#123;</span><br><span class="line">      hit_count++;   <span class="comment">//修改  store一定hit</span></span><br><span class="line">      <span class="keyword">if</span>(flag_v == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; hit\n&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(flag_v == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//=====================</span></span><br><span class="line">    <span class="built_in">fscanf</span>(fp, <span class="string">&quot;%c&quot;</span>, &amp;ignorechar);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  printSummary(hit_count, miss_count, eviction_count);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Mygetopt</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[], <span class="type">int</span> *p_s, <span class="type">int</span> *p_E, <span class="type">int</span> *p_b, <span class="type">char</span> *fn, <span class="type">int</span> *flag_v)</span>&#123;</span><br><span class="line">  <span class="type">int</span> opt;</span><br><span class="line">  <span class="keyword">while</span> ((opt = getopt(argc, argv, <span class="string">&quot;vh:s:E:b:t:&quot;</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">        *p_s = atoi(optarg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:</span><br><span class="line">        *p_E = atoi(optarg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">        *p_b = atoi(optarg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line">        <span class="built_in">strcpy</span>(fn, optarg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:</span><br><span class="line">        *flag_v = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="title function_">Hex2dec</span><span class="params">(<span class="type">char</span> *hex)</span>&#123;</span><br><span class="line">  <span class="type">int</span> len = <span class="built_in">strlen</span>(hex);</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> dec = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> pow16 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isdigit</span>(hex[i]))&#123;</span><br><span class="line">      dec += (hex[i] - <span class="string">&#x27;0&#x27;</span>) * pow16;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      dec += (hex[i] - <span class="number">87</span>) * pow16;</span><br><span class="line">    &#125;</span><br><span class="line">    pow16 *= <span class="number">16</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dec;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="title function_">GetDecTag</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> dec, <span class="type">int</span> s, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> dec &gt;&gt; (s + b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">GetDecSetNum</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> dec, <span class="type">int</span> s, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">  <span class="type">int</span> setbits = (<span class="number">1</span> &lt;&lt; s);</span><br><span class="line">  setbits = ~(~setbits + <span class="number">1</span>);</span><br><span class="line">  dec = dec &gt;&gt; (b);</span><br><span class="line">  <span class="keyword">return</span> dec &amp; setbits;   <span class="comment">//返回set组号</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">GetDecRestByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> dec, <span class="type">int</span> s, <span class="type">int</span> b, <span class="type">int</span> B)</span>&#123;</span><br><span class="line">  <span class="type">int</span> Bytebits = <span class="number">1</span> &lt;&lt; b;</span><br><span class="line">  Bytebits = ~(~Bytebits + <span class="number">1</span>);</span><br><span class="line">  dec = dec &amp; Bytebits;   <span class="comment">//剩余偏移量</span></span><br><span class="line">  <span class="keyword">return</span> B - dec;  <span class="comment">//返回剩余的字节数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Initset</span><span class="params">(Mycache *mc)</span>&#123;</span><br><span class="line">  <span class="type">int</span> S = (*mc).S;</span><br><span class="line">  <span class="type">int</span> E = (*mc).E;</span><br><span class="line">  (*mc).<span class="built_in">set</span> = (Myline **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Myline *) * S);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; S; i++)&#123;</span><br><span class="line">    (*mc).<span class="built_in">set</span>[i] = (Myline *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Myline) * E);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; (*mc).S; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; (*mc).E; j++)&#123;</span><br><span class="line">      (*mc).<span class="built_in">set</span>[i][j].valid = <span class="number">0</span>;  <span class="comment">//有效位为0</span></span><br><span class="line">      (*mc).<span class="built_in">set</span>[i][j].lru_num = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">GetminLRU</span><span class="params">(Myline *<span class="built_in">set</span>, <span class="type">int</span> E)</span>&#123;</span><br><span class="line">  <span class="type">int</span> min = <span class="number">1000</span>;</span><br><span class="line">  <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; E; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">set</span>[i].valid == <span class="number">0</span>)&#123;   <span class="comment">// 如果存在一个无效位置 直接返回</span></span><br><span class="line">      k = i;</span><br><span class="line">      <span class="keyword">break</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">set</span>[i].lru_num &lt; min)&#123;  </span><br><span class="line">      min = <span class="built_in">set</span>[i].lru_num;</span><br><span class="line">      k = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">IsFullSet</span><span class="params">(Myline *<span class="built_in">set</span>, <span class="type">int</span> E)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; E; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">set</span>[i].valid == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">HitDeal</span><span class="params">(Myline *<span class="built_in">set</span>, <span class="type">int</span> E, <span class="type">int</span> Eindex)</span>&#123;</span><br><span class="line">  <span class="type">int</span> nowLRU = <span class="built_in">set</span>[Eindex].lru_num;</span><br><span class="line">  <span class="comment">//把比现在要访问的cache set中lrunum大的全部减一  </span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; E; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">set</span>[i].lru_num &gt; nowLRU)&#123;</span><br><span class="line">      <span class="built_in">set</span>[i].lru_num--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">set</span>[Eindex].lru_num = E - <span class="number">1</span>;  <span class="comment">//最新访问的cache LRU设置为最大</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">MissLoadDeal</span><span class="params">(Myline *<span class="built_in">set</span>, <span class="type">int</span> E, <span class="type">int</span> Eindex, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> dec_tag)</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//把比现在要访问的cache set中lrunum大的全部减一  </span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; E; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">set</span>[i].lru_num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">set</span>[i].lru_num--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">set</span>[Eindex].tag = dec_tag;</span><br><span class="line">  <span class="built_in">set</span>[Eindex].valid = <span class="number">1</span>;  </span><br><span class="line">  <span class="built_in">set</span>[Eindex].lru_num = E - <span class="number">1</span>;  <span class="comment">//最新访问的cache LRU设置为最大</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MissEvictionDeal</span><span class="params">(Myline *<span class="built_in">set</span>, <span class="type">int</span> E, <span class="type">int</span> delindex, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> dec_tag)</span>&#123;</span><br><span class="line">  <span class="comment">//将要替换的line命中  改为最近访问过,然后再替换掉tag值</span></span><br><span class="line">  HitDeal(<span class="built_in">set</span>, E, delindex);</span><br><span class="line">  <span class="built_in">set</span>[delindex].tag = dec_tag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">LoadDeal</span><span class="params">(Myline *<span class="built_in">set</span>, <span class="type">int</span> E, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> now_tag, <span class="type">int</span> flag_v)</span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; E; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">set</span>[i].tag == now_tag &amp;&amp; <span class="built_in">set</span>[i].valid == <span class="number">1</span>)&#123;</span><br><span class="line">      HitDeal(<span class="built_in">set</span>, E, i);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(i == E)&#123;</span><br><span class="line">    <span class="type">int</span> Lindex = GetminLRU(<span class="built_in">set</span>, E);</span><br><span class="line">    <span class="keyword">if</span>(IsFullSet(<span class="built_in">set</span>, E) == <span class="number">1</span>)&#123;</span><br><span class="line">      <span class="comment">//满的  替换</span></span><br><span class="line">      MissEvictionDeal(<span class="built_in">set</span>, E, Lindex, now_tag);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      MissLoadDeal(<span class="built_in">set</span>, E, Lindex, now_tag);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">StoreDeal</span><span class="params">(Myline *<span class="built_in">set</span>, <span class="type">int</span> E, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> now_tag, <span class="type">int</span> flag_v)</span>&#123;</span><br><span class="line">  <span class="comment">//Store 相当于 Load</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ModifyDeal</span><span class="params">(Myline *<span class="built_in">set</span>, <span class="type">int</span> E, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> now_tag, <span class="type">int</span> flag_v)</span>&#123;</span><br><span class="line">  <span class="comment">//int kind = LoadDeal(set, E, now_tag,flag_v);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Part-B-Optimizing-Matrix-Transpose"><a href="#Part-B-Optimizing-Matrix-Transpose" class="headerlink" title="Part B Optimizing Matrix Transpose"></a>Part B Optimizing Matrix Transpose</h2><p>完成<code>trans.c</code>文件，实现一个转置矩阵代码<code>transpose_submit</code>，尽可能少的产生cache未命中。</p>
<h3 id="相关内容-2"><a href="#相关内容-2" class="headerlink" title="相关内容"></a>相关内容</h3><ul>
<li><p>只允许使用最多12个本地int变量，调用函数中一起计算</p>
</li>
<li><p>不允许使用long或者其他存储数值的方法，不允许使用数组</p>
</li>
<li><p>不能递归</p>
</li>
<li><p>使用参考模拟器来测试代码，cache参数为<code>s = 5， E = 1， b = 5</code></p>
</li>
<li><p>int为4个字节。</p>
</li>
<li><p>只有三种形式的矩阵，32*32，64*64，61*67。</p>
</li>
<li><img src="/2024/03/09/16-34-34/QQ20240310-152729@2x.png" class=""> 
<p>矩阵乘法的分块技术</p>
</li>
<li><p>两个数组的第一个数据，在cache中存储到相同位置，数组按照行优先存储，数据是对齐的</p>
</li>
<li><p><code>./test-trans -M 32 -N 32</code> 测试函数 </p>
</li>
<li><p><code>./tracegen -M 64 -N 64 -F 0</code> 输出错误信息</p>
</li>
</ul>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>数据是对齐的，所以一个cache行包含32个字节，存储8个int数据，cache能存储256个int数据，根据<del><code>3B^2 &lt;&lt; C</code>，块长为B&#x3D;8</del>。根据<code>2B^2 &lt;&lt; C</code>，块长&lt;&#x3D;11，由于cache行可以存8个数据，所以选择块长8。</p>
<img src="/2024/03/09/16-34-34/QQ20240310-191918@2x.png" class="">

<p>以32*32的矩阵为例，除了处于对角线上的块会产生冲突不命中，其他块都可以优化不命中情况</p>
<p>以上这种情况对32*32是成立的，64*64和61*67不成立，所以重新思考了这道题的解法，根据data lab中数据的操作都是在内存中进行的。</p>
<p><strong>数组的首地址给出后，行优先数据为一维连续存储形式</strong></p>
<p>这道题可以转换为数组A[N][M]在内存中连续存放，每一个位置x的数根据相同的转换方式保存到数组B[M][N]的位置y，转换公式为<code>i_a = x / M</code>，<code>j_a = x % M</code>，<code>y = j_a * N + i_a * M</code>。于是存储公式为<code>B(y) = A(x)</code>。</p>
<img src="/2024/03/09/16-34-34/QQ20240312-145802@2x.png" class="">

<blockquote>
<p>示意图如上，cache行存2个数据，3*3的数组中，无法直观看出内存区别，而cache的分块目的是为了在内存中读取到cache时减少miss次数，所以我们根据内存进行重排数组，改为5*2的数组。</p>
</blockquote>
<p>所以这道题可以把数组转换为32列的任意数组，由于一行只有32列，远远小于cache的容量256个数据，所以相邻行的上下两个数据不会映射的同一个cache行。</p>
<p>需要把文件放入linux的文件夹中，如果在共享文件夹中会出现运行超时。</p>
<h3 id="32-x-32"><a href="#32-x-32" class="headerlink" title="32 x 32"></a>32 x 32</h3><p>基本步骤：</p>
<ul>
<li><p>重排数组</p>
</li>
<li><p>处理AB数组中x，y映射相同的位置，先用局部变量保存，然后处理这一行的其他数据，最后保存在B数组的中，cache行自动换出。</p>
</li>
</ul>
<p><strong>分析原因</strong></p>
<blockquote>
<p>当<code>A[i][j]</code>与<code>B[j][i]</code>的cache映射相同set内时，取出<code>A[i][j]</code>中的值，写入B数组时会换出A的cache行，导致下次访问A的同一行cache数据时需要继续换出一次。</p>
</blockquote>
<p><strong>解决办法</strong></p>
<blockquote>
<p>用局部变量保存访问冲突的值，等循环结束后，在写入B中。</p>
<p>计算所在行，x表示数组一维连续内存的位置(0开始)，cache 组号<code>s=（x%256 ) / 8;</code></p>
</blockquote>
<p><strong>结果</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> A[N][M], <span class="type">int</span> B[M][N])</span> &#123;</span><br><span class="line">  <span class="comment">//int t_1, t_2, t_3;</span></span><br><span class="line">  <span class="type">int</span> t_4, t_5;</span><br><span class="line">  <span class="type">int</span> i, j, ii, jj;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i += <span class="number">8</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; M; j += <span class="number">8</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (ii = i; ii &lt; ((i + <span class="number">8</span>) &lt; N ? i + <span class="number">8</span> : N); ii++) &#123;</span><br><span class="line">        <span class="comment">//标记没有访问冲突</span></span><br><span class="line">        t_4 = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (jj = j; jj &lt; ((j + <span class="number">8</span>) &lt; M ? j + <span class="number">8</span> : M); jj++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (ii * M + jj == jj * N + ii) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t_4 == <span class="number">-1</span>) &#123;</span><br><span class="line">              t_4 = ii;</span><br><span class="line">              t_5 = jj;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// printf(&quot;**  2-- %d  3--  %d\n&quot;, t_2, t_3);</span></span><br><span class="line">          B[jj][ii] = A[ii][jj];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t_4 != <span class="number">-1</span>) &#123;</span><br><span class="line">          B[t_5][t_4] = A[t_4][t_5];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2024/03/09/16-34-34/QQ20240312-183951@2x.png" class="">

<p>miss数量287，满分</p>
<h3 id="64-x-64"><a href="#64-x-64" class="headerlink" title="64 x 64"></a>64 x 64</h3><p>出现一个cache行中两次相同映射的问题</p>
<p><strong>分析原因</strong></p>
<blockquote>
<p>在32 x 32的数组中，一个cache行为8，块为8x8，一个cache行最多只有对角线的的一个元素冲突miss，但是64x64的数组中，8x8的块中，前四行与后四行冲突miss，所以一个cache行的8个数据中，最多有两个元素冲突miss</p>
</blockquote>
<p><strong>解决办法</strong></p>
<blockquote>
<p>继续添加一个局部变量记录冲突位置，一行遍历完后再处理。</p>
<p>继续出现了只遍历到了32，在64 X 64的数组转换为32列时，行数为128。</p>
</blockquote>
<img src="/2024/03/09/16-34-34/QQ20240312-225626@2x.png" class="">

<p>miss数量为4611，还需要继续调低。</p>
<p><strong>分析原因</strong></p>


<p><del>错误答案</del></p>
<p>64X64中，改了内存排列后，第二行与第一行的转置不在同一cache行内。</p>
<p>按照左上右上，左下，右下顺序。</p>
<p><strong>结果</strong></p>
<img src="/2024/03/09/16-34-34/QQ20240313-183244@2x.png" class="">

<p><strong>分析原因</strong></p>
<blockquote>
<p>没有拿到满分，按照上下划分为两个4X8的数组</p>
<p>下边的4X8数组，一行中的后四列在B数组中会cache冲突行，如图<img src="/2024/03/09/16-34-34/QQ20240313-191649@2x.png" class=""></p>
<p>注意：</p>
<p>上四行转置之后，B数组的下四行正在cache中，为了不换出，先转置A数组的右下，再左下。</p>
</blockquote>
<p><strong>结果</strong></p>
<img src="/2024/03/09/16-34-34/QQ20240313-193617@2x.png" class="">

<p>减少到1547，但是还没有满分。</p>
<p>继续修改</p>
<blockquote>
<p>题目要求减少miss数量，可以利用cache中空闲的地方保存数据  最后在替换出去</p>
<img src="/2024/03/09/16-34-34/QQ20240313-202434@2x.png" class="">

<p>如图，A的上半部分的后四列存到B的后四列中</p>
<img src="/2024/03/09/16-34-34/QQ20240313-202818@2x.png" class="">

<p>下半部分的第一列，先把B数组的第一行后四列保存到下部分的第一行，这样第一个cache就替换完成，依次完成其他行，最后把右下角转置过去。</p>
</blockquote>
<p><strong>结果</strong></p>
<img src="/2024/03/09/16-34-34/QQ20240313-210554@2x.png" class="">

<p>miss数1339，差39次满分，没有找到优化位置。</p>
<h3 id="61-X-67"><a href="#61-X-67" class="headerlink" title="61 X 67"></a>61 X 67</h3><p><strong>结果</strong></p>
<img src="/2024/03/09/16-34-34/QQ20240313-210917@2x.png" class="">

<p><strong>最终得分</strong></p>
<img src="/2024/03/09/16-34-34/QQ20240314-144148@2x.png" class="">

<p>拿到了51.5分，之后有时间再来查代码优化的地方。</p>
]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 笔记六 存储器层次结构</title>
    <url>/2023/07/23/09-27-18/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>23.07.23：初稿</li>
</ul>
<h1 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h1><ul>
<li><a href="/2023/03/15/10-59-10/" title="csapp 笔记汇总">CSAPP - 笔记汇总</a></li>
<li><a href="/2023/05/24/13-04-09/" title="CSAPP 笔记三 程序的机器级表示">第三章 - 程序的机器级表示</a></li>
<li><a href="/2023/07/06/14-25-42/" title="CSAPP 笔记五 优化程序性能">第五章 - 优化程序性能</a></li>
<li><a href="/2023/07/23/09-27-18/" title="CSAPP 笔记六 存储器层次结构">第六章 - 存储器层次结构</a></li>
</ul>
<h1 id="The-Memory-Hierarchy"><a href="#The-Memory-Hierarchy" class="headerlink" title="The Memory Hierarchy"></a>The Memory Hierarchy</h1><h2 id="Storage-technologies-and-trends"><a href="#Storage-technologies-and-trends" class="headerlink" title="Storage technologies and trends"></a>Storage technologies and trends</h2><p><strong>Random-Access Memory(RAM)</strong></p>
<p>根据存储单元实现方式区分为：</p>
<p><strong>SRAM(Static)</strong></p>
<ul>
<li><p>4或6个晶体存储 1 bit， 成本很高</p>
</li>
<li><p>访问速度比DRAM快</p>
</li>
<li><p>不太需要EDC(error detection and correction)错误检测和纠正</p>
</li>
<li><p>组成cache</p>
</li>
</ul>
<p><strong>DRAM(Dynamic)</strong></p>
<ul>
<li><p>一个晶体存储 1 bit</p>
</li>
<li><p>需要刷新 </p>
</li>
<li><p>需要EDC</p>
</li>
<li><p>组成主存储器，图形显卡的帧缓存(frame buffers)</p>
</li>
</ul>
<p><strong>Nonvolatile Memories</strong></p>
<p>Read-only memory(ROM):生产期间硬编程一次</p>
<p>Programmable ROM(PROM): 可编程ROM</p>
<p>Eraseable PROM(EPROM): 可擦拭可编程ROM</p>
<p>Electrically eraseable PROM(EEPROM): 电子可擦拭可编程ROM</p>
<p>Flash memory: 闪存，提供了擦拭模块，但是会有损耗。</p>
<p><strong>Disk Drive</strong></p>
<p>因为机械特性，硬盘会比SRAM，DRAM慢很多。</p>
<img src="/2023/07/23/09-27-18/QQ20230723-095730@2x.jpg" class="">

<p>Sectors：扇区</p>
<img src="/2023/07/23/09-27-18/QQ20230723-143055@2x.jpg" class="">

<p>Cylinder: 柱面</p>
<p>Logical Disk Blocks：逻辑块</p>
<p>实现物理块与逻辑块之间的映射关系。</p>
<p><strong>Solid State Disks(SSDs)</strong></p>
<img src="/2023/07/23/09-27-18/QQ20230723-143913@2x.jpg" class="">

<ul>
<li><p>没有机械部件，由闪存翻译层固件控制</p>
</li>
<li><p>以页为单位读写，写入时必须擦拭整个块</p>
</li>
</ul>
<h2 id="Locality-of-reference"><a href="#Locality-of-reference" class="headerlink" title="Locality of reference"></a>Locality of reference</h2><p>程序的局部性</p>
<p>程序需要良好的局部性，有利用于读写内存。</p>
<h2 id="Caching-in-the-Memory-Hierarchy"><a href="#Caching-in-the-Memory-Hierarchy" class="headerlink" title="Caching in the Memory Hierarchy"></a>Caching in the Memory Hierarchy</h2><p>利用缓存和局部性原理构建了存储器层次结构。</p>
<img src="/2023/07/23/09-27-18/QQ20230723-144603@2x.jpg" class="">

<blockquote>
<p>高层保存着从低层检索到的数据</p>
</blockquote>
<p><strong>Caches</strong></p>
<img src="/2023/07/23/09-27-18/QQ20230723-144821@2x.jpg" class="">

<p>Cold (compulsory) miss: 冷命中，初始时cache为空</p>
<p>Conflict miss: 冲突不命中，位置被占用了</p>
<p>Capacity miss: 容量不命中，不可以容纳超过缓存大小的工作集</p>
]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 实验V Performance Lab</title>
    <url>/2023/07/07/16-27-21/</url>
    <content><![CDATA[<p>更新历史：</p>
<ul>
<li>23.07.07：初稿</li>
<li>23.07.22：没学过汇编，复杂代码看不懂，明年有时间再回头做这个实验</li>
<li>24.03.09：实验作废，用cache lab 替代。</li>
</ul>
<h1 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h1><ul>
<li><a href="/2023/03/15/10-59-10/" title="csapp 笔记汇总">CSAPP - 笔记汇总</a></li>
</ul>
<h1 id="任务目标"><a href="#任务目标" class="headerlink" title="任务目标"></a>任务目标</h1><p>采用代码移动，循环展开以及指令并行对图像的旋转和平滑函数进行优化。</p>
<h1 id="相关内容"><a href="#相关内容" class="headerlink" title="相关内容"></a>相关内容</h1><ol>
<li><p><code>make driver</code>：生成运行文件， 运行<code>./driver</code>参数</p>
<blockquote>
<p><code>-g</code>：尽运行<code>rotate</code>和<code>smooth</code>函数</p>
<p><code>-f</code>：指定文件输入运行</p>
<p><code>-d</code>： 运行写入指定文件</p>
<p><code>-q</code>：写入文件后结束运行</p>
</blockquote>
</li>
<li><p><code>指导文件建议</code>：观看汇编代码，平滑函数计算密集，翻转函数存储密集。</p>
</li>
<li><p>允许添加宏，全局变量和其他函数(过程)。</p>
</li>
<li><p>假定图像矩阵的大小为32的倍数</p>
</li>
</ol>
<h1 id="题目及解法"><a href="#题目及解法" class="headerlink" title="题目及解法"></a>题目及解法</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>课程中讲过的常见优化方式：代码移动，减少重复过程调用，消除不必要的内存引用，循环展开以及提高并行性。先查看汇编代码，根据汇编代码选择合适的方法对函数进行优化。</p>
<h2 id="Phase-Rotate"><a href="#Phase-Rotate" class="headerlink" title="Phase Rotate"></a>Phase Rotate</h2><p>原函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">naive_rotate</span><span class="params">(<span class="type">int</span> dim, pixel *src, pixel *dst)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; dim; i++)</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; dim; j++)</span><br><span class="line">        dst[RIDX(dim<span class="number">-1</span>-j, i, dim)] = src[RIDX(i, j, dim)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>汇编：</p>
<img src="/2023/07/07/16-27-21/QQ20230719-190626@2x.jpg" class="">

<img src="/2023/07/07/16-27-21/QQ20230719-190641@2x.jpg" class="">

<blockquote>
<p><del>之前的lab里讲过实验环境在32位shark机器下，这里汇编代码在push占用了8个字节，不太明白是不是我的环境不对</del></p>
<p><code>已解决</code>：确实环境不对，没有32位依赖，更新之后push占用4个字节</p>
<p><code>imul multi， src， des</code>三目运算</p>
</blockquote>
<p><strong>1.数据存放方式</strong></p>
<p>数据在栈空间中小端存放，<code>rdi</code>存放在<code>rsp + 0x18</code>，<code>edi</code>存放在加4个字节的位置。所以 0x1c(%esp) 的值就是dim。</p>
]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
        <tag>shell</tag>
        <tag>gdb</tag>
        <tag>objdump</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 笔记五 优化程序性能</title>
    <url>/2023/07/06/14-25-42/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>23.07.06：初稿</li>
</ul>
<h1 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h1><ul>
<li><a href="/2023/03/15/10-59-10/" title="csapp 笔记汇总">CSAPP - 笔记汇总</a></li>
<li><a href="/2023/05/24/13-04-09/" title="CSAPP 笔记三 程序的机器级表示">第三章 - 程序的机器级表示</a></li>
<li><a href="/2023/07/06/14-25-42/" title="CSAPP 笔记五 优化程序性能">第五章 - 优化程序性能</a></li>
<li><a href="/2023/07/23/09-27-18/" title="CSAPP 笔记六 存储器层次结构">第六章 - 存储器层次结构</a></li>
</ul>
<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>通过查看汇编代码，对没有优化的代码进行调整。</p>
<h1 id="Generally-Useful-Optimizations"><a href="#Generally-Useful-Optimizations" class="headerlink" title="Generally Useful Optimizations"></a>Generally Useful Optimizations</h1><ul>
<li><p>Code Motion：代码移动，把常用的结果存到循环外。优化等级1以上，编译器会自动完成这个工作。</p>
</li>
<li><p>Reduction in Strength：减少计算量，乘法换左移或加法。</p>
</li>
<li><p>Share Common Subexpressions：寻找公共表达式，减少计算量。</p>
</li>
</ul>
<h1 id="Optimization-Blockers"><a href="#Optimization-Blockers" class="headerlink" title="Optimization Blockers"></a>Optimization Blockers</h1><ul>
<li><p>Procedure Calls：循环中进行相同结果的重复调用。</p>
<blockquote>
<p>编译器无法优化的原因：</p>
<p>1.不知道是否在循环中修改了字符串；2. 文件单独编译，编译器不知道函数使用的是哪个文件中的函数，编译器事先假设函数是一个黑盒。</p>
</blockquote>
</li>
<li><p>Memory Matters: 循环中重复读取内存。</p>
<blockquote>
<p>无法优化的原因：</p>
<p>编译器不确定C语言是否存在内存别名，之前的结果会不会影响下一次读取的内存值。所以每次都进行读取写入操作。</p>
</blockquote>
</li>
<li><p>Memory Aliasing：引入局部变量防止内存重叠。</p>
</li>
</ul>
<h1 id="Exploiting-Instruction-Level-Parallelism"><a href="#Exploiting-Instruction-Level-Parallelism" class="headerlink" title="Exploiting Instruction-Level Parallelism"></a>Exploiting Instruction-Level Parallelism</h1><p>采用指令级并行，适用于各种机器的通用优化方法</p>
<h2 id="Benchmark-Example"><a href="#Benchmark-Example" class="headerlink" title="Benchmark Example"></a>Benchmark Example</h2><p>基准例子，使用一个抽象的数据结构。</p>
<img src="/2023/07/06/14-25-42/WX20230706-153904@2x.png" class="">

<p><strong>Basic Optimizations</strong></p>
<ul>
<li><p>计算数组长度移出循环</p>
</li>
<li><p>移除边界检查，用新函数获取数组</p>
</li>
<li><p>引入局部变量</p>
</li>
</ul>
<img src="/2023/07/06/14-25-42/WX20230706-154041@2x.png" class="">

<p>优化后性能：</p>
<img src="/2023/07/06/14-25-42/WX20230706-154316@2x.png" class="">

<p><code>优化的基本限制</code>: 程序限制了整数和浮点数的乘法必须顺序执行，所需要的周期为3和5。</p>
<p><strong>Modern CPU Design</strong></p>
<img src="/2023/07/06/14-25-42/WX20230706-163939@2x.png" class="">

<p> 1995年的CPU，了解流程。</p>
<p> 超标量乱序执行：顺序指令分解重组，实现指令级并行。</p>
<p>Superscalar Processor：超标量处理器</p>
<p><strong>Pipelined Functional Units</strong></p>
<img src="/2023/07/06/14-25-42/WX20230706-170033@2x.png" class="">

<p>指令流水线：<code>这里假设指令需要三个阶段完成</code></p>
<h2 id="Loop-Unrolling"><a href="#Loop-Unrolling" class="headerlink" title="Loop Unrolling"></a>Loop Unrolling</h2><p><code>循环展开</code>: 循环中计算多个值，而不是计算一次。</p>
<img src="/2023/07/06/14-25-42/WX20230707-094102@2x.png" class="">

<blockquote>
<p>每次循环计算两个操作数</p>
<p><code>limit</code>: n-1, 循环i跳出时满足 i + 1 &lt; (n - 1) + 1 &#x3D; n; </p>
</blockquote>
<img src="/2023/07/06/14-25-42/WX20230707-094654@2x.png" class="">

<blockquote>
<p>只有加法的CPE有了提升，降低了循环计数的消耗。其他没用提升是因为接近了延迟界限。</p>
</blockquote>
<p>调整循环展开的计算顺序：</p>
<p><code>x = x OP (d[i] OP d[i+1])</code></p>
<img src="/2023/07/06/14-25-42/WX20230707-105030@2x.png" class="">

<p>吞吐量突破了延迟界限，浮点数两个乘法器，一个加法器。</p>
<img src="/2023/07/06/14-25-42/WX20230707-105355@2x.png" class="">

<p>减少了计算的依赖，两个元素的计算不需要等上一个x的结果。浮点数不满足结合律，改变括号可能会发生舍入溢出，结果发生变化。</p>
<p><code>Latency Bound</code>：严格顺序执行时，一条指令需要花费的全部时间。</p>
<p><code>Throughput Bound</code>：基于硬件数量和性能限制，<code>只有两个load单元，吞吐量为0.5</code></p>
<p><strong>Separate Accumulators</strong></p>
<p>多累加器，改变元素组合的顺序，如奇偶分开。</p>
<img src="/2023/07/06/14-25-42/WX20230707-112901@2x.png" class="">

<p><strong>Unrolling &amp; Accumulating</strong></p>
<p>以K为因子展开一个L长度的数组，CPE可以接近吞吐界限</p>
<h2 id="Programming-with-AVX2"><a href="#Programming-with-AVX2" class="headerlink" title="Programming with AVX2"></a>Programming with AVX2</h2><p><strong>YMM Registers</strong></p>
<p>总共有16个32字节的寄存器 ，是%XMM的二倍。</p>
<h2 id="SIMD-Operations"><a href="#SIMD-Operations" class="headerlink" title="SIMD Operations"></a>SIMD Operations</h2><img src="/2023/07/06/14-25-42/WX20230707-114005@2x.png" class="">

<p><code>Vector Instructions</code>矢量指令：并行执行八次单精度或四次双精度浮点操作</p>
<p>矢量指令是为处理视频，声音，图形引入的</p>
<p>gcc对矢量指令的优化是有限的</p>
<h1 id="Dealing-with-Conditionals"><a href="#Dealing-with-Conditionals" class="headerlink" title="Dealing with Conditionals"></a>Dealing with Conditionals</h1><h2 id="What-About-Branches？"><a href="#What-About-Branches？" class="headerlink" title="What About Branches？"></a>What About Branches？</h2><p><strong>Branch Prediction</strong></p>
<p>分支预测技术：先执行猜测的分支，然后再判断分支是否正确</p>
<blockquote>
<p>所有的分支预测结果都写在寄存器副本中，错误时会回退正确的寄存器结果</p>
</blockquote>
<p><strong>Performance Cost</strong></p>
<p>执行代价就是用了很多时钟周期处理所有的分支指令，可能会执行大量无效操作</p>
]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 笔记三 程序的机器级表示</title>
    <url>/2023/05/24/13-04-09/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>23.05.24：初稿</li>
</ul>
<h1 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h1><ul>
<li><a href="/2023/03/15/10-59-10/" title="csapp 笔记汇总">CSAPP - 笔记汇总</a></li>
<li><a href="/2023/05/24/13-04-09/" title="CSAPP 笔记三 程序的机器级表示">第三章 - 程序的机器级表示</a></li>
<li><a href="/2023/07/06/14-25-42/" title="CSAPP 笔记五 优化程序性能">第五章 - 优化程序性能</a></li>
<li><a href="/2023/07/23/09-27-18/" title="CSAPP 笔记六 存储器层次结构">第六章 - 存储器层次结构</a></li>
</ul>
<h1 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h1><h2 id="Intel-x86-Processors"><a href="#Intel-x86-Processors" class="headerlink" title="Intel x86 Processors"></a>Intel x86 Processors</h2><ul>
<li><p>CISC - Complex 复杂指令集，RISC - Reduced 精简指令集。</p>
</li>
<li><p>x86-64，Linux的命名</p>
</li>
<li><p>ARM架构- Acorn RISC Machine</p>
</li>
<li><p>两种汇编语法：AT&amp;T和Intel。Linux和课程使用的是AT&amp;T。</p>
</li>
</ul>
<h2 id="C-assembly-machine-code"><a href="#C-assembly-machine-code" class="headerlink" title="C,assembly, machine code"></a>C,assembly, machine code</h2><ul>
<li>Micro architecture：微指令架构，CSAPP中很少涉及</li>
</ul>
<p><strong>Turning C into Object Code</strong></p>
<ul>
<li>编译命令<br><code>gcc -Og p1.c p2.c -o p</code><br><code>gcc -Og -S sum.c</code>：<br><code>-S</code>:编译阶段终止，生成汇编语言<br><code>-Og</code>:Optimize编译优化，<code>O1</code>是过去的优化级别，<code>g</code>级可以使代码更可读</li>
</ul>
<p><strong>Assembly Characteristics</strong></p>
<p>Data Types</p>
<ul>
<li><p>integer: 以1，2，4，8字节存储<br>数据和地址都用整型保存，不区分无符号和有符号。</p>
</li>
<li><p>floating point: 4，8，10字节</p>
</li>
<li><p>没有数组以及结构体，这些是由编译器构造的。</p>
</li>
</ul>
<p><strong>Operations</strong></p>
<ul>
<li><p>执行算术操作</p>
</li>
<li><p>在内存和寄存器之间传送数据</p>
</li>
<li><p>转移控制</p>
</li>
</ul>
<p>Disassembling Object Code</p>
<blockquote>
<p>指令长度在1-15个字节</p>
</blockquote>
<p>反汇编：将目标代码文件反汇编为类汇编语言。</p>
<ul>
<li><code>objdump -d sum</code>: 反汇编</li>
</ul>
<h2 id="Assembly-Basics-Registers-operands-move"><a href="#Assembly-Basics-Registers-operands-move" class="headerlink" title="Assembly Basics: Registers, operands, move"></a>Assembly Basics: Registers, operands, move</h2><p><strong>Integer Registers</strong></p>
<img src="/2023/05/24/13-04-09/WX20230603-145124@2x.png" class="">

<ul>
<li><p>参数：1<code>rdi</code>, 2<code>rsi</code>, 3<code>rdx</code>, 4<code>rcx</code>, 5<code>r8</code>, 6<code>r9</code>，只能传递整型或者指针，浮点数由另外一组单独的寄存器传递。超出的参数存在栈里。</p>
</li>
<li><p>返回值：<code>rax</code></p>
</li>
</ul>
<p><strong>Moving Data</strong></p>
<blockquote>
<p><code>mov Source, Dest</code></p>
</blockquote>
<ul>
<li><p>不允许从内存取出，存入内存。从内存取出，只能存入寄存器。</p>
</li>
<li><p><code>mov $0x4, %rax</code>：目的地址是寄存器<br><code>mov $0x4, (%rax)</code>: 目的地址是内存</p>
</li>
<li><p><code>D(R)</code>: Mem[Reg[R] + D]</p>
</li>
<li><p><code>D(Rb, Ri, S)</code>: Mem[Reg[Rb] + S * Reg[Ri] + D]</p>
</li>
</ul>
<h2 id="Arithmetic-amp-logical-operations"><a href="#Arithmetic-amp-logical-operations" class="headerlink" title="Arithmetic &amp; logical operations"></a>Arithmetic &amp; logical operations</h2><p><strong>lea Src, Dst</strong></p>
<blockquote>
<p>C语言中的&amp;，取地址</p>
</blockquote>
<p>实际使用中C语言编译器喜欢用这条指令做算术运算，<code>lea (%rdi, %rdi, 2), %rax</code>, mov是将地址指向的内存值取出，lea指令将内存值所在地址取出，相当于存入的是<code>%rdi + %rdi * 2</code>。</p>
<p>Some ArTwo Operand Instructions</p>
<img src="/2023/05/24/13-04-09/WX20230603-152227@2x.png" class="">

<ul>
<li><p>目的操作数作为第一个操作数，类似<code>x+=y</code></p>
</li>
<li><p>算术左移和逻辑左移相同</p>
</li>
</ul>
<p>One Operand Instructions</p>
<img src="/2023/05/24/13-04-09/WX20230603-152823@2x.png" class="">

<h1 id="Control"><a href="#Control" class="headerlink" title="Control"></a>Control</h1><h2 id="Condition-Codes"><a href="#Condition-Codes" class="headerlink" title="Condition Codes"></a>Condition Codes</h2><p><strong>Single bit registers</strong></p>
<ul>
<li><p><code>CF</code>: Carry Flag (for unsigned)，同样表示无符号数溢出</p>
</li>
<li><p><code>SF</code>: Sign Flag (for signed)，负数为1</p>
</li>
<li><p><code>ZF</code>: Zero Flag</p>
</li>
<li><p><code>OF</code>: Overflow Flag (for signed)</p>
</li>
</ul>
<p><strong>Explicit Setting</strong></p>
<p>Compare</p>
<blockquote>
<p>cmpq Src2, Src1</p>
</blockquote>
<p>类似减法，Src1 - Src2，但是不保存值，只改变四个条件码</p>
<ul>
<li><p>溢出：<code>cmp b， a</code>，有符号补码<br>同号不会溢出，异号才会溢出</p>
<ul>
<li><p>负溢出：a-，b+， a-b&gt;0</p>
</li>
<li><p>正溢出：a+，b-，a-b&lt;0</p>
</li>
</ul>
</li>
</ul>
<p>Test</p>
<blockquote>
<p>testq Src2, Src1</p>
</blockquote>
<p>与运算，改变SF和ZF。</p>
<p>SetX Instructions</p>
<img src="/2023/05/24/13-04-09/WX20230605-113101@2x.png" class="">

<blockquote>
<p>x86-64中4字节计算结果会将高4字节零填充，而2字节操作只会改变2字节。</p>
</blockquote>
<h2 id="Conditional-branches"><a href="#Conditional-branches" class="headerlink" title="Conditional branches"></a>Conditional branches</h2><p><strong>Jumping</strong></p>
<p>JX Instructions</p>
<img src="/2023/05/24/13-04-09/WX20230605-113806@2x.png" class="">

<p><strong>Using Conditional Moves</strong></p>
<p>分支预测技术，更多时候分支预测正确率很低，选择执行分支的两部分指令，计算出两个结果，在最后一分钟选择需要的结果。只适用在两个分支都是简单计算。</p>
<blockquote>
<p><code>cmovle</code>: 小于等于的时候移动</p>
</blockquote>
<h2 id="Loops"><a href="#Loops" class="headerlink" title="Loops"></a>Loops</h2><p>C代码中最底层的控制就是跳转和测试。</p>
<h2 id="Switch-Statements"><a href="#Switch-Statements" class="headerlink" title="Switch Statements"></a>Switch Statements</h2><ul>
<li><p>用跳转表保存代码块的地址，可以快速跳转到该地址。</p>
</li>
<li><p>无论最小值是多少，通过增加偏置变为0</p>
</li>
<li><p>跳转表由编译器生成，汇编程序填写。</p>
</li>
<li><p>值范围很大，相对稀疏，会转变为条件树。</p>
</li>
</ul>
<h1 id="Procedures"><a href="#Procedures" class="headerlink" title="Procedures"></a>Procedures</h1><h2 id="Stack-Structure"><a href="#Stack-Structure" class="headerlink" title="Stack Structure"></a>Stack Structure</h2><ul>
<li><p>内存地址从下往上递增</p>
</li>
<li><p>栈底在上，push时rsp减小</p>
</li>
</ul>
<p><strong>Push &amp; Pop</strong></p>
<ul>
<li><p>Push：先减小，在写入</p>
</li>
<li><p>Pop：rsp增加</p>
</li>
</ul>
<h2 id="Calling-Conventions"><a href="#Calling-Conventions" class="headerlink" title="Calling Conventions"></a>Calling Conventions</h2><p><strong>Passing Control</strong></p>
<ul>
<li><p><code>call label</code>: 返回地址入栈，跳转到label</p>
</li>
<li><p><code>ret</code>: 出栈，返回</p>
</li>
<li><p><code>pc</code>寄存器就存在<code>rip</code>。</p>
</li>
</ul>
<p><strong>Passing data</strong></p>
<p>数据在寄存器和内存中传递，采用默认的规则，在不同的编译器下都可以传递参数。</p>
<p><strong>Managing local data</strong></p>
<p>Stack Frame</p>
<p>每个函数使用的内存块称为栈帧。</p>
<ul>
<li><p><code>rbp</code>: 表示基指针，栈底。调用者的<code>rbp</code>保存在被调用者的栈底。</p>
</li>
<li><p><code>rsp</code>: 栈顶，当它被分配了多少字节，就知道需要释放多少字节</p>
</li>
</ul>
<h2 id="Illustration-of-Recursion"><a href="#Illustration-of-Recursion" class="headerlink" title="Illustration of Recursion"></a>Illustration of Recursion</h2><p>栈帧是递归调用的前提。</p>
<h1 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h1><h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><p><strong>One-dimensional</strong></p>
<ul>
<li>指针加常量， 常量会被适当放缩。</li>
</ul>
<p><strong>Multi-dimensional(nested)</strong></p>
<ul>
<li>多维嵌套数组，按行或列连续存储。</li>
</ul>
<p><strong>Multi-level</strong></p>
<ul>
<li>三个数组，一个以为指针数组保存三个数组的起始地址。</li>
</ul>
<h2 id="Structures"><a href="#Structures" class="headerlink" title="Structures"></a>Structures</h2><p><strong>Access</strong></p>
<ul>
<li>通过字节偏移访问对应的结构体成员。</li>
</ul>
<p><strong>Alignment</strong></p>
<ul>
<li><p>字节对齐，访问更方便，数据不会跨越多个块</p>
</li>
<li><p>占m字节的变量，就存放在m的倍数地址处</p>
</li>
<li><p>调整声明顺序，可以优化对齐</p>
</li>
</ul>
<h2 id="Floating-Point"><a href="#Floating-Point" class="headerlink" title="Floating Point"></a>Floating Point</h2><img src="/2023/05/24/13-04-09/WX20230605-164923@2x.png" class="">

<h1 id="Advanced-Topics"><a href="#Advanced-Topics" class="headerlink" title="Advanced Topics"></a>Advanced Topics</h1><h2 id="Memory-Layout"><a href="#Memory-Layout" class="headerlink" title="Memory Layout"></a>Memory Layout</h2><p>目前64位的内存只允许使用47位。Linux栈的大小为8MB。</p>
<ul>
<li><p>Stack: 局部变量</p>
</li>
<li><p>Text：执行的机器指令，只可读</p>
</li>
<li><p>Data：存放全局变量，静态变量，字符串常量</p>
</li>
<li><p>Heap：动态申请，malloc，calloc，new</p>
</li>
<li><p>Shared Libraries：存放库函数，动态加载</p>
</li>
</ul>
<p>堆分配的内存是从高位低位向中间分配，中间的一部分没有分配的内存访问段错误。<code>这是由操作系统的管理策略决定</code></p>
<h2 id="Buffer-Overflow"><a href="#Buffer-Overflow" class="headerlink" title="Buffer Overflow"></a>Buffer Overflow</h2><p><strong>Vulnerability</strong></p>
<ul>
<li><p><code>gets()</code>: 函数不检查缓冲区大小，容易越界。 </p>
</li>
<li><p><code>strcpy</code>, <code>strcat</code>,<code>scanf</code>, <code>fscanf</code>, <code>sscanf</code>, 都有溢出风险。</p>
</li>
<li><p>机器指令是小端存放的，低位在前。</p>
</li>
</ul>
<p><strong>Code Injection Attacks</strong></p>
<p>代码注入攻击，把字符填充到缓冲区中，形成可执行的指令，修改返回指针。</p>
<blockquote>
<p>Worm与Virus：蠕虫可以自己生存，病毒不能独自运行。</p>
</blockquote>
<p><strong>Protection</strong></p>
<p><strong>Randomized stack offsets</strong>栈随机化</p>
<p>栈随机化会让缓冲区随机变化，无法预测下一个地址。</p>
<p><strong>Nonexecutable code segments</strong></p>
<p>标记栈是不可执行的代码。</p>
<p><strong>Stack Canaries</strong></p>
<p><code>gcc -fstack-protector</code> 默认启动栈保护</p>
<p><code>%fs</code>: 特殊寄存器，某块内存的值，如果Canay值改变了说明有溢出。Canay值是<code>小端存放</code>。</p>
<blockquote>
<p>Canay的值最低位字节为0，这是字符串的off-by-one bug，虽然字符串的空字符占用了Canay值，产生了溢出，但是检测不到溢出。</p>
</blockquote>
<p><strong>Return-Oriented Programming Attacks</strong></p>
<p>Canay无法破解，但是我们知道代码在什么地方，全局变量和代码的位置没有改变，通过找到某段代码组合在一起，面向返回编程。</p>
<blockquote>
<p>gadget: 通过截断一些指令，形成新的指令，替换了程序计数器</p>
</blockquote>
<img src="/2023/05/24/13-04-09/WX20230608-112255@2x.png" class="">

<p>attack Lab中关闭了canary，可以通过缓冲区溢出设置需要的返回地址。</p>
<h2 id="Unions"><a href="#Unions" class="headerlink" title="Unions"></a>Unions</h2><ul>
<li><p>联合体只会为最大的域分配地址。</p>
</li>
<li><p>联合体可以用来做类型转换，不改变位。</p>
</li>
</ul>
<h2 id="大端小端"><a href="#大端小端" class="headerlink" title="大端小端"></a>大端小端</h2><ul>
<li><p>IA32：字节小端存放</p>
</li>
<li><p>x86-64：字节小端存放</p>
</li>
</ul>
]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 实验III Attack Lab</title>
    <url>/2023/03/18/15-54-47/</url>
    <content><![CDATA[<p>更新历史：</p>
<ul>
<li>23.03.18：初稿</li>
</ul>
<h1 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h1><ul>
<li><a href="/2023/03/15/10-59-10/" title="csapp 笔记汇总">CSAPP - 笔记汇总</a>
</li>
<li><a href="/2023/03/09/11-54-50/" title="CSAPP 实验I Data Lab">I Data Lab - 位操作，数据表示</a>
</li>
<li><a href="/2023/03/14/09-43-26/" title="CSAPP 实验II Bomb Lab">II Bomb Lab - 汇编，栈帧与 gdb</a>
</li>
<li><a href="/2023/03/18/15-54-47/" title="CSAPP 实验III Attack Lab">III Attack Lab - 漏洞是如何被攻击的</a>
</li>
<li><a href="/2024/03/09/16-34-34/" title="CSAPP 实验IV CacheLab">IV Cache Lab - 实现一个缓存系统</a>
</li>
<li><a href="/2024/03/14/12-34-42/" title="CSAPP实验VShellLab">V Shell Lab - 实现一个Shell</a></li>
</ul>
<h1 id="任务目标"><a href="#任务目标" class="headerlink" title="任务目标"></a>任务目标</h1><p>Attack Lab实验，采用 code-injection 和 return-oriented 两种方法攻击程序。</p>
<h1 id="相关内容"><a href="#相关内容" class="headerlink" title="相关内容"></a>相关内容</h1><ol>
<li><code>./ctarget -q</code>：运行目标文件用参数<code>-q</code>，不使用服务器</li>
<li><code>-i FILE</code>: 文件输入</li>
<li><code>./hex2raw &lt; 1.txt | ./ctarget -q</code>: 答案不换行，用<code>hex2raw</code>转换成字符串，注意需要用小端存储。</li>
<li><code>call</code>指令会将8个字节的<code>rip</code>值入栈，作为<code>ret</code>返回地址。</li>
<li>code-injection：关闭了栈随机化，栈不可执行和canary。</li>
<li>return-oriented：打开栈随机化和不可执行，关闭canary。</li>
</ol>
<h1 id="题目及解法"><a href="#题目及解法" class="headerlink" title="题目及解法"></a>题目及解法</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>和课程中讲解的两种漏洞的破解方式相同：代码注入利用缓冲区溢出，把需要执行的指令输入到栈中。面向返回编程将需要的指令片段返回地址输入到缓冲区中，模拟一个程序计数器，顺序执行需要执行的指令。由于bomb实验对每一条汇编命令都进行了解释，这个实验就不逐条解释了，把之前做过的答案重新整理一遍。</p>
<h2 id="Phase-1"><a href="#Phase-1" class="headerlink" title="Phase 1"></a>Phase 1</h2><p>思路：第一个很简单输入函数开辟了0x28的空间用于保存输入,返回地址在rsp+0x28的位置,所以输入一段0x28字节的字符串后面跟上返回touch1的地址,注意地址是小端存放:<code>C0 17 40 00 00 00 00 00 </code>, 以下答案为了方便观看添加了换行，运行程序时需要去掉换行。</p>
<ol>
<li><p>gdb进入程序，对test函数反汇编：</p>
<img src="/2023/03/18/15-54-47/WX20230609-103056@2x.png" class="">
</li>
<li><p>调用了getbuf函数，可以查看一下汇编代码，找出缓冲区的大小</p>
<img src="/2023/03/18/15-54-47/WX20230609-103332@2x.png" class="">
</li>
<li><p>缓冲区大小为<code>0x28</code>，40个字节，输入的字符串保存在当前<code>rsp</code>处。然后输入40个字节无用数据，充满缓冲区，继续输入8个字节的touch1地址，覆盖掉原地址。</p>
</li>
<li><p>对要跳转的touch1函数反汇编，找一下函数入口地址：</p>
<img src="/2023/03/18/15-54-47/WX20230609-102814@2x.png" class="">
</li>
<li><p>所以需要返回的地址为<code>0x00000000004017c0</code>，输入小端存放。</p>
</li>
</ol>
<p>答案：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">c0 <span class="number">17</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br></pre></td></tr></table></figure>

<h2 id="Phase-2"><a href="#Phase-2" class="headerlink" title="Phase 2"></a>Phase 2</h2><p>思路：</p>
<p>第二个需要注入可执行代码, 需要把touch2的参数寄存器<code>rdi</code>内容设置为cookie, 这样重置ret到touch2才能正确执行, 所有第一次在getbuf中把返回值重置为一个栈地址, 然后在这个地址内写入一系列操作, 每次ret后返回地址会自动退栈, 所以先把<code>rsp</code>-8, 然后在<code>rdi</code>写入touch2的地址,然后将<code>rdi</code>写入<code>rsp</code>指向的栈地址中,然后把cookie值写入<code>rdi</code>中,最后ret。</p>
<ol>
<li><p>先查看一下touch2函数的入口在哪里：</p>
<img src="/2023/03/18/15-54-47/WX20230609-104729@2x.png" class="">
</li>
<li><p>可以看到需要返回地址为<code>0x00000000004017ec</code>， 参数可以进入touch2函数打印一下那个局部变量的值，也可以在上一个题目输出信息那里看到，我的cookie值为<code>0x59b997fa</code>。</p>
</li>
<li><p>这次需要让指令在栈中执行，所以需要知道getbuf时<code>%rsp</code>的值，可以在test处打断点，<code>display $rsp</code>，值为<code>$rsp = (void *) 0x5561dcb0</code>。test函数中分配8个字节，call getbuf 时使用了8个字节，getbuf分配40个字节，一共分配了56个字节，所以在我们输入字符串时，<code>rsp</code>指向的地址值应该是<code>0x5561dc78</code></p>
</li>
<li><p>接下来就是注入一段需要运行的代码，可以先写汇编代码，通过指令<code>gcc -c foo.s</code>，生成二进制代码<code>foo.o</code>， 在通过<code>objdump -d foo.o</code>反汇编，生成可读的机器指令。</p>
</li>
</ol>
<p>答案：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">48</span> <span class="number">83</span> ec <span class="number">08</span>           <span class="comment">/*  sub    $0x8,%rsp */</span></span><br><span class="line"><span class="number">48</span> c7 c7 ec <span class="number">17</span> <span class="number">40</span> <span class="number">00</span>  <span class="comment">/*  mov    $0x4017ec,%rdi */</span></span><br><span class="line"><span class="number">48</span> <span class="number">89</span> <span class="number">3</span>c <span class="number">24</span>           <span class="comment">/*  mov    %rdi,(%rsp) */</span></span><br><span class="line"><span class="number">48</span> c7 c7 fa <span class="number">97</span> b9 <span class="number">59</span>  <span class="comment">/*  mov    $0x59b997fa,%rdi   -   set cookie */</span></span><br><span class="line">c3                    <span class="comment">/*  retq  */</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span></span><br><span class="line"><span class="number">78</span> dc <span class="number">61</span> <span class="number">55</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span><span class="comment">/* return adress, execute exploit code */</span></span><br></pre></td></tr></table></figure>

<h2 id="Phase-3"><a href="#Phase-3" class="headerlink" title="Phase 3"></a>Phase 3</h2><p>思路：</p>
<p>第三题和第二题基本相同return到touch3后要进行一次cookie对比,第二题是十六进制的数字对比,可以提前把cookie写入<code>rdi</code>寄存器里,但是第三题的参数是一个字符串指针,所以要把字符串地址写入<code>rsi</code>第二个参数寄存器里,不能用在栈中写,因为后面还有两次函数调用,栈空间很容易被覆盖,找了一下变量cookie的地址,这个地址<code>0x6044e4</code>的后面有很长一段地址没有使用过,所以可以把字符串写入<code>0x6044ec</code>,<code>rsi</code>的参数传递在<code>0x6044ec</code>,还有一个地方是字符串<code>0x59b997fa</code>,每个字符存在一个字节里,一共需要8个字节的空间,可以用<code>mov</code>,写入十六进制数,但是要注意字符串大端存放,数字是小端存放,翻转一下就可以了.</p>
<ol>
<li><p>根据实验指南中提示的函数<code>hexmatch</code>, 做了一个字符串对比，第二个参数是字符串地址，而且在函数中将传入的cookie值转换成了一个随机地址的字符串，然后进行字符串对比，所以我们需要提前把字符串写入到固定的地址，然参数传进去。</p>
</li>
<li><p><code>disas touch3</code></p>
<img src="/2023/03/18/15-54-47/WX20230609-123834@2x.png" class="">
</li>
<li><p>可以看出cookie值存在内存的<code>0x6044e4</code>处，打印一下周围的内存值，<code>x/6xg</code></p>
<img src="/2023/03/18/15-54-47/WX20230609-130233@2x.png" class="">
</li>
<li><p>上面可以看到后面有一部分是没有使用的内存，选一个<code>0x6044ec</code>，把我们的字符串写入这里，注意大端存放。</p>
</li>
<li><p>接下来注入要运行的指令，和上一题相同，但是要把字符串写入到选定的地址里，字符串<code>59b997fa</code>转换为16进制为<code>0x35 0x39 0x62 0x39 0x39 0x37 0x66 0x61</code>，但是要注意小端存放的值为<code>0x6166373939623935</code>，所以写入这个值，当做字符串读出时刚好是cookie值。<code>movabs</code>：用于64位立即数赋值。</p>
</li>
</ol>
<p>答案：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">48</span> <span class="number">83</span> ec <span class="number">08</span>           <span class="comment">/*  sub    $0x8,%rsp */</span></span><br><span class="line">bf fa <span class="number">18</span> <span class="number">40</span> <span class="number">00</span>        <span class="comment">/*  mov    $0x4018fa,%edi */</span></span><br><span class="line"><span class="number">48</span> <span class="number">89</span> <span class="number">3</span>c <span class="number">24</span>           <span class="comment">/*  mov    %rdi,(%rsp) */</span></span><br><span class="line">bf ec <span class="number">44</span> <span class="number">60</span> <span class="number">00</span>        <span class="comment">/*  mov    $0x6044ec,%edi  */</span></span><br><span class="line"><span class="number">48</span> be <span class="number">35</span> <span class="number">39</span> <span class="number">62</span> <span class="number">39</span> <span class="number">39</span>  </span><br><span class="line"><span class="number">37</span> <span class="number">66</span> <span class="number">61</span>              <span class="comment">/*  movabs $0x6166373939623935,%rsi */</span></span><br><span class="line"><span class="number">48</span> <span class="number">89</span> <span class="number">37</span>              <span class="comment">/*  mov    %rsi,(%rdi)    */</span></span><br><span class="line">c3                    <span class="comment">/*  retq  */</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span></span><br><span class="line"><span class="number">78</span> dc <span class="number">61</span> <span class="number">55</span> <span class="comment">/* return adress, execute exploit code */</span></span><br></pre></td></tr></table></figure>

<h2 id="Phase-4"><a href="#Phase-4" class="headerlink" title="Phase 4"></a>Phase 4</h2><p>思路：</p>
<p>第四题,和第二题相同,需要把代码返回到touch2里面,但是不能像phase2中代码注入运行代码,因为栈内标记为不可执行了,所以要使用ROP的方法来操作,在给出的gadget中选择两个连续的48 89 c7 c3, mov %rax,%rdi,   还有一个58 c3, popq %rax,将这两条指令的地址用栈溢出的方法写到返回里,在返回地址中间加上cookie码。</p>
<ol>
<li><p><em><strong><code>gcc -c farm.c</code>：生成目标文件<br><code>objdump -d farm.o &gt; farm.s</code>：反汇编生成可读指令<br><code>这里需要注意优化级别为 -Og，与实验的优化级别相同</code></strong></em><br><code>objdump -d rtarget.o &gt; rtarget.s</code>：直接对可执行文件反汇编生成的指令带地址，更方便看一些。</p>
</li>
<li><p>在<code>rtarget.s</code>中找我们需要的指令，</p>
</li>
<li><p><code>setval_426</code>函数中有：地址为<code>4019c5</code></p>
<img src="/2023/03/18/15-54-47/WX20230609-140230@2x.png" class="">
</li>
<li><p>找到我们需要的<code>48 89 c7</code>，后续的<code>90</code>是一个nop，什么也不做，计数器加1，最后跟着<code>c3</code>ret。</p>
</li>
<li><p>上面把<code>rax</code>的值存到<code>rdi</code>中了，接下来我们就是找一个pop指令<code>58 90 c3</code>，退栈到<code>rax</code>中，找到<code>getval_280</code>：地址为<code>4019cc</code></p>
<img src="/2023/03/18/15-54-47/WX20230609-140336@2x.png" class="">
</li>
<li><p>所以溢出的输入为退栈到<code>rax</code>，栈顶是cookie值，然后执行<code>0x4019c5</code>的mov指令，最后返回touch2。注意所有的操作都是8字节。</p>
</li>
</ol>
<p>答案：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">01</span> <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>   <span class="comment">/*40个字节溢出  */</span></span><br><span class="line">cc <span class="number">19</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">fa <span class="number">97</span> b9 <span class="number">59</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">c5 <span class="number">19</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">ec <span class="number">17</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br></pre></td></tr></table></figure>

<h2 id="Phase-5"><a href="#Phase-5" class="headerlink" title="Phase 5"></a>Phase 5</h2><p>思路：</p>
<p>和Phase 3相同，但是要把代码注入改为target序列执行指令，可能需要对寄存器的低字节进行操作，还没想出怎么做这个题目，后面有时间了再来做。</p>
<p>答案：</p>
]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
        <tag>shell</tag>
        <tag>gdb</tag>
        <tag>objdump</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 实验II Bomb Lab</title>
    <url>/2023/03/14/09-43-26/</url>
    <content><![CDATA[<p>更新历史：</p>
<ul>
<li>23.03.14：初稿</li>
<li>23.03.18：新增secret_phase</li>
</ul>
<h1 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h1><ul>
<li><a href="/2023/03/15/10-59-10/" title="csapp 笔记汇总">CSAPP - 笔记汇总</a>
</li>
<li><a href="/2023/03/09/11-54-50/" title="CSAPP 实验I Data Lab">I Data Lab - 位操作，数据表示</a>
</li>
<li><a href="/2023/03/14/09-43-26/" title="CSAPP 实验II Bomb Lab">II Bomb Lab - 汇编，栈帧与 gdb</a>
</li>
<li><a href="/2023/03/18/15-54-47/" title="CSAPP 实验III Attack Lab">III Attack Lab - 漏洞是如何被攻击的</a>
</li>
<li><a href="/2024/03/09/16-34-34/" title="CSAPP 实验IV CacheLab">IV Cache Lab - 实现一个缓存系统</a>
</li>
<li><a href="/2024/03/14/12-34-42/" title="CSAPP实验VShellLab">V Shell Lab - 实现一个Shell</a></li>
</ul>
<h1 id="任务目标"><a href="#任务目标" class="headerlink" title="任务目标"></a>任务目标</h1><p>Bomb Lab实验，使用GDB工具拆除六个阶段的炸弹，需要仔细输入，爆炸次数过多实验会失败。</p>
<h1 id="相关内容"><a href="#相关内容" class="headerlink" title="相关内容"></a>相关内容</h1><ol>
<li><p>下载自己的炸弹，不能修改bomb.c代码。</p>
</li>
<li><p>每爆炸一次失去一半的分数。</p>
</li>
<li><p>测试命令</p>
<blockquote>
<p><code>./bomb</code>：运行炸弹程序， <code>psol.txt</code>：文件输入答案</p>
</blockquote>
</li>
<li><p>GDB命令</p>
<blockquote>
<p><code>gdb boom</code>：调试命令。参数：<code>-e</code>：置顶可执行文件名<br><code>quit</code>：退出调试<br><code>run [参数]</code>：运行程序；<code>&lt; psol.txt</code>：文件输入<br><code>continue</code>：断点继续<br><code>print expr</code>：打印表达式值，区别：x打印的内存的值<br><code>nexti</code>：单步执行，不进入函数调用<br><code>stepi</code>：单步执行进入函数调用<br><code>break function</code>：函数处断点<br><code>break *address</code>：内存地址处断点<br><code>delete n</code>：删除n号断点<br><code>delete</code>：删除所有断点<br><code>finish</code>：运行的当前函数返回停止<br><code>x/5cb str</code> ：显示5个单字节；<code>h</code>：两个；<code>w</code>：四个；<code>g</code>：八个<br><code>x/1sb str</code> ：显示字符串str<br><code>x/4dw arr</code> ：取4个整型数字以十进制格式显示<br><code>display arr</code>：每次断点都打印数据，参数<code>/x /s /u /c</code>。<br><code>disas</code>：反汇编当前函数<br><code>info registers</code>：显示寄存器内容</p>
</blockquote>
</li>
<li><p>objdump命令 <code>反汇编</code></p>
<blockquote>
<p><code>objdump -t</code>：打印变量内容的存储位置<br><code>objdump -d bomb &gt; bomb.s</code>：反汇编生成bomb.s文件。<code>需要使用gdb查看函数</code></p>
</blockquote>
</li>
<li><p>screen 命令 <code>分屏看汇编文件，也可以不分屏在GDB中使用disas命令</code></p>
<blockquote>
<p><code>screen -ls</code>：查看所有screen终端<br><code>screen -S name</code> ：创建终端<br><code>screen -r name or id</code> ：连接终端。连接失败用<code>screen -d **</code>：连接<br><code>exit</code>：退出终端<br><code>Ctrl + a，d</code>：暂离；<code>c</code>：创建子会话；<code>w</code>：子会话列表；<code>p</code>：上一个；<code>n</code>：下一个；<code>0-9</code>：切换；<code>：</code>：命令行模式(<code>resize 80</code>)调整窗口大小。<br><code>screen -S id -X quit</code>：关闭视窗</p>
</blockquote>
</li>
<li><p>函数参数传递相关寄存器</p>
<blockquote>
<p><code>%rax</code>：返回值<br><code>%rdi</code>：第一个参数<br><code>%rsi</code>：第二个参数<br><code>%rdx</code>：第三个参数<br><code>%rcx</code>：第四个参数<br><code>%d8</code>，<code>%d9</code>，<code>%d10</code>依次是后面的参数</p>
</blockquote>
</li>
</ol>
<h1 id="题目及解法"><a href="#题目及解法" class="headerlink" title="题目及解法"></a>题目及解法</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先从源码<code>bomb.c</code>可以看出调用顺序，通过函数<code>explode_bomb</code>让炸弹爆炸，所有我们在调试过程中，在这个函数处打断点，每次只要输入错误密码，炸弹爆炸的时候程序都会进入断点，这样就不会扣分了。从源码里还能看出每一个关卡的函数都是<code>phase_x</code>，所以每次调试之前，在爆炸处打断点，在<code>phase_x</code>处打断点，进入这关之后，用反汇编命令<code>disas</code>，显示函数的汇编代码，然后进行解题。</p>
<h2 id="phase-1"><a href="#phase-1" class="headerlink" title="phase_1"></a>phase_1</h2><p>思路：</p>
<p>第一个比较简单，找到字符串对比函数，参数1放在寄存器rdi里，参数2放在寄存器rsi里。<br>在字符串对比函数内打断点，命令<code>x/1sb $rsi</code>,打印出寄存器里的字符串内容。<br>做法：</p>
<ol>
<li><p><code>break phase_1</code> ：打断点</p>
</li>
<li><p><code>disas</code>：显示汇编指令</p>
<img src="/2023/03/14/09-43-26/WX20230315-120145@2x.png" class="">
</li>
<li><p><code>break explode_bomb</code> ：在爆炸函数打断点，防止进入这里引爆炸弹  </p>
</li>
<li><p>根据汇编语言可以看出，输入的字符串在调用字符串对比函数中进行对比，根据返回值进行选择是否爆炸。<br><code>break strings_not_equal</code> ：打断点</p>
</li>
<li><p><code>x/1sb $rsi</code>：打印<code>$rsi</code>内容，根据phase_1函数的汇编指令中，改变了rsi内容，说明我们输入的密码在<code>$rdi</code>中，解密的密码在<code>$rsi</code>中。</p>
<img src="/2023/03/14/09-43-26/WX20230315-122703@2x.png" class=""></li>
</ol>
<p>答案:</p>
<p><code>Border relations with Canada have never been better.</code></p>
<h2 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h2><p>思路：</p>
<p>第二个主要是是在函数分配的栈里面进行操作,通过sscanf函数的第二个参数,format,”%d %d %d %d %d %d”，可以看出密码应该是六个数,通过记录的<code>%rsi</code>是phase2函数的<code>%rsp</code>，可以知道最终密码应该是保存在主函数的栈区，第一次和1比较,相同才能继续，第一个数字是1， 后面每一个数字都是和前一个数字*2相比较，那么就是一个等比数列，公比2。<br>做法：</p>
<ol>
<li><p><code>break phase_2</code> ：打断点</p>
</li>
<li><p><code>disas</code>：显示汇编指令</p>
<img src="/2023/03/14/09-43-26/WX20230315-164003@2x.png" class="">
<p>发现函数调用了read_six_numbers函数，所以继续在这里打断点，看具体输入了什么。</p>
</li>
<li><p><code>break read_six_numbers</code>，查看这个函数的汇编指令</p>
<img src="/2023/03/14/09-43-26/WX20230315-164335@2x.png" class="">
<p>从调用sscanf函数之前可以看出输入格式在第二个参数里 ，以在调用之前打断点，打印<code>rsi</code>的内容。从调用爆炸函数的条件也可以看出来，sscanf返回值大于等于6的时候才会正常跳转，输入的数太少会直接爆炸。</p>
<img src="/2023/03/14/09-43-26/WX20230315-164848@2x.png" class="">
<p>这道题的密码应该是6位数字，输入的内容保存在后面的传参里，地址在<code>rsi</code>寄存器里，根据phase_2的调用之前，<code>rsi</code>寄存器里存的是<code>rsp</code>的地址，所以可以判断出，读取函数把输入的数字存到了<code>rsp</code>内的地址里。</p>
</li>
<li><p>根据返回到phase_2函数的下一条指令<code>cmpl   $0x1,(%rsp)</code><br><code>cmpl</code>：代表双字，四个字节，用<code>x/6dw $rsp</code>：打印输入的内容看一下是不是自己输入的；根据跳转条件可以看出，第一个密码是1，</p>
</li>
<li><p>第一个密码正确后，依次看后面的指令:<br><code>lea    0x4(%rsp),%rbx</code>：下四个字节，第二个密码地址放到<code>rbx</code>里。<br><code>lea    0x18(%rsp),%rbp</code>：第24字节地址放到<code>rbx</code>里。<code>相当于for循环结束条件</code><br><code>mov    -0x4(%rbx),%eax</code>：第一个密码1存到<code>eax</code>。<br><code>add    %eax,%eax</code>：<code>eax</code>+<code>eax</code>。<code>乘2</code><br><code>cmp    %eax,(%rbx)</code>：对比第二个密码是不是2。<br><code>add    $0x4,%rbx</code>：<code>rbx</code>指向下四个字节，第三个密码。<br><code>cmp    %rbp,%rbx</code>：对比是不是到了结束末尾，否则继续进行循环。<br>所以这六个数字密码是一个1开头的等比数列，公比为2。</p>
</li>
</ol>
<p>答案:</p>
<p><code>1 2 4 8 16 32</code></p>
<h2 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h2><p>思路：</p>
<p>第三个和第二个相同,查看输入的是两个%d,存在phase3的栈里面,不一样的地方是,这道题目的答案有7种,因为第一个密码小于7,所有一共有8组答案,分别是0,207,   1-0x137,2-0x2c3,3-0x100,4-0x185,5-0xce, 6-0x2aa, 7-0x147.<br>做法：</p>
<ol>
<li><p><code>break phase_3</code> ：打断点</p>
</li>
<li><p><code>disas</code>：显示汇编指令</p>
<img src="/2023/03/14/09-43-26/WX20230316-103622@2x.png" class="">
<p>找到<code>sscanf</code>函数，和之前一样打断点查看输入格式。</p>
</li>
<li><p><code>x/1sb $rsi</code>：这道题的密码应该是两个数</p>
<img src="/2023/03/14/09-43-26/WX20230316-103921@2x.png" class="">
</li>
<li><p>基本步骤和上面一样，看一下密码对比的循环指令：<br><code>cmpl   $0x7,0x8(%rsp)</code>：对比第一个数字和7的大小<br><code>ja     0x400fad &lt;phase_3+106&gt;</code>：无符号大于就跳转，跳转之后调用了爆炸函数，说明第一个数字小于等于7并且大于等于0<code>负数当无符号数时第一位总是1，一定比8大</code>。<br><code>mov    0x8(%rsp),%eax</code>：把第一个数字放到<code>eax</code>里。<br><code>jmpq   *0x402470(,%rax,8)</code>：跳转到<code>*(0x402470 + (%rax * 8))</code><br>打印一下从<code>0x402470</code>这里开始存的是什么：<code>x/8xg 0x402470</code>或者<code>x/64xb 0x402470</code>：这里要注意数据是按照大端法存储的。</p>
<img src="/2023/03/14/09-43-26/WX20230316-110646@2x.png" class="">
<p>可以看出对应跳转关系，跳转后执行的指令为：<code>mov    $0xcf,%eax</code>，根据不同的第一位数字得到的为：<code>0--0xcf</code> <code>1--0x137</code> <code>2--0x2c3</code> <code>3--0x100</code> <code>4--0x185</code> <code>5--0xce</code> <code>6--0x2aa</code> <code>7--0x147</code></p>
</li>
</ol>
<p>答案:</p>
<p><code>0 207</code></p>
<h2 id="phase-4"><a href="#phase-4" class="headerlink" title="phase_4"></a>phase_4</h2><p>思路：</p>
<p>第四个主要难点在func4函数里有一个单操作数的sar指令，之前一直以为移位的数存在寄存器cl里，后来才发现这是默认移位1，所有这个题的密码第一位是在用二分法在(0-14)中找值，但是由于函数返回值是0才不会爆炸，往右半部分查找时，返回值不为0,所以密码只能在左半部分，分别是7，3，1，0，四种答案，第二个密码是在phase_4函数里，对比的数字是0，所以第二个密码是0。<br>做法：</p>
<ol>
<li><p><code>break phase_4</code> ：打断点</p>
</li>
<li><p><code>disas</code>：显示汇编指令</p>
<img src="/2023/03/14/09-43-26/WX20230316-112833@2x.png" class="">
<p>找到<code>sscanf</code>函数，和之前一样打断点查看输入格式。这道题和上一道的<code>rsi</code>内容一样，说明都是两个数。</p>
</li>
<li><p><code>cmpl   $0xe,0x8(%rsp)</code>：<br><code>jbe    0x40103a &lt;phase_4+46&gt;</code>：小于等于跳转，说明第一个密码小于等于14。<br><code>mov    $0xe,%edx</code>：14存到<code>rdx</code>第三个参数。<br><code>mov    $0x0,%esi</code>：0存到<code>rsi</code>第二个参数。<br><code>mov    0x8(%rsp),%edi</code>：第一个密码存到<code>rdi</code>第一个参数。<br><code>callq  0x400fce &lt;func4&gt;</code>：调用func4函数。</p>
</li>
<li><p><code>disas</code>：打断点反汇编，区间(a,b)</p>
<img src="/2023/03/14/09-43-26/WX20230316-113725@2x.png" class="">
<p><code>mov    %edx,%eax</code>：第三个参数14存到<code>rax</code><br><code>sub    %esi,%eax</code>：<code>rax</code>-<code>rsi</code><br><code>mov    %eax,%ecx</code>：把两个参数的差存到<code>rcx</code> 记为m<br><code>shr    $0x1f,%ecx</code>：<code>ecx</code>逻辑右移31位，<code>ecx</code>是32位的，移动31位，只剩下了符号位。<br><code>add    %ecx,%eax</code>：<code>eax</code>等于0+差。<code>如果b-a=-1，ecx=1，eax+1=0</code><br><code>sar    %eax</code>：<code>eax</code>右移一位，算术右移，等于7，m<br><code>lea    (%rax,%rsi,1),%ecx</code>：加载有效地址，效果是<code>rcx</code>里存入了a+m<br><code>cmp    %edi,%ecx</code>比较中间值是否等于第一个数字。<br>如果大于：<code>lea    -0x1(%rcx),%edx</code>b等于m-1。递归函数，左边区间查找是结束递归后<code>rax</code>乘2。<br>小于等于：<br><code>mov    $0x0,%eax</code>：<code>eax</code>等于0<br><code>cmp    %edi,%ecx</code>：对比中间值和第一个数字<br><code>jge    0x401007 &lt;func4+57&gt;</code>：大于等于跳转，本来是小于等于，相等于等于跳转，所以结束标志是第一个参数等于中间值m。返回值<code>rax</code>为0。<br><code>0x1(%rcx),%esi</code>：小于时，a &#x3D; m+ 1，继续递归，小于时结束递归后执行的是<code>0x1(%rax,%rax,1),%eax</code>，不为0。</p>
</li>
<li><p>根据<code>func4</code>返回后<code>test   %eax,%eax</code>，如果不相等就爆炸，所以eax只能等于0，所以第一个数字一定是在二分查找的左边区间，所以可能值为7，3，1，0。</p>
</li>
<li><p><code>cmpl   $0x0,0xc(%rsp)</code>：相等时函数结束，说明第二个密码是固定值0。</p>
</li>
</ol>
<p>答案:</p>
<p><code>0 0</code></p>
<h2 id="phase-5"><a href="#phase-5" class="headerlink" title="phase_5"></a>phase_5</h2><p>思路：</p>
<p>第五个比较有趣,还是和12一样计算字符串长度,知道密码应该是一个6位长度字符串，计算字符串是不是相等函数的参数显示待匹配的字符串是”flyers”，编译的时候用了canary，栈指针每次都不同，这个对解密应该是没影响，主要是输入的字符串，每一个字节只保留了低四位,然后加上一个地址，将内存中的值送到了rsp里，那么这个地址应该是一个数组，打印一下这个地址开始的15个字节，是一串字符maduiersnfotvbyl，需要我们从里面找出密码，位置分别是9，15，14，5，6，7。所以输入的字符串的ASCII编码后四位应该就是这个值，答案比较多，找<br>了一个’a’-‘z’中的答案。<br>做法：</p>
<ol>
<li><p><code>break phase_5</code> ：打断点</p>
</li>
<li><p><code>disas</code>：显示汇编指令</p>
<img src="/2023/03/14/09-43-26/WX20230316-132301@2x.png" class="">
<p>根据字符串对比函数的下一条<code>cmp    $0x6,%eax</code>，可以看出这道题密码长度为6。</p>
</li>
<li><p>分析跳转后的代码</p>
<img src="/2023/03/14/09-43-26/WX20230316-160027@2x.png" class="">
<p><code>movzbl (%rbx,%rax,1),%ecx</code>：<code>ecx</code>内存的是<code>rbx</code>的第<code>rax</code>个字节做零扩展到双字，如图是<code>0x69</code>；<code>rax</code>相当于是for循环里的i。<br><code>mov    %cl,(%rsp)</code>：把<code>rcx</code>的低八位送入栈顶指针指向的地址。<br><code>mov    (%rsp),%rdx</code>：把值继续送到<code>rdx</code>。<br><code>and    $0xf,%edx</code>：只保留<code>rdx</code>的低四位。<br><code>movzbl 0x4024b0(%rdx),%edx</code>：把<code>rdx</code>的值加上<code>0x4024b0</code>，新地址的内容存到<code>edx</code>里。<br><code>mov    %dl,0x10(%rsp,%rax,1)</code>：把<code>rdx</code>的低八位存入<code>rax+rsp+0x10</code>的位置。<br><code>add    $0x1,%rax</code>：i自加<br><code>cmp    $0x6,%rax</code>：循环结束判断</p>
</li>
<li><p>后续指令把所有的输入字符改变之后保存在了<code>rsp + 0x10</code>指向的地址里，然后调用<code>strings_not_equal</code>：我们可以根据查看传参，看一下标准答案是什么。</p>
<img src="/2023/03/14/09-43-26/WX20230316-161808@2x.png" class="">
<p>可以看到密码是字符串<code>flyers</code>，对应的字节是<code>0x66 0x6c 0x79 0x65 0x72 0x73</code>。</p>
</li>
<li><p>我们在打印一下for循环里跳转的地址<code>0x4024b0</code>保存的是什么?</p>
<img src="/2023/03/14/09-43-26/WX20230316-162400@2x.png" class="">
<p>由于偏移量总是低四位，范围是0-15，所以字符串只需要关注<br><code>maduiersnfotvbyl</code>前面这些，需要我们从里面找出密码，位置分别是9，15，14，5，6，7。所以输入的字符串的ASCII编码后四位应该就是这个值，答案比较多，找了一个’a’-‘z’中的答案。</p>
</li>
</ol>
<p>答案:</p>
<p><code>ionefg</code></p>
<h2 id="phase-6"><a href="#phase-6" class="headerlink" title="phase_6"></a>phase_6</h2><p>思路：</p>
<p>第六个是一个链表，节点的前八个字节中低位是数据，高位是输入的密码，高位的8个字节是下一跳地址，根据输入的6个数必须是1-6，切两两不相同，还进行了一次处理，每一位密码x，变成了y &#x3D; 7-x。</p>
<p>然后是链表的操作，每一个密码的节点对应的是(y - 1) * 8 + 结点首地址， 分配好结点后进行结点连接。<br>每一位密码的下一跳就是下一位密码对应的结点地址，最后一位结点的下一跳是0；要求是必要让结点中的数据，满足前一个结点大于等于后一个结点，<br>而所有结点的数据分别是：<br>(1):332<br>(2):168<br>(3):924<br>(4):691<br>(5):477<br>(6):443<br>所以数据最大的结点应该在最前面，序号应该是3 4 5 6 1 2。<br>而输入的密码应该是7 - y：   4 3 2 1 6 5<br>做法：</p>
<ol>
<li><p><code>break phase_6</code> ：打断点</p>
</li>
<li><p><code>disas</code>：显示汇编指令</p>
<img src="/2023/03/14/09-43-26/WX20230316-163103@2x.png" class="">
<img src="/2023/03/14/09-43-26/WX20230316-163118@2x.png" class="">
<img src="/2023/03/14/09-43-26/WX20230316-163134@2x.png" class="">
</li>
<li><p>根据指令，这道题是读取了六个数字，我们直接看后面的处理。输入的数字保存在<code>rsp</code>指向的地址里。每个数字存储在四个字节里<br><code>mov    %rsp,%r14</code>：把输入的数组起始地址送到<code>r14</code><br><code>mov    $0x0,%r12d</code>：<code>r12d</code>赋值0，记为<code>i</code><br><code>mov    %r13,%rbp</code>：<code>rbp</code>保存栈顶指针，数组起始地址<br><code>mov    0x0(%r13),%eax</code>：<code>rax</code>等于输入的第一个值<br><code>sub    $0x1,%eax</code>：自减1<br><code>cmp    $0x5,%eax</code>：判断<code>rax</code>是不是等于5<br><code>jbe    0x401128 &lt;phase_6+52&gt;</code>：无符号小于等于才不会爆炸，所以输入的数字自减前必须是<code>1-6</code>。<br><code>add    $0x1,%r12d</code>：<code>i</code>+1<br><code>cmp    $0x6,%r12d</code>：循环结束标志，相等跳转<br>不相等：<br><code>mov    %r12d,%ebx</code>：把<code>i</code>送到<code>rbx</code>， 记为<code>j = i + 1</code>。<br><code>movslq %ebx,%rax</code>：符号扩展送到<code>rax</code>，等于<code>j</code><br><code>mov    (%rsp,%rax,4),%eax</code>：输入的第<code>j</code>个数 送到 <code>rax</code><br><code>cmp    %eax,0x0(%rbp)</code>：对比<code>rax</code>和栈顶指针指向的数是否相同，相等就爆炸，数字不能重复。<br><code>add    $0x1,%ebx</code>：<code>j++</code><br><code>cmp    $0x5,%ebx</code>：循环跳出条件，后面的每一个数不能和第一个数相等。<br><code>add    $0x4,%r13</code>：循环重复，<code>i</code>指向下一个数<br>所有的数范围是<code>1-6</code>，且不重复时。</p>
</li>
<li><p><code>lea    0x18(%rsp),%rsi</code>：把最后一个数的地址送到<code>rsi</code><br><code>mov    %r14,%rax</code>：数组的第一个地址送到<code>rax</code><br><code>mov    $0x7,%ecx</code>：<code>rcx</code>等于7<br><code>mov    %ecx,%edx</code>：<code>rdx</code> &#x3D; 7<br><code>sub    (%rax),%edx</code>：<code>rdx</code> &#x3D; 7 - <code>*rax</code>，数组的第一个数<br><code>mov    %edx,(%rax)</code>：覆盖这个数<br><code>add    $0x4,%rax</code>：数组下一个<br><code>cmp    %rsi,%rax</code>：跳出条件<br>这段代码把所有数组的数，全部用7减，保存差</p>
</li>
<li><p><code>mov    $0x0,%esi</code>：<code>rsi</code> &#x3D; 0，记为<code>i</code><br><code>mov    (%rsp,%rsi,1),%ecx</code>：<code>rcx</code>保存<code>rsp</code>的第<code>i</code>个字节地址的数字，记为<code>x</code>，注意数字在4的倍数字节处<br><code>cmp    $0x1,%ecx</code>：<code>x</code> &#x3D;&#x3D; 1，1进行这个if判断<br>如果x&#x3D;&#x3D;1：<br><code>mov    $0x6032d0,%edx</code>：<code>rdx</code>赋值，这里要注意应该就是密码所在地<br>如果x&gt;1：<br><code>mov    $0x1,%eax</code>：<code>rax</code> &#x3D; 1<br><code>mov    $0x6032d0,%edx</code>:<br><code>mov    0x8(%rdx),%rdx</code>：<code>rdx</code> &#x3D;  （<code>rdx</code> + 8地址保存的数据），就是<code>rdx</code>地址指向的节点的next。<br><code>add    $0x1,%eax</code>：<code>rax</code> + 1<br><code>cmp    %ecx,%eax</code>：对比<code>x</code>和<code>rax</code><br>不相等时<code>rax</code>一直加1，最终<code>rdx</code>指向第x个节点地址<br>if判断结束：<br><code>mov    %rdx,0x20(%rsp,%rsi,2)</code>：把<code>rdx</code>数送入<code>rsp</code> + 2 * i + 0x20，这个地址，相当于把数组整体换位置，后面是偏移量。<br><code>add    $0x4,%rsi</code>：<code>i</code> &#x3D; <code>i</code> + 4<br><code>cmp    $0x18,%rsi</code>：结束条件<br>这段循环把数组里的数，全部向后偏移保存了一个数组，这个数组中0，1对应的是固定值<code>$0x6032d0</code>，大于1的值都是<code>$0x6032d0 + 8 * (x - 1)</code>。新数组的每一个数长度是8字节，数据是一串地址。</p>
<img src="/2023/03/14/09-43-26/WX20230317-124521@2x.png" class="">
<p>可以看出在<code>rsp</code>后0x20地址处，是六个地址。</p>
</li>
<li><p><code>mov    0x20(%rsp),%rbx</code>：<code>rbx</code>等于新建数组的第一个数，记为<code>i</code><br><code>lea    0x28(%rsp),%rax</code>：<code>rax</code>是新数组第二个数的地址，记为<code>&amp;j</code><br><code>lea    0x50(%rsp),%rsi</code>：<code>rsi</code>数组最大地址<br><code>mov    %rbx,%rcx</code>：<code>rcx</code>存第一个数，记为<code>i</code><br>循环：<br><code>mov    (%rax),%rdx</code>：<code>rdx</code>：存下个数，记为<code>j</code><br><code>mov    %rdx,0x8(%rcx)</code>：把<code>j</code>放到<code>i</code>后8个字节处<br><code>add    $0x8,%rax</code>：<code>&amp;j = &amp;j + 8</code>，后移八个字节<br><code>cmp    %rsi,%rax</code>：对比有没有到了数组末尾<br>没有到最后一个地址：<br><code>mov    %rdx,%rcx</code>：<code>rcx</code> &#x3D; <code>rdx</code>，<code>i</code>后移8个字节<br>继续上面的循环<br>如果到了最后一个地址：<br><code>movq   $0x0,0x8(%rdx)</code>：把0存到最后一个节点的后8字节处，尾结点的next&#x3D;0。<br>上面把所有链表连接起来了。链接方式是按照输入的六个数字进行连接，按照1-6的顺序，数字越大，地址越大。每个数字代表一个地址，从1-6链接起来。</p>
</li>
<li><p>下面进行的是爆炸判断：<br><code>mov    $0x5,%ebp</code>：<code>rbp</code> &#x3D; 5<br>循环：<br><code>mov    0x8(%rbx),%rax</code>：<code>rax</code>&#x3D;第一个节点的next<br><code>mov    (%rax),%eax</code>：<code>rax</code>&#x3D;地址保存的数<br><code>cmp    %eax,(%rbx)</code>：*next对比**this<br>小于就爆炸：<br>大于等于：<br><code>mov    0x8(%rbx),%rbx</code>：this向后移动8位<br><code>sub    $0x1,%ebp</code>：<code>rbp</code>减1<br>不等于0时，循环继续<br>上面这段循环如果链表的数据表示的地址内存的数是递增的就爆炸了。所以就是要把链表调整为递减的链表，通过输入的1-6。</p>
</li>
<li><p>打印看一下这个<code>$0x6032d0</code>地址处保存的数据是什么？<br>链接之前的链表：</p>

<p>重新链接之后的链表：</p>

<p>根据爆炸判断，这道题就是让链表排序成递减。</p>
</li>
</ol>
<p>答案:</p>
<p><code>4 3 2 1 6 5</code></p>
<h2 id="secret-phase"><a href="#secret-phase" class="headerlink" title="secret_phase"></a>secret_phase</h2><p>重新开始写解题笔记的时候，按照小土刀的博客搭建了hexo博客，根据他的文章格式写出了这篇解题笔记，在他的文章里发现还有一道彩蛋题目，藏在了<code>phase_defused</code>函数里。这个不仔细读汇编代码很难发现，因为一般不会看拆弹成功的函数。现在自己把这个彩蛋也做一下。</p>
<p>思路：</p>
<p>做法：</p>
<ol>
<li><p>在函数<code>phase_defused</code>处打断点。</p>
<img src="/2023/03/14/09-43-26/WX20230317-143025@2x.png" class="">
<p>发现这里有一个<code>secret_phase</code>函数，对这个函数打断点发现不会进入。<br>在汇编代码里找一下函数入口。</p>
</li>
<li><p><code>cmpl   $0x6,0x202181(%rip)        # 0x603760 &lt;num_input_strings&gt;</code>：对比当前的关卡数，不等于6时跳转，等于6时，可能会进入彩蛋。</p>
</li>
<li><p><code>mov    $0x402619,%esi</code>和<code>mov    $0x603870,%edi</code>，根据这两个参数，应该是调用的sscanf函数，看一下输入参数是什么？</p>
<img src="/2023/03/14/09-43-26/WX20230317-145028@2x.png" class="">
<p>可以看出密码是两个数字一个字符串。</p>
</li>
<li><p><code>mov    $0x402622,%esi</code>：打印看一下这里存的是什么？</p>
<img src="/2023/03/14/09-43-26/WX20230317-150241@2x.png" class="">
<p>可以确定第三个密码是<code>DrEvil</code></p>
</li>
<li><p><code>mov    $0x4024f8,%edi</code>：<br><code>mov    $0x402520,%edi</code>：打印看一下这里是什么？</p>
<img src="/2023/03/14/09-43-26/WX20230317-150454@2x.png" class="">
</li>
<li><p>修改一下我们的<code>psol.txt</code>，最后一行加上<code>0 0 DrEvil</code>，重新调试进入<code>secret_phase</code>看一下汇编代码，代码没有进入，说明输入不在最后，继续看一下汇编代码。</p>
</li>
<li><p>根据sscanf的第一个参数地址在<code>0x603870</code>，我们就找一下之前输入的数据哪一个存放在这周围，在<code>bomb.s</code>文件里搜一下最近的是<code>read_line</code>函数里的<code>0x603780</code>。<br>看一下附件的代码：<br><code>lea    (%rax,%rax,4),%rsi</code>：<br><code>shl    $0x4,%rsi</code>：<br><code>add    $0x603780,%rsi</code>：<br><code>rax</code>放的是题目序号，乘5，左移4位，加上<code>0x603780</code>后等于我要的值，<code>rax</code>应该等于3。也就是说第三道题目解出来之后，第四道题目的输入缓冲区在<code>0x603870</code>。把输入文件改一下。</p>
</li>
<li><p>成功进入彩蛋函数，现在开始解这个彩蛋。<br>这里要把彩蛋的输入放在第六道题的下一行，彩蛋的入口在第四道题的输入后面。<br><code>disas</code>：先看一下汇编代码</p>
<img src="/2023/03/14/09-43-26/WX20230317-163059@2x.png" class="">
<p><code>mov    $0xa,%edx</code>：<code>rdx</code>&#x3D;10<br><code>mov    $0x0,%esi</code>：<code>rsi</code>&#x3D;0<br><code>mov    %rax,%rdi</code>：<code>rdi</code> &#x3D; read_line的返回值。就是我们输入的字符串地址。<br><code>callq  0x400bd0 &lt;strtol@plt&gt;</code>：调用函数，找开头的十进制数转换为long int，存在<code>rax</code>里，结尾的下一个地址放在<code>rsi</code>里。<br><code>mov    %rax,%rbx</code>：<code>rbx</code>&#x3D;数字<br><code>lea    -0x1(%rax),%eax</code>：<code>rax</code>-1存到<code>rax</code>里<br><code>cmp    $0x3e8,%eax</code>：对比如果，0x3e8是1000<br>如果大于，爆炸：<br>如果小于等于：<br><code>mov    %ebx,%esi</code>：<code>rsi</code>&#x3D;<code>rbx</code><br><code>mov    $0x6030f0,%edi</code>：<code>rdi</code>赋值，这里应该是密码所在地<br><code>callq  0x401204 &lt;fun7&gt;</code>：跳转到fun7函数</p>
</li>
<li><p>在fun7函数里打断点，看下汇编代码</p>
<img src="/2023/03/14/09-43-26/WX20230317-174533@2x.png" class="">
<p><code>test   %rdi,%rdi</code>：test<code>rdi</code><br>如果等于0就跳转：<br><code>mov    $0xffffffff,%eax</code>：赋值32位全1，返回<br>不等于0：<br><code>mov    (%rdi),%edx</code>：把<code>rdi</code>地址保存的数据<code>$</code>给<code>rdx</code><br><code>cmp    %esi,%edx</code>：对比<code>rdx</code>和我们输入的密码<br><code>jle    0x401220 &lt;fun7+28&gt;</code>：<br>如果<code>rdx</code>&lt;&#x3D;<code>rsi</code>：<br><code>mov    $0x0,%eax</code>：赋值0<br><code>cmp    %esi,%edx</code>：继续对比<br>如果<code>rdx</code>&#x3D;&#x3D;<code>rsi</code>：返回0。根据彩蛋的汇编代码，可以看出返回值等于2才可以拆弹成功。<br>如果<code>rdx</code>&lt;<code>rsi</code>：<br><code>mov    0x10(%rdi),%rdi</code>：把<code>rdi</code>指向的地址+0x10，取数据送到<code>rdi</code><br>递归fun7。<br><code>lea    0x1(%rax,%rax,1),%eax</code>：<code>rax</code>左移一位再加1。<br>如果<code>rdx</code> &gt; <code>rsi</code>：<br><code>mov    0x8(%rdi),%rdi</code>：把<code>rdi</code>指向的地址+0x8，取数据送到<code>rdi</code><br>递归fun7。<br><code>add    %eax,%eax</code>：<code>rax</code>左移一位</p>
</li>
<li><p>根据上面的分析。递归的返回值一共四种<br>（1）：返回32位1<br>（2）：左移一位<br>（3）：0<br>（4）：左移一位加1<br>要想拆掉炸弹，需要返回的是2。<br>返回值顺序是：左移一位&lt;左移一位加1&lt;返回0<br>先从内层递归找条件：fun(x，y)<br>返回0：<code>rdi</code>指向的数 &#x3D;&#x3D; y<br>左移一位加1：<code>rdi</code>指向的数 &lt; y，这里x+16字节<br>左移一位：<code>rdi</code>指向的数 &gt; y，这里x+8字节<br>递归顺序为：<br>fun(x，y) -&gt; fun(x + 8，y) -&gt; fun(x+16，y)</p>
</li>
<li><p>打印一下链表存的数据是哪些？</p>
<img src="/2023/03/14/09-43-26/WX20230317-174533@2x.png" class="">
<img src="/2023/03/14/09-43-26/WX20230317-174534@2x.png" class="">
<p>根据搜索路径可以看出，需要输入的密码应该是22。</p>
</li>
<li><p>测试一下</p>
<img src="/2023/03/14/09-43-26/WX20230317-174535@2x.png" class="">
<p>彩蛋拆除成功！！</p>
</li>
</ol>
<p>答案：<code>22</code>+任意字符串</p>
]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
        <tag>shell</tag>
        <tag>gdb</tag>
        <tag>objdump</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux和SSH相关命令</title>
    <url>/2023/03/11/15-22-24/</url>
    <content><![CDATA[<h1 id="linux命令"><a href="#linux命令" class="headerlink" title="linux命令"></a>linux命令</h1><h2 id="ln链接文件"><a href="#ln链接文件" class="headerlink" title="ln链接文件"></a>ln链接文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ln -s 源文件  目的文件    #建立软链接</span><br><span class="line">ln    源文件  目的文件    #硬链接</span><br></pre></td></tr></table></figure>

<h2 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a>pwd命令</h2><p>显示当前地址</p>
<h1 id="SSH命令"><a href="#SSH命令" class="headerlink" title="SSH命令"></a>SSH命令</h1><h2 id="scp传输文件"><a href="#scp传输文件" class="headerlink" title="scp传输文件"></a>scp传输文件</h2><p><code>注意要在本地使用这个命令，ssh登录后使用，文件从服务器下载到服务器了</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scp username@ip_address:/home/username/filename ~/   #从服务器下载到本地</span><br><span class="line"># 参数 -P 端口号   要大写</span><br><span class="line"># 参数 -r 文件夹</span><br><span class="line">scp -P2222 -r</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ssh</tag>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP 实验I Data Lab</title>
    <url>/2023/03/09/11-54-50/</url>
    <content><![CDATA[<p>更新历史</p>
<ul>
<li>23.03.10：初稿</li>
<li></li>
</ul>
<h1 id="系列"><a href="#系列" class="headerlink" title="系列"></a>系列</h1><ul>
<li><a href="/2023/03/15/10-59-10/" title="csapp 笔记汇总">CSAPP - 笔记汇总</a></li>
<li><a href="/2023/03/09/11-54-50/" title="CSAPP 实验I Data Lab">I Data Lab - 位操作，数据表示</a></li>
<li><a href="/2023/03/14/09-43-26/" title="CSAPP 实验II Bomb Lab">II Bomb Lab - 汇编，栈帧与 gdb</a></li>
<li><a href="/2023/03/18/15-54-47/" title="CSAPP 实验III Attack Lab">III Attack Lab - 漏洞是如何被攻击的</a></li>
<li><a href="/2024/03/09/16-34-34/" title="CSAPP 实验IV CacheLab">IV Cache Lab - 实现一个缓存系统</a></li>
<li><a href="/2024/03/14/12-34-42/" title="CSAPP实验VShellLab">V Shell Lab - 实现一个Shell</a></li>
</ul>
<h1 id="任务目标"><a href="#任务目标" class="headerlink" title="任务目标"></a>任务目标</h1><p>DataLab实验，需要我们完善函数，条件是使用限定的操作符，并且操作符的数量也有限制，“&#x3D;”不做数量限制。</p>
<h1 id="相关内容"><a href="#相关内容" class="headerlink" title="相关内容"></a>相关内容</h1><ol>
<li><p>自己定义的int整型的赋值范围是0到0xFF，8bits</p>
</li>
<li><p>机器是32位</p>
</li>
<li><p>只能使用一元操作符<code>!</code> <code>~</code>，二元操作符<code>&amp;</code> <code>|</code> <code>+</code> <code>&lt;&lt;</code> <code>&gt;&gt;</code> </p>
</li>
<li><p>不可以调用其他函数</p>
</li>
<li><p>测试命令</p>
<blockquote>
<p><code>make clean</code>：清除生成，每次修改<code>bits.c</code>文件都要清除重新生成<code>make</code>：生成文件<br><code>./btest -f funname -1 v</code>：测试单独的函数，带参数 <code>-T 100</code>：修改限制时间<br><code>./dlc bits.c</code> ：测试编码是否符合规则,符合规则无输出，参数<code>-e</code>，输出所有信息<br><code>./ishow 22</code>：输出int值的二进制，数值<br><code>./fshow 22</code>：输出float的二进制，数值，已经非规范值</p>
</blockquote>
</li>
</ol>
<h1 id="题目及解法"><a href="#题目及解法" class="headerlink" title="题目及解法"></a>题目及解法</h1><h2 id="bitXor"><a href="#bitXor" class="headerlink" title="bitXor"></a>bitXor</h2><ul>
<li><p>题目要求：返回两个int的异或值</p>
</li>
<li><p>允许操作：<code>~ &amp;</code></p>
</li>
<li><p>操作数量：14</p>
</li>
<li><p>分值：1</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bitXor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ~(~(~x &amp; y) &amp; ~(x &amp; ~y));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="tmin"><a href="#tmin" class="headerlink" title="tmin"></a>tmin</h2><ul>
<li><p>题目要求：求补码的最小值</p>
</li>
<li><p>允许操作：<code>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</code></p>
</li>
<li><p>操作数量：4</p>
</li>
<li><p>分值：1</p>
</li>
</ul>
<p>32位机器码的补码最小值是最高位为1，其他位0，所以用1左移31位形成。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tmin</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">  x = x &lt;&lt; <span class="number">31</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="isTmax"><a href="#isTmax" class="headerlink" title="isTmax"></a>isTmax</h2><ul>
<li><p>题目要求：如果x是补码最大值返回1，否则返回0</p>
</li>
<li><p>允许操作：<code>! ~ &amp; ^ | +</code></p>
</li>
<li><p>操作数量：10</p>
</li>
<li><p>分值：1</p>
</li>
</ul>
<p>补码的最大值是最高位0，其他位1。加1后是最小值，Tmin和Tmax每位都相反，Tmin^Tmax是全1，可以使用这个值进行返回。需要注意补码的特殊值Tmin，Tmax，还需要注意-1，32位全1 <code>1111</code>，因为-1 ^ 0 &#x3D; 1，需要排除这种情况</p>
<ul>
<li><p>flag_2 表示x是否等于 -1 </p>
<ol>
<li><p>如果x&#x3D;&#x3D;-1， y&#x3D;0，y^0 &#x3D;&#x3D; 0   flag_2为0</p>
</li>
<li><p>如果x!&#x3D;-1，y!&#x3D;0， y^0 !&#x3D; 0，flag_2不为0，flag的值是0或1，所以需要取非两次，把非零值转换为1</p>
</li>
</ol>
</li>
<li><p>flag_1 表示(x+1)^x，有两种情况结果为全1，x是<code>Tmax</code>和<code>-1</code>，我们只需要全为1的情况，所以先取反~，换成全0，再取非!， 转为1。</p>
</li>
<li><p>返回值为两个标志相与，用flag_2排除掉flag_1中-1的这种情况，剩下的就是Tmax</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isTmax</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> y = x + <span class="number">1</span>;  <span class="comment">//Tmin</span></span><br><span class="line">  <span class="type">int</span> flag_1 = !(~(x ^ y)); </span><br><span class="line">  <span class="type">int</span> flag_2= !!(y ^ <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> flag_1 &amp; flag_2; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="allOddBits"><a href="#allOddBits" class="headerlink" title="allOddBits"></a>allOddBits</h2><ul>
<li><p>题目要求：如果每一个偶数位都是1返回1，否则返回0</p>
</li>
<li><p>允许操作：<code>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</code></p>
</li>
<li><p>操作数量：12</p>
</li>
<li><p>分值：2</p>
</li>
</ul>
<p>先从32比特中只保留所有偶数位的值，其他位赋值0，再和<code>0xAAAAAAAA</code>作对比相等返回1，因为不能用等号，所以用异或^代替判断，如果相等全为0，取非!值为1，否则为0。</p>
<ul>
<li><p>移位和加法让变量y等于0xAAAAAAAA。</p>
</li>
<li><p>x与y相与，只留下x的偶数位的值</p>
</li>
<li><p>用异或判断x与y是不是相等</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">allOddBits</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> y = <span class="number">0xAA</span>; </span><br><span class="line">  <span class="comment">//+优先级大于 &lt;&lt; </span></span><br><span class="line">  y  = y + (y &lt;&lt; <span class="number">8</span>);</span><br><span class="line">  y = y + (y &lt;&lt; <span class="number">16</span>);</span><br><span class="line">  <span class="comment">//只留下x的偶数位值</span></span><br><span class="line">  x = x &amp; y;</span><br><span class="line">  <span class="keyword">return</span> !(y ^ x) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="negate"><a href="#negate" class="headerlink" title="negate"></a>negate</h2><ul>
<li><p>题目要求：返回-x</p>
</li>
<li><p>允许操作：<code>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</code></p>
</li>
<li><p>操作数量：5</p>
</li>
<li><p>分值：2</p>
</li>
</ul>
<p>这个比较简单，根据二进制补码x与-x就是按位取反再加1。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">negate</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ~x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="isAsciiDigit"><a href="#isAsciiDigit" class="headerlink" title="isAsciiDigit"></a>isAsciiDigit</h2><ul>
<li><p>题目要求：判断x是不是ASCII码的0-9， 相当于判断x的值是不是0x30到0x39。</p>
</li>
<li><p>允许操作：<code>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</code></p>
</li>
<li><p>操作数量：15</p>
</li>
<li><p>分值：3</p>
</li>
</ul>
<p>先观察0-9的补码形式</p>
<p>0x30 <code>110000</code>  </p>
<p>0x37 <code>110111</code>  </p>
<p>0x38 <code>111000</code>  </p>
<p>0x39 <code>111001</code></p>
<p>首先需要满足除后6位外，高位全为0，满足第一个条件后0-7满足前三位为<code>110</code>，剩下的直接对比是不是等于8或9。<code>不能使用等号所以用异或判断相等</code></p>
<ul>
<li><p>flag_1 右移6位后，如果高位全为0，就是0，取非!为1，不然就是0</p>
</li>
<li><p>flag_2 右移3位后，满足第一个条件的除了低3位其他全为0，与<code>110</code>比较相等就是0到7中的值</p>
</li>
<li><p>flag_3， flag_4，直接判断是不是等于8，9。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isAsciiDigit</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> y = x &amp; <span class="number">0x3f</span>; <span class="comment">//截取x的后6位</span></span><br><span class="line">  <span class="type">int</span> flag_1 = !(x &gt;&gt; <span class="number">6</span>); <span class="comment">//右移六位后,取非为1   x的高位全是0  符合条件</span></span><br><span class="line">  <span class="type">int</span> flag_2 = !((x &gt;&gt; <span class="number">3</span>) ^ <span class="number">0x6</span>);  <span class="comment">//满足第一个条件后,右移3位   异或110   如果为0  就是属于&#x27;0&#x27; 到&#x27;7&#x27;</span></span><br><span class="line">  <span class="type">int</span> flag_3 = !(y ^ <span class="number">0x38</span>);  <span class="comment">//满足第一个条件后   是&#x27;8&#x27;</span></span><br><span class="line">  <span class="type">int</span> flag_4 = !(y ^ <span class="number">0x39</span>);   <span class="comment">//满足第一个条件后   是&#x27;9&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> flag_1 &amp; (flag_2 | flag_3 | flag_4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="conditional"><a href="#conditional" class="headerlink" title="conditional"></a>conditional</h2><ul>
<li><p>题目要求：x不为0，返回y， x等于0，返回z。</p>
</li>
<li><p>允许操作：<code>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</code></p>
</li>
<li><p>操作数量：16</p>
</li>
<li><p>分值：3</p>
</li>
</ul>
<p>先找返回值，x等于0，return (x &amp; y) ^ (~x &amp; z)，x不等于0的时候，结果很多，这时候把x处理一下变为全1，返回值就相等了。</p>
<ul>
<li><p>对于x不等于0的情况，换全1比较麻烦，对x取非!，把x简化成0或1。</p>
</li>
<li><p>把x扩展到全1和全0，用移位加也能做出来而且满足操作数量的限制，继续做后面的题目<code>logicalNeg</code>想到了一个快速扩展的方法，0或1，取反加1，就是全0或者全1。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">conditional</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> &#123;</span><br><span class="line">  x = !x;   <span class="comment">//取非 把x变为 0 1两种    把他们扩展到32位</span></span><br><span class="line">  x = ~x + <span class="number">1</span>;  <span class="comment">//01快速扩展到全0全1 </span></span><br><span class="line"> <span class="comment">// x = (x &lt;&lt; 1) + x;</span></span><br><span class="line"> <span class="comment">// x = (x &lt;&lt; 2) + x;</span></span><br><span class="line"> <span class="comment">// x = (x &lt;&lt; 4) + x;</span></span><br><span class="line"> <span class="comment">// x = (x &lt;&lt; 8) + x;</span></span><br><span class="line"> <span class="comment">// x = (x &lt;&lt; 16) + x;</span></span><br><span class="line">  <span class="keyword">return</span> ((~x) &amp; y) ^ (x &amp; z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="isLessOrEqual"><a href="#isLessOrEqual" class="headerlink" title="isLessOrEqual"></a>isLessOrEqual</h2><ul>
<li><p>题目要求：x&lt;&#x3D;y，返回1，否则返回0。</p>
</li>
<li><p>允许操作：<code>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</code></p>
</li>
<li><p>操作数量：24</p>
</li>
<li><p>分值：3</p>
</li>
</ul>
<p>找出所以返回1的情况，一共两种情况，相等，小于。相等的时候比较好做，用异或判断相等，小于的情况比较复杂。</p>
<ul>
<li><p>等于：flag_3表示相等的情况  异或判断</p>
</li>
<li><p>小于：有两种情况 <code>需要注意减法同号一点不会溢出</code></p>
<ol>
<li><p>flag_5：x负数，y正数。</p>
</li>
<li><p>flag_4：x，y同号，x &lt; y，转换为 y-x&gt;0。</p>
</li>
</ol>
</li>
<li><p>用flag_5 表示x负数，y正数。   <code>用右移31位看符号看判断正负</code></p>
</li>
<li><p>用flag_6 表示x正数，y负数。</p>
</li>
<li><p>用sum&#x3D;y - x，flag_4 表示符号。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isLessOrEqual</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">  <span class="type">int</span> nagete_x = ~x + <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> sum = y + nagete_x; </span><br><span class="line">  <span class="type">int</span> flag_3 = !(x ^ y);</span><br><span class="line">  <span class="type">int</span> flag_5 = (x &gt;&gt; <span class="number">31</span>) &amp; !(y &gt;&gt; <span class="number">31</span>);   </span><br><span class="line">  <span class="type">int</span> flag_6 = !(x &gt;&gt; <span class="number">31</span>) &amp; (y &gt;&gt; <span class="number">31</span>);   </span><br><span class="line">  <span class="type">int</span> flag_4 = !(sum &gt;&gt; <span class="number">31</span>) &amp; !flag_5 &amp; !flag_6;   <span class="comment">//xy同号  减法不会溢出  减法有效</span></span><br><span class="line">  <span class="keyword">return</span> flag_3 | flag_4 | flag_5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="logicalNeg"><a href="#logicalNeg" class="headerlink" title="logicalNeg"></a>logicalNeg</h2><ul>
<li><p>题目要求：实现取非!的功能</p>
</li>
<li><p>允许操作：<code>~ &amp; ^ | + &lt;&lt; &gt;&gt;</code></p>
</li>
<li><p>操作数量：12</p>
</li>
<li><p>分值：4</p>
</li>
</ul>
<p>思路：取非结果只有0和1，把全0或全1加1，就是1或0，所以就需要把0转换为全1，非0转换为全0，然后加1，就是返回值。默认返回0，找出返回1的情况，也就是全1。<code>只有0和Tmin的负值和自己符号相同，其他的符号都相反</code></p>
<ul>
<li><p>取负值，对符号位扩展，然后自己的符号位和负值符号位相加，</p>
<ol>
<li><p>0和Tmin，结果为0。</p>
</li>
<li><p>其他结果为全1。</p>
</li>
</ol>
</li>
<li><p>flag_1：~sum，0和Tmin结果为全1， 其他为全0。</p>
</li>
<li><p>flag_2：~Tmin 01111 ~0全1</p>
</li>
<li><p>flag_3：flag_1 中排除到flag_2的Tmin情况</p>
<ol>
<li><p>Tmin <code>0111</code>  0为<code>1111</code>  其余为<code>0000</code></p>
</li>
<li><p>取反，只保留符号位， Tmin <code>1111</code> 0为<code>0000</code> 其余为<code>1111</code></p>
</li>
<li><p>加1后，0为<code>0001</code>， 其余都统一为<code>0000</code></p>
</li>
</ol>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">logicalNeg</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> neg_x = ~x;</span><br><span class="line">  <span class="type">int</span> y = neg_x + <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> hight_x = x &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  <span class="type">int</span> hight_y = y &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  <span class="type">int</span> flag_1 = ~(hight_x + hight_y);</span><br><span class="line">  <span class="type">int</span> flag_2 = neg_x;</span><br><span class="line">  <span class="type">int</span> flag_3 = (~(flag_1 &amp; flag_2) &gt;&gt; <span class="number">31</span>) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> flag_3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="howManyBits"><a href="#howManyBits" class="headerlink" title="howManyBits"></a>howManyBits</h2><ul>
<li><p>题目要求：返回表示x的补码最短长度 <code>注意-1，用一位</code></p>
</li>
<li><p>允许操作：<code>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</code></p>
</li>
<li><p>操作数量：90</p>
</li>
<li><p>分值：4</p>
</li>
</ul>
<p>思路：用上面做的函数 conditional 做两个if功能， 一次返回分半查找的剩余一半函数 ，一次计算分半如果选择前一半，bit数要加上一半的长度，选择后面长度加0不做处理。</p>
<blockquote>
<p>用0xffff0000 留下x的前16位,如果不等于0 说明位数大于16 等于0 说明位数小于16 在后16位内再进行分半查找</p>
</blockquote>
<p>正负数的处理<code>重点</code><br>都处理成正数，方便右移添0。加上符号位就是有效位数。</p>
<ul>
<li><p>正数：找出最高位的1。</p>
</li>
<li><p>负数：找出最高位的0，<code>Tmin也符合</code></p>
<blockquote>
<p>负数高位连续的1都是无用数据，只需要找到高位连续的1后的第一个0在哪里，做法是取反，如<code>1110010</code>，有用的数据是<code>10010</code>，全部取反后<code>0001101</code>， 有效位数是4位，加上符号位。</p>
</blockquote>
</li>
<li><p>flag_nage： x是负数 值为1</p>
</li>
<li><p>重点代码，</p>
<ol>
<li><p>if函数功能</p>
<blockquote>
<p><code>x = (extend_f_n &amp; (~x)) ^ ((~extend_f_n) &amp; x);</code> ：如果标记为全1，选择的~x， 如果为全0，选择的x。异或的两边有一个一直为全0，结果一定是另一个。</p>
</blockquote>
</li>
<li><p>一个二分法</p>
<blockquote>
<p><code>x_32 = x &amp; bit_32;</code> ：取x的前16位<br><code>x_32 = !x_32;</code>：取非，如果前16位全0，值就是1，否则是0<br><code>x_32 = ~x_32 + 1;</code> 前16位全0，扩充到全1，否则扩充到全0<br><code>flag_32 = ~x_32;</code> 这里是为了减少一个op值，重复使用代码<br><code>x_16 = (flag_32 &amp; (x &gt;&gt; 16)) ^ ((x_32 &amp; (x &amp; (~bit_32))));</code><br>x_32如果全0，说明前16位，有1，那就把x右移16位，覆盖掉后面，继续对这16位进行二分法。<code>这里不用考虑右移补1，因为都是正数最高位都是0</code>。并且总数加16。<br>如果全1，说明前16位都是0，要从后16位开始二分法，不用移位，x_16要等于x的后16位。总数加0。<br><code>sum = sum + (flag_32 &amp; 16);</code>：</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">howManyBits</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> x_32, x_16, x_8, x_4, x_2;  <span class="comment">//分别表示x的不同比特</span></span><br><span class="line">  <span class="type">int</span> bit_8 = <span class="number">0xff</span> &lt;&lt; <span class="number">8</span>;</span><br><span class="line">  <span class="type">int</span> bit_32 = (bit_8 + <span class="number">0xff</span>) &lt;&lt; <span class="number">16</span>;   </span><br><span class="line">  <span class="type">int</span> bit_16 = bit_8;</span><br><span class="line">  <span class="type">int</span> flag_32,flag_16,flag_8,flag_4,flag_2;  <span class="comment">//表示 ~x_32  重使用一次 减少 ops数量</span></span><br><span class="line">  <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> flag_nage = !!(x &gt;&gt; <span class="number">31</span>);     <span class="comment">//  x是负数   值为1</span></span><br><span class="line">  <span class="comment">//通过负0和Tmin 都是自己   ^之后为0  排除x是0的情况    当x是Tmin 是值为1</span></span><br><span class="line">  <span class="comment">//int flag_Tmin = !(x ^ (~x + 1)) &amp; x; </span></span><br><span class="line">  <span class="type">int</span> flag_Tmin = !(x &lt;&lt; <span class="number">1</span>) &amp; x;   <span class="comment">//Tmin 左移一位 去掉符号位后是全0   比上面的方法减少op</span></span><br><span class="line">  <span class="type">int</span> extend_f_T = ~flag_Tmin + <span class="number">1</span>;      <span class="comment">//扩展flag_Tmin</span></span><br><span class="line">  <span class="type">int</span> extend_f_n = ~flag_nage + <span class="number">1</span>;      <span class="comment">//扩展flag_nage</span></span><br><span class="line">  sum = sum + (flag_Tmin &amp; <span class="number">32</span>);</span><br><span class="line">  x = (extend_f_T &amp; <span class="number">0</span>) ^ ((~extend_f_T) &amp; x);  <span class="comment">// flag_Tmin 是1时  x赋值0   是0是  x不变</span></span><br><span class="line"></span><br><span class="line">  x = (extend_f_n &amp; (~x)) ^ ((~extend_f_n) &amp; x);  <span class="comment">// flag_nage 是1时  x赋值~x   是0是  x不变</span></span><br><span class="line"></span><br><span class="line">  bit_8 = <span class="number">0xf0</span>; </span><br><span class="line">  x_32 = x &amp; bit_32;</span><br><span class="line">  x_32 = !x_32;</span><br><span class="line">  x_32 = ~x_32 + <span class="number">1</span>;</span><br><span class="line">  flag_32 = ~x_32;</span><br><span class="line">  x_16 = (flag_32 &amp; (x &gt;&gt; <span class="number">16</span>)) ^ ((x_32 &amp; (x &amp; (~bit_32))));</span><br><span class="line">  sum = sum + (flag_32 &amp; <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">  x = x_16;   <span class="comment">//改变x</span></span><br><span class="line">  x_16 = x &amp; bit_16;</span><br><span class="line">  x_16 = !x_16;</span><br><span class="line">  x_16 = ~x_16 + <span class="number">1</span>;</span><br><span class="line">  flag_16 = ~x_16;</span><br><span class="line">  x_8 = (flag_16 &amp; (x &gt;&gt; <span class="number">8</span>)) ^ ((x_16 &amp; (x &amp; <span class="number">0xff</span>)));</span><br><span class="line">  sum = sum + (flag_16 &amp; <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">  x = x_8;   <span class="comment">//改变x</span></span><br><span class="line">  x_8 = x &amp; bit_8;</span><br><span class="line">  x_8 = !x_8;</span><br><span class="line">  x_8 = ~x_8 + <span class="number">1</span>;</span><br><span class="line">  flag_8 = ~x_8;</span><br><span class="line">  x_4 = (flag_8 &amp; (x &gt;&gt; <span class="number">4</span>)) ^ ((x_8 &amp; (x &amp; (<span class="number">0xf</span>))));   <span class="comment">//~bit_8  改为0xf  省一个op</span></span><br><span class="line">  sum = sum + (flag_8 &amp; <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">  x = x_4;   <span class="comment">//改变x</span></span><br><span class="line">  x_4 = x &amp; <span class="number">12</span>;</span><br><span class="line">  x_4 = !x_4;</span><br><span class="line">  x_4 = ~x_4 + <span class="number">1</span>;</span><br><span class="line">  flag_4 = ~x_4;</span><br><span class="line">  x_2 = (flag_4 &amp; (x &gt;&gt; <span class="number">2</span>)) ^ ((x_4 &amp; (x &amp; <span class="number">3</span>)));</span><br><span class="line">  sum = sum + (flag_4 &amp; <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  x = x_2;</span><br><span class="line">  x_2 = x_2 &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  x_2 = !x_2;</span><br><span class="line">  x_2 = ~x_2 + <span class="number">1</span>;</span><br><span class="line">  flag_2 = ~x_2;</span><br><span class="line">  x = (flag_2 &amp; (x &gt;&gt; <span class="number">1</span>)) ^ ((x_2 &amp; (x &amp; <span class="number">1</span>)));</span><br><span class="line">  sum = sum + (flag_2 &amp; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  sum = sum + (x &amp; <span class="number">1</span>);  <span class="comment">//如果x是0  或者处理之后的Tmin  剩余位全是0    不加最后一个比特位   其他情况加上1</span></span><br><span class="line"></span><br><span class="line">  sum = sum + (!flag_Tmin &amp; <span class="number">1</span>);   <span class="comment">//非Tmin  加上符号位    0符号位就是0  一个bit表示</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="floatScale2"><a href="#floatScale2" class="headerlink" title="floatScale2"></a>floatScale2</h2><ul>
<li><p>题目要求：无符号数保存的float值，返回乘2</p>
</li>
<li><p>允许操作：<code>所有的int，无符号操作符，if，while</code></p>
</li>
<li><p>操作数量：30</p>
</li>
<li><p>分值：4</p>
</li>
</ul>
<p>思路：</p>
<ol>
<li><p>0返回0</p>
</li>
<li><p>exp全1： 为无穷 直接返回</p>
</li>
<li><p>exp全0： <code>非规格化值：小数部分没有隐藏位</code></p>
<blockquote>
<p>f不是全0 直接加左移一位 最后补上符号。<code>非规格化到规格化的过渡</code><br>f是全0 不做处理 返回原值 ，就是第一种情况</p>
</blockquote>
</li>
<li><p>exp 不全1全0 直接加1 相当于乘2</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="title function_">floatScale2</span><span class="params">(<span class="type">unsigned</span> uf)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> bit_exp;</span><br><span class="line">  <span class="type">unsigned</span> bit_f;  <span class="comment">//小数部分</span></span><br><span class="line">  <span class="type">unsigned</span> flag_s;  <span class="comment">//符号位</span></span><br><span class="line">  <span class="keyword">if</span>(uf == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bit_f = uf &amp; (<span class="number">0x007fffff</span>);</span><br><span class="line">  bit_exp = uf &amp; (<span class="number">0x7f800000</span>);   <span class="comment">//取出指数部分</span></span><br><span class="line">  flag_s = uf &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  <span class="keyword">if</span>(bit_exp == <span class="number">0x7f800000</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> uf;</span><br><span class="line">  &#125;</span><br><span class="line">  bit_exp = bit_exp &gt;&gt; <span class="number">23</span>;       <span class="comment">//exp的值</span></span><br><span class="line">  <span class="keyword">if</span>(bit_exp != <span class="number">0</span>)&#123;</span><br><span class="line">    bit_exp = bit_exp + <span class="number">1</span>;</span><br><span class="line">    bit_exp = bit_exp &lt;&lt; <span class="number">23</span>;</span><br><span class="line">    uf = uf &amp; ~(<span class="number">0x7f800000</span>);</span><br><span class="line">    uf = uf ^ bit_exp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(bit_exp == <span class="number">0</span> &amp;&amp; bit_f != <span class="number">0</span>)&#123;</span><br><span class="line">      uf = uf &lt;&lt; <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(flag_s == <span class="number">1</span>)&#123;</span><br><span class="line">        uf = uf | (flag_s &lt;&lt; <span class="number">31</span>);  <span class="comment">//补上符号位</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> uf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="floatFloat2Int"><a href="#floatFloat2Int" class="headerlink" title="floatFloat2Int"></a>floatFloat2Int</h2><ul>
<li><p>题目要求：float转int值</p>
</li>
<li><p>允许操作：<code>所有的int，无符号操作符，if，while</code></p>
</li>
<li><p>操作数量：30</p>
</li>
<li><p>分值：4</p>
</li>
</ul>
<p>思路：<code>确定指数的范围</code></p>
<ol>
<li><p>exp &lt; 127 指数小于0时，是小数，返回0。</p>
</li>
<li><p>exp &gt; 158 指数大于31 越界</p>
</li>
<li><p>exp 全0 返回0</p>
</li>
<li><p>exp 全1 返回0x80000000u</p>
</li>
<li><p>exp 其他情况下 对f部分补上隐藏位1 再右移exp-127位，最后补上符号位</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">floatFloat2Int</span><span class="params">(<span class="type">unsigned</span> uf)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> bit_exp;</span><br><span class="line">  <span class="type">unsigned</span> bit_f;  <span class="comment">//小数部分</span></span><br><span class="line">  <span class="type">unsigned</span> flag_s;  <span class="comment">//符号位</span></span><br><span class="line">  <span class="type">unsigned</span> E;      <span class="comment">//指数</span></span><br><span class="line">  <span class="type">int</span> F2Int;</span><br><span class="line">  bit_f = uf &amp; (<span class="number">0x007fffff</span>);   <span class="comment">//取出小数部分</span></span><br><span class="line">  bit_f = bit_f | (<span class="number">0x00800000</span>);  <span class="comment">//补上前面隐藏1</span></span><br><span class="line">  bit_exp = uf &amp; (<span class="number">0x7f800000</span>);   <span class="comment">//取出指数部分</span></span><br><span class="line">  bit_exp = bit_exp &gt;&gt; <span class="number">23</span>;</span><br><span class="line">  flag_s = uf &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  <span class="comment">//printf(&quot;s %u %x  exp  %u %x   f  %u  %x\n&quot;, flag_s, flag_s, bit_exp, bit_exp, bit_f, bit_f);</span></span><br><span class="line">  <span class="keyword">if</span>(bit_exp == <span class="number">0xff</span> || bit_exp &gt; <span class="number">158</span>)&#123;  <span class="comment">//无穷   或者NaN   指数越界  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x80000000</span>u;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(bit_exp &lt; <span class="number">127</span> || bit_exp  == <span class="number">0</span>)&#123;  <span class="comment">//指数是负数   非规格数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;   </span><br><span class="line">  E = bit_exp - <span class="number">127</span>;</span><br><span class="line">  bit_f = bit_f &gt;&gt; (<span class="number">23</span> - E);  <span class="comment">//右移</span></span><br><span class="line">  <span class="comment">//printf(&quot;E %u %x  bit_f   %u %x \n&quot;, E, E, bit_f, bit_f);</span></span><br><span class="line">  F2Int = bit_f;   </span><br><span class="line">  <span class="keyword">if</span>(flag_s == <span class="number">1</span>)&#123;</span><br><span class="line">    F2Int = -F2Int;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> F2Int;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="floatPower2"><a href="#floatPower2" class="headerlink" title="floatPower2"></a>floatPower2</h2><ul>
<li><p>题目要求：返回float值 2的x次方，x为32位int</p>
</li>
<li><p>允许操作：<code>所有的int，无符号操作符，if，while</code></p>
</li>
<li><p>操作数量：30</p>
</li>
<li><p>分值：4</p>
</li>
</ul>
<p>思路：<code>确定指数的范围</code> x为-127到128之间。</p>
<p>时间超时 10s内跑不完所有测试数据 可能是电脑问题</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="title function_">floatPower2</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> bit_exp;</span><br><span class="line">  <span class="type">unsigned</span> bit_float;  <span class="comment">//float值的bit位</span></span><br><span class="line">  <span class="type">unsigned</span> INF = <span class="number">0x7f800000</span>;</span><br><span class="line">  <span class="keyword">if</span>(x &lt; <span class="number">-127</span>)&#123;  <span class="comment">//值太小</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;   </span><br><span class="line">  <span class="keyword">if</span>(x &gt; <span class="number">128</span>)&#123;  <span class="comment">//太大  返回+INF</span></span><br><span class="line">    <span class="keyword">return</span> INF;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//printf(&quot;x    %d\n&quot;, x);</span></span><br><span class="line">  bit_exp = x + <span class="number">127</span>;</span><br><span class="line">  bit_exp = bit_exp &lt;&lt; <span class="number">23</span>;</span><br><span class="line">  <span class="comment">//printf(&quot;bit_float  %u  %x\n&quot;, bit_float, bit_float);</span></span><br><span class="line">  <span class="keyword">return</span> bit_exp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>csapp</category>
      </categories>
      <tags>
        <tag>csapp</tag>
      </tags>
  </entry>
  <entry>
    <title>git笔记</title>
    <url>/2023/03/08/14-59-55/</url>
    <content><![CDATA[<p>克隆项目到当前文件夹</p>
<ul>
<li><p>git clone https:&#x2F;&#x2F; .</p>
</li>
<li><p>注意 .</p>
</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>算法模板</title>
    <url>/2023/03/08/14-45-11/</url>
    <content><![CDATA[<h1 id="特殊函数"><a href="#特殊函数" class="headerlink" title="特殊函数"></a>特殊函数</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//万能头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span> </span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="built_in">sort</span>(a,a+n,<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;());<span class="comment">//内置类型的由小到大排序</span></span><br><span class="line"><span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line"><span class="comment">//作用相当于 bool cmd();</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line">  string s;</span><br><span class="line">  s = <span class="built_in">bitset</span>&lt;<span class="number">8</span>&gt;(a[i]).<span class="built_in">to_string</span>();     <span class="comment">//  转换字符串</span></span><br><span class="line">  <span class="built_in">to_ulong</span>()    <span class="comment">// 转换为unsigned long类型</span></span><br><span class="line">  <span class="built_in">to_ullong</span>();　<span class="comment">// 转换成unsigned long long类型</span></span><br><span class="line">  <span class="built_in">set</span>(x, v);    <span class="comment">// 没有参数时 将全部位设为1</span></span><br><span class="line">                <span class="comment">// 有一个x， 将x下标处设为1</span></span><br><span class="line">                <span class="comment">// 两个参数，将x处设为v值</span></span><br><span class="line">  <span class="built_in">reset</span>(x);    <span class="comment">// 置0   无参全部置，有参置下标</span></span><br><span class="line">  <span class="built_in">flip</span>(x);     <span class="comment">// 取反，无参全部取，有参取下标处</span></span><br><span class="line">  <span class="built_in">text</span>(x);     <span class="comment">// 检测下标处是不是1 返回true 0返回false</span></span><br><span class="line">  <span class="built_in">any</span>();       <span class="comment">// 检查是否有1</span></span><br><span class="line">  <span class="built_in">none</span>();      <span class="comment">// 检查是否没有1</span></span><br><span class="line">  <span class="built_in">all</span>();       <span class="comment">// 检查是否全为1</span></span><br><span class="line">  <span class="built_in">count</span>();     <span class="comment">// 求1的个数</span></span><br><span class="line">  <span class="built_in">size</span>();      <span class="comment">// 求位数</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="built_in">typeid</span>(x).<span class="built_in">name</span>();   <span class="comment">// 获取x的类型</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输出重定向</span></span><br><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"><span class="comment">//控制台输入数据，如何输入文件结束标志</span></span><br><span class="line"><span class="comment">//**在Windows下，输入完毕后先按Enter键，再按Ctrl＋Z键，最后再按Enter键</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加快输入速度的两种方法</span></span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);   cin &gt;&gt; x;</span><br><span class="line"><span class="built_in">scanf</span>()；</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类型转换</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line">ss.<span class="built_in">clear</span>();  <span class="comment">// 清空</span></span><br><span class="line">ss &lt;&lt; s;</span><br><span class="line">ss &gt;&gt; a;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="built_in">isdigit</span>(s[i]);  <span class="comment">// 若参数c为阿拉伯数字0~9 字符，则返回非0值，否则返回0。</span></span><br><span class="line"><span class="type">int</span> n = <span class="built_in">stoi</span>(s);   <span class="comment">//  把s转化为int型 </span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line">cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>);   <span class="comment">// 设置位数</span></span><br><span class="line"><span class="built_in">setprecision</span>(n)     <span class="comment">//设置显示小数精度为n位</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">stefill</span>(c);  <span class="comment">// 设置填充字符</span></span><br><span class="line"><span class="built_in">setiosflags</span>(ios::scientific)   <span class="comment">//指数表示</span></span><br><span class="line"><span class="built_in">setiosflags</span>(ios::left)     <span class="comment">//左对齐</span></span><br><span class="line"><span class="built_in">setiosflags</span>(ios::right)    <span class="comment">//右对齐</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">include &lt;string&gt;</span><br><span class="line"><span class="built_in">substr</span>(<span class="type">int</span> index, <span class="type">int</span> mum); <span class="comment">// 返回一个子字符串 </span></span><br><span class="line"><span class="comment">//std::string::npos是一个常数，它等于size_type类型可以表示的最大值</span></span><br><span class="line"><span class="comment">//用在 s.find()  返回值</span></span><br></pre></td></tr></table></figure>

<h1 id="算法模板"><a href="#算法模板" class="headerlink" title="算法模板"></a>算法模板</h1><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法比赛</tag>
        <tag>c++</tag>
        <tag>算法模板</tag>
      </tags>
  </entry>
  <entry>
    <title>macOS使用ssh登陆WSL2的ubuntu</title>
    <url>/2023/03/07/14-58-00/</url>
    <content><![CDATA[<h1 id="ssh-登录wsl-ubuntu"><a href="#ssh-登录wsl-ubuntu" class="headerlink" title="ssh 登录wsl ubuntu"></a>ssh 登录wsl ubuntu</h1><h2 id="固定wsl2的ip地址"><a href="#固定wsl2的ip地址" class="headerlink" title="固定wsl2的ip地址"></a>固定wsl2的ip地址</h2><p>wsl2的ip地址每次都会改变，所以一直要重新设置防火墙端口，通过脚本，每次管理员运行脚本固定ip，就不需要重复设置防火墙端口。</p>
<ul>
<li>优化之后固定wsl2 IP:192.168.120.181,运行脚本,转发端口,设置防火墙,自动命令</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@echo off</span><br><span class="line">setlocal enabledelayedexpansion</span><br><span class="line"></span><br><span class="line">::先停掉wsl实例</span><br><span class="line">wsl --shutdown</span><br><span class="line">::重新拉起，启动ssh服务</span><br><span class="line">wsl -u root -d Ubuntu-20.04 service ssh start</span><br><span class="line">:: 固定IP</span><br><span class="line">wsl -u root ip addr | findstr &quot;192.168.120.181&quot; &gt; nul</span><br><span class="line">if !errorlevel! equ 0 (</span><br><span class="line">   echo wsl ip has set</span><br><span class="line">) else (</span><br><span class="line">   wsl -u root ip addr add 192.168.120.181/24 broadcast 192.168.120.0 dev eth0 label eth0:1</span><br><span class="line">   echo set wsl ip success: 192.168.120.181</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">::windows作为wsl的宿主，在wsl的固定IP的同一网段也给安排另外一个IP</span><br><span class="line">ipconfig | findstr &quot;192.168.120.100&quot; &gt; nul</span><br><span class="line">if !errorlevel! equ 0 (</span><br><span class="line">    echo windows ip has set</span><br><span class="line">) else (</span><br><span class="line">    netsh interface ip add address &quot;vEthernet (WSL)&quot; 192.168.120.100 255.255.255.0</span><br><span class="line">    echo set windows ip success: 192.168.120.100</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">::windows的2222端口转发到ubuntu</span><br><span class="line">netsh interface portproxy add v4tov4 listenaddress=0.0.0.0 listenport=2222 connectaddress=192.168.120.181 connectport=2222</span><br><span class="line">::防火墙开启入站规则</span><br><span class="line">::netsh advfirewall firewall add rule name=WSL2 dir=in action=allow protocol=TCP localport=2222</span><br><span class="line"></span><br><span class="line">pause</span><br></pre></td></tr></table></figure>

<ul>
<li><p>管理员模式运行脚本后直接连接</p>
</li>
<li><p>连接 ip为<code>windows的地址</code></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh name@ip -p2222</span><br></pre></td></tr></table></figure>

<h2 id="ssh服务器命令"><a href="#ssh服务器命令" class="headerlink" title="ssh服务器命令"></a>ssh服务器命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo service ssh restart</span><br><span class="line">sudo service ssh start</span><br><span class="line">sudo service ssh stop</span><br><span class="line">sudo service ssh status</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="wsl命令"><a href="#wsl命令" class="headerlink" title="wsl命令"></a>wsl命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wsl -- hostname -I    #显示wsl的ip</span><br><span class="line">wsl -l -v             #列出当前linux版本状态</span><br><span class="line">wsl --shutdown        #关闭linux</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>ssh</tag>
        <tag>mac</tag>
        <tag>ubuntu</tag>
        <tag>wsl2</tag>
      </tags>
  </entry>
</search>
